+ source /opt/miniconda3/bin/activate
++ _CONDA_ROOT=/opt/miniconda3
++ . /opt/miniconda3/etc/profile.d/conda.sh
+++ export CONDA_EXE=/opt/miniconda3/bin/conda
+++ CONDA_EXE=/opt/miniconda3/bin/conda
+++ export _CE_M=
+++ _CE_M=
+++ export _CE_CONDA=
+++ _CE_CONDA=
+++ export CONDA_PYTHON_EXE=/opt/miniconda3/bin/python
+++ CONDA_PYTHON_EXE=/opt/miniconda3/bin/python
+++ '[' -z '' ']'
+++ export CONDA_SHLVL=0
+++ CONDA_SHLVL=0
+++ '[' -n '' ']'
+++++ dirname /opt/miniconda3/bin/conda
++++ dirname /opt/miniconda3/bin
+++ PATH=/opt/miniconda3/condabin:/opt/miniconda3/bin:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin
+++ export PATH
+++ '[' -z '' ']'
+++ PS1=
++ conda activate
++ local cmd=activate
++ case "$cmd" in
++ __conda_activate activate
++ '[' -n '' ']'
++ local ask_conda
+++ PS1=
+++ __conda_exe shell.posix activate
+++ /opt/miniconda3/bin/conda shell.posix activate
++ ask_conda='PS1='\''(base) '\''
export PATH='\''/opt/miniconda3/bin:/opt/miniconda3/condabin:/opt/miniconda3/bin:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin'\''
export CONDA_PREFIX='\''/opt/miniconda3'\''
export CONDA_SHLVL='\''1'\''
export CONDA_DEFAULT_ENV='\''base'\''
export CONDA_PROMPT_MODIFIER='\''(base) '\''
export CONDA_EXE='\''/opt/miniconda3/bin/conda'\''
export _CE_M='\'''\''
export _CE_CONDA='\'''\''
export CONDA_PYTHON_EXE='\''/opt/miniconda3/bin/python'\'''
++ eval 'PS1='\''(base) '\''
export PATH='\''/opt/miniconda3/bin:/opt/miniconda3/condabin:/opt/miniconda3/bin:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin'\''
export CONDA_PREFIX='\''/opt/miniconda3'\''
export CONDA_SHLVL='\''1'\''
export CONDA_DEFAULT_ENV='\''base'\''
export CONDA_PROMPT_MODIFIER='\''(base) '\''
export CONDA_EXE='\''/opt/miniconda3/bin/conda'\''
export _CE_M='\'''\''
export _CE_CONDA='\'''\''
export CONDA_PYTHON_EXE='\''/opt/miniconda3/bin/python'\'''
+++ PS1='(base) '
+++ export PATH=/opt/miniconda3/bin:/opt/miniconda3/condabin:/opt/miniconda3/bin:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin
+++ PATH=/opt/miniconda3/bin:/opt/miniconda3/condabin:/opt/miniconda3/bin:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin
+++ export CONDA_PREFIX=/opt/miniconda3
+++ CONDA_PREFIX=/opt/miniconda3
+++ export CONDA_SHLVL=1
+++ CONDA_SHLVL=1
+++ export CONDA_DEFAULT_ENV=base
+++ CONDA_DEFAULT_ENV=base
+++ export 'CONDA_PROMPT_MODIFIER=(base) '
+++ CONDA_PROMPT_MODIFIER='(base) '
+++ export CONDA_EXE=/opt/miniconda3/bin/conda
+++ CONDA_EXE=/opt/miniconda3/bin/conda
+++ export _CE_M=
+++ _CE_M=
+++ export _CE_CONDA=
+++ _CE_CONDA=
+++ export CONDA_PYTHON_EXE=/opt/miniconda3/bin/python
+++ CONDA_PYTHON_EXE=/opt/miniconda3/bin/python
++ __conda_hashr
++ '[' -n '' ']'
++ '[' -n '' ']'
++ hash -r
+ conda activate testbed
+ local cmd=activate
+ case "$cmd" in
+ __conda_activate activate testbed
+ '[' -n '' ']'
+ local ask_conda
++ PS1='(base) '
++ __conda_exe shell.posix activate testbed
++ /opt/miniconda3/bin/conda shell.posix activate testbed
+ ask_conda='PS1='\''(testbed) '\''
export PATH='\''/opt/miniconda3/envs/testbed/bin:/opt/miniconda3/condabin:/opt/miniconda3/bin:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin'\''
export CONDA_PREFIX='\''/opt/miniconda3/envs/testbed'\''
export CONDA_SHLVL='\''2'\''
export CONDA_DEFAULT_ENV='\''testbed'\''
export CONDA_PROMPT_MODIFIER='\''(testbed) '\''
export CONDA_PREFIX_1='\''/opt/miniconda3'\''
export CONDA_EXE='\''/opt/miniconda3/bin/conda'\''
export _CE_M='\'''\''
export _CE_CONDA='\'''\''
export CONDA_PYTHON_EXE='\''/opt/miniconda3/bin/python'\'''
+ eval 'PS1='\''(testbed) '\''
export PATH='\''/opt/miniconda3/envs/testbed/bin:/opt/miniconda3/condabin:/opt/miniconda3/bin:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin'\''
export CONDA_PREFIX='\''/opt/miniconda3/envs/testbed'\''
export CONDA_SHLVL='\''2'\''
export CONDA_DEFAULT_ENV='\''testbed'\''
export CONDA_PROMPT_MODIFIER='\''(testbed) '\''
export CONDA_PREFIX_1='\''/opt/miniconda3'\''
export CONDA_EXE='\''/opt/miniconda3/bin/conda'\''
export _CE_M='\'''\''
export _CE_CONDA='\'''\''
export CONDA_PYTHON_EXE='\''/opt/miniconda3/bin/python'\'''
++ PS1='(testbed) '
++ export PATH=/opt/miniconda3/envs/testbed/bin:/opt/miniconda3/condabin:/opt/miniconda3/bin:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin
++ PATH=/opt/miniconda3/envs/testbed/bin:/opt/miniconda3/condabin:/opt/miniconda3/bin:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin
++ export CONDA_PREFIX=/opt/miniconda3/envs/testbed
++ CONDA_PREFIX=/opt/miniconda3/envs/testbed
++ export CONDA_SHLVL=2
++ CONDA_SHLVL=2
++ export CONDA_DEFAULT_ENV=testbed
++ CONDA_DEFAULT_ENV=testbed
++ export 'CONDA_PROMPT_MODIFIER=(testbed) '
++ CONDA_PROMPT_MODIFIER='(testbed) '
++ export CONDA_PREFIX_1=/opt/miniconda3
++ CONDA_PREFIX_1=/opt/miniconda3
++ export CONDA_EXE=/opt/miniconda3/bin/conda
++ CONDA_EXE=/opt/miniconda3/bin/conda
++ export _CE_M=
++ _CE_M=
++ export _CE_CONDA=
++ _CE_CONDA=
++ export CONDA_PYTHON_EXE=/opt/miniconda3/bin/python
++ CONDA_PYTHON_EXE=/opt/miniconda3/bin/python
+ __conda_hashr
+ '[' -n '' ']'
+ '[' -n '' ']'
+ hash -r
+ cd /testbed
+ git config --global --add safe.directory /testbed
+ cd /testbed
+ git status
On branch main
Untracked files:
  (use "git add <file>..." to include in what will be committed)
	reproduce_issue.py

nothing added to commit but untracked files present (use "git add" to track)
+ git show
commit 14e1a23a3166b9a645a16de96f694c77a5d4abb7
Author: myschkyna <65536105+myschkyna@users.noreply.github.com>
Date:   Wed Oct 13 16:14:42 2021 +0200

    Snowflake auto increments fixes (#1620)
    
    * Replace non-existent NumericLiteralValue with NumericLiteralSegment
    
    * Update tests

diff --git a/src/sqlfluff/dialects/dialect_snowflake.py b/src/sqlfluff/dialects/dialect_snowflake.py
index 7920e3544..546fc3dae 100644
--- a/src/sqlfluff/dialects/dialect_snowflake.py
+++ b/src/sqlfluff/dialects/dialect_snowflake.py
@@ -1158,12 +1158,12 @@ class ColumnConstraintSegment(BaseSegment):
         Sequence(
             OneOf("AUTOINCREMENT", "IDENTITY"),
             OneOf(
-                Bracketed(Delimited(Ref("NumericLiteralValue"))),
+                Bracketed(Delimited(Ref("NumericLiteralSegment"))),
                 Sequence(
                     "START",
-                    Ref("NumericLiteralValue"),
+                    Ref("NumericLiteralSegment"),
                     "INCREMENT",
-                    Ref("NumericLiteralValue"),
+                    Ref("NumericLiteralSegment"),
                 ),
             ),
         ),
diff --git a/test/fixtures/dialects/snowflake/snowflake_create_table.sql b/test/fixtures/dialects/snowflake/snowflake_create_table.sql
index 8a024f858..5a07667b8 100644
--- a/test/fixtures/dialects/snowflake/snowflake_create_table.sql
+++ b/test/fixtures/dialects/snowflake/snowflake_create_table.sql
@@ -71,3 +71,7 @@ CREATE TABLE timestamp_column_default_value_demo (
 	timestamp_col3 TIMESTAMP_TZ DEFAULT CURRENT_TIMESTAMP(2),
 	sysdate_col4 TIMESTAMP_TZ DEFAULT SYSDATE()
 );
+
+create table test_table (test_column NUMBER autoincrement (0, 1));
+create table test_schema.test_table (test_column NUMBER autoincrement (0, 1));
+create or replace table test_schema.test_table (test_column NUMBER autoincrement (0, 1));
diff --git a/test/fixtures/dialects/snowflake/snowflake_create_table.yml b/test/fixtures/dialects/snowflake/snowflake_create_table.yml
index 36f850dd6..fcf187d19 100644
--- a/test/fixtures/dialects/snowflake/snowflake_create_table.yml
+++ b/test/fixtures/dialects/snowflake/snowflake_create_table.yml
@@ -3,7 +3,7 @@
 # computed by SQLFluff when running the tests. Please run
 # `python test/generate_parse_fixture_yml.py`  to generate them after adding or
 # altering SQL files.
-_hash: 42d41ad60a4693f4fce33fdc6d8a2da40c5ac054ee5cca2951debc2672c56a12
+_hash: 63464647b2201f8b0742e86153275af74f2954ad95b1dab8d7043977e27c2bc3
 file:
 - statement:
     create_table_statement:
@@ -625,3 +625,75 @@ file:
               end_bracket: )
       - end_bracket: )
 - statement_terminator: ;
+- statement:
+    create_table_statement:
+    - keyword: create
+    - keyword: table
+    - table_reference:
+        identifier: test_table
+    - bracketed:
+        start_bracket: (
+        column_definition:
+          identifier: test_column
+          data_type:
+            data_type_identifier: NUMBER
+          column_constraint_segment:
+            keyword: autoincrement
+            bracketed:
+            - start_bracket: (
+            - literal: '0'
+            - comma: ','
+            - literal: '1'
+            - end_bracket: )
+        end_bracket: )
+- statement_terminator: ;
+- statement:
+    create_table_statement:
+    - keyword: create
+    - keyword: table
+    - table_reference:
+      - identifier: test_schema
+      - dot: .
+      - identifier: test_table
+    - bracketed:
+        start_bracket: (
+        column_definition:
+          identifier: test_column
+          data_type:
+            data_type_identifier: NUMBER
+          column_constraint_segment:
+            keyword: autoincrement
+            bracketed:
+            - start_bracket: (
+            - literal: '0'
+            - comma: ','
+            - literal: '1'
+            - end_bracket: )
+        end_bracket: )
+- statement_terminator: ;
+- statement:
+    create_table_statement:
+    - keyword: create
+    - binary_operator: or
+    - keyword: replace
+    - keyword: table
+    - table_reference:
+      - identifier: test_schema
+      - dot: .
+      - identifier: test_table
+    - bracketed:
+        start_bracket: (
+        column_definition:
+          identifier: test_column
+          data_type:
+            data_type_identifier: NUMBER
+          column_constraint_segment:
+            keyword: autoincrement
+            bracketed:
+            - start_bracket: (
+            - literal: '0'
+            - comma: ','
+            - literal: '1'
+            - end_bracket: )
+        end_bracket: )
+- statement_terminator: ;
+ git diff 14e1a23a3166b9a645a16de96f694c77a5d4abb7
+ source /opt/miniconda3/bin/activate
++ _CONDA_ROOT=/opt/miniconda3
++ . /opt/miniconda3/etc/profile.d/conda.sh
+++ export CONDA_EXE=/opt/miniconda3/bin/conda
+++ CONDA_EXE=/opt/miniconda3/bin/conda
+++ export _CE_M=
+++ _CE_M=
+++ export _CE_CONDA=
+++ _CE_CONDA=
+++ export CONDA_PYTHON_EXE=/opt/miniconda3/bin/python
+++ CONDA_PYTHON_EXE=/opt/miniconda3/bin/python
+++ '[' -z x ']'
++ conda activate
++ local cmd=activate
++ case "$cmd" in
++ __conda_activate activate
++ '[' -n '' ']'
++ local ask_conda
+++ PS1='(testbed) '
+++ __conda_exe shell.posix activate
+++ /opt/miniconda3/bin/conda shell.posix activate
++ ask_conda='PS1='\''(base) '\''
export PATH='\''/opt/miniconda3/bin:/opt/miniconda3/condabin:/opt/miniconda3/bin:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin'\''
export CONDA_PREFIX='\''/opt/miniconda3'\''
export CONDA_SHLVL='\''3'\''
export CONDA_DEFAULT_ENV='\''base'\''
export CONDA_PROMPT_MODIFIER='\''(base) '\''
export CONDA_PREFIX_2='\''/opt/miniconda3/envs/testbed'\''
export CONDA_EXE='\''/opt/miniconda3/bin/conda'\''
export _CE_M='\'''\''
export _CE_CONDA='\'''\''
export CONDA_PYTHON_EXE='\''/opt/miniconda3/bin/python'\'''
++ eval 'PS1='\''(base) '\''
export PATH='\''/opt/miniconda3/bin:/opt/miniconda3/condabin:/opt/miniconda3/bin:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin'\''
export CONDA_PREFIX='\''/opt/miniconda3'\''
export CONDA_SHLVL='\''3'\''
export CONDA_DEFAULT_ENV='\''base'\''
export CONDA_PROMPT_MODIFIER='\''(base) '\''
export CONDA_PREFIX_2='\''/opt/miniconda3/envs/testbed'\''
export CONDA_EXE='\''/opt/miniconda3/bin/conda'\''
export _CE_M='\'''\''
export _CE_CONDA='\'''\''
export CONDA_PYTHON_EXE='\''/opt/miniconda3/bin/python'\'''
+++ PS1='(base) '
+++ export PATH=/opt/miniconda3/bin:/opt/miniconda3/condabin:/opt/miniconda3/bin:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin
+++ PATH=/opt/miniconda3/bin:/opt/miniconda3/condabin:/opt/miniconda3/bin:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin
+++ export CONDA_PREFIX=/opt/miniconda3
+++ CONDA_PREFIX=/opt/miniconda3
+++ export CONDA_SHLVL=3
+++ CONDA_SHLVL=3
+++ export CONDA_DEFAULT_ENV=base
+++ CONDA_DEFAULT_ENV=base
+++ export 'CONDA_PROMPT_MODIFIER=(base) '
+++ CONDA_PROMPT_MODIFIER='(base) '
+++ export CONDA_PREFIX_2=/opt/miniconda3/envs/testbed
+++ CONDA_PREFIX_2=/opt/miniconda3/envs/testbed
+++ export CONDA_EXE=/opt/miniconda3/bin/conda
+++ CONDA_EXE=/opt/miniconda3/bin/conda
+++ export _CE_M=
+++ _CE_M=
+++ export _CE_CONDA=
+++ _CE_CONDA=
+++ export CONDA_PYTHON_EXE=/opt/miniconda3/bin/python
+++ CONDA_PYTHON_EXE=/opt/miniconda3/bin/python
++ __conda_hashr
++ '[' -n '' ']'
++ '[' -n '' ']'
++ hash -r
+ conda activate testbed
+ local cmd=activate
+ case "$cmd" in
+ __conda_activate activate testbed
+ '[' -n '' ']'
+ local ask_conda
++ PS1='(base) '
++ __conda_exe shell.posix activate testbed
++ /opt/miniconda3/bin/conda shell.posix activate testbed
+ ask_conda='PS1='\''(testbed) '\''
export PATH='\''/opt/miniconda3/envs/testbed/bin:/opt/miniconda3/condabin:/opt/miniconda3/bin:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin'\''
export CONDA_PREFIX='\''/opt/miniconda3/envs/testbed'\''
export CONDA_SHLVL='\''4'\''
export CONDA_DEFAULT_ENV='\''testbed'\''
export CONDA_PROMPT_MODIFIER='\''(testbed) '\''
export CONDA_PREFIX_3='\''/opt/miniconda3'\''
export CONDA_EXE='\''/opt/miniconda3/bin/conda'\''
export _CE_M='\'''\''
export _CE_CONDA='\'''\''
export CONDA_PYTHON_EXE='\''/opt/miniconda3/bin/python'\'''
+ eval 'PS1='\''(testbed) '\''
export PATH='\''/opt/miniconda3/envs/testbed/bin:/opt/miniconda3/condabin:/opt/miniconda3/bin:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin'\''
export CONDA_PREFIX='\''/opt/miniconda3/envs/testbed'\''
export CONDA_SHLVL='\''4'\''
export CONDA_DEFAULT_ENV='\''testbed'\''
export CONDA_PROMPT_MODIFIER='\''(testbed) '\''
export CONDA_PREFIX_3='\''/opt/miniconda3'\''
export CONDA_EXE='\''/opt/miniconda3/bin/conda'\''
export _CE_M='\'''\''
export _CE_CONDA='\'''\''
export CONDA_PYTHON_EXE='\''/opt/miniconda3/bin/python'\'''
++ PS1='(testbed) '
++ export PATH=/opt/miniconda3/envs/testbed/bin:/opt/miniconda3/condabin:/opt/miniconda3/bin:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin
++ PATH=/opt/miniconda3/envs/testbed/bin:/opt/miniconda3/condabin:/opt/miniconda3/bin:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin
++ export CONDA_PREFIX=/opt/miniconda3/envs/testbed
++ CONDA_PREFIX=/opt/miniconda3/envs/testbed
++ export CONDA_SHLVL=4
++ CONDA_SHLVL=4
++ export CONDA_DEFAULT_ENV=testbed
++ CONDA_DEFAULT_ENV=testbed
++ export 'CONDA_PROMPT_MODIFIER=(testbed) '
++ CONDA_PROMPT_MODIFIER='(testbed) '
++ export CONDA_PREFIX_3=/opt/miniconda3
++ CONDA_PREFIX_3=/opt/miniconda3
++ export CONDA_EXE=/opt/miniconda3/bin/conda
++ CONDA_EXE=/opt/miniconda3/bin/conda
++ export _CE_M=
++ _CE_M=
++ export _CE_CONDA=
++ _CE_CONDA=
++ export CONDA_PYTHON_EXE=/opt/miniconda3/bin/python
++ CONDA_PYTHON_EXE=/opt/miniconda3/bin/python
+ __conda_hashr
+ '[' -n '' ']'
+ '[' -n '' ']'
+ hash -r
+ python -m pip install -e .
Obtaining file:///testbed
  Preparing metadata (setup.py): started
  Preparing metadata (setup.py): finished with status 'done'
Requirement already satisfied: click>=7.1 in /opt/miniconda3/envs/testbed/lib/python3.9/site-packages (from sqlfluff==0.7.0a8) (8.1.7)
Requirement already satisfied: colorama>=0.3 in /opt/miniconda3/envs/testbed/lib/python3.9/site-packages (from sqlfluff==0.7.0a8) (0.4.6)
Requirement already satisfied: configparser in /opt/miniconda3/envs/testbed/lib/python3.9/site-packages (from sqlfluff==0.7.0a8) (7.1.0)
Requirement already satisfied: oyaml in /opt/miniconda3/envs/testbed/lib/python3.9/site-packages (from sqlfluff==0.7.0a8) (1.0)
Requirement already satisfied: Jinja2 in /opt/miniconda3/envs/testbed/lib/python3.9/site-packages (from sqlfluff==0.7.0a8) (3.1.4)
Requirement already satisfied: diff-cover>=2.5.0 in /opt/miniconda3/envs/testbed/lib/python3.9/site-packages (from sqlfluff==0.7.0a8) (9.2.0)
Requirement already satisfied: pathspec in /opt/miniconda3/envs/testbed/lib/python3.9/site-packages (from sqlfluff==0.7.0a8) (0.12.1)
Requirement already satisfied: appdirs in /opt/miniconda3/envs/testbed/lib/python3.9/site-packages (from sqlfluff==0.7.0a8) (1.4.4)
Requirement already satisfied: cached-property in /opt/miniconda3/envs/testbed/lib/python3.9/site-packages (from sqlfluff==0.7.0a8) (2.0.1)
Requirement already satisfied: typing_extensions in /opt/miniconda3/envs/testbed/lib/python3.9/site-packages (from sqlfluff==0.7.0a8) (4.12.2)
Requirement already satisfied: pytest in /opt/miniconda3/envs/testbed/lib/python3.9/site-packages (from sqlfluff==0.7.0a8) (8.3.3)
Requirement already satisfied: toml in /opt/miniconda3/envs/testbed/lib/python3.9/site-packages (from sqlfluff==0.7.0a8) (0.10.2)
Requirement already satisfied: tblib in /opt/miniconda3/envs/testbed/lib/python3.9/site-packages (from sqlfluff==0.7.0a8) (3.0.0)
Requirement already satisfied: Pygments<3.0.0,>=2.9.0 in /opt/miniconda3/envs/testbed/lib/python3.9/site-packages (from diff-cover>=2.5.0->sqlfluff==0.7.0a8) (2.18.0)
Requirement already satisfied: chardet>=3.0.0 in /opt/miniconda3/envs/testbed/lib/python3.9/site-packages (from diff-cover>=2.5.0->sqlfluff==0.7.0a8) (5.2.0)
Requirement already satisfied: pluggy<2,>=0.13.1 in /opt/miniconda3/envs/testbed/lib/python3.9/site-packages (from diff-cover>=2.5.0->sqlfluff==0.7.0a8) (1.5.0)
Requirement already satisfied: MarkupSafe>=2.0 in /opt/miniconda3/envs/testbed/lib/python3.9/site-packages (from Jinja2->sqlfluff==0.7.0a8) (3.0.2)
Requirement already satisfied: pyyaml in /opt/miniconda3/envs/testbed/lib/python3.9/site-packages (from oyaml->sqlfluff==0.7.0a8) (6.0.2)
Requirement already satisfied: iniconfig in /opt/miniconda3/envs/testbed/lib/python3.9/site-packages (from pytest->sqlfluff==0.7.0a8) (2.0.0)
Requirement already satisfied: packaging in /opt/miniconda3/envs/testbed/lib/python3.9/site-packages (from pytest->sqlfluff==0.7.0a8) (24.1)
Requirement already satisfied: exceptiongroup>=1.0.0rc8 in /opt/miniconda3/envs/testbed/lib/python3.9/site-packages (from pytest->sqlfluff==0.7.0a8) (1.2.2)
Requirement already satisfied: tomli>=1 in /opt/miniconda3/envs/testbed/lib/python3.9/site-packages (from pytest->sqlfluff==0.7.0a8) (2.0.2)
Installing collected packages: sqlfluff
  Attempting uninstall: sqlfluff
    Found existing installation: sqlfluff 0.7.0a8
    Uninstalling sqlfluff-0.7.0a8:
      Successfully uninstalled sqlfluff-0.7.0a8
  DEPRECATION: Legacy editable install of sqlfluff==0.7.0a8 from file:///testbed (setup.py develop) is deprecated. pip 25.0 will enforce this behaviour change. A possible replacement is to add a pyproject.toml or enable --use-pep517, and use setuptools >= 64. If the resulting installation is not behaving as expected, try using --config-settings editable_mode=compat. Please consult the setuptools documentation for more information. Discussion can be found at https://github.com/pypa/pip/issues/11457
  Running setup.py develop for sqlfluff
Successfully installed sqlfluff
WARNING: Running pip as the 'root' user can result in broken permissions and conflicting behaviour with the system package manager, possibly rendering your system unusable.It is recommended to use a virtual environment instead: https://pip.pypa.io/warnings/venv. Use the --root-user-action option if you know what you are doing and want to suppress this warning.
+ git checkout 14e1a23a3166b9a645a16de96f694c77a5d4abb7 test/cli/commands_test.py
Updated 0 paths from dd86467b8
+ git apply -v -
Checking patch test/cli/commands_test.py...
Applied patch test/cli/commands_test.py cleanly.
+ pytest -rA test/cli/commands_test.py
============================= test session starts ==============================
platform linux -- Python 3.9.20, pytest-8.3.3, pluggy-1.5.0
rootdir: /testbed
configfile: pytest.ini
plugins: cov-6.0.0, hypothesis-6.115.6, sugar-1.0.0
collected 69 items

test/cli/commands_test.py F............................................. [ 66%]
.......................                                                  [100%]

=================================== FAILURES ===================================
_________________________ test__cli__command_directed __________________________

    def test__cli__command_directed():
        """Basic checking of lint functionality."""
        result = invoke_assert_code(
            ret_code=65,
            args=[lint, ["test/fixtures/linter/indentation_error_simple.sql"]],
        )
        # We should get a readout of what the error was
        check_a = "L:   2 | P:   4 | L003"
        # NB: Skip the number at the end because it's configurable
        check_b = "Indentation"
        assert check_a in result.output
        assert check_b in result.output
        # Finally check the WHOLE output to make sure that unexpected newlines are not added.
        # The replace command just accounts for cross platform testing.
>       assert result.output.replace("\\", "/").startswith(expected_output)
E       AssertionError: assert False
E        +  where False = <built-in method startswith of str object at 0x2764500>('== [test/fixtures/linter/indentation_error_simple.sql] FAIL\nL:   2 | P:   4 | L003 | Indentation not hanging or a mu...ywords must be consistently upper case.\nL:   5 | P:  13 | L031 | Avoid aliases in from clauses and join conditions.\n')
E        +    where <built-in method startswith of str object at 0x2764500> = '== [test/fixtures/linter/indentation_error_simple.sql] FAIL\nL:   2 | P:   4 | L003 | Indentation not hanging or a mu... must be consistently upper case.\nL:   5 | P:  13 | L031 | Avoid using aliases in join condition\nAll Finished 📜 🎉!\n'.startswith
E        +      where '== [test/fixtures/linter/indentation_error_simple.sql] FAIL\nL:   2 | P:   4 | L003 | Indentation not hanging or a mu... must be consistently upper case.\nL:   5 | P:  13 | L031 | Avoid using aliases in join condition\nAll Finished 📜 🎉!\n' = <built-in method replace of str object at 0x2764500>('\\', '/')
E        +        where <built-in method replace of str object at 0x2764500> = '== [test/fixtures/linter/indentation_error_simple.sql] FAIL\nL:   2 | P:   4 | L003 | Indentation not hanging or a mu... must be consistently upper case.\nL:   5 | P:  13 | L031 | Avoid using aliases in join condition\nAll Finished 📜 🎉!\n'.replace
E        +          where '== [test/fixtures/linter/indentation_error_simple.sql] FAIL\nL:   2 | P:   4 | L003 | Indentation not hanging or a mu... must be consistently upper case.\nL:   5 | P:  13 | L031 | Avoid using aliases in join condition\nAll Finished 📜 🎉!\n' = <Result SystemExit(65)>.output

test/cli/commands_test.py:70: AssertionError
----------------------------- Captured stdout call -----------------------------
== [test/fixtures/linter/indentation_error_simple.sql] FAIL
L:   2 | P:   4 | L003 | Indentation not hanging or a multiple of 4 spaces
L:   5 | P:  10 | L010 | Keywords must be consistently upper case.
L:   5 | P:  13 | L031 | Avoid using aliases in join condition
All Finished 📜 🎉!

=============================== warnings summary ===============================
src/sqlfluff/__init__.py:9
  /testbed/src/sqlfluff/__init__.py:9: DeprecationWarning: pkg_resources is deprecated as an API. See https://setuptools.pypa.io/en/latest/pkg_resources.html
    import pkg_resources

-- Docs: https://docs.pytest.org/en/stable/how-to/capture-warnings.html
==================================== PASSES ====================================
__________________________ test__cli__command_dialect __________________________
----------------------------- Captured stdout call -----------------------------
Error: Unknown dialect 'faslkjh'

______________________ test__cli__command_dialect_legacy _______________________
----------------------------- Captured stdout call -----------------------------
Error loading dialect 'exasol_fs': As of 0.7.0 the 'exasol_fs' dialect has been combined with the 'exasol' dialect, and is no longer a standalone dialect. Please use the 'exasol' dialect instead.

___________________ test__cli__command_lint_stdin[command0] ____________________
----------------------------- Captured stdout call -----------------------------
All Finished!

___________________ test__cli__command_lint_stdin[command1] ____________________
----------------------------- Captured stdout call -----------------------------
==== sqlfluff ====
sqlfluff:              0.7.0a8 python:                 3.9.20
implementation:        cpython dialect:                  ansi
verbosity:                   1 templater:               jinja

== [stdin] PASS
All Finished!

___________________ test__cli__command_lint_stdin[command2] ____________________
----------------------------- Captured stdout call -----------------------------
==== sqlfluff ====
sqlfluff:              0.7.0a8 python:                 3.9.20
implementation:        cpython dialect:                  ansi
verbosity:                   2 templater:               jinja

== Raw Config:
core:                                   
    color:              False               
    dialect:            ansi                
    encoding:           autodetect          
    ignore:             []                  
    ignore_templated_areas:True                
    nocolor:            True                
    output_line_length: 80                  
    recurse:            True                
    runaway_limit:      10                  
    sql_file_exts:      .sql,.sql.j2,.dml,.ddl
    templater:          jinja               
    verbose:            2                   
indentation:                            
    indented_joins:     False               
    indented_using_on:  True                
    template_blocks_indent:True                
rules:                                  
    allow_scalar:       True                
    comma_style:        trailing            
    indent_unit:        space               
    max_line_length:    80                  
    single_table_references:consistent          
    tab_space_size:     4                   
    unquoted_identifiers_policy:all                 
    L007:                                   
        operator_new_lines: after               
    L010:                                   
        capitalisation_policy:consistent          
    L011:                                   
        aliasing:           explicit            
    L012:                                   
        aliasing:           explicit            
    L014:                                   
        extended_capitalisation_policy:consistent          
    L016:                                   
        ignore_comment_lines:False               
    L026:                                   
        force_enable:       False               
    L028:                                   
        force_enable:       False               
    L029:                                   
        unquoted_identifiers_policy:aliases             
    L030:                                   
        capitalisation_policy:consistent          
    L038:                                   
        select_clause_trailing_comma:forbid              
    L040:                                   
        capitalisation_policy:consistent          
    L042:                                   
        forbid_subquery_in: join                
    L047:                                   
        prefer_count_0:     False               
        prefer_count_1:     False               
templater:                              
    unwrap_wrapped_queries:True                
    jinja:                                  
        apply_dbt_builtins: True                
        macros:                                 
            dbt_config:         {% macro config() %}{% for k in kwargs %}{% endfor %}{% endmacro %}
            dbt_is_incremental: {% macro is_incremental() %}True{% endmacro %}
            dbt_ref:            {% macro ref(model_ref) %}{{model_ref}}{% endmacro %}
            dbt_source:         {% macro source(source_name, table) %}{{source_name}}_{{table}}{% endmacro %}
            dbt_var:            {% macro var(variable, default='') %}item{% endmacro %}

== [stdin] TEMPLATING
== [stdin] PARSING
== [stdin] LINTING
== [stdin] PASS
All Finished!

___________________ test__cli__command_lint_stdin[command3] ____________________
----------------------------- Captured stdout call -----------------------------
==== sqlfluff ====
sqlfluff:              0.7.0a8 python:                 3.9.20
implementation:        cpython dialect:                  ansi
verbosity:                   2 templater:               jinja

== Raw Config:
core:                                   
    dialect:            ansi                
    encoding:           autodetect          
    ignore:             []                  
    ignore_templated_areas:True                
    nocolor:            False               
    output_line_length: 80                  
    recurse:            True                
    runaway_limit:      10                  
    sql_file_exts:      .sql,.sql.j2,.dml,.ddl
    templater:          jinja               
    verbose:            2                   
indentation:                            
    indented_joins:     False               
    indented_using_on:  True                
    template_blocks_indent:True                
rules:                                  
    allow_scalar:       True                
    comma_style:        trailing            
    indent_unit:        space               
    max_line_length:    80                  
    single_table_references:consistent          
    tab_space_size:     4                   
    unquoted_identifiers_policy:all                 
    L007:                                   
        operator_new_lines: after               
    L010:                                   
        capitalisation_policy:consistent          
    L011:                                   
        aliasing:           explicit            
    L012:                                   
        aliasing:           explicit            
    L014:                                   
        extended_capitalisation_policy:consistent          
    L016:                                   
        ignore_comment_lines:False               
    L026:                                   
        force_enable:       False               
    L028:                                   
        force_enable:       False               
    L029:                                   
        unquoted_identifiers_policy:aliases             
    L030:                                   
        capitalisation_policy:consistent          
    L038:                                   
        select_clause_trailing_comma:forbid              
    L040:                                   
        capitalisation_policy:consistent          
    L042:                                   
        forbid_subquery_in: join                
    L047:                                   
        prefer_count_0:     False               
        prefer_count_1:     False               
templater:                              
    unwrap_wrapped_queries:True                
    jinja:                                  
        apply_dbt_builtins: True                
        macros:                                 
            dbt_config:         {% macro config() %}{% for k in kwargs %}{% endfor %}{% endmacro %}
            dbt_is_incremental: {% macro is_incremental() %}True{% endmacro %}
            dbt_ref:            {% macro ref(model_ref) %}{{model_ref}}{% endmacro %}
            dbt_source:         {% macro source(source_name, table) %}{{source_name}}_{{table}}{% endmacro %}
            dbt_var:            {% macro var(variable, default='') %}item{% endmacro %}

== [stdin] TEMPLATING
== [stdin] PARSING
== [stdin] LINTING
== [stdin] PASS
All Finished 📜 🎉!

___________________ test__cli__command_lint_parse[command0] ____________________
----------------------------- Captured stdout call -----------------------------
All Finished!

___________________ test__cli__command_lint_parse[command1] ____________________
----------------------------- Captured stdout call -----------------------------
All Finished!

___________________ test__cli__command_lint_parse[command2] ____________________
----------------------------- Captured stdout call -----------------------------
==== sqlfluff ====
sqlfluff:              0.7.0a8 python:                 3.9.20
implementation:        cpython dialect:                  ansi
verbosity:                   1 templater:               jinja

==== readout ====

=== [ path: test/fixtures/cli/passing_a.sql ] ===

== [test/fixtures/cli/passing_a.sql] PASS
==== summary ====
violations:        0 status:         PASS
All Finished!

___________________ test__cli__command_lint_parse[command3] ____________________
----------------------------- Captured stdout call -----------------------------
==== sqlfluff ====
sqlfluff:              0.7.0a8 python:                 3.9.20
implementation:        cpython dialect:                  ansi
verbosity:                   4 templater:               jinja

== Raw Config:
core:                                   
    color:              False               
    dialect:            ansi                
    encoding:           autodetect          
    ignore:             []                  
    ignore_templated_areas:True                
    nocolor:            True                
    output_line_length: 80                  
    recurse:            True                
    runaway_limit:      10                  
    sql_file_exts:      .sql,.sql.j2,.dml,.ddl
    templater:          jinja               
    verbose:            4                   
indentation:                            
    indented_joins:     False               
    indented_using_on:  True                
    template_blocks_indent:True                
rules:                                  
    allow_scalar:       True                
    comma_style:        trailing            
    indent_unit:        space               
    max_line_length:    80                  
    single_table_references:consistent          
    tab_space_size:     4                   
    unquoted_identifiers_policy:all                 
    L007:                                   
        operator_new_lines: after               
    L010:                                   
        capitalisation_policy:consistent          
    L011:                                   
        aliasing:           explicit            
    L012:                                   
        aliasing:           explicit            
    L014:                                   
        extended_capitalisation_policy:consistent          
    L016:                                   
        ignore_comment_lines:False               
    L026:                                   
        force_enable:       False               
    L028:                                   
        force_enable:       False               
    L029:                                   
        unquoted_identifiers_policy:aliases             
    L030:                                   
        capitalisation_policy:consistent          
    L038:                                   
        select_clause_trailing_comma:forbid              
    L040:                                   
        capitalisation_policy:consistent          
    L042:                                   
        forbid_subquery_in: join                
    L047:                                   
        prefer_count_0:     False               
        prefer_count_1:     False               
templater:                              
    unwrap_wrapped_queries:True                
    jinja:                                  
        apply_dbt_builtins: True                
        macros:                                 
            dbt_config:         {% macro config() %}{% for k in kwargs %}{% endfor %}{% endmacro %}
            dbt_is_incremental: {% macro is_incremental() %}True{% endmacro %}
            dbt_ref:            {% macro ref(model_ref) %}{{model_ref}}{% endmacro %}
            dbt_source:         {% macro source(source_name, table) %}{{source_name}}_{{table}}{% endmacro %}
            dbt_var:            {% macro var(variable, default='') %}item{% endmacro %}

==== readout ====

=== [ path: test/fixtures/cli/passing_a.sql ] ===

INFO       TEMPLATING RAW [jinja] (test/fixtures/cli/passing_a.sql)
INFO       Slicing File Template
DEBUG          Raw String: 'SELECT\n    tbl.name,\n    tbl.value\nFROM tbl\n'
DEBUG          Templated String: 'SELECT\n    tbl.name,\n    tbl.value\nFROM tbl\n'
DEBUG          Raw Sliced:
DEBUG              0: RawFileSlice(raw='SELECT\n    tbl.name,\n    tbl.value\nFROM tbl\n', slice_type='literal', source_idx=0, slice_subtype=None)
DEBUG          Literals: ['SELECT\n    tbl.name,\n    tbl.value\nFROM tbl\n']
DEBUG          # Slice Loop 0
DEBUG          Occurrences: Raw: {'SELECT\n    tbl.name,\n    tbl.value\nFROM tbl\n': [0]}, Templated: {'SELECT\n    tbl.name,\n    tbl.value\nFROM tbl\n': [0]}
DEBUG          Split Sliced:
DEBUG              0: IntermediateFileSlice(intermediate_type='invariant', source_slice=slice(0, 44, None), templated_slice=slice(0, 44, None), slice_buffer=[RawFileSlice(raw='SELECT\n    tbl.name,\n    tbl.value\nFROM tbl\n', slice_type='literal', source_idx=0, slice_subtype=None)])
DEBUG          _split_uniques_coalesce_rest: [IntermediateFileSlice(intermediate_type='invariant', source_slice=slice(0, 44, None), templated_slice=slice(0, 44, None), slice_buffer=[RawFileSlice(raw='SELECT\n    tbl.name,\n    tbl.value\nFROM tbl\n', slice_type='literal', source_idx=0, slice_subtype=None)])]
DEBUG              Yielding Simple: TemplatedFileSlice(slice_type='literal', source_slice=slice(0, 44, None), templated_slice=slice(0, 44, None))
DEBUG          Fully Sliced:
DEBUG              0: TemplatedFileSlice(slice_type='literal', source_slice=slice(0, 44, None), templated_slice=slice(0, 44, None))
INFO       [L001] No config_keywords defined for L001
INFO       [L005] No config_keywords defined for L005
INFO       [L006] No config_keywords defined for L006
INFO       [L008] No config_keywords defined for L008
INFO       [L009] No config_keywords defined for L009
INFO       [L015] No config_keywords defined for L015
INFO       [L017] No config_keywords defined for L017
INFO       [L020] No config_keywords defined for L020
INFO       [L021] No config_keywords defined for L021
INFO       [L023] No config_keywords defined for L023
INFO       [L024] No config_keywords defined for L024
INFO       [L025] No config_keywords defined for L025
INFO       [L027] No config_keywords defined for L027
INFO       [L031] No config_keywords defined for L031
INFO       [L032] No config_keywords defined for L032
INFO       [L033] No config_keywords defined for L033
INFO       [L034] No config_keywords defined for L034
INFO       [L035] No config_keywords defined for L035
INFO       [L036] No config_keywords defined for L036
INFO       [L037] No config_keywords defined for L037
INFO       [L039] No config_keywords defined for L039
INFO       [L041] No config_keywords defined for L041
INFO       [L043] No config_keywords defined for L043
INFO       [L044] No config_keywords defined for L044
INFO       [L045] No config_keywords defined for L045
INFO       [L046] No config_keywords defined for L046
INFO       [L048] No config_keywords defined for L048
INFO       [L049] No config_keywords defined for L049
INFO       LEXING RAW (test/fixtures/cli/passing_a.sql)
INFO       Elements to Segments.
INFO       Source-only slices: []
DEBUG        0, TemplateElement(raw='SELECT', template_slice=slice(0, 6, None), matcher=<RegexLexer: code>), slice(0, 6, None), 'SELECT'
DEBUG        1, TemplateElement(raw='\n', template_slice=slice(6, 7, None), matcher=<RegexLexer: newline>), slice(6, 7, None), '\n'
DEBUG        2, TemplateElement(raw='    ', template_slice=slice(7, 11, None), matcher=<RegexLexer: whitespace>), slice(7, 11, None), '    '
DEBUG        3, TemplateElement(raw='tbl', template_slice=slice(11, 14, None), matcher=<RegexLexer: code>), slice(11, 14, None), 'tbl'
DEBUG        4, TemplateElement(raw='.', template_slice=slice(14, 15, None), matcher=<StringLexer: dot>), slice(14, 15, None), '.'
DEBUG        5, TemplateElement(raw='name', template_slice=slice(15, 19, None), matcher=<RegexLexer: code>), slice(15, 19, None), 'name'
DEBUG        6, TemplateElement(raw=',', template_slice=slice(19, 20, None), matcher=<StringLexer: comma>), slice(19, 20, None), ','
DEBUG        7, TemplateElement(raw='\n', template_slice=slice(20, 21, None), matcher=<RegexLexer: newline>), slice(20, 21, None), '\n'
DEBUG        8, TemplateElement(raw='    ', template_slice=slice(21, 25, None), matcher=<RegexLexer: whitespace>), slice(21, 25, None), '    '
DEBUG        9, TemplateElement(raw='tbl', template_slice=slice(25, 28, None), matcher=<RegexLexer: code>), slice(25, 28, None), 'tbl'
DEBUG        10, TemplateElement(raw='.', template_slice=slice(28, 29, None), matcher=<StringLexer: dot>), slice(28, 29, None), '.'
DEBUG        11, TemplateElement(raw='value', template_slice=slice(29, 34, None), matcher=<RegexLexer: code>), slice(29, 34, None), 'value'
DEBUG        12, TemplateElement(raw='\n', template_slice=slice(34, 35, None), matcher=<RegexLexer: newline>), slice(34, 35, None), '\n'
DEBUG        13, TemplateElement(raw='FROM', template_slice=slice(35, 39, None), matcher=<RegexLexer: code>), slice(35, 39, None), 'FROM'
DEBUG        14, TemplateElement(raw=' ', template_slice=slice(39, 40, None), matcher=<RegexLexer: whitespace>), slice(39, 40, None), ' '
DEBUG        15, TemplateElement(raw='tbl', template_slice=slice(40, 43, None), matcher=<RegexLexer: code>), slice(40, 43, None), 'tbl'
DEBUG        16, TemplateElement(raw='\n', template_slice=slice(43, 44, None), matcher=<RegexLexer: newline>), slice(43, 44, None), '\n'
INFO       Lexed tokens: ['SELECT', '\n', '    ', 'tbl', '.', 'name', ',', '\n', '    ', 'tbl', '.', 'value', '\n', 'FROM', ' ', 'tbl', '\n']
INFO       PARSING (test/fixtures/cli/passing_a.sql)
INFO       [PD:0  MD:2 ]	..StatementSegment                                	Greed.match OUT     	++  	[match=<MatchResult 16/16: 'SELECT\n    tbl.....value\nFROM tbl'>, seg="'SELECT\\n    tbl.name,...'"]
INFO       [PD:0  MD:0 ]	FileSegment                                       	Delim.match OUT     	++  	[match=<MatchResult 1/1: 'SELECT\n    tbl.....value\nFROM tbl'>, seg="'SELECT\\n    tbl.name,...'"]
INFO       
###
#
# Parse Depth 1. Expanding: StatementSegment: 'SELECT\n    tbl.name,\n    tbl.value\nFROM ...'
#
###
INFO       [PD:1  MD:0 ]	StatementSegment                                  	OneOf.match PRN     	    	[ns=0, ps=28, ms=1, pruned=[<Ref: InsertStatementSegment>, <Ref: TransactionStatementSegment>, <Ref: DropStatementSegment>, <Ref: TruncateStatementSegment>, <Ref: AccessStatementSegment>, <Ref: CreateTableStatementSegment>, <Ref: CreateTypeStatementSegment>, <Ref: CreateRoleStatementSegment>, <Ref: AlterTableStatementSegment>, <Ref: CreateSchemaStatementSegment>, <Ref: SetSchemaStatementSegment>, <Ref: DropSchemaStatementSegment>, <Ref: CreateDatabaseStatementSegment>, <Ref: CreateExtensionStatementSegment>, <Ref: CreateIndexStatementSegment>, <Ref: DropIndexStatementSegment>, <Ref: CreateViewStatementSegment>, <Ref: DeleteStatementSegment>, <Ref: UpdateStatementSegment>, <Ref: CreateFunctionStatementSegment>, <Ref: CreateModelStatementSegment>, <Ref: DropModelStatementSegment>, <Ref: DescribeStatementSegment>, <Ref: UseStatementSegment>, <Ref: ExplainStatementSegment>, <Ref: CreateSequenceStatementSegment>, <Ref: AlterSequenceStatementSegment>, <Ref: DropSequenceStatementSegment>], opts=[<Ref: SelectableGrammar>]]
INFO       [PD:1  MD:1 ]	.SelectableGrammar                                	OneOf.match PRN     	    	[ns=0, ps=1, ms=1, pruned=[<Ref: WithCompoundStatementSegment>], opts=[<Ref: NonWithSelectableGrammar>]]
INFO       [PD:1  MD:2 ]	..NonWithSelectableGrammar                        	OneOf.match PRN     	    	[ns=0, ps=0, ms=3, pruned=[], opts=[<Ref: SetExpressionSegment>, <OptionallyBracketed: [<Bracketed: [<Ref: SelectStatementSegmen..., <Ref: SelectStatementSegment>]>, <Ref: NonSetSelectableGrammar>]]
INFO       [PD:1  MD:5 ]	.....NonSetSelectableGrammar                      	OneOf.match PRN     	    	[ns=0, ps=2, ms=1, pruned=[<Ref: ValuesClauseSegment>, <Bracketed: [<Ref: SelectStatementSegment>]>], opts=[<Ref: UnorderedSelectStatementSegment>]]
INFO       [PD:1  MD:15]	...............WildcardIdentifierSegment          	AnyNu.match PRN     	    	[ns=1, ps=0, ms=0, pruned=[], opts=[<Sequence: [<Ref: SingleIdentifierGrammar>, <Ref: DotSegment>]>]]
INFO       [PD:1  MD:17]	.................SingleIdentifierGrammar          	OneOf.match PRN     	    	[ns=2, ps=0, ms=0, pruned=[], opts=[<Ref: NakedIdentifierSegment>, <Ref: QuotedIdentifierSegment>]]
INFO       [PD:1  MD:17]	.................SingleIdentifierGrammar          	OneOf.match OUT     	+   	[match=<MatchResult 1/13: 'tbl'>, seg="'tbl.name,\\n    tbl.va...'"]
INFO       [PD:1  MD:16]	................WildcardIdentifierSegment         	Seque.match OUT     	+   	[match=<MatchResult 2/13: 'tbl.'>, seg="'tbl.name,\\n    tbl.va...'"]
INFO       [PD:1  MD:15]	...............WildcardIdentifierSegment          	AnyNu.match PRN     	    	[ns=1, ps=0, ms=0, pruned=[], opts=[<Sequence: [<Ref: SingleIdentifierGrammar>, <Ref: DotSegment>]>]]
INFO       [PD:1  MD:17]	.................SingleIdentifierGrammar          	OneOf.match PRN     	    	[ns=2, ps=0, ms=0, pruned=[], opts=[<Ref: NakedIdentifierSegment>, <Ref: QuotedIdentifierSegment>]]
INFO       [PD:1  MD:17]	.................SingleIdentifierGrammar          	OneOf.match OUT     	+   	[match=<MatchResult 1/11: 'name'>, seg="'name,\\n    tbl.value\\n...'"]
INFO       [PD:1  MD:16]	................WildcardIdentifierSegment         	Seque.match OUT     	    	[match=<MatchResult 0/11: ''>, seg="'name,\\n    tbl.value\\n...'"]
INFO       [PD:1  MD:15]	...............WildcardIdentifierSegment          	AnyNu.match OUT     	+   	[match=<MatchResult 2/13: 'tbl.'>, seg="'tbl.name,\\n    tbl.va...'"]
INFO       [PD:1  MD:14]	..............WildcardIdentifierSegment           	Seque.match OUT     	    	[match=<MatchResult 0/13: ''>, seg="'tbl.name,\\n    tbl.va...'"]
INFO       [PD:1  MD:12]	............WildcardExpressionSegment             	Seque.match OUT     	    	[match=<MatchResult 0/13: ''>, seg="'tbl.name,\\n    tbl.va...'"]
INFO       [PD:1  MD:10]	..........SelectClauseSegment                     	Seque.match OUT     	+   	[match=<MatchResult 1/16: 'SELECT'>, seg="'SELECT\\n    tbl.name,...'"]
INFO       [PD:1  MD:10]	..........SelectClauseSegment                     	OneOf.match PRN     	    	[ns=0, ps=5, ms=1, pruned=[<Ref: WhereKeywordSegment>, <Ref: OrderKeywordSegment>, <Ref: LimitKeywordSegment>, <Ref: OverlapsKeywordSegment>, <Ref: SetOperatorSegment>], opts=[<Ref: FromKeywordSegment>]]
INFO       [PD:1  MD:10]	..........SelectClauseSegment                     	OneOf.match OUT     	+   	[match=<MatchResult 1/3: 'FROM'>, seg="'FROM tbl'"]
INFO       [PD:1  MD:9 ]	.........SelectClauseSegment                      	Start.match OUT     	+   	[match=<MatchResult 12/16: 'SELECT\n    tbl....,\n    tbl.value'>, seg="'SELECT\\n    tbl.name,...'"]
INFO       [PD:1  MD:7 ]	.......UnorderedSelectStatementSegment            	Start.match OUT     	++  	[match=<MatchResult 5/5: 'SELECT\n    tbl.....value\nFROM tbl'>, seg="'SELECT\\n    tbl.name,...'"]
INFO       [PD:1  MD:5 ]	.....NonSetSelectableGrammar                      	OneOf.match OUT     	++  	[match=<MatchResult 1/1: 'SELECT\n    tbl.....value\nFROM tbl'>, seg="'SELECT\\n    tbl.name,...'"]
INFO       [PD:1  MD:4 ]	....SetExpressionSegment                          	Seque.match OUT     	    	[match=<MatchResult 0/16: ''>, seg="'SELECT\\n    tbl.name,...'"]
INFO       [PD:1  MD:3 ]	...NonWithSelectableGrammar                       	Optio.match PRN     	    	[ns=0, ps=1, ms=1, pruned=[<Bracketed: [<Ref: SelectStatementSegment>]>], opts=[<Ref: SelectStatementSegment>]]
INFO       [PD:1  MD:13]	.............WildcardIdentifierSegment            	AnyNu.match PRN     	    	[ns=1, ps=0, ms=0, pruned=[], opts=[<Sequence: [<Ref: SingleIdentifierGrammar>, <Ref: DotSegment>]>]]
INFO       [PD:1  MD:15]	...............SingleIdentifierGrammar            	OneOf.match PRN     	    	[ns=2, ps=0, ms=0, pruned=[], opts=[<Ref: NakedIdentifierSegment>, <Ref: QuotedIdentifierSegment>]]
INFO       [PD:1  MD:15]	...............SingleIdentifierGrammar            	OneOf.match OUT     	+   	[match=<MatchResult 1/13: 'tbl'>, seg="'tbl.name,\\n    tbl.va...'"]
INFO       [PD:1  MD:14]	..............WildcardIdentifierSegment           	Seque.match OUT     	+   	[match=<MatchResult 2/13: 'tbl.'>, seg="'tbl.name,\\n    tbl.va...'"]
INFO       [PD:1  MD:13]	.............WildcardIdentifierSegment            	AnyNu.match PRN     	    	[ns=1, ps=0, ms=0, pruned=[], opts=[<Sequence: [<Ref: SingleIdentifierGrammar>, <Ref: DotSegment>]>]]
INFO       [PD:1  MD:15]	...............SingleIdentifierGrammar            	OneOf.match PRN     	    	[ns=2, ps=0, ms=0, pruned=[], opts=[<Ref: NakedIdentifierSegment>, <Ref: QuotedIdentifierSegment>]]
INFO       [PD:1  MD:15]	...............SingleIdentifierGrammar            	OneOf.match OUT     	+   	[match=<MatchResult 1/11: 'name'>, seg="'name,\\n    tbl.value\\n...'"]
INFO       [PD:1  MD:14]	..............WildcardIdentifierSegment           	Seque.match OUT     	    	[match=<MatchResult 0/11: ''>, seg="'name,\\n    tbl.value\\n...'"]
INFO       [PD:1  MD:13]	.............WildcardIdentifierSegment            	AnyNu.match OUT     	+   	[match=<MatchResult 2/13: 'tbl.'>, seg="'tbl.name,\\n    tbl.va...'"]
INFO       [PD:1  MD:12]	............WildcardIdentifierSegment             	Seque.match OUT     	    	[match=<MatchResult 0/13: ''>, seg="'tbl.name,\\n    tbl.va...'"]
INFO       [PD:1  MD:10]	..........WildcardExpressionSegment               	Seque.match OUT     	    	[match=<MatchResult 0/13: ''>, seg="'tbl.name,\\n    tbl.va...'"]
INFO       [PD:1  MD:8 ]	........SelectClauseSegment                       	Seque.match OUT     	+   	[match=<MatchResult 1/16: 'SELECT'>, seg="'SELECT\\n    tbl.name,...'"]
INFO       [PD:1  MD:8 ]	........SelectClauseSegment                       	OneOf.match PRN     	    	[ns=0, ps=5, ms=1, pruned=[<Ref: WhereKeywordSegment>, <Ref: OrderKeywordSegment>, <Ref: LimitKeywordSegment>, <Ref: OverlapsKeywordSegment>, <Ref: SetOperatorSegment>], opts=[<Ref: FromKeywordSegment>]]
INFO       [PD:1  MD:8 ]	........SelectClauseSegment                       	OneOf.match OUT     	+   	[match=<MatchResult 1/3: 'FROM'>, seg="'FROM tbl'"]
INFO       [PD:1  MD:7 ]	.......SelectClauseSegment                        	Start.match OUT     	+   	[match=<MatchResult 12/16: 'SELECT\n    tbl....,\n    tbl.value'>, seg="'SELECT\\n    tbl.name,...'"]
INFO       [PD:1  MD:5 ]	.....SelectStatementSegment                       	Start.match OUT     	++  	[match=<MatchResult 5/5: 'SELECT\n    tbl.....value\nFROM tbl'>, seg="'SELECT\\n    tbl.name,...'"]
INFO       [PD:1  MD:3 ]	...NonWithSelectableGrammar                       	Optio.match OUT     	++  	[match=<MatchResult 1/1: 'SELECT\n    tbl.....value\nFROM tbl'>, seg="'SELECT\\n    tbl.name,...'"]
INFO       [PD:1  MD:2 ]	..NonWithSelectableGrammar                        	OneOf.match OUT     	++  	[match=<MatchResult 1/1: 'SELECT\n    tbl.....value\nFROM tbl'>, seg="'SELECT\\n    tbl.name,...'"]
INFO       [PD:1  MD:1 ]	.SelectableGrammar                                	OneOf.match OUT     	++  	[match=<MatchResult 1/1: 'SELECT\n    tbl.....value\nFROM tbl'>, seg="'SELECT\\n    tbl.name,...'"]
INFO       [PD:1  MD:0 ]	StatementSegment                                  	OneOf.match OUT     	++  	[match=<MatchResult 1/1: 'SELECT\n    tbl.....value\nFROM tbl'>, seg="'SELECT\\n    tbl.name,...'"]
INFO       
###
#
# Parse Depth 2. Expanding: SelectStatementSegment: 'SELECT\n    tbl.name,\n    tbl.value\nFROM ...'
#
###
INFO       [PD:2  MD:1 ]	.SelectClauseSegment                              	Selec._match SELF   	    
INFO       [PD:2  MD:2 ]	..FromClauseSegment                               	Start.match OUT     	++  	[match=<MatchResult 3/3: 'FROM tbl'>, seg="'FROM tbl'"]
INFO       [PD:2  MD:0 ]	SelectStatementSegment                            	Seque.match OUT     	++  	[match=<MatchResult 4/4: 'SELECT\n    tbl.....value\nFROM tbl'>, seg="'SELECT\\n    tbl.name,...'"]
INFO       
###
#
# Parse Depth 3. Expanding: SelectClauseSegment: 'SELECT\n    tbl.name,\n    tbl.value'
#
###
INFO       [PD:3  MD:2 ]	..SelectClauseModifierSegment                     	OneOf.match PRN     	    	[ns=0, ps=2, ms=0, pruned=[<Ref: DistinctKeywordSegment>, <Ref: AllKeywordSegment>], opts='ALL']
INFO       [PD:3  MD:2 ]	..SelectClauseModifierSegment                     	OneOf.match OUT     	    	[match=<MatchResult 0/9: ''>, seg="'tbl.name,\\n    tbl.va...'"]
INFO       [PD:3  MD:3 ]	...SelectClauseElementSegment                     	Greed.match OUT     	++  	[match=<MatchResult 3/3: 'tbl.name'>, seg="'tbl.name'"]
INFO       [PD:3  MD:3 ]	...SelectClauseElementSegment                     	Greed.match OUT     	++  	[match=<MatchResult 3/3: 'tbl.value'>, seg="'tbl.value'"]
INFO       [PD:3  MD:1 ]	.SelectClauseSegmentGrammar                       	Delim.match OUT     	++  	[match=<MatchResult 5/5: 'tbl.name,\n    tbl.value'>, seg="'tbl.name,\\n    tbl.va...'"]
INFO       [PD:3  MD:0 ]	SelectClauseSegmentGrammar                        	Seque.match OUT     	++  	[match=<MatchResult 9/9: 'SELECT\n    tbl....,\n    tbl.value'>, seg="'SELECT\\n    tbl.name,...'"]
INFO       [PD:4] Skipping expansion of <KeywordSegment: ([L:  1, P:  1]) 'SELECT'>...
INFO       [PD:4] Skipping expansion of <Indent: ([L:  1, P:  7]) ''>...
INFO       [PD:4] Skipping expansion of <NewlineSegment: ([L:  1, P:  7]) '\n'>...
INFO       [PD:4] Skipping expansion of <WhitespaceSegment: ([L:  2, P:  1]) '    '>...
INFO       
###
#
# Parse Depth 4. Expanding: SelectClauseElementSegment: 'tbl.name'
#
###
INFO       [PD:4  MD:0 ]	SelectClauseElementSegment                        	OneOf.match PRN     	    	[ns=2, ps=0, ms=0, pruned=[], opts=[<Ref: WildcardExpressionSegment>, <Sequence: [<Ref: BaseExpressionElementGrammar>, <Ref: AliasExpressionSegment [opt]>]>]]
INFO       [PD:4  MD:5 ]	.....WildcardIdentifierSegment                    	AnyNu.match PRN     	    	[ns=1, ps=0, ms=0, pruned=[], opts=[<Sequence: [<Ref: SingleIdentifierGrammar>, <Ref: DotSegment>]>]]
INFO       [PD:4  MD:7 ]	.......SingleIdentifierGrammar                    	OneOf.match PRN     	    	[ns=2, ps=0, ms=0, pruned=[], opts=[<Ref: NakedIdentifierSegment>, <Ref: QuotedIdentifierSegment>]]
INFO       [PD:4  MD:7 ]	.......SingleIdentifierGrammar                    	OneOf.match OUT     	+   	[match=<MatchResult 1/3: 'tbl'>, seg="'tbl.name'"]
INFO       [PD:4  MD:6 ]	......WildcardIdentifierSegment                   	Seque.match OUT     	+   	[match=<MatchResult 2/3: 'tbl.'>, seg="'tbl.name'"]
INFO       [PD:4  MD:5 ]	.....WildcardIdentifierSegment                    	AnyNu.match PRN     	    	[ns=1, ps=0, ms=0, pruned=[], opts=[<Sequence: [<Ref: SingleIdentifierGrammar>, <Ref: DotSegment>]>]]
INFO       [PD:4  MD:7 ]	.......SingleIdentifierGrammar                    	OneOf.match PRN     	    	[ns=2, ps=0, ms=0, pruned=[], opts=[<Ref: NakedIdentifierSegment>, <Ref: QuotedIdentifierSegment>]]
INFO       [PD:4  MD:7 ]	.......SingleIdentifierGrammar                    	OneOf.match OUT     	++  	[match=<MatchResult 1/1: 'name'>, seg="'name'"]
INFO       [PD:4  MD:6 ]	......WildcardIdentifierSegment                   	Seque.match OUT     	    	[match=<MatchResult 0/1: ''>, seg="'name'"]
INFO       [PD:4  MD:5 ]	.....WildcardIdentifierSegment                    	AnyNu.match OUT     	+   	[match=<MatchResult 2/3: 'tbl.'>, seg="'tbl.name'"]
INFO       [PD:4  MD:4 ]	....WildcardIdentifierSegment                     	Seque.match OUT     	    	[match=<MatchResult 0/3: ''>, seg="'tbl.name'"]
INFO       [PD:4  MD:2 ]	..WildcardExpressionSegment                       	Seque.match OUT     	    	[match=<MatchResult 0/3: ''>, seg="'tbl.name'"]
INFO       [PD:4  MD:2 ]	..BaseExpressionElementGrammar                    	OneOf.match PRN     	    	[ns=5, ps=1, ms=0, pruned=[<Ref: IntervalExpressionSegment>], opts=[<Ref: LiteralGrammar>, <Ref: BareFunctionSegment>, <Ref: FunctionSegment>, <Ref: ColumnReferenceSegment>, <Ref: ExpressionSegment>]]
INFO       [PD:4  MD:3 ]	...LiteralGrammar                                 	OneOf.match PRN     	    	[ns=2, ps=4, ms=0, pruned=[<Ref: BooleanLiteralGrammar>, <Ref: QualifiedNumericLiteralSegment>, <Ref: NullLiteralSegment>, <Ref: DateTimeLiteralGrammar>], opts=[<Ref: QuotedLiteralSegment>, <Ref: NumericLiteralSegment>]]
INFO       [PD:4  MD:3 ]	...LiteralGrammar                                 	OneOf.match OUT     	    	[match=<MatchResult 0/3: ''>, seg="'tbl.name'"]
INFO       [PD:4  MD:4 ]	....FunctionSegment                               	OneOf.match PRN     	    	[ns=1, ps=1, ms=0, pruned=[<Sequence: [<Sequence: [<Ref: DateAddFunctionNameSeg...]>], opts=[<Sequence: [<Sequence: [<AnyNumberOf: [<Ref: Functio..., <Ref: PostFunctionGrammar [opt]>]>]]
INFO       [PD:4  MD:9 ]	.........DateAddFunctionNameSegment               	Seque.match OUT     	    	[match=<MatchResult 0/3: ''>, seg="'tbl.name'"]
INFO       [PD:4  MD:7 ]	.......FunctionSegment                            	AnyNu.match PRN     	    	[ns=1, ps=0, ms=0, pruned=[], opts=[<Ref: FunctionNameSegment>]]
INFO       [PD:4  MD:10]	..........FunctionNameSegment                     	AnyNu.match PRN     	    	[ns=1, ps=0, ms=0, pruned=[], opts=[<Sequence: [<Ref: SingleIdentifierGrammar>, <Ref: DotSegment>]>]]
INFO       [PD:4  MD:12]	............SingleIdentifierGrammar               	OneOf.match PRN     	    	[ns=2, ps=0, ms=0, pruned=[], opts=[<Ref: NakedIdentifierSegment>, <Ref: QuotedIdentifierSegment>]]
INFO       [PD:4  MD:12]	............SingleIdentifierGrammar               	OneOf.match OUT     	+   	[match=<MatchResult 1/3: 'tbl'>, seg="'tbl.name'"]
INFO       [PD:4  MD:11]	...........FunctionNameSegment                    	Seque.match OUT     	+   	[match=<MatchResult 2/3: 'tbl.'>, seg="'tbl.name'"]
INFO       [PD:4  MD:10]	..........FunctionNameSegment                     	AnyNu.match PRN     	    	[ns=1, ps=0, ms=0, pruned=[], opts=[<Sequence: [<Ref: SingleIdentifierGrammar>, <Ref: DotSegment>]>]]
INFO       [PD:4  MD:12]	............SingleIdentifierGrammar               	OneOf.match PRN     	    	[ns=2, ps=0, ms=0, pruned=[], opts=[<Ref: NakedIdentifierSegment>, <Ref: QuotedIdentifierSegment>]]
INFO       [PD:4  MD:12]	............SingleIdentifierGrammar               	OneOf.match OUT     	++  	[match=<MatchResult 1/1: 'name'>, seg="'name'"]
INFO       [PD:4  MD:11]	...........FunctionNameSegment                    	Seque.match OUT     	    	[match=<MatchResult 0/1: ''>, seg="'name'"]
INFO       [PD:4  MD:10]	..........FunctionNameSegment                     	AnyNu.match OUT     	+   	[match=<MatchResult 2/3: 'tbl.'>, seg="'tbl.name'"]
INFO       [PD:4  MD:10]	..........FunctionNameSegment                     	OneOf.match PRN     	    	[ns=2, ps=0, ms=0, pruned=[], opts=[<Ref: FunctionNameIdentifierSegment>, <Ref: QuotedIdentifierSegment>]]
INFO       [PD:4  MD:10]	..........FunctionNameSegment                     	OneOf.match OUT     	++  	[match=<MatchResult 1/1: 'name'>, seg="'name'"]
INFO       [PD:4  MD:9 ]	.........FunctionNameSegment                      	Seque.match OUT     	++  	[match=<MatchResult 3/3: 'tbl.name'>, seg="'tbl.name'"]
INFO       [PD:4  MD:7 ]	.......FunctionSegment                            	AnyNu.match OUT     	++  	[match=<MatchResult 1/1: 'tbl.name'>, seg="'tbl.name'"]
INFO       [PD:4  MD:6 ]	......FunctionSegment                             	Seque.match OUT     	    	[match=<MatchResult 0/3: ''>, seg="'tbl.name'"]
INFO       [PD:4  MD:5 ]	.....FunctionSegment                              	Seque.match OUT     	    	[match=<MatchResult 0/3: ''>, seg="'tbl.name'"]
INFO       [PD:4  MD:4 ]	....FunctionSegment                               	OneOf.match OUT     	    	[match=<MatchResult 0/3: ''>, seg="'tbl.name'"]
INFO       [PD:4  MD:5 ]	.....ColumnReferenceSegment                       	OneOf.match PRN     	    	[ns=0, ps=0, ms=2, pruned=[], opts=[<Ref: DotSegment>, <Sequence: [<Ref: DotSegment>, <Ref: DotSegment>]>]]
INFO       [PD:4  MD:6 ]	......ColumnReferenceSegment                      	Seque.match OUT     	    	[match=<MatchResult 0/2: ''>, seg="'.name'"]
INFO       [PD:4  MD:5 ]	.....ColumnReferenceSegment                       	OneOf.match OUT     	+   	[match=<MatchResult 1/2: '.'>, seg="'.name'"]
INFO       [PD:4  MD:5 ]	.....ColumnReferenceSegment                       	OneOf.match PRN     	    	[ns=0, ps=0, ms=2, pruned=[], opts=[<Ref: DotSegment>, <Sequence: [<Ref: DotSegment>, <Ref: DotSegment>]>]]
INFO       [PD:4  MD:6 ]	......ColumnReferenceSegment                      	Seque.match OUT     	    	[match=<MatchResult 0/2: ''>, seg="'.name'"]
INFO       [PD:4  MD:5 ]	.....ColumnReferenceSegment                       	OneOf.match OUT     	+   	[match=<MatchResult 1/2: '.'>, seg="'.name'"]
INFO       [PD:4  MD:5 ]	.....ColumnReferenceSegment                       	OneOf.match PRN     	    	[ns=1, ps=10, ms=0, pruned=[<Ref: OnKeywordSegment>, <Ref: AsKeywordSegment>, <Ref: UsingKeywordSegment>, <Ref: CommaSegment>, <Ref: CastOperatorSegment>, <Ref: StartSquareBracketSegment>, <Ref: StartBracketSegment>, <Ref: ColonSegment>, <Ref: DelimiterSegment>, <class 'sqlfluff.core.parser.segments.base.BracketedSegment'>], opts=[<Ref: BinaryOperatorGrammar>]]
INFO       [PD:4  MD:6 ]	......BinaryOperatorGrammar                       	OneOf.match PRN     	    	[ns=1, ps=3, ms=0, pruned=[<Ref: ArithmeticBinaryOperatorGrammar>, <Ref: StringBinaryOperatorGrammar>, <Ref: BooleanBinaryOperatorGrammar>], opts=[<Ref: ComparisonOperatorGrammar>]]
INFO       [PD:4  MD:7 ]	.......ComparisonOperatorGrammar                  	OneOf.match PRN     	    	[ns=1, ps=7, ms=0, pruned=[<Ref: EqualsSegment>, <Ref: GreaterThanSegment>, <Ref: LessThanSegment>, <Ref: GreaterThanOrEqualToSegment>, <Ref: LessThanOrEqualToSegment>, <Ref: NotEqualToSegment_a>, <Ref: NotEqualToSegment_b>], opts=[<Ref: LikeOperatorSegment>]]
INFO       [PD:4  MD:7 ]	.......ComparisonOperatorGrammar                  	OneOf.match OUT     	    	[match=<MatchResult 0/3: ''>, seg="'tbl.name'"]
INFO       [PD:4  MD:6 ]	......BinaryOperatorGrammar                       	OneOf.match OUT     	    	[match=<MatchResult 0/3: ''>, seg="'tbl.name'"]
INFO       [PD:4  MD:5 ]	.....ColumnReferenceSegment                       	OneOf.match OUT     	    	[match=<MatchResult 0/3: ''>, seg="'tbl.name'"]
INFO       [PD:4  MD:5 ]	.....ColumnReferenceSegment                       	OneOf.match PRN     	    	[ns=1, ps=10, ms=0, pruned=[<Ref: OnKeywordSegment>, <Ref: AsKeywordSegment>, <Ref: UsingKeywordSegment>, <Ref: CommaSegment>, <Ref: CastOperatorSegment>, <Ref: StartSquareBracketSegment>, <Ref: StartBracketSegment>, <Ref: ColonSegment>, <Ref: DelimiterSegment>, <class 'sqlfluff.core.parser.segments.base.BracketedSegment'>], opts=[<Ref: BinaryOperatorGrammar>]]
INFO       [PD:4  MD:6 ]	......BinaryOperatorGrammar                       	OneOf.match PRN     	    	[ns=1, ps=3, ms=0, pruned=[<Ref: ArithmeticBinaryOperatorGrammar>, <Ref: StringBinaryOperatorGrammar>, <Ref: BooleanBinaryOperatorGrammar>], opts=[<Ref: ComparisonOperatorGrammar>]]
INFO       [PD:4  MD:7 ]	.......ComparisonOperatorGrammar                  	OneOf.match PRN     	    	[ns=1, ps=7, ms=0, pruned=[<Ref: EqualsSegment>, <Ref: GreaterThanSegment>, <Ref: LessThanSegment>, <Ref: GreaterThanOrEqualToSegment>, <Ref: LessThanOrEqualToSegment>, <Ref: NotEqualToSegment_a>, <Ref: NotEqualToSegment_b>], opts=[<Ref: LikeOperatorSegment>]]
INFO       [PD:4  MD:7 ]	.......ComparisonOperatorGrammar                  	OneOf.match OUT     	    	[match=<MatchResult 0/2: ''>, seg="'.name'"]
INFO       [PD:4  MD:6 ]	......BinaryOperatorGrammar                       	OneOf.match OUT     	    	[match=<MatchResult 0/2: ''>, seg="'.name'"]
INFO       [PD:4  MD:5 ]	.....ColumnReferenceSegment                       	OneOf.match OUT     	    	[match=<MatchResult 0/2: ''>, seg="'.name'"]
INFO       [PD:4  MD:5 ]	.....SingleIdentifierGrammar                      	OneOf.match PRN     	    	[ns=2, ps=0, ms=0, pruned=[], opts=[<Ref: NakedIdentifierSegment>, <Ref: QuotedIdentifierSegment>]]
INFO       [PD:4  MD:5 ]	.....SingleIdentifierGrammar                      	OneOf.match OUT     	++  	[match=<MatchResult 1/1: 'tbl'>, seg="'tbl'"]
INFO       [PD:4  MD:5 ]	.....ColumnReferenceSegment                       	OneOf.match PRN     	    	[ns=1, ps=10, ms=0, pruned=[<Ref: OnKeywordSegment>, <Ref: AsKeywordSegment>, <Ref: UsingKeywordSegment>, <Ref: CommaSegment>, <Ref: CastOperatorSegment>, <Ref: StartSquareBracketSegment>, <Ref: StartBracketSegment>, <Ref: ColonSegment>, <Ref: DelimiterSegment>, <class 'sqlfluff.core.parser.segments.base.BracketedSegment'>], opts=[<Ref: BinaryOperatorGrammar>]]
INFO       [PD:4  MD:6 ]	......BinaryOperatorGrammar                       	OneOf.match PRN     	    	[ns=1, ps=3, ms=0, pruned=[<Ref: ArithmeticBinaryOperatorGrammar>, <Ref: StringBinaryOperatorGrammar>, <Ref: BooleanBinaryOperatorGrammar>], opts=[<Ref: ComparisonOperatorGrammar>]]
INFO       [PD:4  MD:7 ]	.......ComparisonOperatorGrammar                  	OneOf.match PRN     	    	[ns=1, ps=7, ms=0, pruned=[<Ref: EqualsSegment>, <Ref: GreaterThanSegment>, <Ref: LessThanSegment>, <Ref: GreaterThanOrEqualToSegment>, <Ref: LessThanOrEqualToSegment>, <Ref: NotEqualToSegment_a>, <Ref: NotEqualToSegment_b>], opts=[<Ref: LikeOperatorSegment>]]
INFO       [PD:4  MD:7 ]	.......ComparisonOperatorGrammar                  	OneOf.match OUT     	    	[match=<MatchResult 0/1: ''>, seg="'name'"]
INFO       [PD:4  MD:6 ]	......BinaryOperatorGrammar                       	OneOf.match OUT     	    	[match=<MatchResult 0/1: ''>, seg="'name'"]
INFO       [PD:4  MD:5 ]	.....ColumnReferenceSegment                       	OneOf.match OUT     	    	[match=<MatchResult 0/1: ''>, seg="'name'"]
INFO       [PD:4  MD:5 ]	.....SingleIdentifierGrammar                      	OneOf.match PRN     	    	[ns=2, ps=0, ms=0, pruned=[], opts=[<Ref: NakedIdentifierSegment>, <Ref: QuotedIdentifierSegment>]]
INFO       [PD:4  MD:5 ]	.....SingleIdentifierGrammar                      	OneOf.match OUT     	++  	[match=<MatchResult 1/1: 'name'>, seg="'name'"]
INFO       [PD:4  MD:4 ]	....ColumnReferenceSegment                        	Delim.match OUT     	++  	[match=<MatchResult 3/3: 'tbl.name'>, seg="'tbl.name'"]
INFO       [PD:4  MD:2 ]	..BaseExpressionElementGrammar                    	OneOf.match OUT     	++  	[match=<MatchResult 1/1: 'tbl.name'>, seg="'tbl.name'"]
INFO       [PD:4  MD:1 ]	.SelectClauseElementSegment                       	Seque.match OUT     	++  	[match=<MatchResult 1/1: 'tbl.name'>, seg="'tbl.name'"]
INFO       [PD:4  MD:0 ]	SelectClauseElementSegment                        	OneOf.match OUT     	++  	[match=<MatchResult 1/1: 'tbl.name'>, seg="'tbl.name'"]
INFO       [PD:5] Skipping expansion of <ColumnReferenceSegment: ([L:  2, P:  5])>...
INFO       [PD:4] Skipping expansion of <SymbolSegment: ([L:  2, P: 13]) ','>...
INFO       [PD:4] Skipping expansion of <NewlineSegment: ([L:  2, P: 14]) '\n'>...
INFO       [PD:4] Skipping expansion of <WhitespaceSegment: ([L:  3, P:  1]) '    '>...
INFO       
###
#
# Parse Depth 4. Expanding: SelectClauseElementSegment: 'tbl.value'
#
###
INFO       [PD:4  MD:0 ]	SelectClauseElementSegment                        	OneOf.match PRN     	    	[ns=2, ps=0, ms=0, pruned=[], opts=[<Ref: WildcardExpressionSegment>, <Sequence: [<Ref: BaseExpressionElementGrammar>, <Ref: AliasExpressionSegment [opt]>]>]]
INFO       [PD:4  MD:5 ]	.....WildcardIdentifierSegment                    	AnyNu.match PRN     	    	[ns=1, ps=0, ms=0, pruned=[], opts=[<Sequence: [<Ref: SingleIdentifierGrammar>, <Ref: DotSegment>]>]]
INFO       [PD:4  MD:7 ]	.......SingleIdentifierGrammar                    	OneOf.match PRN     	    	[ns=2, ps=0, ms=0, pruned=[], opts=[<Ref: NakedIdentifierSegment>, <Ref: QuotedIdentifierSegment>]]
INFO       [PD:4  MD:7 ]	.......SingleIdentifierGrammar                    	OneOf.match OUT     	+   	[match=<MatchResult 1/3: 'tbl'>, seg="'tbl.value'"]
INFO       [PD:4  MD:6 ]	......WildcardIdentifierSegment                   	Seque.match OUT     	+   	[match=<MatchResult 2/3: 'tbl.'>, seg="'tbl.value'"]
INFO       [PD:4  MD:5 ]	.....WildcardIdentifierSegment                    	AnyNu.match PRN     	    	[ns=1, ps=0, ms=0, pruned=[], opts=[<Sequence: [<Ref: SingleIdentifierGrammar>, <Ref: DotSegment>]>]]
INFO       [PD:4  MD:7 ]	.......SingleIdentifierGrammar                    	OneOf.match PRN     	    	[ns=2, ps=0, ms=0, pruned=[], opts=[<Ref: NakedIdentifierSegment>, <Ref: QuotedIdentifierSegment>]]
INFO       [PD:4  MD:7 ]	.......SingleIdentifierGrammar                    	OneOf.match OUT     	++  	[match=<MatchResult 1/1: 'value'>, seg="'value'"]
INFO       [PD:4  MD:6 ]	......WildcardIdentifierSegment                   	Seque.match OUT     	    	[match=<MatchResult 0/1: ''>, seg="'value'"]
INFO       [PD:4  MD:5 ]	.....WildcardIdentifierSegment                    	AnyNu.match OUT     	+   	[match=<MatchResult 2/3: 'tbl.'>, seg="'tbl.value'"]
INFO       [PD:4  MD:4 ]	....WildcardIdentifierSegment                     	Seque.match OUT     	    	[match=<MatchResult 0/3: ''>, seg="'tbl.value'"]
INFO       [PD:4  MD:2 ]	..WildcardExpressionSegment                       	Seque.match OUT     	    	[match=<MatchResult 0/3: ''>, seg="'tbl.value'"]
INFO       [PD:4  MD:2 ]	..BaseExpressionElementGrammar                    	OneOf.match PRN     	    	[ns=5, ps=1, ms=0, pruned=[<Ref: IntervalExpressionSegment>], opts=[<Ref: LiteralGrammar>, <Ref: BareFunctionSegment>, <Ref: FunctionSegment>, <Ref: ColumnReferenceSegment>, <Ref: ExpressionSegment>]]
INFO       [PD:4  MD:3 ]	...LiteralGrammar                                 	OneOf.match PRN     	    	[ns=2, ps=4, ms=0, pruned=[<Ref: BooleanLiteralGrammar>, <Ref: QualifiedNumericLiteralSegment>, <Ref: NullLiteralSegment>, <Ref: DateTimeLiteralGrammar>], opts=[<Ref: QuotedLiteralSegment>, <Ref: NumericLiteralSegment>]]
INFO       [PD:4  MD:3 ]	...LiteralGrammar                                 	OneOf.match OUT     	    	[match=<MatchResult 0/3: ''>, seg="'tbl.value'"]
INFO       [PD:4  MD:4 ]	....FunctionSegment                               	OneOf.match PRN     	    	[ns=1, ps=1, ms=0, pruned=[<Sequence: [<Sequence: [<Ref: DateAddFunctionNameSeg...]>], opts=[<Sequence: [<Sequence: [<AnyNumberOf: [<Ref: Functio..., <Ref: PostFunctionGrammar [opt]>]>]]
INFO       [PD:4  MD:9 ]	.........DateAddFunctionNameSegment               	Seque.match OUT     	    	[match=<MatchResult 0/3: ''>, seg="'tbl.value'"]
INFO       [PD:4  MD:7 ]	.......FunctionSegment                            	AnyNu.match PRN     	    	[ns=1, ps=0, ms=0, pruned=[], opts=[<Ref: FunctionNameSegment>]]
INFO       [PD:4  MD:10]	..........FunctionNameSegment                     	AnyNu.match PRN     	    	[ns=1, ps=0, ms=0, pruned=[], opts=[<Sequence: [<Ref: SingleIdentifierGrammar>, <Ref: DotSegment>]>]]
INFO       [PD:4  MD:12]	............SingleIdentifierGrammar               	OneOf.match PRN     	    	[ns=2, ps=0, ms=0, pruned=[], opts=[<Ref: NakedIdentifierSegment>, <Ref: QuotedIdentifierSegment>]]
INFO       [PD:4  MD:12]	............SingleIdentifierGrammar               	OneOf.match OUT     	+   	[match=<MatchResult 1/3: 'tbl'>, seg="'tbl.value'"]
INFO       [PD:4  MD:11]	...........FunctionNameSegment                    	Seque.match OUT     	+   	[match=<MatchResult 2/3: 'tbl.'>, seg="'tbl.value'"]
INFO       [PD:4  MD:10]	..........FunctionNameSegment                     	AnyNu.match PRN     	    	[ns=1, ps=0, ms=0, pruned=[], opts=[<Sequence: [<Ref: SingleIdentifierGrammar>, <Ref: DotSegment>]>]]
INFO       [PD:4  MD:12]	............SingleIdentifierGrammar               	OneOf.match PRN     	    	[ns=2, ps=0, ms=0, pruned=[], opts=[<Ref: NakedIdentifierSegment>, <Ref: QuotedIdentifierSegment>]]
INFO       [PD:4  MD:12]	............SingleIdentifierGrammar               	OneOf.match OUT     	++  	[match=<MatchResult 1/1: 'value'>, seg="'value'"]
INFO       [PD:4  MD:11]	...........FunctionNameSegment                    	Seque.match OUT     	    	[match=<MatchResult 0/1: ''>, seg="'value'"]
INFO       [PD:4  MD:10]	..........FunctionNameSegment                     	AnyNu.match OUT     	+   	[match=<MatchResult 2/3: 'tbl.'>, seg="'tbl.value'"]
INFO       [PD:4  MD:10]	..........FunctionNameSegment                     	OneOf.match PRN     	    	[ns=2, ps=0, ms=0, pruned=[], opts=[<Ref: FunctionNameIdentifierSegment>, <Ref: QuotedIdentifierSegment>]]
INFO       [PD:4  MD:10]	..........FunctionNameSegment                     	OneOf.match OUT     	++  	[match=<MatchResult 1/1: 'value'>, seg="'value'"]
INFO       [PD:4  MD:9 ]	.........FunctionNameSegment                      	Seque.match OUT     	++  	[match=<MatchResult 3/3: 'tbl.value'>, seg="'tbl.value'"]
INFO       [PD:4  MD:7 ]	.......FunctionSegment                            	AnyNu.match OUT     	++  	[match=<MatchResult 1/1: 'tbl.value'>, seg="'tbl.value'"]
INFO       [PD:4  MD:6 ]	......FunctionSegment                             	Seque.match OUT     	    	[match=<MatchResult 0/3: ''>, seg="'tbl.value'"]
INFO       [PD:4  MD:5 ]	.....FunctionSegment                              	Seque.match OUT     	    	[match=<MatchResult 0/3: ''>, seg="'tbl.value'"]
INFO       [PD:4  MD:4 ]	....FunctionSegment                               	OneOf.match OUT     	    	[match=<MatchResult 0/3: ''>, seg="'tbl.value'"]
INFO       [PD:4  MD:5 ]	.....ColumnReferenceSegment                       	OneOf.match PRN     	    	[ns=0, ps=0, ms=2, pruned=[], opts=[<Ref: DotSegment>, <Sequence: [<Ref: DotSegment>, <Ref: DotSegment>]>]]
INFO       [PD:4  MD:6 ]	......ColumnReferenceSegment                      	Seque.match OUT     	    	[match=<MatchResult 0/2: ''>, seg="'.value'"]
INFO       [PD:4  MD:5 ]	.....ColumnReferenceSegment                       	OneOf.match OUT     	+   	[match=<MatchResult 1/2: '.'>, seg="'.value'"]
INFO       [PD:4  MD:5 ]	.....ColumnReferenceSegment                       	OneOf.match PRN     	    	[ns=0, ps=0, ms=2, pruned=[], opts=[<Ref: DotSegment>, <Sequence: [<Ref: DotSegment>, <Ref: DotSegment>]>]]
INFO       [PD:4  MD:6 ]	......ColumnReferenceSegment                      	Seque.match OUT     	    	[match=<MatchResult 0/2: ''>, seg="'.value'"]
INFO       [PD:4  MD:5 ]	.....ColumnReferenceSegment                       	OneOf.match OUT     	+   	[match=<MatchResult 1/2: '.'>, seg="'.value'"]
INFO       [PD:4  MD:5 ]	.....ColumnReferenceSegment                       	OneOf.match PRN     	    	[ns=1, ps=10, ms=0, pruned=[<Ref: OnKeywordSegment>, <Ref: AsKeywordSegment>, <Ref: UsingKeywordSegment>, <Ref: CommaSegment>, <Ref: CastOperatorSegment>, <Ref: StartSquareBracketSegment>, <Ref: StartBracketSegment>, <Ref: ColonSegment>, <Ref: DelimiterSegment>, <class 'sqlfluff.core.parser.segments.base.BracketedSegment'>], opts=[<Ref: BinaryOperatorGrammar>]]
INFO       [PD:4  MD:6 ]	......BinaryOperatorGrammar                       	OneOf.match PRN     	    	[ns=1, ps=3, ms=0, pruned=[<Ref: ArithmeticBinaryOperatorGrammar>, <Ref: StringBinaryOperatorGrammar>, <Ref: BooleanBinaryOperatorGrammar>], opts=[<Ref: ComparisonOperatorGrammar>]]
INFO       [PD:4  MD:7 ]	.......ComparisonOperatorGrammar                  	OneOf.match PRN     	    	[ns=1, ps=7, ms=0, pruned=[<Ref: EqualsSegment>, <Ref: GreaterThanSegment>, <Ref: LessThanSegment>, <Ref: GreaterThanOrEqualToSegment>, <Ref: LessThanOrEqualToSegment>, <Ref: NotEqualToSegment_a>, <Ref: NotEqualToSegment_b>], opts=[<Ref: LikeOperatorSegment>]]
INFO       [PD:4  MD:7 ]	.......ComparisonOperatorGrammar                  	OneOf.match OUT     	    	[match=<MatchResult 0/3: ''>, seg="'tbl.value'"]
INFO       [PD:4  MD:6 ]	......BinaryOperatorGrammar                       	OneOf.match OUT     	    	[match=<MatchResult 0/3: ''>, seg="'tbl.value'"]
INFO       [PD:4  MD:5 ]	.....ColumnReferenceSegment                       	OneOf.match OUT     	    	[match=<MatchResult 0/3: ''>, seg="'tbl.value'"]
INFO       [PD:4  MD:5 ]	.....ColumnReferenceSegment                       	OneOf.match PRN     	    	[ns=1, ps=10, ms=0, pruned=[<Ref: OnKeywordSegment>, <Ref: AsKeywordSegment>, <Ref: UsingKeywordSegment>, <Ref: CommaSegment>, <Ref: CastOperatorSegment>, <Ref: StartSquareBracketSegment>, <Ref: StartBracketSegment>, <Ref: ColonSegment>, <Ref: DelimiterSegment>, <class 'sqlfluff.core.parser.segments.base.BracketedSegment'>], opts=[<Ref: BinaryOperatorGrammar>]]
INFO       [PD:4  MD:6 ]	......BinaryOperatorGrammar                       	OneOf.match PRN     	    	[ns=1, ps=3, ms=0, pruned=[<Ref: ArithmeticBinaryOperatorGrammar>, <Ref: StringBinaryOperatorGrammar>, <Ref: BooleanBinaryOperatorGrammar>], opts=[<Ref: ComparisonOperatorGrammar>]]
INFO       [PD:4  MD:7 ]	.......ComparisonOperatorGrammar                  	OneOf.match PRN     	    	[ns=1, ps=7, ms=0, pruned=[<Ref: EqualsSegment>, <Ref: GreaterThanSegment>, <Ref: LessThanSegment>, <Ref: GreaterThanOrEqualToSegment>, <Ref: LessThanOrEqualToSegment>, <Ref: NotEqualToSegment_a>, <Ref: NotEqualToSegment_b>], opts=[<Ref: LikeOperatorSegment>]]
INFO       [PD:4  MD:7 ]	.......ComparisonOperatorGrammar                  	OneOf.match OUT     	    	[match=<MatchResult 0/2: ''>, seg="'.value'"]
INFO       [PD:4  MD:6 ]	......BinaryOperatorGrammar                       	OneOf.match OUT     	    	[match=<MatchResult 0/2: ''>, seg="'.value'"]
INFO       [PD:4  MD:5 ]	.....ColumnReferenceSegment                       	OneOf.match OUT     	    	[match=<MatchResult 0/2: ''>, seg="'.value'"]
INFO       [PD:4  MD:5 ]	.....SingleIdentifierGrammar                      	OneOf.match PRN     	    	[ns=2, ps=0, ms=0, pruned=[], opts=[<Ref: NakedIdentifierSegment>, <Ref: QuotedIdentifierSegment>]]
INFO       [PD:4  MD:5 ]	.....SingleIdentifierGrammar                      	OneOf.match OUT     	++  	[match=<MatchResult 1/1: 'tbl'>, seg="'tbl'"]
INFO       [PD:4  MD:5 ]	.....ColumnReferenceSegment                       	OneOf.match PRN     	    	[ns=1, ps=10, ms=0, pruned=[<Ref: OnKeywordSegment>, <Ref: AsKeywordSegment>, <Ref: UsingKeywordSegment>, <Ref: CommaSegment>, <Ref: CastOperatorSegment>, <Ref: StartSquareBracketSegment>, <Ref: StartBracketSegment>, <Ref: ColonSegment>, <Ref: DelimiterSegment>, <class 'sqlfluff.core.parser.segments.base.BracketedSegment'>], opts=[<Ref: BinaryOperatorGrammar>]]
INFO       [PD:4  MD:6 ]	......BinaryOperatorGrammar                       	OneOf.match PRN     	    	[ns=1, ps=3, ms=0, pruned=[<Ref: ArithmeticBinaryOperatorGrammar>, <Ref: StringBinaryOperatorGrammar>, <Ref: BooleanBinaryOperatorGrammar>], opts=[<Ref: ComparisonOperatorGrammar>]]
INFO       [PD:4  MD:7 ]	.......ComparisonOperatorGrammar                  	OneOf.match PRN     	    	[ns=1, ps=7, ms=0, pruned=[<Ref: EqualsSegment>, <Ref: GreaterThanSegment>, <Ref: LessThanSegment>, <Ref: GreaterThanOrEqualToSegment>, <Ref: LessThanOrEqualToSegment>, <Ref: NotEqualToSegment_a>, <Ref: NotEqualToSegment_b>], opts=[<Ref: LikeOperatorSegment>]]
INFO       [PD:4  MD:7 ]	.......ComparisonOperatorGrammar                  	OneOf.match OUT     	    	[match=<MatchResult 0/1: ''>, seg="'value'"]
INFO       [PD:4  MD:6 ]	......BinaryOperatorGrammar                       	OneOf.match OUT     	    	[match=<MatchResult 0/1: ''>, seg="'value'"]
INFO       [PD:4  MD:5 ]	.....ColumnReferenceSegment                       	OneOf.match OUT     	    	[match=<MatchResult 0/1: ''>, seg="'value'"]
INFO       [PD:4  MD:5 ]	.....SingleIdentifierGrammar                      	OneOf.match PRN     	    	[ns=2, ps=0, ms=0, pruned=[], opts=[<Ref: NakedIdentifierSegment>, <Ref: QuotedIdentifierSegment>]]
INFO       [PD:4  MD:5 ]	.....SingleIdentifierGrammar                      	OneOf.match OUT     	++  	[match=<MatchResult 1/1: 'value'>, seg="'value'"]
INFO       [PD:4  MD:4 ]	....ColumnReferenceSegment                        	Delim.match OUT     	++  	[match=<MatchResult 3/3: 'tbl.value'>, seg="'tbl.value'"]
INFO       [PD:4  MD:2 ]	..BaseExpressionElementGrammar                    	OneOf.match OUT     	++  	[match=<MatchResult 1/1: 'tbl.value'>, seg="'tbl.value'"]
INFO       [PD:4  MD:1 ]	.SelectClauseElementSegment                       	Seque.match OUT     	++  	[match=<MatchResult 1/1: 'tbl.value'>, seg="'tbl.value'"]
INFO       [PD:4  MD:0 ]	SelectClauseElementSegment                        	OneOf.match OUT     	++  	[match=<MatchResult 1/1: 'tbl.value'>, seg="'tbl.value'"]
INFO       [PD:5] Skipping expansion of <ColumnReferenceSegment: ([L:  3, P:  5])>...
INFO       [PD:3] Skipping expansion of <NewlineSegment: ([L:  3, P: 14]) '\n'>...
INFO       [PD:3] Skipping expansion of <Dedent: ([L:  4, P:  1]) ''>...
INFO       
###
#
# Parse Depth 3. Expanding: FromClauseSegment: 'FROM tbl'
#
###
INFO       [PD:3  MD:4 ]	....FromExpressionSegment                         	OneOf.match PRN     	    	[ns=1, ps=1, ms=0, pruned=[<Ref: MLTableExpressionSegment>], opts=[<Ref: FromExpressionElementSegment>]]
INFO       [PD:3  MD:7 ]	.......FromExpressionElementSegment               	Optio.match PRN     	    	[ns=1, ps=1, ms=0, pruned=[<Bracketed: [<Ref: TableExpressionSegment>]>], opts=[<Ref: TableExpressionSegment>]]
INFO       [PD:3  MD:9 ]	.........TableExpressionSegment                   	OneOf.match PRN     	    	[ns=3, ps=1, ms=0, pruned=[<Bracketed: [<Ref: SelectableGrammar>]>], opts=[<Ref: BareFunctionSegment>, <Ref: FunctionSegment>, <Ref: TableReferenceSegment>]]
INFO       [PD:3  MD:11]	...........FunctionSegment                        	OneOf.match PRN     	    	[ns=1, ps=1, ms=0, pruned=[<Sequence: [<Sequence: [<Ref: DateAddFunctionNameSeg...]>], opts=[<Sequence: [<Sequence: [<AnyNumberOf: [<Ref: Functio..., <Ref: PostFunctionGrammar [opt]>]>]]
INFO       [PD:3  MD:16]	................DateAddFunctionNameSegment        	Seque.match OUT     	    	[match=<MatchResult 0/1: ''>, seg="'tbl'"]
INFO       [PD:3  MD:14]	..............FunctionSegment                     	AnyNu.match PRN     	    	[ns=1, ps=0, ms=0, pruned=[], opts=[<Ref: FunctionNameSegment>]]
INFO       [PD:3  MD:17]	.................FunctionNameSegment              	AnyNu.match PRN     	    	[ns=1, ps=0, ms=0, pruned=[], opts=[<Sequence: [<Ref: SingleIdentifierGrammar>, <Ref: DotSegment>]>]]
INFO       [PD:3  MD:19]	...................SingleIdentifierGrammar        	OneOf.match PRN     	    	[ns=2, ps=0, ms=0, pruned=[], opts=[<Ref: NakedIdentifierSegment>, <Ref: QuotedIdentifierSegment>]]
INFO       [PD:3  MD:19]	...................SingleIdentifierGrammar        	OneOf.match OUT     	++  	[match=<MatchResult 1/1: 'tbl'>, seg="'tbl'"]
INFO       [PD:3  MD:18]	..................FunctionNameSegment             	Seque.match OUT     	    	[match=<MatchResult 0/1: ''>, seg="'tbl'"]
INFO       [PD:3  MD:17]	.................FunctionNameSegment              	AnyNu.match OUT     	    	[match=<MatchResult 0/1: ''>, seg="'tbl'"]
INFO       [PD:3  MD:17]	.................FunctionNameSegment              	OneOf.match PRN     	    	[ns=2, ps=0, ms=0, pruned=[], opts=[<Ref: FunctionNameIdentifierSegment>, <Ref: QuotedIdentifierSegment>]]
INFO       [PD:3  MD:17]	.................FunctionNameSegment              	OneOf.match OUT     	++  	[match=<MatchResult 1/1: 'tbl'>, seg="'tbl'"]
INFO       [PD:3  MD:16]	................FunctionNameSegment               	Seque.match OUT     	++  	[match=<MatchResult 1/1: 'tbl'>, seg="'tbl'"]
INFO       [PD:3  MD:14]	..............FunctionSegment                     	AnyNu.match OUT     	++  	[match=<MatchResult 1/1: 'tbl'>, seg="'tbl'"]
INFO       [PD:3  MD:13]	.............FunctionSegment                      	Seque.match OUT     	    	[match=<MatchResult 0/1: ''>, seg="'tbl'"]
INFO       [PD:3  MD:12]	............FunctionSegment                       	Seque.match OUT     	    	[match=<MatchResult 0/1: ''>, seg="'tbl'"]
INFO       [PD:3  MD:11]	...........FunctionSegment                        	OneOf.match OUT     	    	[match=<MatchResult 0/1: ''>, seg="'tbl'"]
INFO       [PD:3  MD:12]	............TableReferenceSegment                 	OneOf.match PRN     	    	[ns=1, ps=10, ms=0, pruned=[<Ref: OnKeywordSegment>, <Ref: AsKeywordSegment>, <Ref: UsingKeywordSegment>, <Ref: CommaSegment>, <Ref: CastOperatorSegment>, <Ref: StartSquareBracketSegment>, <Ref: StartBracketSegment>, <Ref: ColonSegment>, <Ref: DelimiterSegment>, <class 'sqlfluff.core.parser.segments.base.BracketedSegment'>], opts=[<Ref: BinaryOperatorGrammar>]]
INFO       [PD:3  MD:13]	.............BinaryOperatorGrammar                	OneOf.match PRN     	    	[ns=1, ps=3, ms=0, pruned=[<Ref: ArithmeticBinaryOperatorGrammar>, <Ref: StringBinaryOperatorGrammar>, <Ref: BooleanBinaryOperatorGrammar>], opts=[<Ref: ComparisonOperatorGrammar>]]
INFO       [PD:3  MD:14]	..............ComparisonOperatorGrammar           	OneOf.match PRN     	    	[ns=1, ps=7, ms=0, pruned=[<Ref: EqualsSegment>, <Ref: GreaterThanSegment>, <Ref: LessThanSegment>, <Ref: GreaterThanOrEqualToSegment>, <Ref: LessThanOrEqualToSegment>, <Ref: NotEqualToSegment_a>, <Ref: NotEqualToSegment_b>], opts=[<Ref: LikeOperatorSegment>]]
INFO       [PD:3  MD:14]	..............ComparisonOperatorGrammar           	OneOf.match OUT     	    	[match=<MatchResult 0/1: ''>, seg="'tbl'"]
INFO       [PD:3  MD:13]	.............BinaryOperatorGrammar                	OneOf.match OUT     	    	[match=<MatchResult 0/1: ''>, seg="'tbl'"]
INFO       [PD:3  MD:12]	............TableReferenceSegment                 	OneOf.match OUT     	    	[match=<MatchResult 0/1: ''>, seg="'tbl'"]
INFO       [PD:3  MD:12]	............SingleIdentifierGrammar               	OneOf.match PRN     	    	[ns=2, ps=0, ms=0, pruned=[], opts=[<Ref: NakedIdentifierSegment>, <Ref: QuotedIdentifierSegment>]]
INFO       [PD:3  MD:12]	............SingleIdentifierGrammar               	OneOf.match OUT     	++  	[match=<MatchResult 1/1: 'tbl'>, seg="'tbl'"]
INFO       [PD:3  MD:11]	...........TableReferenceSegment                  	Delim.match OUT     	++  	[match=<MatchResult 1/1: 'tbl'>, seg="'tbl'"]
INFO       [PD:3  MD:9 ]	.........TableExpressionSegment                   	OneOf.match OUT     	++  	[match=<MatchResult 1/1: 'tbl'>, seg="'tbl'"]
INFO       [PD:3  MD:7 ]	.......FromExpressionElementSegment               	Optio.match OUT     	++  	[match=<MatchResult 1/1: 'tbl'>, seg="'tbl'"]
INFO       [PD:3  MD:6 ]	......FromExpressionElementSegment                	Seque.match OUT     	++  	[match=<MatchResult 1/1: 'tbl'>, seg="'tbl'"]
INFO       [PD:3  MD:4 ]	....FromExpressionSegment                         	OneOf.match OUT     	++  	[match=<MatchResult 1/1: 'tbl'>, seg="'tbl'"]
INFO       [PD:3  MD:3 ]	...FromExpressionSegment                          	Condi.match OUT     	++  	[match=<MatchResult 1/1: ''>, seg="''"]
INFO       [PD:3  MD:3 ]	...FromExpressionSegment                          	Seque.match OUT     	++  	[match=<MatchResult 3/3: 'tbl'>, seg="'tbl'"]
INFO       [PD:3  MD:1 ]	.FromClauseSegment                                	Delim.match OUT     	++  	[match=<MatchResult 1/1: 'tbl'>, seg="'tbl'"]
INFO       [PD:3  MD:0 ]	FromClauseSegment                                 	Seque.match OUT     	++  	[match=<MatchResult 3/3: 'FROM tbl'>, seg="'FROM tbl'"]
INFO       [PD:4] Skipping expansion of <KeywordSegment: ([L:  4, P:  1]) 'FROM'>...
INFO       [PD:4] Skipping expansion of <WhitespaceSegment: ([L:  4, P:  5]) ' '>...
INFO       [PD:4] Skipping expansion of <FromExpressionSegment: ([L:  4, P:  6])>...
INFO       [PD:1] Skipping expansion of <NewlineSegment: ([L:  4, P:  9]) '\n'>...
INFO       
###
#
# Parsed Tree:
#
###
INFO       
[L:  1, P:  1]      |file:
[L:  1, P:  1]      |    statement:
[L:  1, P:  1]      |        select_statement:
[L:  1, P:  1]      |            select_clause:
[L:  1, P:  1]      |                keyword:                                      'SELECT'
[L:  1, P:  7]      |                [META] indent:
[L:  1, P:  7]      |                newline:                                      '\n'
[L:  2, P:  1]      |                whitespace:                                   '    '
[L:  2, P:  5]      |                select_clause_element:
[L:  2, P:  5]      |                    column_reference:
[L:  2, P:  5]      |                        identifier:                           'tbl'
[L:  2, P:  8]      |                        dot:                                  '.'
[L:  2, P:  9]      |                        identifier:                           'name'
[L:  2, P: 13]      |                comma:                                        ','
[L:  2, P: 14]      |                newline:                                      '\n'
[L:  3, P:  1]      |                whitespace:                                   '    '
[L:  3, P:  5]      |                select_clause_element:
[L:  3, P:  5]      |                    column_reference:
[L:  3, P:  5]      |                        identifier:                           'tbl'
[L:  3, P:  8]      |                        dot:                                  '.'
[L:  3, P:  9]      |                        identifier:                           'value'
[L:  3, P: 14]      |            newline:                                          '\n'
[L:  4, P:  1]      |            [META] dedent:
[L:  4, P:  1]      |            from_clause:
[L:  4, P:  1]      |                keyword:                                      'FROM'
[L:  4, P:  5]      |                whitespace:                                   ' '
[L:  4, P:  6]      |                from_expression:
[L:  4, P:  6]      |                    [META] indent:
[L:  4, P:  6]      |                    from_expression_element:
[L:  4, P:  6]      |                        table_expression:
[L:  4, P:  6]      |                            table_reference:
[L:  4, P:  6]      |                                identifier:                   'tbl'
[L:  4, P:  9]      |                    [META] dedent:
[L:  4, P:  9]      |    newline:                                                  '\n'

INFO       LINTING (test/fixtures/cli/passing_a.sql)
== [test/fixtures/cli/passing_a.sql] LINTING
DEBUG      [L003] Evaluating line #1. {'line_no': 1, 'indent_size': 0, 'indent_balance': 0, 'hanging_indent': None, 'clean_indent': False}
DEBUG      [L003] Evaluating line #2. {'line_no': 2, 'indent_size': 4, 'indent_balance': 1, 'hanging_indent': None, 'clean_indent': True}
DEBUG      [L003]     [deeper indent balance] Comparing to #1
DEBUG      [L003]     Comparison Line: {'line_no': 1, 'indent_size': 0, 'indent_balance': 0, 'hanging_indent': None, 'clean_indent': False}
DEBUG      [L003]     Indent deemed ok comparing to #1
DEBUG      [L003] Evaluating line #3. {'line_no': 3, 'indent_size': 4, 'indent_balance': 1, 'hanging_indent': None, 'clean_indent': False}
DEBUG      [L003]     [same indent balance] Comparing to #2
DEBUG      [L003]     Indent deemed ok comparing to #2
DEBUG      [L003] Evaluating line #4. {'line_no': 4, 'indent_size': 0, 'indent_balance': 0, 'hanging_indent': None, 'clean_indent': False}
DEBUG      [L003]     [same indent balance] Comparing to #1
DEBUG      [L003]     Indent deemed ok comparing to #1
DEBUG      [L010] Selected 'capitalisation_policy': 'consistent' from options ['upper', 'lower', 'capitalise']
DEBUG      [L010] Refuted cases after segment 'SELECT': {'lower', 'capitalise'}
DEBUG      [L010] Possible cases after segment 'SELECT': ['upper']
DEBUG      [L010] Consistent capitalization, returning with memory: {'refuted_cases': {'lower', 'capitalise'}, 'latest_possible_case': 'upper'}
DEBUG      [L010] Refuted cases after segment 'FROM': {'lower', 'capitalise'}
DEBUG      [L010] Possible cases after segment 'FROM': ['upper']
DEBUG      [L010] Consistent capitalization, returning with memory: {'refuted_cases': {'lower', 'capitalise'}, 'latest_possible_case': 'upper'}
DEBUG      [L014] Selected 'extended_capitalisation_policy': 'consistent' from options ['upper', 'lower', 'pascal', 'capitalise']
DEBUG      [L014] Refuted cases after segment 'tbl': {'upper', 'pascal', 'capitalise'}
DEBUG      [L014] Possible cases after segment 'tbl': ['lower']
DEBUG      [L014] Consistent capitalization, returning with memory: {'refuted_cases': {'upper', 'pascal', 'capitalise'}, 'latest_possible_case': 'lower'}
DEBUG      [L014] Refuted cases after segment 'name': {'upper', 'pascal', 'capitalise'}
DEBUG      [L014] Possible cases after segment 'name': ['lower']
DEBUG      [L014] Consistent capitalization, returning with memory: {'refuted_cases': {'upper', 'pascal', 'capitalise'}, 'latest_possible_case': 'lower'}
DEBUG      [L014] Refuted cases after segment 'tbl': {'upper', 'pascal', 'capitalise'}
DEBUG      [L014] Possible cases after segment 'tbl': ['lower']
DEBUG      [L014] Consistent capitalization, returning with memory: {'refuted_cases': {'upper', 'pascal', 'capitalise'}, 'latest_possible_case': 'lower'}
DEBUG      [L014] Refuted cases after segment 'value': {'upper', 'pascal', 'capitalise'}
DEBUG      [L014] Possible cases after segment 'value': ['lower']
DEBUG      [L014] Consistent capitalization, returning with memory: {'refuted_cases': {'upper', 'pascal', 'capitalise'}, 'latest_possible_case': 'lower'}
DEBUG      [L014] Refuted cases after segment 'tbl': {'upper', 'pascal', 'capitalise'}
DEBUG      [L014] Possible cases after segment 'tbl': ['lower']
DEBUG      [L014] Consistent capitalization, returning with memory: {'refuted_cases': {'upper', 'pascal', 'capitalise'}, 'latest_possible_case': 'lower'}
DEBUG      [L044] Analyzing query: SELECT
    tbl.name,
    tbl.value
FROM tbl
== [test/fixtures/cli/passing_a.sql] PASS
==== summary ====
files:             1 violations:        0
clean files:       1 unclean files:     0
avg per file:   0.00 unclean rate:     0%
status:         PASS
All Finished!

___________________ test__cli__command_lint_parse[command4] ____________________
----------------------------- Captured stdout call -----------------------------
==== sqlfluff ====
sqlfluff:              0.7.0a8 python:                 3.9.20
implementation:        cpython dialect:                  ansi
verbosity:                   4 templater:               jinja

== Raw Config:
core:                                   
    dialect:            ansi                
    encoding:           autodetect          
    ignore:             []                  
    ignore_templated_areas:True                
    nocolor:            False               
    output_line_length: 80                  
    recurse:            True                
    runaway_limit:      10                  
    sql_file_exts:      .sql,.sql.j2,.dml,.ddl
    templater:          jinja               
    verbose:            4                   
indentation:                            
    indented_joins:     False               
    indented_using_on:  True                
    template_blocks_indent:True                
rules:                                  
    allow_scalar:       True                
    comma_style:        trailing            
    indent_unit:        space               
    max_line_length:    80                  
    single_table_references:consistent          
    tab_space_size:     4                   
    unquoted_identifiers_policy:all                 
    L007:                                   
        operator_new_lines: after               
    L010:                                   
        capitalisation_policy:consistent          
    L011:                                   
        aliasing:           explicit            
    L012:                                   
        aliasing:           explicit            
    L014:                                   
        extended_capitalisation_policy:consistent          
    L016:                                   
        ignore_comment_lines:False               
    L026:                                   
        force_enable:       False               
    L028:                                   
        force_enable:       False               
    L029:                                   
        unquoted_identifiers_policy:aliases             
    L030:                                   
        capitalisation_policy:consistent          
    L038:                                   
        select_clause_trailing_comma:forbid              
    L040:                                   
        capitalisation_policy:consistent          
    L042:                                   
        forbid_subquery_in: join                
    L047:                                   
        prefer_count_0:     False               
        prefer_count_1:     False               
templater:                              
    unwrap_wrapped_queries:True                
    jinja:                                  
        apply_dbt_builtins: True                
        macros:                                 
            dbt_config:         {% macro config() %}{% for k in kwargs %}{% endfor %}{% endmacro %}
            dbt_is_incremental: {% macro is_incremental() %}True{% endmacro %}
            dbt_ref:            {% macro ref(model_ref) %}{{model_ref}}{% endmacro %}
            dbt_source:         {% macro source(source_name, table) %}{{source_name}}_{{table}}{% endmacro %}
            dbt_var:            {% macro var(variable, default='') %}item{% endmacro %}

==== readout ====

=== [ path: test/fixtures/cli/passing_a.sql ] ===

INFO       TEMPLATING RAW [jinja] (test/fixtures/cli/passing_a.sql)
INFO       Slicing File Template
DEBUG          Raw String: 'SELECT\n    tbl.name,\n    tbl.value\nFROM tbl\n'
DEBUG          Templated String: 'SELECT\n    tbl.name,\n    tbl.value\nFROM tbl\n'
DEBUG          Raw Sliced:
DEBUG              0: RawFileSlice(raw='SELECT\n    tbl.name,\n    tbl.value\nFROM tbl\n', slice_type='literal', source_idx=0, slice_subtype=None)
DEBUG          Literals: ['SELECT\n    tbl.name,\n    tbl.value\nFROM tbl\n']
DEBUG          # Slice Loop 0
DEBUG          Occurrences: Raw: {'SELECT\n    tbl.name,\n    tbl.value\nFROM tbl\n': [0]}, Templated: {'SELECT\n    tbl.name,\n    tbl.value\nFROM tbl\n': [0]}
DEBUG          Split Sliced:
DEBUG              0: IntermediateFileSlice(intermediate_type='invariant', source_slice=slice(0, 44, None), templated_slice=slice(0, 44, None), slice_buffer=[RawFileSlice(raw='SELECT\n    tbl.name,\n    tbl.value\nFROM tbl\n', slice_type='literal', source_idx=0, slice_subtype=None)])
DEBUG          _split_uniques_coalesce_rest: [IntermediateFileSlice(intermediate_type='invariant', source_slice=slice(0, 44, None), templated_slice=slice(0, 44, None), slice_buffer=[RawFileSlice(raw='SELECT\n    tbl.name,\n    tbl.value\nFROM tbl\n', slice_type='literal', source_idx=0, slice_subtype=None)])]
DEBUG              Yielding Simple: TemplatedFileSlice(slice_type='literal', source_slice=slice(0, 44, None), templated_slice=slice(0, 44, None))
DEBUG          Fully Sliced:
DEBUG              0: TemplatedFileSlice(slice_type='literal', source_slice=slice(0, 44, None), templated_slice=slice(0, 44, None))
INFO       [L001] No config_keywords defined for L001
INFO       [L005] No config_keywords defined for L005
INFO       [L006] No config_keywords defined for L006
INFO       [L008] No config_keywords defined for L008
INFO       [L009] No config_keywords defined for L009
INFO       [L015] No config_keywords defined for L015
INFO       [L017] No config_keywords defined for L017
INFO       [L020] No config_keywords defined for L020
INFO       [L021] No config_keywords defined for L021
INFO       [L023] No config_keywords defined for L023
INFO       [L024] No config_keywords defined for L024
INFO       [L025] No config_keywords defined for L025
INFO       [L027] No config_keywords defined for L027
INFO       [L031] No config_keywords defined for L031
INFO       [L032] No config_keywords defined for L032
INFO       [L033] No config_keywords defined for L033
INFO       [L034] No config_keywords defined for L034
INFO       [L035] No config_keywords defined for L035
INFO       [L036] No config_keywords defined for L036
INFO       [L037] No config_keywords defined for L037
INFO       [L039] No config_keywords defined for L039
INFO       [L041] No config_keywords defined for L041
INFO       [L043] No config_keywords defined for L043
INFO       [L044] No config_keywords defined for L044
INFO       [L045] No config_keywords defined for L045
INFO       [L046] No config_keywords defined for L046
INFO       [L048] No config_keywords defined for L048
INFO       [L049] No config_keywords defined for L049
INFO       LEXING RAW (test/fixtures/cli/passing_a.sql)
INFO       Elements to Segments.
INFO       Source-only slices: []
DEBUG        0, TemplateElement(raw='SELECT', template_slice=slice(0, 6, None), matcher=<RegexLexer: code>), slice(0, 6, None), 'SELECT'
DEBUG        1, TemplateElement(raw='\n', template_slice=slice(6, 7, None), matcher=<RegexLexer: newline>), slice(6, 7, None), '\n'
DEBUG        2, TemplateElement(raw='    ', template_slice=slice(7, 11, None), matcher=<RegexLexer: whitespace>), slice(7, 11, None), '    '
DEBUG        3, TemplateElement(raw='tbl', template_slice=slice(11, 14, None), matcher=<RegexLexer: code>), slice(11, 14, None), 'tbl'
DEBUG        4, TemplateElement(raw='.', template_slice=slice(14, 15, None), matcher=<StringLexer: dot>), slice(14, 15, None), '.'
DEBUG        5, TemplateElement(raw='name', template_slice=slice(15, 19, None), matcher=<RegexLexer: code>), slice(15, 19, None), 'name'
DEBUG        6, TemplateElement(raw=',', template_slice=slice(19, 20, None), matcher=<StringLexer: comma>), slice(19, 20, None), ','
DEBUG        7, TemplateElement(raw='\n', template_slice=slice(20, 21, None), matcher=<RegexLexer: newline>), slice(20, 21, None), '\n'
DEBUG        8, TemplateElement(raw='    ', template_slice=slice(21, 25, None), matcher=<RegexLexer: whitespace>), slice(21, 25, None), '    '
DEBUG        9, TemplateElement(raw='tbl', template_slice=slice(25, 28, None), matcher=<RegexLexer: code>), slice(25, 28, None), 'tbl'
DEBUG        10, TemplateElement(raw='.', template_slice=slice(28, 29, None), matcher=<StringLexer: dot>), slice(28, 29, None), '.'
DEBUG        11, TemplateElement(raw='value', template_slice=slice(29, 34, None), matcher=<RegexLexer: code>), slice(29, 34, None), 'value'
DEBUG        12, TemplateElement(raw='\n', template_slice=slice(34, 35, None), matcher=<RegexLexer: newline>), slice(34, 35, None), '\n'
DEBUG        13, TemplateElement(raw='FROM', template_slice=slice(35, 39, None), matcher=<RegexLexer: code>), slice(35, 39, None), 'FROM'
DEBUG        14, TemplateElement(raw=' ', template_slice=slice(39, 40, None), matcher=<RegexLexer: whitespace>), slice(39, 40, None), ' '
DEBUG        15, TemplateElement(raw='tbl', template_slice=slice(40, 43, None), matcher=<RegexLexer: code>), slice(40, 43, None), 'tbl'
DEBUG        16, TemplateElement(raw='\n', template_slice=slice(43, 44, None), matcher=<RegexLexer: newline>), slice(43, 44, None), '\n'
INFO       Lexed tokens: ['SELECT', '\n', '    ', 'tbl', '.', 'name', ',', '\n', '    ', 'tbl', '.', 'value', '\n', 'FROM', ' ', 'tbl', '\n']
INFO       PARSING (test/fixtures/cli/passing_a.sql)
INFO       [PD:0  MD:2 ]	..StatementSegment                                	Greed.match OUT     	++  	[match=<MatchResult 16/16: 'SELECT\n    tbl.....value\nFROM tbl'>, seg="'SELECT\\n    tbl.name,...'"]
INFO       [PD:0  MD:0 ]	FileSegment                                       	Delim.match OUT     	++  	[match=<MatchResult 1/1: 'SELECT\n    tbl.....value\nFROM tbl'>, seg="'SELECT\\n    tbl.name,...'"]
INFO       
###
#
# Parse Depth 1. Expanding: StatementSegment: 'SELECT\n    tbl.name,\n    tbl.value\nFROM ...'
#
###
INFO       [PD:1  MD:0 ]	StatementSegment                                  	OneOf.match PRN     	    	[ns=0, ps=28, ms=1, pruned=[<Ref: InsertStatementSegment>, <Ref: TransactionStatementSegment>, <Ref: DropStatementSegment>, <Ref: TruncateStatementSegment>, <Ref: AccessStatementSegment>, <Ref: CreateTableStatementSegment>, <Ref: CreateTypeStatementSegment>, <Ref: CreateRoleStatementSegment>, <Ref: AlterTableStatementSegment>, <Ref: CreateSchemaStatementSegment>, <Ref: SetSchemaStatementSegment>, <Ref: DropSchemaStatementSegment>, <Ref: CreateDatabaseStatementSegment>, <Ref: CreateExtensionStatementSegment>, <Ref: CreateIndexStatementSegment>, <Ref: DropIndexStatementSegment>, <Ref: CreateViewStatementSegment>, <Ref: DeleteStatementSegment>, <Ref: UpdateStatementSegment>, <Ref: CreateFunctionStatementSegment>, <Ref: CreateModelStatementSegment>, <Ref: DropModelStatementSegment>, <Ref: DescribeStatementSegment>, <Ref: UseStatementSegment>, <Ref: ExplainStatementSegment>, <Ref: CreateSequenceStatementSegment>, <Ref: AlterSequenceStatementSegment>, <Ref: DropSequenceStatementSegment>], opts=[<Ref: SelectableGrammar>]]
INFO       [PD:1  MD:1 ]	.SelectableGrammar                                	OneOf.match PRN     	    	[ns=0, ps=1, ms=1, pruned=[<Ref: WithCompoundStatementSegment>], opts=[<Ref: NonWithSelectableGrammar>]]
INFO       [PD:1  MD:2 ]	..NonWithSelectableGrammar                        	OneOf.match PRN     	    	[ns=0, ps=0, ms=3, pruned=[], opts=[<Ref: SetExpressionSegment>, <OptionallyBracketed: [<Bracketed: [<Ref: SelectStatementSegmen..., <Ref: SelectStatementSegment>]>, <Ref: NonSetSelectableGrammar>]]
INFO       [PD:1  MD:5 ]	.....NonSetSelectableGrammar                      	OneOf.match PRN     	    	[ns=0, ps=2, ms=1, pruned=[<Ref: ValuesClauseSegment>, <Bracketed: [<Ref: SelectStatementSegment>]>], opts=[<Ref: UnorderedSelectStatementSegment>]]
INFO       [PD:1  MD:15]	...............WildcardIdentifierSegment          	AnyNu.match PRN     	    	[ns=1, ps=0, ms=0, pruned=[], opts=[<Sequence: [<Ref: SingleIdentifierGrammar>, <Ref: DotSegment>]>]]
INFO       [PD:1  MD:17]	.................SingleIdentifierGrammar          	OneOf.match PRN     	    	[ns=2, ps=0, ms=0, pruned=[], opts=[<Ref: NakedIdentifierSegment>, <Ref: QuotedIdentifierSegment>]]
INFO       [PD:1  MD:17]	.................SingleIdentifierGrammar          	OneOf.match OUT     	+   	[match=<MatchResult 1/13: 'tbl'>, seg="'tbl.name,\\n    tbl.va...'"]
INFO       [PD:1  MD:16]	................WildcardIdentifierSegment         	Seque.match OUT     	+   	[match=<MatchResult 2/13: 'tbl.'>, seg="'tbl.name,\\n    tbl.va...'"]
INFO       [PD:1  MD:15]	...............WildcardIdentifierSegment          	AnyNu.match PRN     	    	[ns=1, ps=0, ms=0, pruned=[], opts=[<Sequence: [<Ref: SingleIdentifierGrammar>, <Ref: DotSegment>]>]]
INFO       [PD:1  MD:17]	.................SingleIdentifierGrammar          	OneOf.match PRN     	    	[ns=2, ps=0, ms=0, pruned=[], opts=[<Ref: NakedIdentifierSegment>, <Ref: QuotedIdentifierSegment>]]
INFO       [PD:1  MD:17]	.................SingleIdentifierGrammar          	OneOf.match OUT     	+   	[match=<MatchResult 1/11: 'name'>, seg="'name,\\n    tbl.value\\n...'"]
INFO       [PD:1  MD:16]	................WildcardIdentifierSegment         	Seque.match OUT     	    	[match=<MatchResult 0/11: ''>, seg="'name,\\n    tbl.value\\n...'"]
INFO       [PD:1  MD:15]	...............WildcardIdentifierSegment          	AnyNu.match OUT     	+   	[match=<MatchResult 2/13: 'tbl.'>, seg="'tbl.name,\\n    tbl.va...'"]
INFO       [PD:1  MD:14]	..............WildcardIdentifierSegment           	Seque.match OUT     	    	[match=<MatchResult 0/13: ''>, seg="'tbl.name,\\n    tbl.va...'"]
INFO       [PD:1  MD:12]	............WildcardExpressionSegment             	Seque.match OUT     	    	[match=<MatchResult 0/13: ''>, seg="'tbl.name,\\n    tbl.va...'"]
INFO       [PD:1  MD:10]	..........SelectClauseSegment                     	Seque.match OUT     	+   	[match=<MatchResult 1/16: 'SELECT'>, seg="'SELECT\\n    tbl.name,...'"]
INFO       [PD:1  MD:10]	..........SelectClauseSegment                     	OneOf.match PRN     	    	[ns=0, ps=5, ms=1, pruned=[<Ref: WhereKeywordSegment>, <Ref: OrderKeywordSegment>, <Ref: LimitKeywordSegment>, <Ref: OverlapsKeywordSegment>, <Ref: SetOperatorSegment>], opts=[<Ref: FromKeywordSegment>]]
INFO       [PD:1  MD:10]	..........SelectClauseSegment                     	OneOf.match OUT     	+   	[match=<MatchResult 1/3: 'FROM'>, seg="'FROM tbl'"]
INFO       [PD:1  MD:9 ]	.........SelectClauseSegment                      	Start.match OUT     	+   	[match=<MatchResult 12/16: 'SELECT\n    tbl....,\n    tbl.value'>, seg="'SELECT\\n    tbl.name,...'"]
INFO       [PD:1  MD:7 ]	.......UnorderedSelectStatementSegment            	Start.match OUT     	++  	[match=<MatchResult 5/5: 'SELECT\n    tbl.....value\nFROM tbl'>, seg="'SELECT\\n    tbl.name,...'"]
INFO       [PD:1  MD:5 ]	.....NonSetSelectableGrammar                      	OneOf.match OUT     	++  	[match=<MatchResult 1/1: 'SELECT\n    tbl.....value\nFROM tbl'>, seg="'SELECT\\n    tbl.name,...'"]
INFO       [PD:1  MD:4 ]	....SetExpressionSegment                          	Seque.match OUT     	    	[match=<MatchResult 0/16: ''>, seg="'SELECT\\n    tbl.name,...'"]
INFO       [PD:1  MD:3 ]	...NonWithSelectableGrammar                       	Optio.match PRN     	    	[ns=0, ps=1, ms=1, pruned=[<Bracketed: [<Ref: SelectStatementSegment>]>], opts=[<Ref: SelectStatementSegment>]]
INFO       [PD:1  MD:13]	.............WildcardIdentifierSegment            	AnyNu.match PRN     	    	[ns=1, ps=0, ms=0, pruned=[], opts=[<Sequence: [<Ref: SingleIdentifierGrammar>, <Ref: DotSegment>]>]]
INFO       [PD:1  MD:15]	...............SingleIdentifierGrammar            	OneOf.match PRN     	    	[ns=2, ps=0, ms=0, pruned=[], opts=[<Ref: NakedIdentifierSegment>, <Ref: QuotedIdentifierSegment>]]
INFO       [PD:1  MD:15]	...............SingleIdentifierGrammar            	OneOf.match OUT     	+   	[match=<MatchResult 1/13: 'tbl'>, seg="'tbl.name,\\n    tbl.va...'"]
INFO       [PD:1  MD:14]	..............WildcardIdentifierSegment           	Seque.match OUT     	+   	[match=<MatchResult 2/13: 'tbl.'>, seg="'tbl.name,\\n    tbl.va...'"]
INFO       [PD:1  MD:13]	.............WildcardIdentifierSegment            	AnyNu.match PRN     	    	[ns=1, ps=0, ms=0, pruned=[], opts=[<Sequence: [<Ref: SingleIdentifierGrammar>, <Ref: DotSegment>]>]]
INFO       [PD:1  MD:15]	...............SingleIdentifierGrammar            	OneOf.match PRN     	    	[ns=2, ps=0, ms=0, pruned=[], opts=[<Ref: NakedIdentifierSegment>, <Ref: QuotedIdentifierSegment>]]
INFO       [PD:1  MD:15]	...............SingleIdentifierGrammar            	OneOf.match OUT     	+   	[match=<MatchResult 1/11: 'name'>, seg="'name,\\n    tbl.value\\n...'"]
INFO       [PD:1  MD:14]	..............WildcardIdentifierSegment           	Seque.match OUT     	    	[match=<MatchResult 0/11: ''>, seg="'name,\\n    tbl.value\\n...'"]
INFO       [PD:1  MD:13]	.............WildcardIdentifierSegment            	AnyNu.match OUT     	+   	[match=<MatchResult 2/13: 'tbl.'>, seg="'tbl.name,\\n    tbl.va...'"]
INFO       [PD:1  MD:12]	............WildcardIdentifierSegment             	Seque.match OUT     	    	[match=<MatchResult 0/13: ''>, seg="'tbl.name,\\n    tbl.va...'"]
INFO       [PD:1  MD:10]	..........WildcardExpressionSegment               	Seque.match OUT     	    	[match=<MatchResult 0/13: ''>, seg="'tbl.name,\\n    tbl.va...'"]
INFO       [PD:1  MD:8 ]	........SelectClauseSegment                       	Seque.match OUT     	+   	[match=<MatchResult 1/16: 'SELECT'>, seg="'SELECT\\n    tbl.name,...'"]
INFO       [PD:1  MD:8 ]	........SelectClauseSegment                       	OneOf.match PRN     	    	[ns=0, ps=5, ms=1, pruned=[<Ref: WhereKeywordSegment>, <Ref: OrderKeywordSegment>, <Ref: LimitKeywordSegment>, <Ref: OverlapsKeywordSegment>, <Ref: SetOperatorSegment>], opts=[<Ref: FromKeywordSegment>]]
INFO       [PD:1  MD:8 ]	........SelectClauseSegment                       	OneOf.match OUT     	+   	[match=<MatchResult 1/3: 'FROM'>, seg="'FROM tbl'"]
INFO       [PD:1  MD:7 ]	.......SelectClauseSegment                        	Start.match OUT     	+   	[match=<MatchResult 12/16: 'SELECT\n    tbl....,\n    tbl.value'>, seg="'SELECT\\n    tbl.name,...'"]
INFO       [PD:1  MD:5 ]	.....SelectStatementSegment                       	Start.match OUT     	++  	[match=<MatchResult 5/5: 'SELECT\n    tbl.....value\nFROM tbl'>, seg="'SELECT\\n    tbl.name,...'"]
INFO       [PD:1  MD:3 ]	...NonWithSelectableGrammar                       	Optio.match OUT     	++  	[match=<MatchResult 1/1: 'SELECT\n    tbl.....value\nFROM tbl'>, seg="'SELECT\\n    tbl.name,...'"]
INFO       [PD:1  MD:2 ]	..NonWithSelectableGrammar                        	OneOf.match OUT     	++  	[match=<MatchResult 1/1: 'SELECT\n    tbl.....value\nFROM tbl'>, seg="'SELECT\\n    tbl.name,...'"]
INFO       [PD:1  MD:1 ]	.SelectableGrammar                                	OneOf.match OUT     	++  	[match=<MatchResult 1/1: 'SELECT\n    tbl.....value\nFROM tbl'>, seg="'SELECT\\n    tbl.name,...'"]
INFO       [PD:1  MD:0 ]	StatementSegment                                  	OneOf.match OUT     	++  	[match=<MatchResult 1/1: 'SELECT\n    tbl.....value\nFROM tbl'>, seg="'SELECT\\n    tbl.name,...'"]
INFO       
###
#
# Parse Depth 2. Expanding: SelectStatementSegment: 'SELECT\n    tbl.name,\n    tbl.value\nFROM ...'
#
###
INFO       [PD:2  MD:1 ]	.SelectClauseSegment                              	Selec._match SELF   	    
INFO       [PD:2  MD:2 ]	..FromClauseSegment                               	Start.match OUT     	++  	[match=<MatchResult 3/3: 'FROM tbl'>, seg="'FROM tbl'"]
INFO       [PD:2  MD:0 ]	SelectStatementSegment                            	Seque.match OUT     	++  	[match=<MatchResult 4/4: 'SELECT\n    tbl.....value\nFROM tbl'>, seg="'SELECT\\n    tbl.name,...'"]
INFO       
###
#
# Parse Depth 3. Expanding: SelectClauseSegment: 'SELECT\n    tbl.name,\n    tbl.value'
#
###
INFO       [PD:3  MD:2 ]	..SelectClauseModifierSegment                     	OneOf.match PRN     	    	[ns=0, ps=2, ms=0, pruned=[<Ref: DistinctKeywordSegment>, <Ref: AllKeywordSegment>], opts='ALL']
INFO       [PD:3  MD:2 ]	..SelectClauseModifierSegment                     	OneOf.match OUT     	    	[match=<MatchResult 0/9: ''>, seg="'tbl.name,\\n    tbl.va...'"]
INFO       [PD:3  MD:3 ]	...SelectClauseElementSegment                     	Greed.match OUT     	++  	[match=<MatchResult 3/3: 'tbl.name'>, seg="'tbl.name'"]
INFO       [PD:3  MD:3 ]	...SelectClauseElementSegment                     	Greed.match OUT     	++  	[match=<MatchResult 3/3: 'tbl.value'>, seg="'tbl.value'"]
INFO       [PD:3  MD:1 ]	.SelectClauseSegmentGrammar                       	Delim.match OUT     	++  	[match=<MatchResult 5/5: 'tbl.name,\n    tbl.value'>, seg="'tbl.name,\\n    tbl.va...'"]
INFO       [PD:3  MD:0 ]	SelectClauseSegmentGrammar                        	Seque.match OUT     	++  	[match=<MatchResult 9/9: 'SELECT\n    tbl....,\n    tbl.value'>, seg="'SELECT\\n    tbl.name,...'"]
INFO       [PD:4] Skipping expansion of <KeywordSegment: ([L:  1, P:  1]) 'SELECT'>...
INFO       [PD:4] Skipping expansion of <Indent: ([L:  1, P:  7]) ''>...
INFO       [PD:4] Skipping expansion of <NewlineSegment: ([L:  1, P:  7]) '\n'>...
INFO       [PD:4] Skipping expansion of <WhitespaceSegment: ([L:  2, P:  1]) '    '>...
INFO       
###
#
# Parse Depth 4. Expanding: SelectClauseElementSegment: 'tbl.name'
#
###
INFO       [PD:4  MD:0 ]	SelectClauseElementSegment                        	OneOf.match PRN     	    	[ns=2, ps=0, ms=0, pruned=[], opts=[<Ref: WildcardExpressionSegment>, <Sequence: [<Ref: BaseExpressionElementGrammar>, <Ref: AliasExpressionSegment [opt]>]>]]
INFO       [PD:4  MD:5 ]	.....WildcardIdentifierSegment                    	AnyNu.match PRN     	    	[ns=1, ps=0, ms=0, pruned=[], opts=[<Sequence: [<Ref: SingleIdentifierGrammar>, <Ref: DotSegment>]>]]
INFO       [PD:4  MD:7 ]	.......SingleIdentifierGrammar                    	OneOf.match PRN     	    	[ns=2, ps=0, ms=0, pruned=[], opts=[<Ref: NakedIdentifierSegment>, <Ref: QuotedIdentifierSegment>]]
INFO       [PD:4  MD:7 ]	.......SingleIdentifierGrammar                    	OneOf.match OUT     	+   	[match=<MatchResult 1/3: 'tbl'>, seg="'tbl.name'"]
INFO       [PD:4  MD:6 ]	......WildcardIdentifierSegment                   	Seque.match OUT     	+   	[match=<MatchResult 2/3: 'tbl.'>, seg="'tbl.name'"]
INFO       [PD:4  MD:5 ]	.....WildcardIdentifierSegment                    	AnyNu.match PRN     	    	[ns=1, ps=0, ms=0, pruned=[], opts=[<Sequence: [<Ref: SingleIdentifierGrammar>, <Ref: DotSegment>]>]]
INFO       [PD:4  MD:7 ]	.......SingleIdentifierGrammar                    	OneOf.match PRN     	    	[ns=2, ps=0, ms=0, pruned=[], opts=[<Ref: NakedIdentifierSegment>, <Ref: QuotedIdentifierSegment>]]
INFO       [PD:4  MD:7 ]	.......SingleIdentifierGrammar                    	OneOf.match OUT     	++  	[match=<MatchResult 1/1: 'name'>, seg="'name'"]
INFO       [PD:4  MD:6 ]	......WildcardIdentifierSegment                   	Seque.match OUT     	    	[match=<MatchResult 0/1: ''>, seg="'name'"]
INFO       [PD:4  MD:5 ]	.....WildcardIdentifierSegment                    	AnyNu.match OUT     	+   	[match=<MatchResult 2/3: 'tbl.'>, seg="'tbl.name'"]
INFO       [PD:4  MD:4 ]	....WildcardIdentifierSegment                     	Seque.match OUT     	    	[match=<MatchResult 0/3: ''>, seg="'tbl.name'"]
INFO       [PD:4  MD:2 ]	..WildcardExpressionSegment                       	Seque.match OUT     	    	[match=<MatchResult 0/3: ''>, seg="'tbl.name'"]
INFO       [PD:4  MD:2 ]	..BaseExpressionElementGrammar                    	OneOf.match PRN     	    	[ns=5, ps=1, ms=0, pruned=[<Ref: IntervalExpressionSegment>], opts=[<Ref: LiteralGrammar>, <Ref: BareFunctionSegment>, <Ref: FunctionSegment>, <Ref: ColumnReferenceSegment>, <Ref: ExpressionSegment>]]
INFO       [PD:4  MD:3 ]	...LiteralGrammar                                 	OneOf.match PRN     	    	[ns=2, ps=4, ms=0, pruned=[<Ref: BooleanLiteralGrammar>, <Ref: QualifiedNumericLiteralSegment>, <Ref: NullLiteralSegment>, <Ref: DateTimeLiteralGrammar>], opts=[<Ref: QuotedLiteralSegment>, <Ref: NumericLiteralSegment>]]
INFO       [PD:4  MD:3 ]	...LiteralGrammar                                 	OneOf.match OUT     	    	[match=<MatchResult 0/3: ''>, seg="'tbl.name'"]
INFO       [PD:4  MD:4 ]	....FunctionSegment                               	OneOf.match PRN     	    	[ns=1, ps=1, ms=0, pruned=[<Sequence: [<Sequence: [<Ref: DateAddFunctionNameSeg...]>], opts=[<Sequence: [<Sequence: [<AnyNumberOf: [<Ref: Functio..., <Ref: PostFunctionGrammar [opt]>]>]]
INFO       [PD:4  MD:9 ]	.........DateAddFunctionNameSegment               	Seque.match OUT     	    	[match=<MatchResult 0/3: ''>, seg="'tbl.name'"]
INFO       [PD:4  MD:7 ]	.......FunctionSegment                            	AnyNu.match PRN     	    	[ns=1, ps=0, ms=0, pruned=[], opts=[<Ref: FunctionNameSegment>]]
INFO       [PD:4  MD:10]	..........FunctionNameSegment                     	AnyNu.match PRN     	    	[ns=1, ps=0, ms=0, pruned=[], opts=[<Sequence: [<Ref: SingleIdentifierGrammar>, <Ref: DotSegment>]>]]
INFO       [PD:4  MD:12]	............SingleIdentifierGrammar               	OneOf.match PRN     	    	[ns=2, ps=0, ms=0, pruned=[], opts=[<Ref: NakedIdentifierSegment>, <Ref: QuotedIdentifierSegment>]]
INFO       [PD:4  MD:12]	............SingleIdentifierGrammar               	OneOf.match OUT     	+   	[match=<MatchResult 1/3: 'tbl'>, seg="'tbl.name'"]
INFO       [PD:4  MD:11]	...........FunctionNameSegment                    	Seque.match OUT     	+   	[match=<MatchResult 2/3: 'tbl.'>, seg="'tbl.name'"]
INFO       [PD:4  MD:10]	..........FunctionNameSegment                     	AnyNu.match PRN     	    	[ns=1, ps=0, ms=0, pruned=[], opts=[<Sequence: [<Ref: SingleIdentifierGrammar>, <Ref: DotSegment>]>]]
INFO       [PD:4  MD:12]	............SingleIdentifierGrammar               	OneOf.match PRN     	    	[ns=2, ps=0, ms=0, pruned=[], opts=[<Ref: NakedIdentifierSegment>, <Ref: QuotedIdentifierSegment>]]
INFO       [PD:4  MD:12]	............SingleIdentifierGrammar               	OneOf.match OUT     	++  	[match=<MatchResult 1/1: 'name'>, seg="'name'"]
INFO       [PD:4  MD:11]	...........FunctionNameSegment                    	Seque.match OUT     	    	[match=<MatchResult 0/1: ''>, seg="'name'"]
INFO       [PD:4  MD:10]	..........FunctionNameSegment                     	AnyNu.match OUT     	+   	[match=<MatchResult 2/3: 'tbl.'>, seg="'tbl.name'"]
INFO       [PD:4  MD:10]	..........FunctionNameSegment                     	OneOf.match PRN     	    	[ns=2, ps=0, ms=0, pruned=[], opts=[<Ref: FunctionNameIdentifierSegment>, <Ref: QuotedIdentifierSegment>]]
INFO       [PD:4  MD:10]	..........FunctionNameSegment                     	OneOf.match OUT     	++  	[match=<MatchResult 1/1: 'name'>, seg="'name'"]
INFO       [PD:4  MD:9 ]	.........FunctionNameSegment                      	Seque.match OUT     	++  	[match=<MatchResult 3/3: 'tbl.name'>, seg="'tbl.name'"]
INFO       [PD:4  MD:7 ]	.......FunctionSegment                            	AnyNu.match OUT     	++  	[match=<MatchResult 1/1: 'tbl.name'>, seg="'tbl.name'"]
INFO       [PD:4  MD:6 ]	......FunctionSegment                             	Seque.match OUT     	    	[match=<MatchResult 0/3: ''>, seg="'tbl.name'"]
INFO       [PD:4  MD:5 ]	.....FunctionSegment                              	Seque.match OUT     	    	[match=<MatchResult 0/3: ''>, seg="'tbl.name'"]
INFO       [PD:4  MD:4 ]	....FunctionSegment                               	OneOf.match OUT     	    	[match=<MatchResult 0/3: ''>, seg="'tbl.name'"]
INFO       [PD:4  MD:5 ]	.....ColumnReferenceSegment                       	OneOf.match PRN     	    	[ns=0, ps=0, ms=2, pruned=[], opts=[<Ref: DotSegment>, <Sequence: [<Ref: DotSegment>, <Ref: DotSegment>]>]]
INFO       [PD:4  MD:6 ]	......ColumnReferenceSegment                      	Seque.match OUT     	    	[match=<MatchResult 0/2: ''>, seg="'.name'"]
INFO       [PD:4  MD:5 ]	.....ColumnReferenceSegment                       	OneOf.match OUT     	+   	[match=<MatchResult 1/2: '.'>, seg="'.name'"]
INFO       [PD:4  MD:5 ]	.....ColumnReferenceSegment                       	OneOf.match PRN     	    	[ns=0, ps=0, ms=2, pruned=[], opts=[<Ref: DotSegment>, <Sequence: [<Ref: DotSegment>, <Ref: DotSegment>]>]]
INFO       [PD:4  MD:6 ]	......ColumnReferenceSegment                      	Seque.match OUT     	    	[match=<MatchResult 0/2: ''>, seg="'.name'"]
INFO       [PD:4  MD:5 ]	.....ColumnReferenceSegment                       	OneOf.match OUT     	+   	[match=<MatchResult 1/2: '.'>, seg="'.name'"]
INFO       [PD:4  MD:5 ]	.....ColumnReferenceSegment                       	OneOf.match PRN     	    	[ns=1, ps=10, ms=0, pruned=[<Ref: OnKeywordSegment>, <Ref: AsKeywordSegment>, <Ref: UsingKeywordSegment>, <Ref: CommaSegment>, <Ref: CastOperatorSegment>, <Ref: StartSquareBracketSegment>, <Ref: StartBracketSegment>, <Ref: ColonSegment>, <Ref: DelimiterSegment>, <class 'sqlfluff.core.parser.segments.base.BracketedSegment'>], opts=[<Ref: BinaryOperatorGrammar>]]
INFO       [PD:4  MD:6 ]	......BinaryOperatorGrammar                       	OneOf.match PRN     	    	[ns=1, ps=3, ms=0, pruned=[<Ref: ArithmeticBinaryOperatorGrammar>, <Ref: StringBinaryOperatorGrammar>, <Ref: BooleanBinaryOperatorGrammar>], opts=[<Ref: ComparisonOperatorGrammar>]]
INFO       [PD:4  MD:7 ]	.......ComparisonOperatorGrammar                  	OneOf.match PRN     	    	[ns=1, ps=7, ms=0, pruned=[<Ref: EqualsSegment>, <Ref: GreaterThanSegment>, <Ref: LessThanSegment>, <Ref: GreaterThanOrEqualToSegment>, <Ref: LessThanOrEqualToSegment>, <Ref: NotEqualToSegment_a>, <Ref: NotEqualToSegment_b>], opts=[<Ref: LikeOperatorSegment>]]
INFO       [PD:4  MD:7 ]	.......ComparisonOperatorGrammar                  	OneOf.match OUT     	    	[match=<MatchResult 0/3: ''>, seg="'tbl.name'"]
INFO       [PD:4  MD:6 ]	......BinaryOperatorGrammar                       	OneOf.match OUT     	    	[match=<MatchResult 0/3: ''>, seg="'tbl.name'"]
INFO       [PD:4  MD:5 ]	.....ColumnReferenceSegment                       	OneOf.match OUT     	    	[match=<MatchResult 0/3: ''>, seg="'tbl.name'"]
INFO       [PD:4  MD:5 ]	.....ColumnReferenceSegment                       	OneOf.match PRN     	    	[ns=1, ps=10, ms=0, pruned=[<Ref: OnKeywordSegment>, <Ref: AsKeywordSegment>, <Ref: UsingKeywordSegment>, <Ref: CommaSegment>, <Ref: CastOperatorSegment>, <Ref: StartSquareBracketSegment>, <Ref: StartBracketSegment>, <Ref: ColonSegment>, <Ref: DelimiterSegment>, <class 'sqlfluff.core.parser.segments.base.BracketedSegment'>], opts=[<Ref: BinaryOperatorGrammar>]]
INFO       [PD:4  MD:6 ]	......BinaryOperatorGrammar                       	OneOf.match PRN     	    	[ns=1, ps=3, ms=0, pruned=[<Ref: ArithmeticBinaryOperatorGrammar>, <Ref: StringBinaryOperatorGrammar>, <Ref: BooleanBinaryOperatorGrammar>], opts=[<Ref: ComparisonOperatorGrammar>]]
INFO       [PD:4  MD:7 ]	.......ComparisonOperatorGrammar                  	OneOf.match PRN     	    	[ns=1, ps=7, ms=0, pruned=[<Ref: EqualsSegment>, <Ref: GreaterThanSegment>, <Ref: LessThanSegment>, <Ref: GreaterThanOrEqualToSegment>, <Ref: LessThanOrEqualToSegment>, <Ref: NotEqualToSegment_a>, <Ref: NotEqualToSegment_b>], opts=[<Ref: LikeOperatorSegment>]]
INFO       [PD:4  MD:7 ]	.......ComparisonOperatorGrammar                  	OneOf.match OUT     	    	[match=<MatchResult 0/2: ''>, seg="'.name'"]
INFO       [PD:4  MD:6 ]	......BinaryOperatorGrammar                       	OneOf.match OUT     	    	[match=<MatchResult 0/2: ''>, seg="'.name'"]
INFO       [PD:4  MD:5 ]	.....ColumnReferenceSegment                       	OneOf.match OUT     	    	[match=<MatchResult 0/2: ''>, seg="'.name'"]
INFO       [PD:4  MD:5 ]	.....SingleIdentifierGrammar                      	OneOf.match PRN     	    	[ns=2, ps=0, ms=0, pruned=[], opts=[<Ref: NakedIdentifierSegment>, <Ref: QuotedIdentifierSegment>]]
INFO       [PD:4  MD:5 ]	.....SingleIdentifierGrammar                      	OneOf.match OUT     	++  	[match=<MatchResult 1/1: 'tbl'>, seg="'tbl'"]
INFO       [PD:4  MD:5 ]	.....ColumnReferenceSegment                       	OneOf.match PRN     	    	[ns=1, ps=10, ms=0, pruned=[<Ref: OnKeywordSegment>, <Ref: AsKeywordSegment>, <Ref: UsingKeywordSegment>, <Ref: CommaSegment>, <Ref: CastOperatorSegment>, <Ref: StartSquareBracketSegment>, <Ref: StartBracketSegment>, <Ref: ColonSegment>, <Ref: DelimiterSegment>, <class 'sqlfluff.core.parser.segments.base.BracketedSegment'>], opts=[<Ref: BinaryOperatorGrammar>]]
INFO       [PD:4  MD:6 ]	......BinaryOperatorGrammar                       	OneOf.match PRN     	    	[ns=1, ps=3, ms=0, pruned=[<Ref: ArithmeticBinaryOperatorGrammar>, <Ref: StringBinaryOperatorGrammar>, <Ref: BooleanBinaryOperatorGrammar>], opts=[<Ref: ComparisonOperatorGrammar>]]
INFO       [PD:4  MD:7 ]	.......ComparisonOperatorGrammar                  	OneOf.match PRN     	    	[ns=1, ps=7, ms=0, pruned=[<Ref: EqualsSegment>, <Ref: GreaterThanSegment>, <Ref: LessThanSegment>, <Ref: GreaterThanOrEqualToSegment>, <Ref: LessThanOrEqualToSegment>, <Ref: NotEqualToSegment_a>, <Ref: NotEqualToSegment_b>], opts=[<Ref: LikeOperatorSegment>]]
INFO       [PD:4  MD:7 ]	.......ComparisonOperatorGrammar                  	OneOf.match OUT     	    	[match=<MatchResult 0/1: ''>, seg="'name'"]
INFO       [PD:4  MD:6 ]	......BinaryOperatorGrammar                       	OneOf.match OUT     	    	[match=<MatchResult 0/1: ''>, seg="'name'"]
INFO       [PD:4  MD:5 ]	.....ColumnReferenceSegment                       	OneOf.match OUT     	    	[match=<MatchResult 0/1: ''>, seg="'name'"]
INFO       [PD:4  MD:5 ]	.....SingleIdentifierGrammar                      	OneOf.match PRN     	    	[ns=2, ps=0, ms=0, pruned=[], opts=[<Ref: NakedIdentifierSegment>, <Ref: QuotedIdentifierSegment>]]
INFO       [PD:4  MD:5 ]	.....SingleIdentifierGrammar                      	OneOf.match OUT     	++  	[match=<MatchResult 1/1: 'name'>, seg="'name'"]
INFO       [PD:4  MD:4 ]	....ColumnReferenceSegment                        	Delim.match OUT     	++  	[match=<MatchResult 3/3: 'tbl.name'>, seg="'tbl.name'"]
INFO       [PD:4  MD:2 ]	..BaseExpressionElementGrammar                    	OneOf.match OUT     	++  	[match=<MatchResult 1/1: 'tbl.name'>, seg="'tbl.name'"]
INFO       [PD:4  MD:1 ]	.SelectClauseElementSegment                       	Seque.match OUT     	++  	[match=<MatchResult 1/1: 'tbl.name'>, seg="'tbl.name'"]
INFO       [PD:4  MD:0 ]	SelectClauseElementSegment                        	OneOf.match OUT     	++  	[match=<MatchResult 1/1: 'tbl.name'>, seg="'tbl.name'"]
INFO       [PD:5] Skipping expansion of <ColumnReferenceSegment: ([L:  2, P:  5])>...
INFO       [PD:4] Skipping expansion of <SymbolSegment: ([L:  2, P: 13]) ','>...
INFO       [PD:4] Skipping expansion of <NewlineSegment: ([L:  2, P: 14]) '\n'>...
INFO       [PD:4] Skipping expansion of <WhitespaceSegment: ([L:  3, P:  1]) '    '>...
INFO       
###
#
# Parse Depth 4. Expanding: SelectClauseElementSegment: 'tbl.value'
#
###
INFO       [PD:4  MD:0 ]	SelectClauseElementSegment                        	OneOf.match PRN     	    	[ns=2, ps=0, ms=0, pruned=[], opts=[<Ref: WildcardExpressionSegment>, <Sequence: [<Ref: BaseExpressionElementGrammar>, <Ref: AliasExpressionSegment [opt]>]>]]
INFO       [PD:4  MD:5 ]	.....WildcardIdentifierSegment                    	AnyNu.match PRN     	    	[ns=1, ps=0, ms=0, pruned=[], opts=[<Sequence: [<Ref: SingleIdentifierGrammar>, <Ref: DotSegment>]>]]
INFO       [PD:4  MD:7 ]	.......SingleIdentifierGrammar                    	OneOf.match PRN     	    	[ns=2, ps=0, ms=0, pruned=[], opts=[<Ref: NakedIdentifierSegment>, <Ref: QuotedIdentifierSegment>]]
INFO       [PD:4  MD:7 ]	.......SingleIdentifierGrammar                    	OneOf.match OUT     	+   	[match=<MatchResult 1/3: 'tbl'>, seg="'tbl.value'"]
INFO       [PD:4  MD:6 ]	......WildcardIdentifierSegment                   	Seque.match OUT     	+   	[match=<MatchResult 2/3: 'tbl.'>, seg="'tbl.value'"]
INFO       [PD:4  MD:5 ]	.....WildcardIdentifierSegment                    	AnyNu.match PRN     	    	[ns=1, ps=0, ms=0, pruned=[], opts=[<Sequence: [<Ref: SingleIdentifierGrammar>, <Ref: DotSegment>]>]]
INFO       [PD:4  MD:7 ]	.......SingleIdentifierGrammar                    	OneOf.match PRN     	    	[ns=2, ps=0, ms=0, pruned=[], opts=[<Ref: NakedIdentifierSegment>, <Ref: QuotedIdentifierSegment>]]
INFO       [PD:4  MD:7 ]	.......SingleIdentifierGrammar                    	OneOf.match OUT     	++  	[match=<MatchResult 1/1: 'value'>, seg="'value'"]
INFO       [PD:4  MD:6 ]	......WildcardIdentifierSegment                   	Seque.match OUT     	    	[match=<MatchResult 0/1: ''>, seg="'value'"]
INFO       [PD:4  MD:5 ]	.....WildcardIdentifierSegment                    	AnyNu.match OUT     	+   	[match=<MatchResult 2/3: 'tbl.'>, seg="'tbl.value'"]
INFO       [PD:4  MD:4 ]	....WildcardIdentifierSegment                     	Seque.match OUT     	    	[match=<MatchResult 0/3: ''>, seg="'tbl.value'"]
INFO       [PD:4  MD:2 ]	..WildcardExpressionSegment                       	Seque.match OUT     	    	[match=<MatchResult 0/3: ''>, seg="'tbl.value'"]
INFO       [PD:4  MD:2 ]	..BaseExpressionElementGrammar                    	OneOf.match PRN     	    	[ns=5, ps=1, ms=0, pruned=[<Ref: IntervalExpressionSegment>], opts=[<Ref: LiteralGrammar>, <Ref: BareFunctionSegment>, <Ref: FunctionSegment>, <Ref: ColumnReferenceSegment>, <Ref: ExpressionSegment>]]
INFO       [PD:4  MD:3 ]	...LiteralGrammar                                 	OneOf.match PRN     	    	[ns=2, ps=4, ms=0, pruned=[<Ref: BooleanLiteralGrammar>, <Ref: QualifiedNumericLiteralSegment>, <Ref: NullLiteralSegment>, <Ref: DateTimeLiteralGrammar>], opts=[<Ref: QuotedLiteralSegment>, <Ref: NumericLiteralSegment>]]
INFO       [PD:4  MD:3 ]	...LiteralGrammar                                 	OneOf.match OUT     	    	[match=<MatchResult 0/3: ''>, seg="'tbl.value'"]
INFO       [PD:4  MD:4 ]	....FunctionSegment                               	OneOf.match PRN     	    	[ns=1, ps=1, ms=0, pruned=[<Sequence: [<Sequence: [<Ref: DateAddFunctionNameSeg...]>], opts=[<Sequence: [<Sequence: [<AnyNumberOf: [<Ref: Functio..., <Ref: PostFunctionGrammar [opt]>]>]]
INFO       [PD:4  MD:9 ]	.........DateAddFunctionNameSegment               	Seque.match OUT     	    	[match=<MatchResult 0/3: ''>, seg="'tbl.value'"]
INFO       [PD:4  MD:7 ]	.......FunctionSegment                            	AnyNu.match PRN     	    	[ns=1, ps=0, ms=0, pruned=[], opts=[<Ref: FunctionNameSegment>]]
INFO       [PD:4  MD:10]	..........FunctionNameSegment                     	AnyNu.match PRN     	    	[ns=1, ps=0, ms=0, pruned=[], opts=[<Sequence: [<Ref: SingleIdentifierGrammar>, <Ref: DotSegment>]>]]
INFO       [PD:4  MD:12]	............SingleIdentifierGrammar               	OneOf.match PRN     	    	[ns=2, ps=0, ms=0, pruned=[], opts=[<Ref: NakedIdentifierSegment>, <Ref: QuotedIdentifierSegment>]]
INFO       [PD:4  MD:12]	............SingleIdentifierGrammar               	OneOf.match OUT     	+   	[match=<MatchResult 1/3: 'tbl'>, seg="'tbl.value'"]
INFO       [PD:4  MD:11]	...........FunctionNameSegment                    	Seque.match OUT     	+   	[match=<MatchResult 2/3: 'tbl.'>, seg="'tbl.value'"]
INFO       [PD:4  MD:10]	..........FunctionNameSegment                     	AnyNu.match PRN     	    	[ns=1, ps=0, ms=0, pruned=[], opts=[<Sequence: [<Ref: SingleIdentifierGrammar>, <Ref: DotSegment>]>]]
INFO       [PD:4  MD:12]	............SingleIdentifierGrammar               	OneOf.match PRN     	    	[ns=2, ps=0, ms=0, pruned=[], opts=[<Ref: NakedIdentifierSegment>, <Ref: QuotedIdentifierSegment>]]
INFO       [PD:4  MD:12]	............SingleIdentifierGrammar               	OneOf.match OUT     	++  	[match=<MatchResult 1/1: 'value'>, seg="'value'"]
INFO       [PD:4  MD:11]	...........FunctionNameSegment                    	Seque.match OUT     	    	[match=<MatchResult 0/1: ''>, seg="'value'"]
INFO       [PD:4  MD:10]	..........FunctionNameSegment                     	AnyNu.match OUT     	+   	[match=<MatchResult 2/3: 'tbl.'>, seg="'tbl.value'"]
INFO       [PD:4  MD:10]	..........FunctionNameSegment                     	OneOf.match PRN     	    	[ns=2, ps=0, ms=0, pruned=[], opts=[<Ref: FunctionNameIdentifierSegment>, <Ref: QuotedIdentifierSegment>]]
INFO       [PD:4  MD:10]	..........FunctionNameSegment                     	OneOf.match OUT     	++  	[match=<MatchResult 1/1: 'value'>, seg="'value'"]
INFO       [PD:4  MD:9 ]	.........FunctionNameSegment                      	Seque.match OUT     	++  	[match=<MatchResult 3/3: 'tbl.value'>, seg="'tbl.value'"]
INFO       [PD:4  MD:7 ]	.......FunctionSegment                            	AnyNu.match OUT     	++  	[match=<MatchResult 1/1: 'tbl.value'>, seg="'tbl.value'"]
INFO       [PD:4  MD:6 ]	......FunctionSegment                             	Seque.match OUT     	    	[match=<MatchResult 0/3: ''>, seg="'tbl.value'"]
INFO       [PD:4  MD:5 ]	.....FunctionSegment                              	Seque.match OUT     	    	[match=<MatchResult 0/3: ''>, seg="'tbl.value'"]
INFO       [PD:4  MD:4 ]	....FunctionSegment                               	OneOf.match OUT     	    	[match=<MatchResult 0/3: ''>, seg="'tbl.value'"]
INFO       [PD:4  MD:5 ]	.....ColumnReferenceSegment                       	OneOf.match PRN     	    	[ns=0, ps=0, ms=2, pruned=[], opts=[<Ref: DotSegment>, <Sequence: [<Ref: DotSegment>, <Ref: DotSegment>]>]]
INFO       [PD:4  MD:6 ]	......ColumnReferenceSegment                      	Seque.match OUT     	    	[match=<MatchResult 0/2: ''>, seg="'.value'"]
INFO       [PD:4  MD:5 ]	.....ColumnReferenceSegment                       	OneOf.match OUT     	+   	[match=<MatchResult 1/2: '.'>, seg="'.value'"]
INFO       [PD:4  MD:5 ]	.....ColumnReferenceSegment                       	OneOf.match PRN     	    	[ns=0, ps=0, ms=2, pruned=[], opts=[<Ref: DotSegment>, <Sequence: [<Ref: DotSegment>, <Ref: DotSegment>]>]]
INFO       [PD:4  MD:6 ]	......ColumnReferenceSegment                      	Seque.match OUT     	    	[match=<MatchResult 0/2: ''>, seg="'.value'"]
INFO       [PD:4  MD:5 ]	.....ColumnReferenceSegment                       	OneOf.match OUT     	+   	[match=<MatchResult 1/2: '.'>, seg="'.value'"]
INFO       [PD:4  MD:5 ]	.....ColumnReferenceSegment                       	OneOf.match PRN     	    	[ns=1, ps=10, ms=0, pruned=[<Ref: OnKeywordSegment>, <Ref: AsKeywordSegment>, <Ref: UsingKeywordSegment>, <Ref: CommaSegment>, <Ref: CastOperatorSegment>, <Ref: StartSquareBracketSegment>, <Ref: StartBracketSegment>, <Ref: ColonSegment>, <Ref: DelimiterSegment>, <class 'sqlfluff.core.parser.segments.base.BracketedSegment'>], opts=[<Ref: BinaryOperatorGrammar>]]
INFO       [PD:4  MD:6 ]	......BinaryOperatorGrammar                       	OneOf.match PRN     	    	[ns=1, ps=3, ms=0, pruned=[<Ref: ArithmeticBinaryOperatorGrammar>, <Ref: StringBinaryOperatorGrammar>, <Ref: BooleanBinaryOperatorGrammar>], opts=[<Ref: ComparisonOperatorGrammar>]]
INFO       [PD:4  MD:7 ]	.......ComparisonOperatorGrammar                  	OneOf.match PRN     	    	[ns=1, ps=7, ms=0, pruned=[<Ref: EqualsSegment>, <Ref: GreaterThanSegment>, <Ref: LessThanSegment>, <Ref: GreaterThanOrEqualToSegment>, <Ref: LessThanOrEqualToSegment>, <Ref: NotEqualToSegment_a>, <Ref: NotEqualToSegment_b>], opts=[<Ref: LikeOperatorSegment>]]
INFO       [PD:4  MD:7 ]	.......ComparisonOperatorGrammar                  	OneOf.match OUT     	    	[match=<MatchResult 0/3: ''>, seg="'tbl.value'"]
INFO       [PD:4  MD:6 ]	......BinaryOperatorGrammar                       	OneOf.match OUT     	    	[match=<MatchResult 0/3: ''>, seg="'tbl.value'"]
INFO       [PD:4  MD:5 ]	.....ColumnReferenceSegment                       	OneOf.match OUT     	    	[match=<MatchResult 0/3: ''>, seg="'tbl.value'"]
INFO       [PD:4  MD:5 ]	.....ColumnReferenceSegment                       	OneOf.match PRN     	    	[ns=1, ps=10, ms=0, pruned=[<Ref: OnKeywordSegment>, <Ref: AsKeywordSegment>, <Ref: UsingKeywordSegment>, <Ref: CommaSegment>, <Ref: CastOperatorSegment>, <Ref: StartSquareBracketSegment>, <Ref: StartBracketSegment>, <Ref: ColonSegment>, <Ref: DelimiterSegment>, <class 'sqlfluff.core.parser.segments.base.BracketedSegment'>], opts=[<Ref: BinaryOperatorGrammar>]]
INFO       [PD:4  MD:6 ]	......BinaryOperatorGrammar                       	OneOf.match PRN     	    	[ns=1, ps=3, ms=0, pruned=[<Ref: ArithmeticBinaryOperatorGrammar>, <Ref: StringBinaryOperatorGrammar>, <Ref: BooleanBinaryOperatorGrammar>], opts=[<Ref: ComparisonOperatorGrammar>]]
INFO       [PD:4  MD:7 ]	.......ComparisonOperatorGrammar                  	OneOf.match PRN     	    	[ns=1, ps=7, ms=0, pruned=[<Ref: EqualsSegment>, <Ref: GreaterThanSegment>, <Ref: LessThanSegment>, <Ref: GreaterThanOrEqualToSegment>, <Ref: LessThanOrEqualToSegment>, <Ref: NotEqualToSegment_a>, <Ref: NotEqualToSegment_b>], opts=[<Ref: LikeOperatorSegment>]]
INFO       [PD:4  MD:7 ]	.......ComparisonOperatorGrammar                  	OneOf.match OUT     	    	[match=<MatchResult 0/2: ''>, seg="'.value'"]
INFO       [PD:4  MD:6 ]	......BinaryOperatorGrammar                       	OneOf.match OUT     	    	[match=<MatchResult 0/2: ''>, seg="'.value'"]
INFO       [PD:4  MD:5 ]	.....ColumnReferenceSegment                       	OneOf.match OUT     	    	[match=<MatchResult 0/2: ''>, seg="'.value'"]
INFO       [PD:4  MD:5 ]	.....SingleIdentifierGrammar                      	OneOf.match PRN     	    	[ns=2, ps=0, ms=0, pruned=[], opts=[<Ref: NakedIdentifierSegment>, <Ref: QuotedIdentifierSegment>]]
INFO       [PD:4  MD:5 ]	.....SingleIdentifierGrammar                      	OneOf.match OUT     	++  	[match=<MatchResult 1/1: 'tbl'>, seg="'tbl'"]
INFO       [PD:4  MD:5 ]	.....ColumnReferenceSegment                       	OneOf.match PRN     	    	[ns=1, ps=10, ms=0, pruned=[<Ref: OnKeywordSegment>, <Ref: AsKeywordSegment>, <Ref: UsingKeywordSegment>, <Ref: CommaSegment>, <Ref: CastOperatorSegment>, <Ref: StartSquareBracketSegment>, <Ref: StartBracketSegment>, <Ref: ColonSegment>, <Ref: DelimiterSegment>, <class 'sqlfluff.core.parser.segments.base.BracketedSegment'>], opts=[<Ref: BinaryOperatorGrammar>]]
INFO       [PD:4  MD:6 ]	......BinaryOperatorGrammar                       	OneOf.match PRN     	    	[ns=1, ps=3, ms=0, pruned=[<Ref: ArithmeticBinaryOperatorGrammar>, <Ref: StringBinaryOperatorGrammar>, <Ref: BooleanBinaryOperatorGrammar>], opts=[<Ref: ComparisonOperatorGrammar>]]
INFO       [PD:4  MD:7 ]	.......ComparisonOperatorGrammar                  	OneOf.match PRN     	    	[ns=1, ps=7, ms=0, pruned=[<Ref: EqualsSegment>, <Ref: GreaterThanSegment>, <Ref: LessThanSegment>, <Ref: GreaterThanOrEqualToSegment>, <Ref: LessThanOrEqualToSegment>, <Ref: NotEqualToSegment_a>, <Ref: NotEqualToSegment_b>], opts=[<Ref: LikeOperatorSegment>]]
INFO       [PD:4  MD:7 ]	.......ComparisonOperatorGrammar                  	OneOf.match OUT     	    	[match=<MatchResult 0/1: ''>, seg="'value'"]
INFO       [PD:4  MD:6 ]	......BinaryOperatorGrammar                       	OneOf.match OUT     	    	[match=<MatchResult 0/1: ''>, seg="'value'"]
INFO       [PD:4  MD:5 ]	.....ColumnReferenceSegment                       	OneOf.match OUT     	    	[match=<MatchResult 0/1: ''>, seg="'value'"]
INFO       [PD:4  MD:5 ]	.....SingleIdentifierGrammar                      	OneOf.match PRN     	    	[ns=2, ps=0, ms=0, pruned=[], opts=[<Ref: NakedIdentifierSegment>, <Ref: QuotedIdentifierSegment>]]
INFO       [PD:4  MD:5 ]	.....SingleIdentifierGrammar                      	OneOf.match OUT     	++  	[match=<MatchResult 1/1: 'value'>, seg="'value'"]
INFO       [PD:4  MD:4 ]	....ColumnReferenceSegment                        	Delim.match OUT     	++  	[match=<MatchResult 3/3: 'tbl.value'>, seg="'tbl.value'"]
INFO       [PD:4  MD:2 ]	..BaseExpressionElementGrammar                    	OneOf.match OUT     	++  	[match=<MatchResult 1/1: 'tbl.value'>, seg="'tbl.value'"]
INFO       [PD:4  MD:1 ]	.SelectClauseElementSegment                       	Seque.match OUT     	++  	[match=<MatchResult 1/1: 'tbl.value'>, seg="'tbl.value'"]
INFO       [PD:4  MD:0 ]	SelectClauseElementSegment                        	OneOf.match OUT     	++  	[match=<MatchResult 1/1: 'tbl.value'>, seg="'tbl.value'"]
INFO       [PD:5] Skipping expansion of <ColumnReferenceSegment: ([L:  3, P:  5])>...
INFO       [PD:3] Skipping expansion of <NewlineSegment: ([L:  3, P: 14]) '\n'>...
INFO       [PD:3] Skipping expansion of <Dedent: ([L:  4, P:  1]) ''>...
INFO       
###
#
# Parse Depth 3. Expanding: FromClauseSegment: 'FROM tbl'
#
###
INFO       [PD:3  MD:4 ]	....FromExpressionSegment                         	OneOf.match PRN     	    	[ns=1, ps=1, ms=0, pruned=[<Ref: MLTableExpressionSegment>], opts=[<Ref: FromExpressionElementSegment>]]
INFO       [PD:3  MD:7 ]	.......FromExpressionElementSegment               	Optio.match PRN     	    	[ns=1, ps=1, ms=0, pruned=[<Bracketed: [<Ref: TableExpressionSegment>]>], opts=[<Ref: TableExpressionSegment>]]
INFO       [PD:3  MD:9 ]	.........TableExpressionSegment                   	OneOf.match PRN     	    	[ns=3, ps=1, ms=0, pruned=[<Bracketed: [<Ref: SelectableGrammar>]>], opts=[<Ref: BareFunctionSegment>, <Ref: FunctionSegment>, <Ref: TableReferenceSegment>]]
INFO       [PD:3  MD:11]	...........FunctionSegment                        	OneOf.match PRN     	    	[ns=1, ps=1, ms=0, pruned=[<Sequence: [<Sequence: [<Ref: DateAddFunctionNameSeg...]>], opts=[<Sequence: [<Sequence: [<AnyNumberOf: [<Ref: Functio..., <Ref: PostFunctionGrammar [opt]>]>]]
INFO       [PD:3  MD:16]	................DateAddFunctionNameSegment        	Seque.match OUT     	    	[match=<MatchResult 0/1: ''>, seg="'tbl'"]
INFO       [PD:3  MD:14]	..............FunctionSegment                     	AnyNu.match PRN     	    	[ns=1, ps=0, ms=0, pruned=[], opts=[<Ref: FunctionNameSegment>]]
INFO       [PD:3  MD:17]	.................FunctionNameSegment              	AnyNu.match PRN     	    	[ns=1, ps=0, ms=0, pruned=[], opts=[<Sequence: [<Ref: SingleIdentifierGrammar>, <Ref: DotSegment>]>]]
INFO       [PD:3  MD:19]	...................SingleIdentifierGrammar        	OneOf.match PRN     	    	[ns=2, ps=0, ms=0, pruned=[], opts=[<Ref: NakedIdentifierSegment>, <Ref: QuotedIdentifierSegment>]]
INFO       [PD:3  MD:19]	...................SingleIdentifierGrammar        	OneOf.match OUT     	++  	[match=<MatchResult 1/1: 'tbl'>, seg="'tbl'"]
INFO       [PD:3  MD:18]	..................FunctionNameSegment             	Seque.match OUT     	    	[match=<MatchResult 0/1: ''>, seg="'tbl'"]
INFO       [PD:3  MD:17]	.................FunctionNameSegment              	AnyNu.match OUT     	    	[match=<MatchResult 0/1: ''>, seg="'tbl'"]
INFO       [PD:3  MD:17]	.................FunctionNameSegment              	OneOf.match PRN     	    	[ns=2, ps=0, ms=0, pruned=[], opts=[<Ref: FunctionNameIdentifierSegment>, <Ref: QuotedIdentifierSegment>]]
INFO       [PD:3  MD:17]	.................FunctionNameSegment              	OneOf.match OUT     	++  	[match=<MatchResult 1/1: 'tbl'>, seg="'tbl'"]
INFO       [PD:3  MD:16]	................FunctionNameSegment               	Seque.match OUT     	++  	[match=<MatchResult 1/1: 'tbl'>, seg="'tbl'"]
INFO       [PD:3  MD:14]	..............FunctionSegment                     	AnyNu.match OUT     	++  	[match=<MatchResult 1/1: 'tbl'>, seg="'tbl'"]
INFO       [PD:3  MD:13]	.............FunctionSegment                      	Seque.match OUT     	    	[match=<MatchResult 0/1: ''>, seg="'tbl'"]
INFO       [PD:3  MD:12]	............FunctionSegment                       	Seque.match OUT     	    	[match=<MatchResult 0/1: ''>, seg="'tbl'"]
INFO       [PD:3  MD:11]	...........FunctionSegment                        	OneOf.match OUT     	    	[match=<MatchResult 0/1: ''>, seg="'tbl'"]
INFO       [PD:3  MD:12]	............TableReferenceSegment                 	OneOf.match PRN     	    	[ns=1, ps=10, ms=0, pruned=[<Ref: OnKeywordSegment>, <Ref: AsKeywordSegment>, <Ref: UsingKeywordSegment>, <Ref: CommaSegment>, <Ref: CastOperatorSegment>, <Ref: StartSquareBracketSegment>, <Ref: StartBracketSegment>, <Ref: ColonSegment>, <Ref: DelimiterSegment>, <class 'sqlfluff.core.parser.segments.base.BracketedSegment'>], opts=[<Ref: BinaryOperatorGrammar>]]
INFO       [PD:3  MD:13]	.............BinaryOperatorGrammar                	OneOf.match PRN     	    	[ns=1, ps=3, ms=0, pruned=[<Ref: ArithmeticBinaryOperatorGrammar>, <Ref: StringBinaryOperatorGrammar>, <Ref: BooleanBinaryOperatorGrammar>], opts=[<Ref: ComparisonOperatorGrammar>]]
INFO       [PD:3  MD:14]	..............ComparisonOperatorGrammar           	OneOf.match PRN     	    	[ns=1, ps=7, ms=0, pruned=[<Ref: EqualsSegment>, <Ref: GreaterThanSegment>, <Ref: LessThanSegment>, <Ref: GreaterThanOrEqualToSegment>, <Ref: LessThanOrEqualToSegment>, <Ref: NotEqualToSegment_a>, <Ref: NotEqualToSegment_b>], opts=[<Ref: LikeOperatorSegment>]]
INFO       [PD:3  MD:14]	..............ComparisonOperatorGrammar           	OneOf.match OUT     	    	[match=<MatchResult 0/1: ''>, seg="'tbl'"]
INFO       [PD:3  MD:13]	.............BinaryOperatorGrammar                	OneOf.match OUT     	    	[match=<MatchResult 0/1: ''>, seg="'tbl'"]
INFO       [PD:3  MD:12]	............TableReferenceSegment                 	OneOf.match OUT     	    	[match=<MatchResult 0/1: ''>, seg="'tbl'"]
INFO       [PD:3  MD:12]	............SingleIdentifierGrammar               	OneOf.match PRN     	    	[ns=2, ps=0, ms=0, pruned=[], opts=[<Ref: NakedIdentifierSegment>, <Ref: QuotedIdentifierSegment>]]
INFO       [PD:3  MD:12]	............SingleIdentifierGrammar               	OneOf.match OUT     	++  	[match=<MatchResult 1/1: 'tbl'>, seg="'tbl'"]
INFO       [PD:3  MD:11]	...........TableReferenceSegment                  	Delim.match OUT     	++  	[match=<MatchResult 1/1: 'tbl'>, seg="'tbl'"]
INFO       [PD:3  MD:9 ]	.........TableExpressionSegment                   	OneOf.match OUT     	++  	[match=<MatchResult 1/1: 'tbl'>, seg="'tbl'"]
INFO       [PD:3  MD:7 ]	.......FromExpressionElementSegment               	Optio.match OUT     	++  	[match=<MatchResult 1/1: 'tbl'>, seg="'tbl'"]
INFO       [PD:3  MD:6 ]	......FromExpressionElementSegment                	Seque.match OUT     	++  	[match=<MatchResult 1/1: 'tbl'>, seg="'tbl'"]
INFO       [PD:3  MD:4 ]	....FromExpressionSegment                         	OneOf.match OUT     	++  	[match=<MatchResult 1/1: 'tbl'>, seg="'tbl'"]
INFO       [PD:3  MD:3 ]	...FromExpressionSegment                          	Condi.match OUT     	++  	[match=<MatchResult 1/1: ''>, seg="''"]
INFO       [PD:3  MD:3 ]	...FromExpressionSegment                          	Seque.match OUT     	++  	[match=<MatchResult 3/3: 'tbl'>, seg="'tbl'"]
INFO       [PD:3  MD:1 ]	.FromClauseSegment                                	Delim.match OUT     	++  	[match=<MatchResult 1/1: 'tbl'>, seg="'tbl'"]
INFO       [PD:3  MD:0 ]	FromClauseSegment                                 	Seque.match OUT     	++  	[match=<MatchResult 3/3: 'FROM tbl'>, seg="'FROM tbl'"]
INFO       [PD:4] Skipping expansion of <KeywordSegment: ([L:  4, P:  1]) 'FROM'>...
INFO       [PD:4] Skipping expansion of <WhitespaceSegment: ([L:  4, P:  5]) ' '>...
INFO       [PD:4] Skipping expansion of <FromExpressionSegment: ([L:  4, P:  6])>...
INFO       [PD:1] Skipping expansion of <NewlineSegment: ([L:  4, P:  9]) '\n'>...
INFO       
###
#
# Parsed Tree:
#
###
INFO       
[L:  1, P:  1]      |file:
[L:  1, P:  1]      |    statement:
[L:  1, P:  1]      |        select_statement:
[L:  1, P:  1]      |            select_clause:
[L:  1, P:  1]      |                keyword:                                      'SELECT'
[L:  1, P:  7]      |                [META] indent:
[L:  1, P:  7]      |                newline:                                      '\n'
[L:  2, P:  1]      |                whitespace:                                   '    '
[L:  2, P:  5]      |                select_clause_element:
[L:  2, P:  5]      |                    column_reference:
[L:  2, P:  5]      |                        identifier:                           'tbl'
[L:  2, P:  8]      |                        dot:                                  '.'
[L:  2, P:  9]      |                        identifier:                           'name'
[L:  2, P: 13]      |                comma:                                        ','
[L:  2, P: 14]      |                newline:                                      '\n'
[L:  3, P:  1]      |                whitespace:                                   '    '
[L:  3, P:  5]      |                select_clause_element:
[L:  3, P:  5]      |                    column_reference:
[L:  3, P:  5]      |                        identifier:                           'tbl'
[L:  3, P:  8]      |                        dot:                                  '.'
[L:  3, P:  9]      |                        identifier:                           'value'
[L:  3, P: 14]      |            newline:                                          '\n'
[L:  4, P:  1]      |            [META] dedent:
[L:  4, P:  1]      |            from_clause:
[L:  4, P:  1]      |                keyword:                                      'FROM'
[L:  4, P:  5]      |                whitespace:                                   ' '
[L:  4, P:  6]      |                from_expression:
[L:  4, P:  6]      |                    [META] indent:
[L:  4, P:  6]      |                    from_expression_element:
[L:  4, P:  6]      |                        table_expression:
[L:  4, P:  6]      |                            table_reference:
[L:  4, P:  6]      |                                identifier:                   'tbl'
[L:  4, P:  9]      |                    [META] dedent:
[L:  4, P:  9]      |    newline:                                                  '\n'

INFO       LINTING (test/fixtures/cli/passing_a.sql)
== [test/fixtures/cli/passing_a.sql] LINTING
DEBUG      [L003] Evaluating line #1. {'line_no': 1, 'indent_size': 0, 'indent_balance': 0, 'hanging_indent': None, 'clean_indent': False}
DEBUG      [L003] Evaluating line #2. {'line_no': 2, 'indent_size': 4, 'indent_balance': 1, 'hanging_indent': None, 'clean_indent': True}
DEBUG      [L003]     [deeper indent balance] Comparing to #1
DEBUG      [L003]     Comparison Line: {'line_no': 1, 'indent_size': 0, 'indent_balance': 0, 'hanging_indent': None, 'clean_indent': False}
DEBUG      [L003]     Indent deemed ok comparing to #1
DEBUG      [L003] Evaluating line #3. {'line_no': 3, 'indent_size': 4, 'indent_balance': 1, 'hanging_indent': None, 'clean_indent': False}
DEBUG      [L003]     [same indent balance] Comparing to #2
DEBUG      [L003]     Indent deemed ok comparing to #2
DEBUG      [L003] Evaluating line #4. {'line_no': 4, 'indent_size': 0, 'indent_balance': 0, 'hanging_indent': None, 'clean_indent': False}
DEBUG      [L003]     [same indent balance] Comparing to #1
DEBUG      [L003]     Indent deemed ok comparing to #1
DEBUG      [L010] Selected 'capitalisation_policy': 'consistent' from options ['upper', 'lower', 'capitalise']
DEBUG      [L010] Refuted cases after segment 'SELECT': {'lower', 'capitalise'}
DEBUG      [L010] Possible cases after segment 'SELECT': ['upper']
DEBUG      [L010] Consistent capitalization, returning with memory: {'refuted_cases': {'lower', 'capitalise'}, 'latest_possible_case': 'upper'}
DEBUG      [L010] Refuted cases after segment 'FROM': {'lower', 'capitalise'}
DEBUG      [L010] Possible cases after segment 'FROM': ['upper']
DEBUG      [L010] Consistent capitalization, returning with memory: {'refuted_cases': {'lower', 'capitalise'}, 'latest_possible_case': 'upper'}
DEBUG      [L014] Selected 'extended_capitalisation_policy': 'consistent' from options ['upper', 'lower', 'pascal', 'capitalise']
DEBUG      [L014] Refuted cases after segment 'tbl': {'upper', 'pascal', 'capitalise'}
DEBUG      [L014] Possible cases after segment 'tbl': ['lower']
DEBUG      [L014] Consistent capitalization, returning with memory: {'refuted_cases': {'upper', 'pascal', 'capitalise'}, 'latest_possible_case': 'lower'}
DEBUG      [L014] Refuted cases after segment 'name': {'upper', 'pascal', 'capitalise'}
DEBUG      [L014] Possible cases after segment 'name': ['lower']
DEBUG      [L014] Consistent capitalization, returning with memory: {'refuted_cases': {'upper', 'pascal', 'capitalise'}, 'latest_possible_case': 'lower'}
DEBUG      [L014] Refuted cases after segment 'tbl': {'upper', 'pascal', 'capitalise'}
DEBUG      [L014] Possible cases after segment 'tbl': ['lower']
DEBUG      [L014] Consistent capitalization, returning with memory: {'refuted_cases': {'upper', 'pascal', 'capitalise'}, 'latest_possible_case': 'lower'}
DEBUG      [L014] Refuted cases after segment 'value': {'upper', 'pascal', 'capitalise'}
DEBUG      [L014] Possible cases after segment 'value': ['lower']
DEBUG      [L014] Consistent capitalization, returning with memory: {'refuted_cases': {'upper', 'pascal', 'capitalise'}, 'latest_possible_case': 'lower'}
DEBUG      [L014] Refuted cases after segment 'tbl': {'upper', 'pascal', 'capitalise'}
DEBUG      [L014] Possible cases after segment 'tbl': ['lower']
DEBUG      [L014] Consistent capitalization, returning with memory: {'refuted_cases': {'upper', 'pascal', 'capitalise'}, 'latest_possible_case': 'lower'}
DEBUG      [L044] Analyzing query: SELECT
    tbl.name,
    tbl.value
FROM tbl
== [test/fixtures/cli/passing_a.sql] PASS
==== summary ====
files:             1 violations:        0
clean files:       1 unclean files:     0
avg per file:   0.00 unclean rate:     0%
status:         PASS
All Finished 📜 🎉!

___________________ test__cli__command_lint_parse[command5] ____________________
----------------------------- Captured stdout call -----------------------------
==== sqlfluff ====
sqlfluff:              0.7.0a8 python:                 3.9.20
implementation:        cpython dialect:                  ansi
verbosity:                  11 templater:               jinja

== Raw Config:
core:                                   
    color:              False               
    dialect:            ansi                
    encoding:           autodetect          
    ignore:             []                  
    ignore_templated_areas:True                
    nocolor:            True                
    output_line_length: 80                  
    recurse:            True                
    runaway_limit:      10                  
    sql_file_exts:      .sql,.sql.j2,.dml,.ddl
    templater:          jinja               
    verbose:            11                  
indentation:                            
    indented_joins:     False               
    indented_using_on:  True                
    template_blocks_indent:True                
rules:                                  
    allow_scalar:       True                
    comma_style:        trailing            
    indent_unit:        space               
    max_line_length:    80                  
    single_table_references:consistent          
    tab_space_size:     4                   
    unquoted_identifiers_policy:all                 
    L007:                                   
        operator_new_lines: after               
    L010:                                   
        capitalisation_policy:consistent          
    L011:                                   
        aliasing:           explicit            
    L012:                                   
        aliasing:           explicit            
    L014:                                   
        extended_capitalisation_policy:consistent          
    L016:                                   
        ignore_comment_lines:False               
    L026:                                   
        force_enable:       False               
    L028:                                   
        force_enable:       False               
    L029:                                   
        unquoted_identifiers_policy:aliases             
    L030:                                   
        capitalisation_policy:consistent          
    L038:                                   
        select_clause_trailing_comma:forbid              
    L040:                                   
        capitalisation_policy:consistent          
    L042:                                   
        forbid_subquery_in: join                
    L047:                                   
        prefer_count_0:     False               
        prefer_count_1:     False               
templater:                              
    unwrap_wrapped_queries:True                
    jinja:                                  
        apply_dbt_builtins: True                
        macros:                                 
            dbt_config:         {% macro config() %}{% for k in kwargs %}{% endfor %}{% endmacro %}
            dbt_is_incremental: {% macro is_incremental() %}True{% endmacro %}
            dbt_ref:            {% macro ref(model_ref) %}{{model_ref}}{% endmacro %}
            dbt_source:         {% macro source(source_name, table) %}{{source_name}}_{{table}}{% endmacro %}
            dbt_var:            {% macro var(variable, default='') %}item{% endmacro %}

==== readout ====

=== [ path: test/fixtures/cli/passing_b.sql ] ===

INFO       TEMPLATING RAW [jinja] (test/fixtures/cli/passing_b.sql)
INFO       Slicing File Template
DEBUG          Raw String: 'SELECT\n    tbl.name,\n    b.value,\n    /*\n    This is a block comment\n    */\n    d.something,    -- Which a comment after it\n    tbl.foo,\n    c.val + b.val / -2 AS a_calculation\nFROM tbl\nINNER JOIN b ON (tbl.common_id = b.common_id)\nJOIN c ON (tbl.id = c.id)\nLEFT JOIN d ON (tbl.id = d.other_id)\nORDER BY tbl.name ASC\n'
DEBUG          Templated String: 'SELECT\n    tbl.name,\n    b.value,\n    /*\n    This is a block comment\n    */\n    d.something,    -- Which a comment after it\n    tbl.foo,\n    c.val + b.val / -2 AS a_calculation\nFROM tbl\nINNER JOIN b ON (tbl.common_id = b.common_id)\nJOIN c ON (tbl.id = c.id)\nLEFT JOIN d ON (tbl.id = d.other_id)\nORDER BY tbl.name ASC\n'
DEBUG          Raw Sliced:
DEBUG              0: RawFileSlice(raw='SELECT\n    tbl.name,\n    b.value,\n    /*\n    This is a block comment\n    */\n    d.something,    -- Which a comment after it\n    tbl.foo,\n    c.val + b.val / -2 AS a_calculation\nFROM tbl\nINNER JOIN b ON (tbl.common_id = b.common_id)\nJOIN c ON (tbl.id = c.id)\nLEFT JOIN d ON (tbl.id = d.other_id)\nORDER BY tbl.name ASC\n', slice_type='literal', source_idx=0, slice_subtype=None)
DEBUG          Literals: ['SELECT\n    tbl.name,\n    b.value,\n    /*\n    This is a block comment\n    */\n    d.something,    -- Which a comment after it\n    tbl.foo,\n    c.val + b.val / -2 AS a_calculation\nFROM tbl\nINNER JOIN b ON (tbl.common_id = b.common_id)\nJOIN c ON (tbl.id = c.id)\nLEFT JOIN d ON (tbl.id = d.other_id)\nORDER BY tbl.name ASC\n']
DEBUG          # Slice Loop 0
DEBUG          Occurrences: Raw: {'SELECT\n    tbl.name,\n    b.value,\n    /*\n    This is a block comment\n    */\n    d.something,    -- Which a comment after it\n    tbl.foo,\n    c.val + b.val / -2 AS a_calculation\nFROM tbl\nINNER JOIN b ON (tbl.common_id = b.common_id)\nJOIN c ON (tbl.id = c.id)\nLEFT JOIN d ON (tbl.id = d.other_id)\nORDER BY tbl.name ASC\n': [0]}, Templated: {'SELECT\n    tbl.name,\n    b.value,\n    /*\n    This is a block comment\n    */\n    d.something,    -- Which a comment after it\n    tbl.foo,\n    c.val + b.val / -2 AS a_calculation\nFROM tbl\nINNER JOIN b ON (tbl.common_id = b.common_id)\nJOIN c ON (tbl.id = c.id)\nLEFT JOIN d ON (tbl.id = d.other_id)\nORDER BY tbl.name ASC\n': [0]}
DEBUG          Split Sliced:
DEBUG              0: IntermediateFileSlice(intermediate_type='invariant', source_slice=slice(0, 317, None), templated_slice=slice(0, 317, None), slice_buffer=[RawFileSlice(raw='SELECT\n    tbl.name,\n    b.value,\n    /*\n    This is a block comment\n    */\n    d.something,    -- Which a comment after it\n    tbl.foo,\n    c.val + b.val / -2 AS a_calculation\nFROM tbl\nINNER JOIN b ON (tbl.common_id = b.common_id)\nJOIN c ON (tbl.id = c.id)\nLEFT JOIN d ON (tbl.id = d.other_id)\nORDER BY tbl.name ASC\n', slice_type='literal', source_idx=0, slice_subtype=None)])
DEBUG          _split_uniques_coalesce_rest: [IntermediateFileSlice(intermediate_type='invariant', source_slice=slice(0, 317, None), templated_slice=slice(0, 317, None), slice_buffer=[RawFileSlice(raw='SELECT\n    tbl.name,\n    b.value,\n    /*\n    This is a block comment\n    */\n    d.something,    -- Which a comment after it\n    tbl.foo,\n    c.val + b.val / -2 AS a_calculation\nFROM tbl\nINNER JOIN b ON (tbl.common_id = b.common_id)\nJOIN c ON (tbl.id = c.id)\nLEFT JOIN d ON (tbl.id = d.other_id)\nORDER BY tbl.name ASC\n', slice_type='literal', source_idx=0, slice_subtype=None)])]
DEBUG              Yielding Simple: TemplatedFileSlice(slice_type='literal', source_slice=slice(0, 317, None), templated_slice=slice(0, 317, None))
DEBUG          Fully Sliced:
DEBUG              0: TemplatedFileSlice(slice_type='literal', source_slice=slice(0, 317, None), templated_slice=slice(0, 317, None))
INFO       [L001] No config_keywords defined for L001
INFO       [L005] No config_keywords defined for L005
INFO       [L006] No config_keywords defined for L006
INFO       [L008] No config_keywords defined for L008
INFO       [L009] No config_keywords defined for L009
INFO       [L015] No config_keywords defined for L015
INFO       [L017] No config_keywords defined for L017
INFO       [L020] No config_keywords defined for L020
INFO       [L021] No config_keywords defined for L021
INFO       [L023] No config_keywords defined for L023
INFO       [L024] No config_keywords defined for L024
INFO       [L025] No config_keywords defined for L025
INFO       [L027] No config_keywords defined for L027
INFO       [L031] No config_keywords defined for L031
INFO       [L032] No config_keywords defined for L032
INFO       [L033] No config_keywords defined for L033
INFO       [L034] No config_keywords defined for L034
INFO       [L035] No config_keywords defined for L035
INFO       [L036] No config_keywords defined for L036
INFO       [L037] No config_keywords defined for L037
INFO       [L039] No config_keywords defined for L039
INFO       [L041] No config_keywords defined for L041
INFO       [L043] No config_keywords defined for L043
INFO       [L044] No config_keywords defined for L044
INFO       [L045] No config_keywords defined for L045
INFO       [L046] No config_keywords defined for L046
INFO       [L048] No config_keywords defined for L048
INFO       [L049] No config_keywords defined for L049
INFO       LEXING RAW (test/fixtures/cli/passing_b.sql)
INFO       Elements to Segments.
INFO       Source-only slices: []
DEBUG        0, TemplateElement(raw='SELECT', template_slice=slice(0, 6, None), matcher=<RegexLexer: code>), slice(0, 6, None), 'SELECT'
DEBUG        1, TemplateElement(raw='\n', template_slice=slice(6, 7, None), matcher=<RegexLexer: newline>), slice(6, 7, None), '\n'
DEBUG        2, TemplateElement(raw='    ', template_slice=slice(7, 11, None), matcher=<RegexLexer: whitespace>), slice(7, 11, None), '    '
DEBUG        3, TemplateElement(raw='tbl', template_slice=slice(11, 14, None), matcher=<RegexLexer: code>), slice(11, 14, None), 'tbl'
DEBUG        4, TemplateElement(raw='.', template_slice=slice(14, 15, None), matcher=<StringLexer: dot>), slice(14, 15, None), '.'
DEBUG        5, TemplateElement(raw='name', template_slice=slice(15, 19, None), matcher=<RegexLexer: code>), slice(15, 19, None), 'name'
DEBUG        6, TemplateElement(raw=',', template_slice=slice(19, 20, None), matcher=<StringLexer: comma>), slice(19, 20, None), ','
DEBUG        7, TemplateElement(raw='\n', template_slice=slice(20, 21, None), matcher=<RegexLexer: newline>), slice(20, 21, None), '\n'
DEBUG        8, TemplateElement(raw='    ', template_slice=slice(21, 25, None), matcher=<RegexLexer: whitespace>), slice(21, 25, None), '    '
DEBUG        9, TemplateElement(raw='b', template_slice=slice(25, 26, None), matcher=<RegexLexer: code>), slice(25, 26, None), 'b'
DEBUG        10, TemplateElement(raw='.', template_slice=slice(26, 27, None), matcher=<StringLexer: dot>), slice(26, 27, None), '.'
DEBUG        11, TemplateElement(raw='value', template_slice=slice(27, 32, None), matcher=<RegexLexer: code>), slice(27, 32, None), 'value'
DEBUG        12, TemplateElement(raw=',', template_slice=slice(32, 33, None), matcher=<StringLexer: comma>), slice(32, 33, None), ','
DEBUG        13, TemplateElement(raw='\n', template_slice=slice(33, 34, None), matcher=<RegexLexer: newline>), slice(33, 34, None), '\n'
DEBUG        14, TemplateElement(raw='    ', template_slice=slice(34, 38, None), matcher=<RegexLexer: whitespace>), slice(34, 38, None), '    '
DEBUG        15, TemplateElement(raw='/*', template_slice=slice(38, 40, None), matcher=<RegexLexer: block_comment>), slice(38, 40, None), '/*'
DEBUG        16, TemplateElement(raw='\n', template_slice=slice(40, 41, None), matcher=<RegexLexer: newline>), slice(40, 41, None), '\n'
DEBUG        17, TemplateElement(raw='    ', template_slice=slice(41, 45, None), matcher=<RegexLexer: whitespace>), slice(41, 45, None), '    '
DEBUG        18, TemplateElement(raw='This is a block comment', template_slice=slice(45, 68, None), matcher=<RegexLexer: block_comment>), slice(45, 68, None), 'This is a block comment'
DEBUG        19, TemplateElement(raw='\n', template_slice=slice(68, 69, None), matcher=<RegexLexer: newline>), slice(68, 69, None), '\n'
DEBUG        20, TemplateElement(raw='    ', template_slice=slice(69, 73, None), matcher=<RegexLexer: whitespace>), slice(69, 73, None), '    '
DEBUG        21, TemplateElement(raw='*/', template_slice=slice(73, 75, None), matcher=<RegexLexer: block_comment>), slice(73, 75, None), '*/'
DEBUG        22, TemplateElement(raw='\n', template_slice=slice(75, 76, None), matcher=<RegexLexer: newline>), slice(75, 76, None), '\n'
DEBUG        23, TemplateElement(raw='    ', template_slice=slice(76, 80, None), matcher=<RegexLexer: whitespace>), slice(76, 80, None), '    '
DEBUG        24, TemplateElement(raw='d', template_slice=slice(80, 81, None), matcher=<RegexLexer: code>), slice(80, 81, None), 'd'
DEBUG        25, TemplateElement(raw='.', template_slice=slice(81, 82, None), matcher=<StringLexer: dot>), slice(81, 82, None), '.'
DEBUG        26, TemplateElement(raw='something', template_slice=slice(82, 91, None), matcher=<RegexLexer: code>), slice(82, 91, None), 'something'
DEBUG        27, TemplateElement(raw=',', template_slice=slice(91, 92, None), matcher=<StringLexer: comma>), slice(91, 92, None), ','
DEBUG        28, TemplateElement(raw='    ', template_slice=slice(92, 96, None), matcher=<RegexLexer: whitespace>), slice(92, 96, None), '    '
DEBUG        29, TemplateElement(raw='-- Which a comment after it', template_slice=slice(96, 123, None), matcher=<RegexLexer: inline_comment>), slice(96, 123, None), '-- Which a comment after it'
DEBUG        30, TemplateElement(raw='\n', template_slice=slice(123, 124, None), matcher=<RegexLexer: newline>), slice(123, 124, None), '\n'
DEBUG        31, TemplateElement(raw='    ', template_slice=slice(124, 128, None), matcher=<RegexLexer: whitespace>), slice(124, 128, None), '    '
DEBUG        32, TemplateElement(raw='tbl', template_slice=slice(128, 131, None), matcher=<RegexLexer: code>), slice(128, 131, None), 'tbl'
DEBUG        33, TemplateElement(raw='.', template_slice=slice(131, 132, None), matcher=<StringLexer: dot>), slice(131, 132, None), '.'
DEBUG        34, TemplateElement(raw='foo', template_slice=slice(132, 135, None), matcher=<RegexLexer: code>), slice(132, 135, None), 'foo'
DEBUG        35, TemplateElement(raw=',', template_slice=slice(135, 136, None), matcher=<StringLexer: comma>), slice(135, 136, None), ','
DEBUG        36, TemplateElement(raw='\n', template_slice=slice(136, 137, None), matcher=<RegexLexer: newline>), slice(136, 137, None), '\n'
DEBUG        37, TemplateElement(raw='    ', template_slice=slice(137, 141, None), matcher=<RegexLexer: whitespace>), slice(137, 141, None), '    '
DEBUG        38, TemplateElement(raw='c', template_slice=slice(141, 142, None), matcher=<RegexLexer: code>), slice(141, 142, None), 'c'
DEBUG        39, TemplateElement(raw='.', template_slice=slice(142, 143, None), matcher=<StringLexer: dot>), slice(142, 143, None), '.'
DEBUG        40, TemplateElement(raw='val', template_slice=slice(143, 146, None), matcher=<RegexLexer: code>), slice(143, 146, None), 'val'
DEBUG        41, TemplateElement(raw=' ', template_slice=slice(146, 147, None), matcher=<RegexLexer: whitespace>), slice(146, 147, None), ' '
DEBUG        42, TemplateElement(raw='+', template_slice=slice(147, 148, None), matcher=<StringLexer: plus>), slice(147, 148, None), '+'
DEBUG        43, TemplateElement(raw=' ', template_slice=slice(148, 149, None), matcher=<RegexLexer: whitespace>), slice(148, 149, None), ' '
DEBUG        44, TemplateElement(raw='b', template_slice=slice(149, 150, None), matcher=<RegexLexer: code>), slice(149, 150, None), 'b'
DEBUG        45, TemplateElement(raw='.', template_slice=slice(150, 151, None), matcher=<StringLexer: dot>), slice(150, 151, None), '.'
DEBUG        46, TemplateElement(raw='val', template_slice=slice(151, 154, None), matcher=<RegexLexer: code>), slice(151, 154, None), 'val'
DEBUG        47, TemplateElement(raw=' ', template_slice=slice(154, 155, None), matcher=<RegexLexer: whitespace>), slice(154, 155, None), ' '
DEBUG        48, TemplateElement(raw='/', template_slice=slice(155, 156, None), matcher=<StringLexer: divide>), slice(155, 156, None), '/'
DEBUG        49, TemplateElement(raw=' ', template_slice=slice(156, 157, None), matcher=<RegexLexer: whitespace>), slice(156, 157, None), ' '
DEBUG        50, TemplateElement(raw='-', template_slice=slice(157, 158, None), matcher=<StringLexer: minus>), slice(157, 158, None), '-'
DEBUG        51, TemplateElement(raw='2', template_slice=slice(158, 159, None), matcher=<RegexLexer: numeric_literal>), slice(158, 159, None), '2'
DEBUG        52, TemplateElement(raw=' ', template_slice=slice(159, 160, None), matcher=<RegexLexer: whitespace>), slice(159, 160, None), ' '
DEBUG        53, TemplateElement(raw='AS', template_slice=slice(160, 162, None), matcher=<RegexLexer: code>), slice(160, 162, None), 'AS'
DEBUG        54, TemplateElement(raw=' ', template_slice=slice(162, 163, None), matcher=<RegexLexer: whitespace>), slice(162, 163, None), ' '
DEBUG        55, TemplateElement(raw='a_calculation', template_slice=slice(163, 176, None), matcher=<RegexLexer: code>), slice(163, 176, None), 'a_calculation'
DEBUG        56, TemplateElement(raw='\n', template_slice=slice(176, 177, None), matcher=<RegexLexer: newline>), slice(176, 177, None), '\n'
DEBUG        57, TemplateElement(raw='FROM', template_slice=slice(177, 181, None), matcher=<RegexLexer: code>), slice(177, 181, None), 'FROM'
DEBUG        58, TemplateElement(raw=' ', template_slice=slice(181, 182, None), matcher=<RegexLexer: whitespace>), slice(181, 182, None), ' '
DEBUG        59, TemplateElement(raw='tbl', template_slice=slice(182, 185, None), matcher=<RegexLexer: code>), slice(182, 185, None), 'tbl'
DEBUG        60, TemplateElement(raw='\n', template_slice=slice(185, 186, None), matcher=<RegexLexer: newline>), slice(185, 186, None), '\n'
DEBUG        61, TemplateElement(raw='INNER', template_slice=slice(186, 191, None), matcher=<RegexLexer: code>), slice(186, 191, None), 'INNER'
DEBUG        62, TemplateElement(raw=' ', template_slice=slice(191, 192, None), matcher=<RegexLexer: whitespace>), slice(191, 192, None), ' '
DEBUG        63, TemplateElement(raw='JOIN', template_slice=slice(192, 196, None), matcher=<RegexLexer: code>), slice(192, 196, None), 'JOIN'
DEBUG        64, TemplateElement(raw=' ', template_slice=slice(196, 197, None), matcher=<RegexLexer: whitespace>), slice(196, 197, None), ' '
DEBUG        65, TemplateElement(raw='b', template_slice=slice(197, 198, None), matcher=<RegexLexer: code>), slice(197, 198, None), 'b'
DEBUG        66, TemplateElement(raw=' ', template_slice=slice(198, 199, None), matcher=<RegexLexer: whitespace>), slice(198, 199, None), ' '
DEBUG        67, TemplateElement(raw='ON', template_slice=slice(199, 201, None), matcher=<RegexLexer: code>), slice(199, 201, None), 'ON'
DEBUG        68, TemplateElement(raw=' ', template_slice=slice(201, 202, None), matcher=<RegexLexer: whitespace>), slice(201, 202, None), ' '
DEBUG        69, TemplateElement(raw='(', template_slice=slice(202, 203, None), matcher=<StringLexer: bracket_open>), slice(202, 203, None), '('
DEBUG        70, TemplateElement(raw='tbl', template_slice=slice(203, 206, None), matcher=<RegexLexer: code>), slice(203, 206, None), 'tbl'
DEBUG        71, TemplateElement(raw='.', template_slice=slice(206, 207, None), matcher=<StringLexer: dot>), slice(206, 207, None), '.'
DEBUG        72, TemplateElement(raw='common_id', template_slice=slice(207, 216, None), matcher=<RegexLexer: code>), slice(207, 216, None), 'common_id'
DEBUG        73, TemplateElement(raw=' ', template_slice=slice(216, 217, None), matcher=<RegexLexer: whitespace>), slice(216, 217, None), ' '
DEBUG        74, TemplateElement(raw='=', template_slice=slice(217, 218, None), matcher=<StringLexer: equals>), slice(217, 218, None), '='
DEBUG        75, TemplateElement(raw=' ', template_slice=slice(218, 219, None), matcher=<RegexLexer: whitespace>), slice(218, 219, None), ' '
DEBUG        76, TemplateElement(raw='b', template_slice=slice(219, 220, None), matcher=<RegexLexer: code>), slice(219, 220, None), 'b'
DEBUG        77, TemplateElement(raw='.', template_slice=slice(220, 221, None), matcher=<StringLexer: dot>), slice(220, 221, None), '.'
DEBUG        78, TemplateElement(raw='common_id', template_slice=slice(221, 230, None), matcher=<RegexLexer: code>), slice(221, 230, None), 'common_id'
DEBUG        79, TemplateElement(raw=')', template_slice=slice(230, 231, None), matcher=<StringLexer: bracket_close>), slice(230, 231, None), ')'
DEBUG        80, TemplateElement(raw='\n', template_slice=slice(231, 232, None), matcher=<RegexLexer: newline>), slice(231, 232, None), '\n'
DEBUG        81, TemplateElement(raw='JOIN', template_slice=slice(232, 236, None), matcher=<RegexLexer: code>), slice(232, 236, None), 'JOIN'
DEBUG        82, TemplateElement(raw=' ', template_slice=slice(236, 237, None), matcher=<RegexLexer: whitespace>), slice(236, 237, None), ' '
DEBUG        83, TemplateElement(raw='c', template_slice=slice(237, 238, None), matcher=<RegexLexer: code>), slice(237, 238, None), 'c'
DEBUG        84, TemplateElement(raw=' ', template_slice=slice(238, 239, None), matcher=<RegexLexer: whitespace>), slice(238, 239, None), ' '
DEBUG        85, TemplateElement(raw='ON', template_slice=slice(239, 241, None), matcher=<RegexLexer: code>), slice(239, 241, None), 'ON'
DEBUG        86, TemplateElement(raw=' ', template_slice=slice(241, 242, None), matcher=<RegexLexer: whitespace>), slice(241, 242, None), ' '
DEBUG        87, TemplateElement(raw='(', template_slice=slice(242, 243, None), matcher=<StringLexer: bracket_open>), slice(242, 243, None), '('
DEBUG        88, TemplateElement(raw='tbl', template_slice=slice(243, 246, None), matcher=<RegexLexer: code>), slice(243, 246, None), 'tbl'
DEBUG        89, TemplateElement(raw='.', template_slice=slice(246, 247, None), matcher=<StringLexer: dot>), slice(246, 247, None), '.'
DEBUG        90, TemplateElement(raw='id', template_slice=slice(247, 249, None), matcher=<RegexLexer: code>), slice(247, 249, None), 'id'
DEBUG        91, TemplateElement(raw=' ', template_slice=slice(249, 250, None), matcher=<RegexLexer: whitespace>), slice(249, 250, None), ' '
DEBUG        92, TemplateElement(raw='=', template_slice=slice(250, 251, None), matcher=<StringLexer: equals>), slice(250, 251, None), '='
DEBUG        93, TemplateElement(raw=' ', template_slice=slice(251, 252, None), matcher=<RegexLexer: whitespace>), slice(251, 252, None), ' '
DEBUG        94, TemplateElement(raw='c', template_slice=slice(252, 253, None), matcher=<RegexLexer: code>), slice(252, 253, None), 'c'
DEBUG        95, TemplateElement(raw='.', template_slice=slice(253, 254, None), matcher=<StringLexer: dot>), slice(253, 254, None), '.'
DEBUG        96, TemplateElement(raw='id', template_slice=slice(254, 256, None), matcher=<RegexLexer: code>), slice(254, 256, None), 'id'
DEBUG        97, TemplateElement(raw=')', template_slice=slice(256, 257, None), matcher=<StringLexer: bracket_close>), slice(256, 257, None), ')'
DEBUG        98, TemplateElement(raw='\n', template_slice=slice(257, 258, None), matcher=<RegexLexer: newline>), slice(257, 258, None), '\n'
DEBUG        99, TemplateElement(raw='LEFT', template_slice=slice(258, 262, None), matcher=<RegexLexer: code>), slice(258, 262, None), 'LEFT'
DEBUG        100, TemplateElement(raw=' ', template_slice=slice(262, 263, None), matcher=<RegexLexer: whitespace>), slice(262, 263, None), ' '
DEBUG        101, TemplateElement(raw='JOIN', template_slice=slice(263, 267, None), matcher=<RegexLexer: code>), slice(263, 267, None), 'JOIN'
DEBUG        102, TemplateElement(raw=' ', template_slice=slice(267, 268, None), matcher=<RegexLexer: whitespace>), slice(267, 268, None), ' '
DEBUG        103, TemplateElement(raw='d', template_slice=slice(268, 269, None), matcher=<RegexLexer: code>), slice(268, 269, None), 'd'
DEBUG        104, TemplateElement(raw=' ', template_slice=slice(269, 270, None), matcher=<RegexLexer: whitespace>), slice(269, 270, None), ' '
DEBUG        105, TemplateElement(raw='ON', template_slice=slice(270, 272, None), matcher=<RegexLexer: code>), slice(270, 272, None), 'ON'
DEBUG        106, TemplateElement(raw=' ', template_slice=slice(272, 273, None), matcher=<RegexLexer: whitespace>), slice(272, 273, None), ' '
DEBUG        107, TemplateElement(raw='(', template_slice=slice(273, 274, None), matcher=<StringLexer: bracket_open>), slice(273, 274, None), '('
DEBUG        108, TemplateElement(raw='tbl', template_slice=slice(274, 277, None), matcher=<RegexLexer: code>), slice(274, 277, None), 'tbl'
DEBUG        109, TemplateElement(raw='.', template_slice=slice(277, 278, None), matcher=<StringLexer: dot>), slice(277, 278, None), '.'
DEBUG        110, TemplateElement(raw='id', template_slice=slice(278, 280, None), matcher=<RegexLexer: code>), slice(278, 280, None), 'id'
DEBUG        111, TemplateElement(raw=' ', template_slice=slice(280, 281, None), matcher=<RegexLexer: whitespace>), slice(280, 281, None), ' '
DEBUG        112, TemplateElement(raw='=', template_slice=slice(281, 282, None), matcher=<StringLexer: equals>), slice(281, 282, None), '='
DEBUG        113, TemplateElement(raw=' ', template_slice=slice(282, 283, None), matcher=<RegexLexer: whitespace>), slice(282, 283, None), ' '
DEBUG        114, TemplateElement(raw='d', template_slice=slice(283, 284, None), matcher=<RegexLexer: code>), slice(283, 284, None), 'd'
DEBUG        115, TemplateElement(raw='.', template_slice=slice(284, 285, None), matcher=<StringLexer: dot>), slice(284, 285, None), '.'
DEBUG        116, TemplateElement(raw='other_id', template_slice=slice(285, 293, None), matcher=<RegexLexer: code>), slice(285, 293, None), 'other_id'
DEBUG        117, TemplateElement(raw=')', template_slice=slice(293, 294, None), matcher=<StringLexer: bracket_close>), slice(293, 294, None), ')'
DEBUG        118, TemplateElement(raw='\n', template_slice=slice(294, 295, None), matcher=<RegexLexer: newline>), slice(294, 295, None), '\n'
DEBUG        119, TemplateElement(raw='ORDER', template_slice=slice(295, 300, None), matcher=<RegexLexer: code>), slice(295, 300, None), 'ORDER'
DEBUG        120, TemplateElement(raw=' ', template_slice=slice(300, 301, None), matcher=<RegexLexer: whitespace>), slice(300, 301, None), ' '
DEBUG        121, TemplateElement(raw='BY', template_slice=slice(301, 303, None), matcher=<RegexLexer: code>), slice(301, 303, None), 'BY'
DEBUG        122, TemplateElement(raw=' ', template_slice=slice(303, 304, None), matcher=<RegexLexer: whitespace>), slice(303, 304, None), ' '
DEBUG        123, TemplateElement(raw='tbl', template_slice=slice(304, 307, None), matcher=<RegexLexer: code>), slice(304, 307, None), 'tbl'
DEBUG        124, TemplateElement(raw='.', template_slice=slice(307, 308, None), matcher=<StringLexer: dot>), slice(307, 308, None), '.'
DEBUG        125, TemplateElement(raw='name', template_slice=slice(308, 312, None), matcher=<RegexLexer: code>), slice(308, 312, None), 'name'
DEBUG        126, TemplateElement(raw=' ', template_slice=slice(312, 313, None), matcher=<RegexLexer: whitespace>), slice(312, 313, None), ' '
DEBUG        127, TemplateElement(raw='ASC', template_slice=slice(313, 316, None), matcher=<RegexLexer: code>), slice(313, 316, None), 'ASC'
DEBUG        128, TemplateElement(raw='\n', template_slice=slice(316, 317, None), matcher=<RegexLexer: newline>), slice(316, 317, None), '\n'
INFO       Lexed tokens: ['SELECT', '\n', '    ', 'tbl', '.', 'name', ',', '\n', '    ', 'b', '.', 'value', ',', '\n', '    ', '/*', '\n', '    ', 'This is a block comment', '\n', '    ', '*/', '\n', '    ', 'd', '.', 'something', ',', '    ', '-- Which a comment after it', '\n', '    ', 'tbl', '.', 'foo', ',', '\n', '    ', 'c', '.', 'val', ' ', '+', ' ', 'b', '.', 'val', ' ', '/', ' ', '-', '2', ' ', 'AS', ' ', 'a_calculation', '\n', 'FROM', ' ', 'tbl', '\n', 'INNER', ' ', 'JOIN', ' ', 'b', ' ', 'ON', ' ', '(', 'tbl', '.', 'common_id', ' ', '=', ' ', 'b', '.', 'common_id', ')', '\n', 'JOIN', ' ', 'c', ' ', 'ON', ' ', '(', 'tbl', '.', 'id', ' ', '=', ' ', 'c', '.', 'id', ')', '\n', 'LEFT', ' ', 'JOIN', ' ', 'd', ' ', 'ON', ' ', '(', 'tbl', '.', 'id', ' ', '=', ' ', 'd', '.', 'other_id', ')', '\n', 'ORDER', ' ', 'BY', ' ', 'tbl', '.', 'name', ' ', 'ASC', '\n']
INFO       PARSING (test/fixtures/cli/passing_b.sql)
DEBUG      [PD:0  MD:1 ]	.FileSegment                                      	Delim._look_ahead_match IN	    	[ls=128, seg='SELECT\n    tbl.name,...']
DEBUG      [PD:0  MD:1 ]	.FileSegment                                      	Delim._look_ahead_match SI	    	[mq=[(<sqlfluff.core.parser.parsers.StringParser object at 0x7c08b844f0d0>, 69, '('), (<sqlfluff.core.parser.parsers.StringParser object at 0x7c08b844f070>, 79, ')'), (<sqlfluff.core.parser.parsers.StringParser object at 0x7c08b844f0d0>, 87, '('), (<sqlfluff.core.parser.parsers.StringParser object at 0x7c08b844f070>, 97, ')'), (<sqlfluff.core.parser.parsers.StringParser object at 0x7c08b844f0d0>, 107, '('), (<sqlfluff.core.parser.parsers.StringParser object at 0x7c08b844f070>, 117, ')')], sb=['SELECT', '', '', 'TBL', '.', 'NAME', ',', '', '', 'B', '.', 'VALUE', ',', '', '', '/*', '', '', 'THIS', '', '', '*/', '', '', 'D', '.', 'SOMETHING', ',', '', '--', '', '', 'TBL', '.', 'FOO', ',', '', '', 'C', '.', 'VAL', '', '+', '', 'B', '.', 'VAL', '', '/', '', '-', '2', '', 'AS', '', 'A_CALCULATION', '', 'FROM', '', 'TBL', '', 'INNER', '', 'JOIN', '', 'B', '', 'ON', '', '(', 'TBL', '.', 'COMMON_ID', '', '=', '', 'B', '.', 'COMMON_ID', ')', '', 'JOIN', '', 'C', '', 'ON', '', '(', 'TBL', '.', 'ID', '', '=', '', 'C', '.', 'ID', ')', '', 'LEFT', '', 'JOIN', '', 'D', '', 'ON', '', '(', 'TBL', '.', 'ID', '', '=', '', 'D', '.', 'OTHER_ID', ')', '', 'ORDER', '', 'BY', '', 'TBL', '.', 'NAME', '', 'ASC']]
DEBUG      [PD:0  MD:1 ]	.FileSegment                                      	Delim._look_ahead_match SC	    	[bsm=(69, 1, <sqlfluff.core.parser.parsers.StringParser object at 0x7c08b844f0d0>)]
DEBUG      [PD:0  MD:1 ]	.FileSegment                                      	Delim._look_ahead_match IN	    	[ls=58, seg='tbl.common_id = b.co...']
DEBUG      [PD:0  MD:1 ]	.FileSegment                                      	Delim._look_ahead_match SI	    	[mq=[(<sqlfluff.core.parser.parsers.StringParser object at 0x7c08b844f070>, 9, ')'), (<sqlfluff.core.parser.parsers.StringParser object at 0x7c08b844f0d0>, 17, '('), (<sqlfluff.core.parser.parsers.StringParser object at 0x7c08b844f070>, 27, ')'), (<sqlfluff.core.parser.parsers.StringParser object at 0x7c08b844f0d0>, 37, '('), (<sqlfluff.core.parser.parsers.StringParser object at 0x7c08b844f070>, 47, ')')], sb=['TBL', '.', 'COMMON_ID', '', '=', '', 'B', '.', 'COMMON_ID', ')', '', 'JOIN', '', 'C', '', 'ON', '', '(', 'TBL', '.', 'ID', '', '=', '', 'C', '.', 'ID', ')', '', 'LEFT', '', 'JOIN', '', 'D', '', 'ON', '', '(', 'TBL', '.', 'ID', '', '=', '', 'D', '.', 'OTHER_ID', ')', '', 'ORDER', '', 'BY', '', 'TBL', '.', 'NAME', '', 'ASC']]
DEBUG      [PD:0  MD:1 ]	.FileSegment                                      	Delim._look_ahead_match SC	    	[bsm=(9, 1, <sqlfluff.core.parser.parsers.StringParser object at 0x7c08b844f070>)]
DEBUG      [PD:0  MD:1 ]	.FileSegment                                      	Delim._look_ahead_match IN	    	[ls=48, seg='\nJOIN c ON (tbl.id =...']
DEBUG      [PD:0  MD:1 ]	.FileSegment                                      	Delim._look_ahead_match SI	    	[mq=[(<sqlfluff.core.parser.parsers.StringParser object at 0x7c08b844f0d0>, 7, '('), (<sqlfluff.core.parser.parsers.StringParser object at 0x7c08b844f070>, 17, ')'), (<sqlfluff.core.parser.parsers.StringParser object at 0x7c08b844f0d0>, 27, '('), (<sqlfluff.core.parser.parsers.StringParser object at 0x7c08b844f070>, 37, ')')], sb=['', 'JOIN', '', 'C', '', 'ON', '', '(', 'TBL', '.', 'ID', '', '=', '', 'C', '.', 'ID', ')', '', 'LEFT', '', 'JOIN', '', 'D', '', 'ON', '', '(', 'TBL', '.', 'ID', '', '=', '', 'D', '.', 'OTHER_ID', ')', '', 'ORDER', '', 'BY', '', 'TBL', '.', 'NAME', '', 'ASC']]
DEBUG      [PD:0  MD:1 ]	.FileSegment                                      	Delim._look_ahead_match SC	    	[bsm=(7, 1, <sqlfluff.core.parser.parsers.StringParser object at 0x7c08b844f0d0>)]
DEBUG      [PD:0  MD:1 ]	.FileSegment                                      	Delim._look_ahead_match IN	    	[ls=40, seg='tbl.id = c.id)\nLEFT ...']
DEBUG      [PD:0  MD:1 ]	.FileSegment                                      	Delim._look_ahead_match SI	    	[mq=[(<sqlfluff.core.parser.parsers.StringParser object at 0x7c08b844f070>, 9, ')'), (<sqlfluff.core.parser.parsers.StringParser object at 0x7c08b844f0d0>, 19, '('), (<sqlfluff.core.parser.parsers.StringParser object at 0x7c08b844f070>, 29, ')')], sb=['TBL', '.', 'ID', '', '=', '', 'C', '.', 'ID', ')', '', 'LEFT', '', 'JOIN', '', 'D', '', 'ON', '', '(', 'TBL', '.', 'ID', '', '=', '', 'D', '.', 'OTHER_ID', ')', '', 'ORDER', '', 'BY', '', 'TBL', '.', 'NAME', '', 'ASC']]
DEBUG      [PD:0  MD:1 ]	.FileSegment                                      	Delim._look_ahead_match SC	    	[bsm=(9, 1, <sqlfluff.core.parser.parsers.StringParser object at 0x7c08b844f070>)]
DEBUG      [PD:0  MD:1 ]	.FileSegment                                      	Delim._look_ahead_match IN	    	[ls=30, seg='\nLEFT JOIN d ON (tbl...']
DEBUG      [PD:0  MD:1 ]	.FileSegment                                      	Delim._look_ahead_match SI	    	[mq=[(<sqlfluff.core.parser.parsers.StringParser object at 0x7c08b844f0d0>, 9, '('), (<sqlfluff.core.parser.parsers.StringParser object at 0x7c08b844f070>, 19, ')')], sb=['', 'LEFT', '', 'JOIN', '', 'D', '', 'ON', '', '(', 'TBL', '.', 'ID', '', '=', '', 'D', '.', 'OTHER_ID', ')', '', 'ORDER', '', 'BY', '', 'TBL', '.', 'NAME', '', 'ASC']]
DEBUG      [PD:0  MD:1 ]	.FileSegment                                      	Delim._look_ahead_match SC	    	[bsm=(9, 1, <sqlfluff.core.parser.parsers.StringParser object at 0x7c08b844f0d0>)]
DEBUG      [PD:0  MD:1 ]	.FileSegment                                      	Delim._look_ahead_match IN	    	[ls=20, seg='tbl.id = d.other_id)...']
DEBUG      [PD:0  MD:1 ]	.FileSegment                                      	Delim._look_ahead_match SI	    	[mq=[(<sqlfluff.core.parser.parsers.StringParser object at 0x7c08b844f070>, 9, ')')], sb=['TBL', '.', 'ID', '', '=', '', 'D', '.', 'OTHER_ID', ')', '', 'ORDER', '', 'BY', '', 'TBL', '.', 'NAME', '', 'ASC']]
DEBUG      [PD:0  MD:1 ]	.FileSegment                                      	Delim._look_ahead_match SC	    	[bsm=(9, 1, <sqlfluff.core.parser.parsers.StringParser object at 0x7c08b844f070>)]
DEBUG      [PD:0  MD:1 ]	.FileSegment                                      	Delim._look_ahead_match IN	    	[ls=10, seg='\nORDER BY tbl.name A...']
DEBUG      [PD:0  MD:1 ]	.FileSegment                                      	Delim._look_ahead_match SI	    	[mq=[], sb=['', 'ORDER', '', 'BY', '', 'TBL', '.', 'NAME', '', 'ASC']]
DEBUG      [PD:0  MD:1 ]	.FileSegment                                      	Delim._look_ahead_match SC	    	[bsm=None]
DEBUG      [PD:0  MD:3 ]	...StatementSegment                               	Greed._look_ahead_match IN	    	[ls=98, seg='SELECT\n    tbl.name,...']
DEBUG      [PD:0  MD:3 ]	...StatementSegment                               	Greed._look_ahead_match SI	    	[mq=[], sb=['SELECT', '', '', 'TBL', '.', 'NAME', ',', '', '', 'B', '.', 'VALUE', ',', '', '', '/*', '', '', 'THIS', '', '', '*/', '', '', 'D', '.', 'SOMETHING', ',', '', '--', '', '', 'TBL', '.', 'FOO', ',', '', '', 'C', '.', 'VAL', '', '+', '', 'B', '.', 'VAL', '', '/', '', '-', '2', '', 'AS', '', 'A_CALCULATION', '', 'FROM', '', 'TBL', '', 'INNER', '', 'JOIN', '', 'B', '', 'ON', '', '(TBL.COMMON_ID', '', 'JOIN', '', 'C', '', 'ON', '', '(TBL.ID', '', 'LEFT', '', 'JOIN', '', 'D', '', 'ON', '', '(TBL.ID', '', 'ORDER', '', 'BY', '', 'TBL', '.', 'NAME', '', 'ASC']]
DEBUG      [PD:0  MD:3 ]	...StatementSegment                               	Greed._look_ahead_match SC	    	[bsm=None]
INFO       [PD:0  MD:2 ]	..StatementSegment                                	Greed.match OUT     	++  	[match=<MatchResult 98/98: 'SELECT\n    tbl....BY tbl.name ASC'>, seg="'SELECT\\n    tbl.name,...'"]
DEBUG      [PD:0  MD:1 ]	.StatementSegment                                 	State.match OUT     	++  	[match=<MatchResult 1/1: 'SELECT\n    tbl....BY tbl.name ASC'>, seg="'SELECT\\n    tbl.name,...'"]
DEBUG      [PD:0  MD:1 ]	.FileSegment                                      	Ref.match OUT       	++  	[match=<MatchResult 1/1: 'SELECT\n    tbl....BY tbl.name ASC'>, seg="'SELECT\\n    tbl.name,...'"]
INFO       [PD:0  MD:0 ]	FileSegment                                       	Delim.match OUT     	++  	[match=<MatchResult 1/1: 'SELECT\n    tbl....BY tbl.name ASC'>, seg="'SELECT\\n    tbl.name,...'"]
DEBUG      FileSegment.parse: Done Parse. Plotting Recursion. Recurse=True
DEBUG      ###
#
# Beginning Parse Depth 1: FileSegment
#
###
Initial Structure:
[L:  1, P:  1]      |file:
[L:  1, P:  1]      |    statement:
[L:  1, P:  1]      |        raw:                                                  'SELECT'
[L:  1, P:  7]      |        newline:                                              '\n'
[L:  2, P:  1]      |        whitespace:                                           '    '
[L:  2, P:  5]      |        raw:                                                  'tbl'
[L:  2, P:  8]      |        raw:                                                  '.'
[L:  2, P:  9]      |        raw:                                                  'name'
[L:  2, P: 13]      |        comma:                                                ','
[L:  2, P: 14]      |        newline:                                              '\n'
[L:  3, P:  1]      |        whitespace:                                           '    '
[L:  3, P:  5]      |        raw:                                                  'b'
[L:  3, P:  6]      |        raw:                                                  '.'
[L:  3, P:  7]      |        raw:                                                  'value'
[L:  3, P: 12]      |        comma:                                                ','
[L:  3, P: 13]      |        newline:                                              '\n'
[L:  4, P:  1]      |        whitespace:                                           '    '
[L:  4, P:  5]      |        comment:                                              '/*'
[L:  4, P:  7]      |        newline:                                              '\n'
[L:  5, P:  1]      |        whitespace:                                           '    '
[L:  5, P:  5]      |        comment:                                              'This is a block comment'
[L:  5, P: 28]      |        newline:                                              '\n'
[L:  6, P:  1]      |        whitespace:                                           '    '
[L:  6, P:  5]      |        comment:                                              '*/'
[L:  6, P:  7]      |        newline:                                              '\n'
[L:  7, P:  1]      |        whitespace:                                           '    '
[L:  7, P:  5]      |        raw:                                                  'd'
[L:  7, P:  6]      |        raw:                                                  '.'
[L:  7, P:  7]      |        raw:                                                  'something'
[L:  7, P: 16]      |        comma:                                                ','
[L:  7, P: 17]      |        whitespace:                                           '    '
[L:  7, P: 21]      |        comment:                                              '-- Which a comment after it'
[L:  7, P: 48]      |        newline:                                              '\n'
[L:  8, P:  1]      |        whitespace:                                           '    '
[L:  8, P:  5]      |        raw:                                                  'tbl'
[L:  8, P:  8]      |        raw:                                                  '.'
[L:  8, P:  9]      |        raw:                                                  'foo'
[L:  8, P: 12]      |        comma:                                                ','
[L:  8, P: 13]      |        newline:                                              '\n'
[L:  9, P:  1]      |        whitespace:                                           '    '
[L:  9, P:  5]      |        raw:                                                  'c'
[L:  9, P:  6]      |        raw:                                                  '.'
[L:  9, P:  7]      |        raw:                                                  'val'
[L:  9, P: 10]      |        whitespace:                                           ' '
[L:  9, P: 11]      |        raw:                                                  '+'
[L:  9, P: 12]      |        whitespace:                                           ' '
[L:  9, P: 13]      |        raw:                                                  'b'
[L:  9, P: 14]      |        raw:                                                  '.'
[L:  9, P: 15]      |        raw:                                                  'val'
[L:  9, P: 18]      |        whitespace:                                           ' '
[L:  9, P: 19]      |        raw:                                                  '/'
[L:  9, P: 20]      |        whitespace:                                           ' '
[L:  9, P: 21]      |        raw:                                                  '-'
[L:  9, P: 22]      |        raw:                                                  '2'
[L:  9, P: 23]      |        whitespace:                                           ' '
[L:  9, P: 24]      |        raw:                                                  'AS'
[L:  9, P: 26]      |        whitespace:                                           ' '
[L:  9, P: 27]      |        raw:                                                  'a_calculation'
[L:  9, P: 40]      |        newline:                                              '\n'
[L: 10, P:  1]      |        raw:                                                  'FROM'
[L: 10, P:  5]      |        whitespace:                                           ' '
[L: 10, P:  6]      |        raw:                                                  'tbl'
[L: 10, P:  9]      |        newline:                                              '\n'
[L: 11, P:  1]      |        raw:                                                  'INNER'
[L: 11, P:  6]      |        whitespace:                                           ' '
[L: 11, P:  7]      |        raw:                                                  'JOIN'
[L: 11, P: 11]      |        whitespace:                                           ' '
[L: 11, P: 12]      |        raw:                                                  'b'
[L: 11, P: 13]      |        whitespace:                                           ' '
[L: 11, P: 14]      |        raw:                                                  'ON'
[L: 11, P: 16]      |        whitespace:                                           ' '
[L: 11, P: 17]      |        bracketed:
[L: 11, P: 17]      |            start_bracket:                                    '('
[L: 11, P: 18]      |            raw:                                              'tbl'
[L: 11, P: 21]      |            raw:                                              '.'
[L: 11, P: 22]      |            raw:                                              'common_id'
[L: 11, P: 31]      |            whitespace:                                       ' '
[L: 11, P: 32]      |            raw:                                              '='
[L: 11, P: 33]      |            whitespace:                                       ' '
[L: 11, P: 34]      |            raw:                                              'b'
[L: 11, P: 35]      |            raw:                                              '.'
[L: 11, P: 36]      |            raw:                                              'common_id'
[L: 11, P: 45]      |            end_bracket:                                      ')'
[L: 11, P: 46]      |        newline:                                              '\n'
[L: 12, P:  1]      |        raw:                                                  'JOIN'
[L: 12, P:  5]      |        whitespace:                                           ' '
[L: 12, P:  6]      |        raw:                                                  'c'
[L: 12, P:  7]      |        whitespace:                                           ' '
[L: 12, P:  8]      |        raw:                                                  'ON'
[L: 12, P: 10]      |        whitespace:                                           ' '
[L: 12, P: 11]      |        bracketed:
[L: 12, P: 11]      |            start_bracket:                                    '('
[L: 12, P: 12]      |            raw:                                              'tbl'
[L: 12, P: 15]      |            raw:                                              '.'
[L: 12, P: 16]      |            raw:                                              'id'
[L: 12, P: 18]      |            whitespace:                                       ' '
[L: 12, P: 19]      |            raw:                                              '='
[L: 12, P: 20]      |            whitespace:                                       ' '
[L: 12, P: 21]      |            raw:                                              'c'
[L: 12, P: 22]      |            raw:                                              '.'
[L: 12, P: 23]      |            raw:                                              'id'
[L: 12, P: 25]      |            end_bracket:                                      ')'
[L: 12, P: 26]      |        newline:                                              '\n'
[L: 13, P:  1]      |        raw:                                                  'LEFT'
[L: 13, P:  5]      |        whitespace:                                           ' '
[L: 13, P:  6]      |        raw:                                                  'JOIN'
[L: 13, P: 10]      |        whitespace:                                           ' '
[L: 13, P: 11]      |        raw:                                                  'd'
[L: 13, P: 12]      |        whitespace:                                           ' '
[L: 13, P: 13]      |        raw:                                                  'ON'
[L: 13, P: 15]      |        whitespace:                                           ' '
[L: 13, P: 16]      |        bracketed:
[L: 13, P: 16]      |            start_bracket:                                    '('
[L: 13, P: 17]      |            raw:                                              'tbl'
[L: 13, P: 20]      |            raw:                                              '.'
[L: 13, P: 21]      |            raw:                                              'id'
[L: 13, P: 23]      |            whitespace:                                       ' '
[L: 13, P: 24]      |            raw:                                              '='
[L: 13, P: 25]      |            whitespace:                                       ' '
[L: 13, P: 26]      |            raw:                                              'd'
[L: 13, P: 27]      |            raw:                                              '.'
[L: 13, P: 28]      |            raw:                                              'other_id'
[L: 13, P: 36]      |            end_bracket:                                      ')'
[L: 13, P: 37]      |        newline:                                              '\n'
[L: 14, P:  1]      |        raw:                                                  'ORDER'
[L: 14, P:  6]      |        whitespace:                                           ' '
[L: 14, P:  7]      |        raw:                                                  'BY'
[L: 14, P:  9]      |        whitespace:                                           ' '
[L: 14, P: 10]      |        raw:                                                  'tbl'
[L: 14, P: 13]      |        raw:                                                  '.'
[L: 14, P: 14]      |        raw:                                                  'name'
[L: 14, P: 18]      |        whitespace:                                           ' '
[L: 14, P: 19]      |        raw:                                                  'ASC'
[L: 14, P: 22]      |    newline:                                                  '\n'

INFO       
###
#
# Parse Depth 1. Expanding: StatementSegment: 'SELECT\n    tbl.name,\n    b.value,\n    /*...'
#
###
INFO       [PD:1  MD:0 ]	StatementSegment                                  	OneOf.match PRN     	    	[ns=0, ps=28, ms=1, pruned=[<Ref: InsertStatementSegment>, <Ref: TransactionStatementSegment>, <Ref: DropStatementSegment>, <Ref: TruncateStatementSegment>, <Ref: AccessStatementSegment>, <Ref: CreateTableStatementSegment>, <Ref: CreateTypeStatementSegment>, <Ref: CreateRoleStatementSegment>, <Ref: AlterTableStatementSegment>, <Ref: CreateSchemaStatementSegment>, <Ref: SetSchemaStatementSegment>, <Ref: DropSchemaStatementSegment>, <Ref: CreateDatabaseStatementSegment>, <Ref: CreateExtensionStatementSegment>, <Ref: CreateIndexStatementSegment>, <Ref: DropIndexStatementSegment>, <Ref: CreateViewStatementSegment>, <Ref: DeleteStatementSegment>, <Ref: UpdateStatementSegment>, <Ref: CreateFunctionStatementSegment>, <Ref: CreateModelStatementSegment>, <Ref: DropModelStatementSegment>, <Ref: DescribeStatementSegment>, <Ref: UseStatementSegment>, <Ref: ExplainStatementSegment>, <Ref: CreateSequenceStatementSegment>, <Ref: AlterSequenceStatementSegment>, <Ref: DropSequenceStatementSegment>], opts=[<Ref: SelectableGrammar>]]
INFO       [PD:1  MD:1 ]	.SelectableGrammar                                	OneOf.match PRN     	    	[ns=0, ps=1, ms=1, pruned=[<Ref: WithCompoundStatementSegment>], opts=[<Ref: NonWithSelectableGrammar>]]
INFO       [PD:1  MD:2 ]	..NonWithSelectableGrammar                        	OneOf.match PRN     	    	[ns=0, ps=0, ms=3, pruned=[], opts=[<Ref: SetExpressionSegment>, <OptionallyBracketed: [<Bracketed: [<Ref: SelectStatementSegmen..., <Ref: SelectStatementSegment>]>, <Ref: NonSetSelectableGrammar>]]
INFO       [PD:1  MD:5 ]	.....NonSetSelectableGrammar                      	OneOf.match PRN     	    	[ns=0, ps=2, ms=1, pruned=[<Ref: ValuesClauseSegment>, <Bracketed: [<Ref: SelectStatementSegment>]>], opts=[<Ref: UnorderedSelectStatementSegment>]]
DEBUG      [PD:1  MD:11]	...........SelectClauseSegment                    	Ref.match OUT       	+   	[match=<MatchResult 1/98: 'SELECT'>, seg="'SELECT\\n    tbl.name,...'"]
INFO       [PD:1  MD:15]	...............WildcardIdentifierSegment          	AnyNu.match PRN     	    	[ns=1, ps=0, ms=0, pruned=[], opts=[<Sequence: [<Ref: SingleIdentifierGrammar>, <Ref: DotSegment>]>]]
INFO       [PD:1  MD:17]	.................SingleIdentifierGrammar          	OneOf.match PRN     	    	[ns=2, ps=0, ms=0, pruned=[], opts=[<Ref: NakedIdentifierSegment>, <Ref: QuotedIdentifierSegment>]]
DEBUG      [PD:1  MD:18]	..................SingleIdentifierGrammar         	Ref.match OUT       	+   	[match=<MatchResult 1/95: 'tbl'>, seg="'tbl.name,\\n    b.valu...'"]
DEBUG      [PD:1  MD:18]	..................SingleIdentifierGrammar         	Ref.match OUT       	    	[match=<MatchResult 0/95: ''>, seg="'tbl.name,\\n    b.valu...'"]
INFO       [PD:1  MD:17]	.................SingleIdentifierGrammar          	OneOf.match OUT     	+   	[match=<MatchResult 1/95: 'tbl'>, seg="'tbl.name,\\n    b.valu...'"]
DEBUG      [PD:1  MD:17]	.................WildcardIdentifierSegment        	Ref.match OUT       	+   	[match=<MatchResult 1/95: 'tbl'>, seg="'tbl.name,\\n    b.valu...'"]
DEBUG      [PD:1  MD:17]	.................WildcardIdentifierSegment        	Ref.match OUT       	+   	[match=<MatchResult 1/94: '.'>, seg="'.name,\\n    b.value,\\n...'"]
INFO       [PD:1  MD:16]	................WildcardIdentifierSegment         	Seque.match OUT     	+   	[match=<MatchResult 2/95: 'tbl.'>, seg="'tbl.name,\\n    b.valu...'"]
INFO       [PD:1  MD:15]	...............WildcardIdentifierSegment          	AnyNu.match PRN     	    	[ns=1, ps=0, ms=0, pruned=[], opts=[<Sequence: [<Ref: SingleIdentifierGrammar>, <Ref: DotSegment>]>]]
INFO       [PD:1  MD:17]	.................SingleIdentifierGrammar          	OneOf.match PRN     	    	[ns=2, ps=0, ms=0, pruned=[], opts=[<Ref: NakedIdentifierSegment>, <Ref: QuotedIdentifierSegment>]]
DEBUG      [PD:1  MD:18]	..................SingleIdentifierGrammar         	Ref.match OUT       	+   	[match=<MatchResult 1/93: 'name'>, seg="'name,\\n    b.value,\\n ...'"]
DEBUG      [PD:1  MD:18]	..................SingleIdentifierGrammar         	Ref.match OUT       	    	[match=<MatchResult 0/93: ''>, seg="'name,\\n    b.value,\\n ...'"]
INFO       [PD:1  MD:17]	.................SingleIdentifierGrammar          	OneOf.match OUT     	+   	[match=<MatchResult 1/93: 'name'>, seg="'name,\\n    b.value,\\n ...'"]
DEBUG      [PD:1  MD:17]	.................WildcardIdentifierSegment        	Ref.match OUT       	+   	[match=<MatchResult 1/93: 'name'>, seg="'name,\\n    b.value,\\n ...'"]
DEBUG      [PD:1  MD:17]	.................WildcardIdentifierSegment        	Ref.match OUT       	    	[match=<MatchResult 0/92: ''>, seg="',\\n    b.value,\\n    /...'"]
INFO       [PD:1  MD:16]	................WildcardIdentifierSegment         	Seque.match OUT     	    	[match=<MatchResult 0/93: ''>, seg="'name,\\n    b.value,\\n ...'"]
INFO       [PD:1  MD:15]	...............WildcardIdentifierSegment          	AnyNu.match OUT     	+   	[match=<MatchResult 2/95: 'tbl.'>, seg="'tbl.name,\\n    b.valu...'"]
DEBUG      [PD:1  MD:15]	...............WildcardIdentifierSegment          	Ref.match OUT       	    	[match=<MatchResult 0/93: ''>, seg="'name,\\n    b.value,\\n ...'"]
INFO       [PD:1  MD:14]	..............WildcardIdentifierSegment           	Seque.match OUT     	    	[match=<MatchResult 0/95: ''>, seg="'tbl.name,\\n    b.valu...'"]
DEBUG      [PD:1  MD:13]	.............WildcardIdentifierSegment            	Wildc.match OUT     	    	[match=<MatchResult 0/95: ''>, seg="'tbl.name,\\n    b.valu...'"]
DEBUG      [PD:1  MD:13]	.............WildcardExpressionSegment            	Ref.match OUT       	    	[match=<MatchResult 0/95: ''>, seg="'tbl.name,\\n    b.valu...'"]
INFO       [PD:1  MD:12]	............WildcardExpressionSegment             	Seque.match OUT     	    	[match=<MatchResult 0/95: ''>, seg="'tbl.name,\\n    b.valu...'"]
DEBUG      [PD:1  MD:11]	...........WildcardExpressionSegment              	Wildc.match OUT     	    	[match=<MatchResult 0/95: ''>, seg="'tbl.name,\\n    b.valu...'"]
DEBUG      [PD:1  MD:11]	...........SelectClauseSegment                    	Ref.match OUT       	    	[match=<MatchResult 0/95: ''>, seg="'tbl.name,\\n    b.valu...'"]
INFO       [PD:1  MD:10]	..........SelectClauseSegment                     	Seque.match OUT     	+   	[match=<MatchResult 1/98: 'SELECT'>, seg="'SELECT\\n    tbl.name,...'"]
DEBUG      [PD:1  MD:10]	..........SelectClauseSegment                     	Start._look_ahead_match IN	    	[ls=97, seg='\n    tbl.name,\n    b...']
DEBUG      [PD:1  MD:10]	..........SelectClauseSegment                     	Start._look_ahead_match SI	    	[mq=[(<OneOf: [<Ref: FromKeywordSegment>, <Ref: WhereKeywordSegment>, <Ref: OrderKeywordSegment>, <Ref: LimitKeywor...]>, 56, 'FROM'), (<OneOf: [<Ref: FromKeywordSegment>, <Ref: WhereKeywordSegment>, <Ref: OrderKeywordSegment>, <Ref: LimitKeywor...]>, 88, 'ORDER')], sb=['', '', 'TBL', '.', 'NAME', ',', '', '', 'B', '.', 'VALUE', ',', '', '', '/*', '', '', 'THIS', '', '', '*/', '', '', 'D', '.', 'SOMETHING', ',', '', '--', '', '', 'TBL', '.', 'FOO', ',', '', '', 'C', '.', 'VAL', '', '+', '', 'B', '.', 'VAL', '', '/', '', '-', '2', '', 'AS', '', 'A_CALCULATION', '', 'FROM', '', 'TBL', '', 'INNER', '', 'JOIN', '', 'B', '', 'ON', '', '(TBL.COMMON_ID', '', 'JOIN', '', 'C', '', 'ON', '', '(TBL.ID', '', 'LEFT', '', 'JOIN', '', 'D', '', 'ON', '', '(TBL.ID', '', 'ORDER', '', 'BY', '', 'TBL', '.', 'NAME', '', 'ASC']]
INFO       [PD:1  MD:10]	..........SelectClauseSegment                     	OneOf.match PRN     	    	[ns=0, ps=5, ms=1, pruned=[<Ref: FromKeywordSegment>, <Ref: WhereKeywordSegment>, <Ref: LimitKeywordSegment>, <Ref: OverlapsKeywordSegment>, <Ref: SetOperatorSegment>], opts=[<Ref: OrderKeywordSegment>]]
DEBUG      [PD:1  MD:11]	...........SelectClauseSegment                    	Ref.match OUT       	+   	[match=<MatchResult 1/9: 'ORDER'>, seg="'ORDER BY tbl.name AS...'"]
INFO       [PD:1  MD:10]	..........SelectClauseSegment                     	OneOf.match OUT     	+   	[match=<MatchResult 1/9: 'ORDER'>, seg="'ORDER BY tbl.name AS...'"]
INFO       [PD:1  MD:10]	..........SelectClauseSegment                     	OneOf.match PRN     	    	[ns=0, ps=5, ms=1, pruned=[<Ref: WhereKeywordSegment>, <Ref: OrderKeywordSegment>, <Ref: LimitKeywordSegment>, <Ref: OverlapsKeywordSegment>, <Ref: SetOperatorSegment>], opts=[<Ref: FromKeywordSegment>]]
DEBUG      [PD:1  MD:11]	...........SelectClauseSegment                    	Ref.match OUT       	+   	[match=<MatchResult 1/41: 'FROM'>, seg="'FROM tbl\\nINNER JOIN ...'"]
INFO       [PD:1  MD:10]	..........SelectClauseSegment                     	OneOf.match OUT     	+   	[match=<MatchResult 1/41: 'FROM'>, seg="'FROM tbl\\nINNER JOIN ...'"]
DEBUG      [PD:1  MD:10]	..........SelectClauseSegment                     	Start._look_ahead_match SC	    	[bsm=(56, 1, <OneOf: [<Ref: FromKeywordSegment>, <Ref: WhereKeywordSegment>, <Ref: OrderKeywordSegment>, <Ref: LimitKeywor...]>)]
INFO       [PD:1  MD:9 ]	.........SelectClauseSegment                      	Start.match OUT     	+   	[match=<MatchResult 56/98: 'SELECT\n    tbl....S a_calculation'>, seg="'SELECT\\n    tbl.name,...'"]
DEBUG      [PD:1  MD:8 ]	........SelectClauseSegment                       	Selec.match OUT     	+   	[match=<MatchResult 1/43: 'SELECT\n    tbl....S a_calculation'>, seg="'SELECT\\n    tbl.name,...'"]
DEBUG      [PD:1  MD:8 ]	........UnorderedSelectStatementSegment           	Ref.match OUT       	+   	[match=<MatchResult 1/43: 'SELECT\n    tbl....S a_calculation'>, seg="'SELECT\\n    tbl.name,...'"]
DEBUG      [PD:1  MD:8 ]	........UnorderedSelectStatementSegment           	Start._look_ahead_match IN	    	[ls=42, seg='\nFROM tbl\nINNER JOIN...']
DEBUG      [PD:1  MD:8 ]	........UnorderedSelectStatementSegment           	Start._look_ahead_match SI	    	[mq=[(<OneOf: [<Ref: SetOperatorSegment>, <Ref: WithNoSchemaBindingClauseSegment>, <Ref: OrderByClauseSegment>, <Re...]>, 33, 'ORDER')], sb=['', 'FROM', '', 'TBL', '', 'INNER', '', 'JOIN', '', 'B', '', 'ON', '', '(TBL.COMMON_ID', '', 'JOIN', '', 'C', '', 'ON', '', '(TBL.ID', '', 'LEFT', '', 'JOIN', '', 'D', '', 'ON', '', '(TBL.ID', '', 'ORDER', '', 'BY', '', 'TBL', '.', 'NAME', '', 'ASC']]
INFO       [PD:1  MD:8 ]	........UnorderedSelectStatementSegment           	OneOf.match PRN     	    	[ns=0, ps=4, ms=1, pruned=[<Ref: SetOperatorSegment>, <Ref: WithNoSchemaBindingClauseSegment>, <Ref: LimitClauseSegment>, <Ref: NamedWindowSegment>], opts=[<Ref: OrderByClauseSegment>]]
DEBUG      [PD:1  MD:11]	...........OrderByClauseSegment                   	Ref.match OUT       	+   	[match=<MatchResult 1/9: 'ORDER'>, seg="'ORDER BY tbl.name AS...'"]
DEBUG      [PD:1  MD:11]	...........OrderByClauseSegment                   	Start._look_ahead_match IN	    	[ls=8, seg=' BY tbl.name ASC']
DEBUG      [PD:1  MD:11]	...........OrderByClauseSegment                   	Start._look_ahead_match SI	    	[mq=[], sb=['', 'BY', '', 'TBL', '.', 'NAME', '', 'ASC']]
DEBUG      [PD:1  MD:11]	...........OrderByClauseSegment                   	Start._look_ahead_match SC	    	[bsm=None]
INFO       [PD:1  MD:10]	..........OrderByClauseSegment                    	Start.match OUT     	++  	[match=<MatchResult 9/9: 'ORDER BY tbl.name ASC'>, seg="'ORDER BY tbl.name AS...'"]
DEBUG      [PD:1  MD:9 ]	.........OrderByClauseSegment                     	Order.match OUT     	++  	[match=<MatchResult 1/1: 'ORDER BY tbl.name ASC'>, seg="'ORDER BY tbl.name AS...'"]
DEBUG      [PD:1  MD:9 ]	.........UnorderedSelectStatementSegment          	Ref.match OUT       	++  	[match=<MatchResult 1/1: 'ORDER BY tbl.name ASC'>, seg="'ORDER BY tbl.name AS...'"]
INFO       [PD:1  MD:8 ]	........UnorderedSelectStatementSegment           	OneOf.match OUT     	++  	[match=<MatchResult 1/1: 'ORDER BY tbl.name ASC'>, seg="'ORDER BY tbl.name AS...'"]
DEBUG      [PD:1  MD:8 ]	........UnorderedSelectStatementSegment           	Start._look_ahead_match SC	    	[bsm=(33, 1, <OneOf: [<Ref: SetOperatorSegment>, <Ref: WithNoSchemaBindingClauseSegment>, <Ref: OrderByClauseSegment>, <Re...]>)]
INFO       [PD:1  MD:7 ]	.......UnorderedSelectStatementSegment            	Start.match OUT     	+   	[match=<MatchResult 33/35: 'SELECT\n    tbl....d = d.other_id)'>, seg="'SELECT\\n    tbl.name,...'"]
DEBUG      [PD:1  MD:6 ]	......UnorderedSelectStatementSegment             	Unord.match OUT     	+   	[match=<MatchResult 1/3: 'SELECT\n    tbl....d = d.other_id)'>, seg="'SELECT\\n    tbl.name,...'"]
DEBUG      [PD:1  MD:6 ]	......NonSetSelectableGrammar                     	Ref.match OUT       	+   	[match=<MatchResult 1/3: 'SELECT\n    tbl....d = d.other_id)'>, seg="'SELECT\\n    tbl.name,...'"]
INFO       [PD:1  MD:5 ]	.....NonSetSelectableGrammar                      	OneOf.match OUT     	+   	[match=<MatchResult 1/3: 'SELECT\n    tbl....d = d.other_id)'>, seg="'SELECT\\n    tbl.name,...'"]
DEBUG      [PD:1  MD:5 ]	.....SetExpressionSegment                         	Ref.match OUT       	+   	[match=<MatchResult 1/3: 'SELECT\n    tbl....d = d.other_id)'>, seg="'SELECT\\n    tbl.name,...'"]
INFO       [PD:1  MD:5 ]	.....SetExpressionSegment                         	AnyNu.match PRN     	    	[ns=0, ps=1, ms=0, pruned=[<Sequence: [<Ref: SetOperatorSegment>, <Ref: NonSetSelectableGrammar>]>], opts='ALL']
INFO       [PD:1  MD:5 ]	.....SetExpressionSegment                         	AnyNu.match OUT     	    	[match=<MatchResult 0/1: ''>, seg="'ORDER BY tbl.name AS...'"]
INFO       [PD:1  MD:4 ]	....SetExpressionSegment                          	Seque.match OUT     	    	[match=<MatchResult 0/98: ''>, seg="'SELECT\\n    tbl.name,...'"]
DEBUG      [PD:1  MD:3 ]	...SetExpressionSegment                           	SetEx.match OUT     	    	[match=<MatchResult 0/98: ''>, seg="'SELECT\\n    tbl.name,...'"]
DEBUG      [PD:1  MD:3 ]	...NonWithSelectableGrammar                       	Ref.match OUT       	    	[match=<MatchResult 0/98: ''>, seg="'SELECT\\n    tbl.name,...'"]
INFO       [PD:1  MD:3 ]	...NonWithSelectableGrammar                       	Optio.match PRN     	    	[ns=0, ps=1, ms=1, pruned=[<Bracketed: [<Ref: SelectStatementSegment>]>], opts=[<Ref: SelectStatementSegment>]]
DEBUG      [PD:1  MD:9 ]	.........SelectClauseSegment                      	Ref.match OUT       	+   	[match=<MatchResult 1/98: 'SELECT'>, seg="'SELECT\\n    tbl.name,...'"]
INFO       [PD:1  MD:13]	.............WildcardIdentifierSegment            	AnyNu.match PRN     	    	[ns=1, ps=0, ms=0, pruned=[], opts=[<Sequence: [<Ref: SingleIdentifierGrammar>, <Ref: DotSegment>]>]]
INFO       [PD:1  MD:15]	...............SingleIdentifierGrammar            	OneOf.match PRN     	    	[ns=2, ps=0, ms=0, pruned=[], opts=[<Ref: NakedIdentifierSegment>, <Ref: QuotedIdentifierSegment>]]
DEBUG      [PD:1  MD:16]	................SingleIdentifierGrammar           	Ref.match OUT       	+   	[match=<MatchResult 1/95: 'tbl'>, seg="'tbl.name,\\n    b.valu...'"]
DEBUG      [PD:1  MD:16]	................SingleIdentifierGrammar           	Ref.match OUT       	    	[match=<MatchResult 0/95: ''>, seg="'tbl.name,\\n    b.valu...'"]
INFO       [PD:1  MD:15]	...............SingleIdentifierGrammar            	OneOf.match OUT     	+   	[match=<MatchResult 1/95: 'tbl'>, seg="'tbl.name,\\n    b.valu...'"]
DEBUG      [PD:1  MD:15]	...............WildcardIdentifierSegment          	Ref.match OUT       	+   	[match=<MatchResult 1/95: 'tbl'>, seg="'tbl.name,\\n    b.valu...'"]
DEBUG      [PD:1  MD:15]	...............WildcardIdentifierSegment          	Ref.match OUT       	+   	[match=<MatchResult 1/94: '.'>, seg="'.name,\\n    b.value,\\n...'"]
INFO       [PD:1  MD:14]	..............WildcardIdentifierSegment           	Seque.match OUT     	+   	[match=<MatchResult 2/95: 'tbl.'>, seg="'tbl.name,\\n    b.valu...'"]
INFO       [PD:1  MD:13]	.............WildcardIdentifierSegment            	AnyNu.match PRN     	    	[ns=1, ps=0, ms=0, pruned=[], opts=[<Sequence: [<Ref: SingleIdentifierGrammar>, <Ref: DotSegment>]>]]
INFO       [PD:1  MD:15]	...............SingleIdentifierGrammar            	OneOf.match PRN     	    	[ns=2, ps=0, ms=0, pruned=[], opts=[<Ref: NakedIdentifierSegment>, <Ref: QuotedIdentifierSegment>]]
DEBUG      [PD:1  MD:16]	................SingleIdentifierGrammar           	Ref.match OUT       	+   	[match=<MatchResult 1/93: 'name'>, seg="'name,\\n    b.value,\\n ...'"]
DEBUG      [PD:1  MD:16]	................SingleIdentifierGrammar           	Ref.match OUT       	    	[match=<MatchResult 0/93: ''>, seg="'name,\\n    b.value,\\n ...'"]
INFO       [PD:1  MD:15]	...............SingleIdentifierGrammar            	OneOf.match OUT     	+   	[match=<MatchResult 1/93: 'name'>, seg="'name,\\n    b.value,\\n ...'"]
DEBUG      [PD:1  MD:15]	...............WildcardIdentifierSegment          	Ref.match OUT       	+   	[match=<MatchResult 1/93: 'name'>, seg="'name,\\n    b.value,\\n ...'"]
DEBUG      [PD:1  MD:15]	...............WildcardIdentifierSegment          	Ref.match OUT       	    	[match=<MatchResult 0/92: ''>, seg="',\\n    b.value,\\n    /...'"]
INFO       [PD:1  MD:14]	..............WildcardIdentifierSegment           	Seque.match OUT     	    	[match=<MatchResult 0/93: ''>, seg="'name,\\n    b.value,\\n ...'"]
INFO       [PD:1  MD:13]	.............WildcardIdentifierSegment            	AnyNu.match OUT     	+   	[match=<MatchResult 2/95: 'tbl.'>, seg="'tbl.name,\\n    b.valu...'"]
DEBUG      [PD:1  MD:13]	.............WildcardIdentifierSegment            	Ref.match OUT       	    	[match=<MatchResult 0/93: ''>, seg="'name,\\n    b.value,\\n ...'"]
INFO       [PD:1  MD:12]	............WildcardIdentifierSegment             	Seque.match OUT     	    	[match=<MatchResult 0/95: ''>, seg="'tbl.name,\\n    b.valu...'"]
DEBUG      [PD:1  MD:11]	...........WildcardIdentifierSegment              	Wildc.match OUT     	    	[match=<MatchResult 0/95: ''>, seg="'tbl.name,\\n    b.valu...'"]
DEBUG      [PD:1  MD:11]	...........WildcardExpressionSegment              	Ref.match OUT       	    	[match=<MatchResult 0/95: ''>, seg="'tbl.name,\\n    b.valu...'"]
INFO       [PD:1  MD:10]	..........WildcardExpressionSegment               	Seque.match OUT     	    	[match=<MatchResult 0/95: ''>, seg="'tbl.name,\\n    b.valu...'"]
DEBUG      [PD:1  MD:9 ]	.........WildcardExpressionSegment                	Wildc.match OUT     	    	[match=<MatchResult 0/95: ''>, seg="'tbl.name,\\n    b.valu...'"]
DEBUG      [PD:1  MD:9 ]	.........SelectClauseSegment                      	Ref.match OUT       	    	[match=<MatchResult 0/95: ''>, seg="'tbl.name,\\n    b.valu...'"]
INFO       [PD:1  MD:8 ]	........SelectClauseSegment                       	Seque.match OUT     	+   	[match=<MatchResult 1/98: 'SELECT'>, seg="'SELECT\\n    tbl.name,...'"]
DEBUG      [PD:1  MD:8 ]	........SelectClauseSegment                       	Start._look_ahead_match IN	    	[ls=97, seg='\n    tbl.name,\n    b...']
DEBUG      [PD:1  MD:8 ]	........SelectClauseSegment                       	Start._look_ahead_match SI	    	[mq=[(<OneOf: [<Ref: FromKeywordSegment>, <Ref: WhereKeywordSegment>, <Ref: OrderKeywordSegment>, <Ref: LimitKeywor...]>, 56, 'FROM'), (<OneOf: [<Ref: FromKeywordSegment>, <Ref: WhereKeywordSegment>, <Ref: OrderKeywordSegment>, <Ref: LimitKeywor...]>, 88, 'ORDER')], sb=['', '', 'TBL', '.', 'NAME', ',', '', '', 'B', '.', 'VALUE', ',', '', '', '/*', '', '', 'THIS', '', '', '*/', '', '', 'D', '.', 'SOMETHING', ',', '', '--', '', '', 'TBL', '.', 'FOO', ',', '', '', 'C', '.', 'VAL', '', '+', '', 'B', '.', 'VAL', '', '/', '', '-', '2', '', 'AS', '', 'A_CALCULATION', '', 'FROM', '', 'TBL', '', 'INNER', '', 'JOIN', '', 'B', '', 'ON', '', '(TBL.COMMON_ID', '', 'JOIN', '', 'C', '', 'ON', '', '(TBL.ID', '', 'LEFT', '', 'JOIN', '', 'D', '', 'ON', '', '(TBL.ID', '', 'ORDER', '', 'BY', '', 'TBL', '.', 'NAME', '', 'ASC']]
INFO       [PD:1  MD:8 ]	........SelectClauseSegment                       	OneOf.match PRN     	    	[ns=0, ps=5, ms=1, pruned=[<Ref: FromKeywordSegment>, <Ref: WhereKeywordSegment>, <Ref: LimitKeywordSegment>, <Ref: OverlapsKeywordSegment>, <Ref: SetOperatorSegment>], opts=[<Ref: OrderKeywordSegment>]]
DEBUG      [PD:1  MD:9 ]	.........SelectClauseSegment                      	Ref.match OUT       	+   	[match=<MatchResult 1/9: 'ORDER'>, seg="'ORDER BY tbl.name AS...'"]
INFO       [PD:1  MD:8 ]	........SelectClauseSegment                       	OneOf.match OUT     	+   	[match=<MatchResult 1/9: 'ORDER'>, seg="'ORDER BY tbl.name AS...'"]
INFO       [PD:1  MD:8 ]	........SelectClauseSegment                       	OneOf.match PRN     	    	[ns=0, ps=5, ms=1, pruned=[<Ref: WhereKeywordSegment>, <Ref: OrderKeywordSegment>, <Ref: LimitKeywordSegment>, <Ref: OverlapsKeywordSegment>, <Ref: SetOperatorSegment>], opts=[<Ref: FromKeywordSegment>]]
DEBUG      [PD:1  MD:9 ]	.........SelectClauseSegment                      	Ref.match OUT       	+   	[match=<MatchResult 1/41: 'FROM'>, seg="'FROM tbl\\nINNER JOIN ...'"]
INFO       [PD:1  MD:8 ]	........SelectClauseSegment                       	OneOf.match OUT     	+   	[match=<MatchResult 1/41: 'FROM'>, seg="'FROM tbl\\nINNER JOIN ...'"]
DEBUG      [PD:1  MD:8 ]	........SelectClauseSegment                       	Start._look_ahead_match SC	    	[bsm=(56, 1, <OneOf: [<Ref: FromKeywordSegment>, <Ref: WhereKeywordSegment>, <Ref: OrderKeywordSegment>, <Ref: LimitKeywor...]>)]
INFO       [PD:1  MD:7 ]	.......SelectClauseSegment                        	Start.match OUT     	+   	[match=<MatchResult 56/98: 'SELECT\n    tbl....S a_calculation'>, seg="'SELECT\\n    tbl.name,...'"]
DEBUG      [PD:1  MD:6 ]	......SelectClauseSegment                         	Selec.match OUT     	+   	[match=<MatchResult 1/43: 'SELECT\n    tbl....S a_calculation'>, seg="'SELECT\\n    tbl.name,...'"]
DEBUG      [PD:1  MD:6 ]	......SelectStatementSegment                      	Ref.match OUT       	+   	[match=<MatchResult 1/43: 'SELECT\n    tbl....S a_calculation'>, seg="'SELECT\\n    tbl.name,...'"]
DEBUG      [PD:1  MD:6 ]	......SelectStatementSegment                      	Start._look_ahead_match IN	    	[ls=42, seg='\nFROM tbl\nINNER JOIN...']
DEBUG      [PD:1  MD:6 ]	......SelectStatementSegment                      	Start._look_ahead_match SI	    	[mq=[], sb=['', 'FROM', '', 'TBL', '', 'INNER', '', 'JOIN', '', 'B', '', 'ON', '', '(TBL.COMMON_ID', '', 'JOIN', '', 'C', '', 'ON', '', '(TBL.ID', '', 'LEFT', '', 'JOIN', '', 'D', '', 'ON', '', '(TBL.ID', '', 'ORDER', '', 'BY', '', 'TBL', '.', 'NAME', '', 'ASC']]
DEBUG      [PD:1  MD:6 ]	......SelectStatementSegment                      	Start._look_ahead_match SC	    	[bsm=None]
INFO       [PD:1  MD:5 ]	.....SelectStatementSegment                       	Start.match OUT     	++  	[match=<MatchResult 43/43: 'SELECT\n    tbl....BY tbl.name ASC'>, seg="'SELECT\\n    tbl.name,...'"]
DEBUG      [PD:1  MD:4 ]	....SelectStatementSegment                        	Selec.match OUT     	++  	[match=<MatchResult 1/1: 'SELECT\n    tbl....BY tbl.name ASC'>, seg="'SELECT\\n    tbl.name,...'"]
DEBUG      [PD:1  MD:4 ]	....NonWithSelectableGrammar                      	Ref.match OUT       	++  	[match=<MatchResult 1/1: 'SELECT\n    tbl....BY tbl.name ASC'>, seg="'SELECT\\n    tbl.name,...'"]
INFO       [PD:1  MD:3 ]	...NonWithSelectableGrammar                       	Optio.match OUT     	++  	[match=<MatchResult 1/1: 'SELECT\n    tbl....BY tbl.name ASC'>, seg="'SELECT\\n    tbl.name,...'"]
INFO       [PD:1  MD:2 ]	..NonWithSelectableGrammar                        	OneOf.match OUT     	++  	[match=<MatchResult 1/1: 'SELECT\n    tbl....BY tbl.name ASC'>, seg="'SELECT\\n    tbl.name,...'"]
DEBUG      [PD:1  MD:2 ]	..SelectableGrammar                               	Ref.match OUT       	++  	[match=<MatchResult 1/1: 'SELECT\n    tbl....BY tbl.name ASC'>, seg="'SELECT\\n    tbl.name,...'"]
INFO       [PD:1  MD:1 ]	.SelectableGrammar                                	OneOf.match OUT     	++  	[match=<MatchResult 1/1: 'SELECT\n    tbl....BY tbl.name ASC'>, seg="'SELECT\\n    tbl.name,...'"]
DEBUG      [PD:1  MD:1 ]	.StatementSegment                                 	Ref.match OUT       	++  	[match=<MatchResult 1/1: 'SELECT\n    tbl....BY tbl.name ASC'>, seg="'SELECT\\n    tbl.name,...'"]
INFO       [PD:1  MD:0 ]	StatementSegment                                  	OneOf.match OUT     	++  	[match=<MatchResult 1/1: 'SELECT\n    tbl....BY tbl.name ASC'>, seg="'SELECT\\n    tbl.name,...'"]
DEBUG      StatementSegment.parse: Done Parse. Plotting Recursion. Recurse=True
DEBUG      ###
#
# Beginning Parse Depth 2: StatementSegment
#
###
Initial Structure:
[L:  1, P:  1]      |statement:
[L:  1, P:  1]      |    select_statement:
[L:  1, P:  1]      |        select_clause:
[L:  1, P:  1]      |            keyword:                                          'SELECT'
[L:  1, P:  7]      |            newline:                                          '\n'
[L:  2, P:  1]      |            whitespace:                                       '    '
[L:  2, P:  5]      |            raw:                                              'tbl'
[L:  2, P:  8]      |            raw:                                              '.'
[L:  2, P:  9]      |            raw:                                              'name'
[L:  2, P: 13]      |            comma:                                            ','
[L:  2, P: 14]      |            newline:                                          '\n'
[L:  3, P:  1]      |            whitespace:                                       '    '
[L:  3, P:  5]      |            raw:                                              'b'
[L:  3, P:  6]      |            raw:                                              '.'
[L:  3, P:  7]      |            raw:                                              'value'
[L:  3, P: 12]      |            comma:                                            ','
[L:  3, P: 13]      |            newline:                                          '\n'
[L:  4, P:  1]      |            whitespace:                                       '    '
[L:  4, P:  5]      |            comment:                                          '/*'
[L:  4, P:  7]      |            newline:                                          '\n'
[L:  5, P:  1]      |            whitespace:                                       '    '
[L:  5, P:  5]      |            comment:                                          'This is a block comment'
[L:  5, P: 28]      |            newline:                                          '\n'
[L:  6, P:  1]      |            whitespace:                                       '    '
[L:  6, P:  5]      |            comment:                                          '*/'
[L:  6, P:  7]      |            newline:                                          '\n'
[L:  7, P:  1]      |            whitespace:                                       '    '
[L:  7, P:  5]      |            raw:                                              'd'
[L:  7, P:  6]      |            raw:                                              '.'
[L:  7, P:  7]      |            raw:                                              'something'
[L:  7, P: 16]      |            comma:                                            ','
[L:  7, P: 17]      |            whitespace:                                       '    '
[L:  7, P: 21]      |            comment:                                          '-- Which a comment after it'
[L:  7, P: 48]      |            newline:                                          '\n'
[L:  8, P:  1]      |            whitespace:                                       '    '
[L:  8, P:  5]      |            raw:                                              'tbl'
[L:  8, P:  8]      |            raw:                                              '.'
[L:  8, P:  9]      |            raw:                                              'foo'
[L:  8, P: 12]      |            comma:                                            ','
[L:  8, P: 13]      |            newline:                                          '\n'
[L:  9, P:  1]      |            whitespace:                                       '    '
[L:  9, P:  5]      |            raw:                                              'c'
[L:  9, P:  6]      |            raw:                                              '.'
[L:  9, P:  7]      |            raw:                                              'val'
[L:  9, P: 10]      |            whitespace:                                       ' '
[L:  9, P: 11]      |            raw:                                              '+'
[L:  9, P: 12]      |            whitespace:                                       ' '
[L:  9, P: 13]      |            raw:                                              'b'
[L:  9, P: 14]      |            raw:                                              '.'
[L:  9, P: 15]      |            raw:                                              'val'
[L:  9, P: 18]      |            whitespace:                                       ' '
[L:  9, P: 19]      |            raw:                                              '/'
[L:  9, P: 20]      |            whitespace:                                       ' '
[L:  9, P: 21]      |            raw:                                              '-'
[L:  9, P: 22]      |            raw:                                              '2'
[L:  9, P: 23]      |            whitespace:                                       ' '
[L:  9, P: 24]      |            raw:                                              'AS'
[L:  9, P: 26]      |            whitespace:                                       ' '
[L:  9, P: 27]      |            raw:                                              'a_calculation'
[L:  9, P: 40]      |        newline:                                              '\n'
[L: 10, P:  1]      |        keyword:                                              'FROM'
[L: 10, P:  5]      |        whitespace:                                           ' '
[L: 10, P:  6]      |        raw:                                                  'tbl'
[L: 10, P:  9]      |        newline:                                              '\n'
[L: 11, P:  1]      |        raw:                                                  'INNER'
[L: 11, P:  6]      |        whitespace:                                           ' '
[L: 11, P:  7]      |        raw:                                                  'JOIN'
[L: 11, P: 11]      |        whitespace:                                           ' '
[L: 11, P: 12]      |        raw:                                                  'b'
[L: 11, P: 13]      |        whitespace:                                           ' '
[L: 11, P: 14]      |        raw:                                                  'ON'
[L: 11, P: 16]      |        whitespace:                                           ' '
[L: 11, P: 17]      |        bracketed:
[L: 11, P: 17]      |            start_bracket:                                    '('
[L: 11, P: 18]      |            raw:                                              'tbl'
[L: 11, P: 21]      |            raw:                                              '.'
[L: 11, P: 22]      |            raw:                                              'common_id'
[L: 11, P: 31]      |            whitespace:                                       ' '
[L: 11, P: 32]      |            raw:                                              '='
[L: 11, P: 33]      |            whitespace:                                       ' '
[L: 11, P: 34]      |            raw:                                              'b'
[L: 11, P: 35]      |            raw:                                              '.'
[L: 11, P: 36]      |            raw:                                              'common_id'
[L: 11, P: 45]      |            end_bracket:                                      ')'
[L: 11, P: 46]      |        newline:                                              '\n'
[L: 12, P:  1]      |        raw:                                                  'JOIN'
[L: 12, P:  5]      |        whitespace:                                           ' '
[L: 12, P:  6]      |        raw:                                                  'c'
[L: 12, P:  7]      |        whitespace:                                           ' '
[L: 12, P:  8]      |        raw:                                                  'ON'
[L: 12, P: 10]      |        whitespace:                                           ' '
[L: 12, P: 11]      |        bracketed:
[L: 12, P: 11]      |            start_bracket:                                    '('
[L: 12, P: 12]      |            raw:                                              'tbl'
[L: 12, P: 15]      |            raw:                                              '.'
[L: 12, P: 16]      |            raw:                                              'id'
[L: 12, P: 18]      |            whitespace:                                       ' '
[L: 12, P: 19]      |            raw:                                              '='
[L: 12, P: 20]      |            whitespace:                                       ' '
[L: 12, P: 21]      |            raw:                                              'c'
[L: 12, P: 22]      |            raw:                                              '.'
[L: 12, P: 23]      |            raw:                                              'id'
[L: 12, P: 25]      |            end_bracket:                                      ')'
[L: 12, P: 26]      |        newline:                                              '\n'
[L: 13, P:  1]      |        raw:                                                  'LEFT'
[L: 13, P:  5]      |        whitespace:                                           ' '
[L: 13, P:  6]      |        raw:                                                  'JOIN'
[L: 13, P: 10]      |        whitespace:                                           ' '
[L: 13, P: 11]      |        raw:                                                  'd'
[L: 13, P: 12]      |        whitespace:                                           ' '
[L: 13, P: 13]      |        raw:                                                  'ON'
[L: 13, P: 15]      |        whitespace:                                           ' '
[L: 13, P: 16]      |        bracketed:
[L: 13, P: 16]      |            start_bracket:                                    '('
[L: 13, P: 17]      |            raw:                                              'tbl'
[L: 13, P: 20]      |            raw:                                              '.'
[L: 13, P: 21]      |            raw:                                              'id'
[L: 13, P: 23]      |            whitespace:                                       ' '
[L: 13, P: 24]      |            raw:                                              '='
[L: 13, P: 25]      |            whitespace:                                       ' '
[L: 13, P: 26]      |            raw:                                              'd'
[L: 13, P: 27]      |            raw:                                              '.'
[L: 13, P: 28]      |            raw:                                              'other_id'
[L: 13, P: 36]      |            end_bracket:                                      ')'
[L: 13, P: 37]      |        newline:                                              '\n'
[L: 14, P:  1]      |        raw:                                                  'ORDER'
[L: 14, P:  6]      |        whitespace:                                           ' '
[L: 14, P:  7]      |        raw:                                                  'BY'
[L: 14, P:  9]      |        whitespace:                                           ' '
[L: 14, P: 10]      |        raw:                                                  'tbl'
[L: 14, P: 13]      |        raw:                                                  '.'
[L: 14, P: 14]      |        raw:                                                  'name'
[L: 14, P: 18]      |        whitespace:                                           ' '
[L: 14, P: 19]      |        raw:                                                  'ASC'

INFO       
###
#
# Parse Depth 2. Expanding: SelectStatementSegment: 'SELECT\n    tbl.name,\n    b.value,\n    /*...'
#
###
INFO       [PD:2  MD:1 ]	.SelectClauseSegment                              	Selec._match SELF   	    
DEBUG      [PD:2  MD:1 ]	.SelectClauseSegment                              	Selec.match OUT     	+   	[match=<MatchResult 1/43: 'SELECT\n    tbl....S a_calculation'>, seg="'SELECT\\n    tbl.name,...'"]
DEBUG      [PD:2  MD:1 ]	.SelectStatementSegment                           	Ref.match OUT       	+   	[match=<MatchResult 1/43: 'SELECT\n    tbl....S a_calculation'>, seg="'SELECT\\n    tbl.name,...'"]
DEBUG      [PD:2  MD:3 ]	...FromClauseSegment                              	Ref.match OUT       	+   	[match=<MatchResult 1/41: 'FROM'>, seg="'FROM tbl\\nINNER JOIN ...'"]
DEBUG      [PD:2  MD:3 ]	...FromClauseSegment                              	Start._look_ahead_match IN	    	[ls=40, seg=' tbl\nINNER JOIN b ON...']
DEBUG      [PD:2  MD:3 ]	...FromClauseSegment                              	Start._look_ahead_match SI	    	[mq=[(<Ref: FromClauseTerminatorGrammar>, 31, 'ORDER')], sb=['', 'TBL', '', 'INNER', '', 'JOIN', '', 'B', '', 'ON', '', '(TBL.COMMON_ID', '', 'JOIN', '', 'C', '', 'ON', '', '(TBL.ID', '', 'LEFT', '', 'JOIN', '', 'D', '', 'ON', '', '(TBL.ID', '', 'ORDER', '', 'BY', '', 'TBL', '.', 'NAME', '', 'ASC']]
INFO       [PD:2  MD:3 ]	...FromClauseTerminatorGrammar                    	OneOf.match PRN     	    	[ns=0, ps=8, ms=1, pruned=[<Ref: WhereKeywordSegment>, <Ref: LimitKeywordSegment>, <Sequence: [<Ref: GroupKeywordSegment>, <Ref: ByKeywordSegment>]>, <Ref: HavingKeywordSegment>, <Ref: QualifyKeywordSegment>, <Ref: WindowKeywordSegment>, <Ref: SetOperatorSegment>, <Ref: WithNoSchemaBindingClauseSegment>], opts=[<Sequence: [<Ref: OrderKeywordSegment>, <Ref: ByKeywordSegment>]>]]
DEBUG      [PD:2  MD:5 ]	.....FromClauseTerminatorGrammar                  	Ref.match OUT       	+   	[match=<MatchResult 1/9: 'ORDER'>, seg="'ORDER BY tbl.name AS...'"]
DEBUG      [PD:2  MD:5 ]	.....FromClauseTerminatorGrammar                  	Ref.match OUT       	+   	[match=<MatchResult 1/7: 'BY'>, seg="'BY tbl.name ASC'"]
INFO       [PD:2  MD:4 ]	....FromClauseTerminatorGrammar                   	Seque.match OUT     	+   	[match=<MatchResult 3/9: 'ORDER BY'>, seg="'ORDER BY tbl.name AS...'"]
INFO       [PD:2  MD:3 ]	...FromClauseTerminatorGrammar                    	OneOf.match OUT     	+   	[match=<MatchResult 3/9: 'ORDER BY'>, seg="'ORDER BY tbl.name AS...'"]
DEBUG      [PD:2  MD:3 ]	...FromClauseSegment                              	Ref.match OUT       	+   	[match=<MatchResult 3/9: 'ORDER BY'>, seg="'ORDER BY tbl.name AS...'"]
DEBUG      [PD:2  MD:3 ]	...FromClauseSegment                              	Start._look_ahead_match SC	    	[bsm=(31, 3, <Ref: FromClauseTerminatorGrammar>)]
INFO       [PD:2  MD:2 ]	..FromClauseSegment                               	Start.match OUT     	+   	[match=<MatchResult 31/41: 'FROM tbl\nINNER ...d = d.other_id)'>, seg="'FROM tbl\\nINNER JOIN ...'"]
DEBUG      [PD:2  MD:1 ]	.FromClauseSegment                                	FromC.match OUT     	+   	[match=<MatchResult 1/11: 'FROM tbl\nINNER ...d = d.other_id)'>, seg="'FROM tbl\\nINNER JOIN ...'"]
DEBUG      [PD:2  MD:1 ]	.SelectStatementSegment                           	Ref.match OUT       	+   	[match=<MatchResult 1/11: 'FROM tbl\nINNER ...d = d.other_id)'>, seg="'FROM tbl\\nINNER JOIN ...'"]
DEBUG      [PD:2  MD:3 ]	...WhereClauseSegment                             	Ref.match OUT       	    	[match=<MatchResult 0/9: ''>, seg="'ORDER BY tbl.name AS...'"]
INFO       [PD:2  MD:2 ]	..WhereClauseSegment                              	Start.match OUT     	    	[match=<MatchResult 0/9: ''>, seg="'ORDER BY tbl.name AS...'"]
DEBUG      [PD:2  MD:1 ]	.WhereClauseSegment                               	Where.match OUT     	    	[match=<MatchResult 0/9: ''>, seg="'ORDER BY tbl.name AS...'"]
DEBUG      [PD:2  MD:1 ]	.SelectStatementSegment                           	Ref.match OUT       	    	[match=<MatchResult 0/9: ''>, seg="'ORDER BY tbl.name AS...'"]
DEBUG      [PD:2  MD:4 ]	....GroupByClauseSegment                          	Ref.match OUT       	    	[match=<MatchResult 0/9: ''>, seg="'ORDER BY tbl.name AS...'"]
INFO       [PD:2  MD:3 ]	...GroupByClauseSegment                           	Seque.match OUT     	    	[match=<MatchResult 0/9: ''>, seg="'ORDER BY tbl.name AS...'"]
INFO       [PD:2  MD:2 ]	..GroupByClauseSegment                            	Start.match OUT     	    	[match=<MatchResult 0/9: ''>, seg="'ORDER BY tbl.name AS...'"]
DEBUG      [PD:2  MD:1 ]	.GroupByClauseSegment                             	Group.match OUT     	    	[match=<MatchResult 0/9: ''>, seg="'ORDER BY tbl.name AS...'"]
DEBUG      [PD:2  MD:1 ]	.SelectStatementSegment                           	Ref.match OUT       	    	[match=<MatchResult 0/9: ''>, seg="'ORDER BY tbl.name AS...'"]
DEBUG      [PD:2  MD:3 ]	...HavingClauseSegment                            	Ref.match OUT       	    	[match=<MatchResult 0/9: ''>, seg="'ORDER BY tbl.name AS...'"]
INFO       [PD:2  MD:2 ]	..HavingClauseSegment                             	Start.match OUT     	    	[match=<MatchResult 0/9: ''>, seg="'ORDER BY tbl.name AS...'"]
DEBUG      [PD:2  MD:1 ]	.HavingClauseSegment                              	Havin.match OUT     	    	[match=<MatchResult 0/9: ''>, seg="'ORDER BY tbl.name AS...'"]
DEBUG      [PD:2  MD:1 ]	.SelectStatementSegment                           	Ref.match OUT       	    	[match=<MatchResult 0/9: ''>, seg="'ORDER BY tbl.name AS...'"]
DEBUG      [PD:2  MD:3 ]	...OverlapsClauseSegment                          	Ref.match OUT       	    	[match=<MatchResult 0/9: ''>, seg="'ORDER BY tbl.name AS...'"]
INFO       [PD:2  MD:2 ]	..OverlapsClauseSegment                           	Start.match OUT     	    	[match=<MatchResult 0/9: ''>, seg="'ORDER BY tbl.name AS...'"]
DEBUG      [PD:2  MD:1 ]	.OverlapsClauseSegment                            	Overl.match OUT     	    	[match=<MatchResult 0/9: ''>, seg="'ORDER BY tbl.name AS...'"]
DEBUG      [PD:2  MD:1 ]	.SelectStatementSegment                           	Ref.match OUT       	    	[match=<MatchResult 0/9: ''>, seg="'ORDER BY tbl.name AS...'"]
DEBUG      [PD:2  MD:3 ]	...OrderByClauseSegment                           	Ref.match OUT       	+   	[match=<MatchResult 1/9: 'ORDER'>, seg="'ORDER BY tbl.name AS...'"]
DEBUG      [PD:2  MD:3 ]	...OrderByClauseSegment                           	Start._look_ahead_match IN	    	[ls=8, seg=' BY tbl.name ASC']
DEBUG      [PD:2  MD:3 ]	...OrderByClauseSegment                           	Start._look_ahead_match SI	    	[mq=[], sb=['', 'BY', '', 'TBL', '.', 'NAME', '', 'ASC']]
DEBUG      [PD:2  MD:3 ]	...OrderByClauseSegment                           	Start._look_ahead_match SC	    	[bsm=None]
INFO       [PD:2  MD:2 ]	..OrderByClauseSegment                            	Start.match OUT     	++  	[match=<MatchResult 9/9: 'ORDER BY tbl.name ASC'>, seg="'ORDER BY tbl.name AS...'"]
DEBUG      [PD:2  MD:1 ]	.OrderByClauseSegment                             	Order.match OUT     	++  	[match=<MatchResult 1/1: 'ORDER BY tbl.name ASC'>, seg="'ORDER BY tbl.name AS...'"]
DEBUG      [PD:2  MD:1 ]	.SelectStatementSegment                           	Ref.match OUT       	++  	[match=<MatchResult 1/1: 'ORDER BY tbl.name ASC'>, seg="'ORDER BY tbl.name AS...'"]
INFO       [PD:2  MD:0 ]	SelectStatementSegment                            	Seque.match OUT     	++  	[match=<MatchResult 6/6: 'SELECT\n    tbl....BY tbl.name ASC'>, seg="'SELECT\\n    tbl.name,...'"]
DEBUG      SelectStatementSegment.parse: Done Parse. Plotting Recursion. Recurse=True
DEBUG      ###
#
# Beginning Parse Depth 3: SelectStatementSegment
#
###
Initial Structure:
[L:  1, P:  1]      |select_statement:
[L:  1, P:  1]      |    select_clause:
[L:  1, P:  1]      |        keyword:                                              'SELECT'
[L:  1, P:  7]      |        newline:                                              '\n'
[L:  2, P:  1]      |        whitespace:                                           '    '
[L:  2, P:  5]      |        raw:                                                  'tbl'
[L:  2, P:  8]      |        raw:                                                  '.'
[L:  2, P:  9]      |        raw:                                                  'name'
[L:  2, P: 13]      |        comma:                                                ','
[L:  2, P: 14]      |        newline:                                              '\n'
[L:  3, P:  1]      |        whitespace:                                           '    '
[L:  3, P:  5]      |        raw:                                                  'b'
[L:  3, P:  6]      |        raw:                                                  '.'
[L:  3, P:  7]      |        raw:                                                  'value'
[L:  3, P: 12]      |        comma:                                                ','
[L:  3, P: 13]      |        newline:                                              '\n'
[L:  4, P:  1]      |        whitespace:                                           '    '
[L:  4, P:  5]      |        comment:                                              '/*'
[L:  4, P:  7]      |        newline:                                              '\n'
[L:  5, P:  1]      |        whitespace:                                           '    '
[L:  5, P:  5]      |        comment:                                              'This is a block comment'
[L:  5, P: 28]      |        newline:                                              '\n'
[L:  6, P:  1]      |        whitespace:                                           '    '
[L:  6, P:  5]      |        comment:                                              '*/'
[L:  6, P:  7]      |        newline:                                              '\n'
[L:  7, P:  1]      |        whitespace:                                           '    '
[L:  7, P:  5]      |        raw:                                                  'd'
[L:  7, P:  6]      |        raw:                                                  '.'
[L:  7, P:  7]      |        raw:                                                  'something'
[L:  7, P: 16]      |        comma:                                                ','
[L:  7, P: 17]      |        whitespace:                                           '    '
[L:  7, P: 21]      |        comment:                                              '-- Which a comment after it'
[L:  7, P: 48]      |        newline:                                              '\n'
[L:  8, P:  1]      |        whitespace:                                           '    '
[L:  8, P:  5]      |        raw:                                                  'tbl'
[L:  8, P:  8]      |        raw:                                                  '.'
[L:  8, P:  9]      |        raw:                                                  'foo'
[L:  8, P: 12]      |        comma:                                                ','
[L:  8, P: 13]      |        newline:                                              '\n'
[L:  9, P:  1]      |        whitespace:                                           '    '
[L:  9, P:  5]      |        raw:                                                  'c'
[L:  9, P:  6]      |        raw:                                                  '.'
[L:  9, P:  7]      |        raw:                                                  'val'
[L:  9, P: 10]      |        whitespace:                                           ' '
[L:  9, P: 11]      |        raw:                                                  '+'
[L:  9, P: 12]      |        whitespace:                                           ' '
[L:  9, P: 13]      |        raw:                                                  'b'
[L:  9, P: 14]      |        raw:                                                  '.'
[L:  9, P: 15]      |        raw:                                                  'val'
[L:  9, P: 18]      |        whitespace:                                           ' '
[L:  9, P: 19]      |        raw:                                                  '/'
[L:  9, P: 20]      |        whitespace:                                           ' '
[L:  9, P: 21]      |        raw:                                                  '-'
[L:  9, P: 22]      |        raw:                                                  '2'
[L:  9, P: 23]      |        whitespace:                                           ' '
[L:  9, P: 24]      |        raw:                                                  'AS'
[L:  9, P: 26]      |        whitespace:                                           ' '
[L:  9, P: 27]      |        raw:                                                  'a_calculation'
[L:  9, P: 40]      |    newline:                                                  '\n'
[L: 10, P:  1]      |    [META] dedent:
[L: 10, P:  1]      |    from_clause:
[L: 10, P:  1]      |        keyword:                                              'FROM'
[L: 10, P:  5]      |        whitespace:                                           ' '
[L: 10, P:  6]      |        raw:                                                  'tbl'
[L: 10, P:  9]      |        newline:                                              '\n'
[L: 11, P:  1]      |        raw:                                                  'INNER'
[L: 11, P:  6]      |        whitespace:                                           ' '
[L: 11, P:  7]      |        raw:                                                  'JOIN'
[L: 11, P: 11]      |        whitespace:                                           ' '
[L: 11, P: 12]      |        raw:                                                  'b'
[L: 11, P: 13]      |        whitespace:                                           ' '
[L: 11, P: 14]      |        raw:                                                  'ON'
[L: 11, P: 16]      |        whitespace:                                           ' '
[L: 11, P: 17]      |        bracketed:
[L: 11, P: 17]      |            start_bracket:                                    '('
[L: 11, P: 18]      |            raw:                                              'tbl'
[L: 11, P: 21]      |            raw:                                              '.'
[L: 11, P: 22]      |            raw:                                              'common_id'
[L: 11, P: 31]      |            whitespace:                                       ' '
[L: 11, P: 32]      |            raw:                                              '='
[L: 11, P: 33]      |            whitespace:                                       ' '
[L: 11, P: 34]      |            raw:                                              'b'
[L: 11, P: 35]      |            raw:                                              '.'
[L: 11, P: 36]      |            raw:                                              'common_id'
[L: 11, P: 45]      |            end_bracket:                                      ')'
[L: 11, P: 46]      |        newline:                                              '\n'
[L: 12, P:  1]      |        raw:                                                  'JOIN'
[L: 12, P:  5]      |        whitespace:                                           ' '
[L: 12, P:  6]      |        raw:                                                  'c'
[L: 12, P:  7]      |        whitespace:                                           ' '
[L: 12, P:  8]      |        raw:                                                  'ON'
[L: 12, P: 10]      |        whitespace:                                           ' '
[L: 12, P: 11]      |        bracketed:
[L: 12, P: 11]      |            start_bracket:                                    '('
[L: 12, P: 12]      |            raw:                                              'tbl'
[L: 12, P: 15]      |            raw:                                              '.'
[L: 12, P: 16]      |            raw:                                              'id'
[L: 12, P: 18]      |            whitespace:                                       ' '
[L: 12, P: 19]      |            raw:                                              '='
[L: 12, P: 20]      |            whitespace:                                       ' '
[L: 12, P: 21]      |            raw:                                              'c'
[L: 12, P: 22]      |            raw:                                              '.'
[L: 12, P: 23]      |            raw:                                              'id'
[L: 12, P: 25]      |            end_bracket:                                      ')'
[L: 12, P: 26]      |        newline:                                              '\n'
[L: 13, P:  1]      |        raw:                                                  'LEFT'
[L: 13, P:  5]      |        whitespace:                                           ' '
[L: 13, P:  6]      |        raw:                                                  'JOIN'
[L: 13, P: 10]      |        whitespace:                                           ' '
[L: 13, P: 11]      |        raw:                                                  'd'
[L: 13, P: 12]      |        whitespace:                                           ' '
[L: 13, P: 13]      |        raw:                                                  'ON'
[L: 13, P: 15]      |        whitespace:                                           ' '
[L: 13, P: 16]      |        bracketed:
[L: 13, P: 16]      |            start_bracket:                                    '('
[L: 13, P: 17]      |            raw:                                              'tbl'
[L: 13, P: 20]      |            raw:                                              '.'
[L: 13, P: 21]      |            raw:                                              'id'
[L: 13, P: 23]      |            whitespace:                                       ' '
[L: 13, P: 24]      |            raw:                                              '='
[L: 13, P: 25]      |            whitespace:                                       ' '
[L: 13, P: 26]      |            raw:                                              'd'
[L: 13, P: 27]      |            raw:                                              '.'
[L: 13, P: 28]      |            raw:                                              'other_id'
[L: 13, P: 36]      |            end_bracket:                                      ')'
[L: 13, P: 37]      |    newline:                                                  '\n'
[L: 14, P:  1]      |    orderby_clause:
[L: 14, P:  1]      |        keyword:                                              'ORDER'
[L: 14, P:  6]      |        whitespace:                                           ' '
[L: 14, P:  7]      |        keyword:                                              'BY'
[L: 14, P:  9]      |        whitespace:                                           ' '
[L: 14, P: 10]      |        raw:                                                  'tbl'
[L: 14, P: 13]      |        raw:                                                  '.'
[L: 14, P: 14]      |        raw:                                                  'name'
[L: 14, P: 18]      |        whitespace:                                           ' '
[L: 14, P: 19]      |        raw:                                                  'ASC'

INFO       
###
#
# Parse Depth 3. Expanding: SelectClauseSegment: 'SELECT\n    tbl.name,\n    b.value,\n    /*...'
#
###
DEBUG      [PD:3  MD:1 ]	.SelectClauseSegmentGrammar                       	Ref.match OUT       	+   	[match=<MatchResult 1/56: 'SELECT'>, seg="'SELECT\\n    tbl.name,...'"]
INFO       [PD:3  MD:2 ]	..SelectClauseModifierSegment                     	OneOf.match PRN     	    	[ns=0, ps=2, ms=0, pruned=[<Ref: DistinctKeywordSegment>, <Ref: AllKeywordSegment>], opts='ALL']
INFO       [PD:3  MD:2 ]	..SelectClauseModifierSegment                     	OneOf.match OUT     	    	[match=<MatchResult 0/53: ''>, seg="'tbl.name,\\n    b.valu...'"]
DEBUG      [PD:3  MD:1 ]	.SelectClauseModifierSegment                      	Selec.match OUT     	    	[match=<MatchResult 0/53: ''>, seg="'tbl.name,\\n    b.valu...'"]
DEBUG      [PD:3  MD:1 ]	.SelectClauseSegmentGrammar                       	Ref.match OUT       	    	[match=<MatchResult 0/53: ''>, seg="'tbl.name,\\n    b.valu...'"]
DEBUG      [PD:3  MD:2 ]	..SelectClauseSegmentGrammar                      	Delim._look_ahead_match IN	    	[ls=53, seg='tbl.name,\n    b.valu...']
DEBUG      [PD:3  MD:2 ]	..SelectClauseSegmentGrammar                      	Delim._look_ahead_match SI	    	[mq=[(<Ref: CommaSegment>, 3, ','), (<Ref: CommaSegment>, 9, ','), (<Ref: CommaSegment>, 24, ','), (<Ref: CommaSegment>, 32, ',')], sb=['TBL', '.', 'NAME', ',', '', '', 'B', '.', 'VALUE', ',', '', '', '/*', '', '', 'THIS', '', '', '*/', '', '', 'D', '.', 'SOMETHING', ',', '', '--', '', '', 'TBL', '.', 'FOO', ',', '', '', 'C', '.', 'VAL', '', '+', '', 'B', '.', 'VAL', '', '/', '', '-', '2', '', 'AS', '', 'A_CALCULATION']]
DEBUG      [PD:3  MD:2 ]	..SelectClauseSegmentGrammar                      	Ref.match OUT       	+   	[match=<MatchResult 1/21: ','>, seg="',\\n    c.val + b.val ...'"]
DEBUG      [PD:3  MD:2 ]	..SelectClauseSegmentGrammar                      	Ref.match OUT       	+   	[match=<MatchResult 1/29: ','>, seg="',    -- Which a comm...'"]
DEBUG      [PD:3  MD:2 ]	..SelectClauseSegmentGrammar                      	Ref.match OUT       	+   	[match=<MatchResult 1/44: ','>, seg="',\\n    /*\\n    This is...'"]
DEBUG      [PD:3  MD:2 ]	..SelectClauseSegmentGrammar                      	Ref.match OUT       	+   	[match=<MatchResult 1/50: ','>, seg="',\\n    b.value,\\n    /...'"]
DEBUG      [PD:3  MD:2 ]	..SelectClauseSegmentGrammar                      	Delim._look_ahead_match SC	    	[bsm=(3, 1, <Ref: CommaSegment>)]
DEBUG      [PD:3  MD:4 ]	....SelectClauseElementSegment                    	Greed._look_ahead_match IN	    	[ls=3, seg='tbl.name']
DEBUG      [PD:3  MD:4 ]	....SelectClauseElementSegment                    	Greed._look_ahead_match SI	    	[mq=[], sb=['TBL', '.', 'NAME']]
DEBUG      [PD:3  MD:4 ]	....SelectClauseElementSegment                    	Greed._look_ahead_match SC	    	[bsm=None]
INFO       [PD:3  MD:3 ]	...SelectClauseElementSegment                     	Greed.match OUT     	++  	[match=<MatchResult 3/3: 'tbl.name'>, seg="'tbl.name'"]
DEBUG      [PD:3  MD:2 ]	..SelectClauseElementSegment                      	Selec.match OUT     	++  	[match=<MatchResult 1/1: 'tbl.name'>, seg="'tbl.name'"]
DEBUG      [PD:3  MD:2 ]	..SelectClauseSegmentGrammar                      	Ref.match OUT       	++  	[match=<MatchResult 1/1: 'tbl.name'>, seg="'tbl.name'"]
DEBUG      [PD:3  MD:2 ]	..SelectClauseSegmentGrammar                      	Delim._look_ahead_match IN	    	[ls=49, seg='\n    b.value,\n    /*...']
DEBUG      [PD:3  MD:2 ]	..SelectClauseSegmentGrammar                      	Delim._look_ahead_match SI	    	[mq=[(<Ref: CommaSegment>, 5, ','), (<Ref: CommaSegment>, 20, ','), (<Ref: CommaSegment>, 28, ',')], sb=['', '', 'B', '.', 'VALUE', ',', '', '', '/*', '', '', 'THIS', '', '', '*/', '', '', 'D', '.', 'SOMETHING', ',', '', '--', '', '', 'TBL', '.', 'FOO', ',', '', '', 'C', '.', 'VAL', '', '+', '', 'B', '.', 'VAL', '', '/', '', '-', '2', '', 'AS', '', 'A_CALCULATION']]
DEBUG      [PD:3  MD:2 ]	..SelectClauseSegmentGrammar                      	Ref.match OUT       	+   	[match=<MatchResult 1/21: ','>, seg="',\\n    c.val + b.val ...'"]
DEBUG      [PD:3  MD:2 ]	..SelectClauseSegmentGrammar                      	Ref.match OUT       	+   	[match=<MatchResult 1/29: ','>, seg="',    -- Which a comm...'"]
DEBUG      [PD:3  MD:2 ]	..SelectClauseSegmentGrammar                      	Ref.match OUT       	+   	[match=<MatchResult 1/44: ','>, seg="',\\n    /*\\n    This is...'"]
DEBUG      [PD:3  MD:2 ]	..SelectClauseSegmentGrammar                      	Delim._look_ahead_match SC	    	[bsm=(5, 1, <Ref: CommaSegment>)]
DEBUG      [PD:3  MD:4 ]	....SelectClauseElementSegment                    	Greed._look_ahead_match IN	    	[ls=3, seg='b.value']
DEBUG      [PD:3  MD:4 ]	....SelectClauseElementSegment                    	Greed._look_ahead_match SI	    	[mq=[], sb=['B', '.', 'VALUE']]
DEBUG      [PD:3  MD:4 ]	....SelectClauseElementSegment                    	Greed._look_ahead_match SC	    	[bsm=None]
INFO       [PD:3  MD:3 ]	...SelectClauseElementSegment                     	Greed.match OUT     	++  	[match=<MatchResult 3/3: 'b.value'>, seg="'b.value'"]
DEBUG      [PD:3  MD:2 ]	..SelectClauseElementSegment                      	Selec.match OUT     	++  	[match=<MatchResult 1/1: 'b.value'>, seg="'b.value'"]
DEBUG      [PD:3  MD:2 ]	..SelectClauseSegmentGrammar                      	Ref.match OUT       	++  	[match=<MatchResult 1/1: 'b.value'>, seg="'b.value'"]
DEBUG      [PD:3  MD:2 ]	..SelectClauseSegmentGrammar                      	Delim._look_ahead_match IN	    	[ls=43, seg='\n    /*\n    This is ...']
DEBUG      [PD:3  MD:2 ]	..SelectClauseSegmentGrammar                      	Delim._look_ahead_match SI	    	[mq=[(<Ref: CommaSegment>, 14, ','), (<Ref: CommaSegment>, 22, ',')], sb=['', '', '/*', '', '', 'THIS', '', '', '*/', '', '', 'D', '.', 'SOMETHING', ',', '', '--', '', '', 'TBL', '.', 'FOO', ',', '', '', 'C', '.', 'VAL', '', '+', '', 'B', '.', 'VAL', '', '/', '', '-', '2', '', 'AS', '', 'A_CALCULATION']]
DEBUG      [PD:3  MD:2 ]	..SelectClauseSegmentGrammar                      	Ref.match OUT       	+   	[match=<MatchResult 1/21: ','>, seg="',\\n    c.val + b.val ...'"]
DEBUG      [PD:3  MD:2 ]	..SelectClauseSegmentGrammar                      	Ref.match OUT       	+   	[match=<MatchResult 1/29: ','>, seg="',    -- Which a comm...'"]
DEBUG      [PD:3  MD:2 ]	..SelectClauseSegmentGrammar                      	Delim._look_ahead_match SC	    	[bsm=(14, 1, <Ref: CommaSegment>)]
DEBUG      [PD:3  MD:4 ]	....SelectClauseElementSegment                    	Greed._look_ahead_match IN	    	[ls=3, seg='d.something']
DEBUG      [PD:3  MD:4 ]	....SelectClauseElementSegment                    	Greed._look_ahead_match SI	    	[mq=[], sb=['D', '.', 'SOMETHING']]
DEBUG      [PD:3  MD:4 ]	....SelectClauseElementSegment                    	Greed._look_ahead_match SC	    	[bsm=None]
INFO       [PD:3  MD:3 ]	...SelectClauseElementSegment                     	Greed.match OUT     	++  	[match=<MatchResult 3/3: 'd.something'>, seg="'d.something'"]
DEBUG      [PD:3  MD:2 ]	..SelectClauseElementSegment                      	Selec.match OUT     	++  	[match=<MatchResult 1/1: 'd.something'>, seg="'d.something'"]
DEBUG      [PD:3  MD:2 ]	..SelectClauseSegmentGrammar                      	Ref.match OUT       	++  	[match=<MatchResult 1/1: 'd.something'>, seg="'d.something'"]
DEBUG      [PD:3  MD:2 ]	..SelectClauseSegmentGrammar                      	Delim._look_ahead_match IN	    	[ls=28, seg='    -- Which a comme...']
DEBUG      [PD:3  MD:2 ]	..SelectClauseSegmentGrammar                      	Delim._look_ahead_match SI	    	[mq=[(<Ref: CommaSegment>, 7, ',')], sb=['', '--', '', '', 'TBL', '.', 'FOO', ',', '', '', 'C', '.', 'VAL', '', '+', '', 'B', '.', 'VAL', '', '/', '', '-', '2', '', 'AS', '', 'A_CALCULATION']]
DEBUG      [PD:3  MD:2 ]	..SelectClauseSegmentGrammar                      	Ref.match OUT       	+   	[match=<MatchResult 1/21: ','>, seg="',\\n    c.val + b.val ...'"]
DEBUG      [PD:3  MD:2 ]	..SelectClauseSegmentGrammar                      	Delim._look_ahead_match SC	    	[bsm=(7, 1, <Ref: CommaSegment>)]
DEBUG      [PD:3  MD:4 ]	....SelectClauseElementSegment                    	Greed._look_ahead_match IN	    	[ls=3, seg='tbl.foo']
DEBUG      [PD:3  MD:4 ]	....SelectClauseElementSegment                    	Greed._look_ahead_match SI	    	[mq=[], sb=['TBL', '.', 'FOO']]
DEBUG      [PD:3  MD:4 ]	....SelectClauseElementSegment                    	Greed._look_ahead_match SC	    	[bsm=None]
INFO       [PD:3  MD:3 ]	...SelectClauseElementSegment                     	Greed.match OUT     	++  	[match=<MatchResult 3/3: 'tbl.foo'>, seg="'tbl.foo'"]
DEBUG      [PD:3  MD:2 ]	..SelectClauseElementSegment                      	Selec.match OUT     	++  	[match=<MatchResult 1/1: 'tbl.foo'>, seg="'tbl.foo'"]
DEBUG      [PD:3  MD:2 ]	..SelectClauseSegmentGrammar                      	Ref.match OUT       	++  	[match=<MatchResult 1/1: 'tbl.foo'>, seg="'tbl.foo'"]
DEBUG      [PD:3  MD:2 ]	..SelectClauseSegmentGrammar                      	Delim._look_ahead_match IN	    	[ls=20, seg='\n    c.val + b.val /...']
DEBUG      [PD:3  MD:2 ]	..SelectClauseSegmentGrammar                      	Delim._look_ahead_match SI	    	[mq=[], sb=['', '', 'C', '.', 'VAL', '', '+', '', 'B', '.', 'VAL', '', '/', '', '-', '2', '', 'AS', '', 'A_CALCULATION']]
DEBUG      [PD:3  MD:2 ]	..SelectClauseSegmentGrammar                      	Delim._look_ahead_match SC	    	[bsm=None]
DEBUG      [PD:3  MD:4 ]	....SelectClauseElementSegment                    	Greed._look_ahead_match IN	    	[ls=18, seg='c.val + b.val / -2 A...']
DEBUG      [PD:3  MD:4 ]	....SelectClauseElementSegment                    	Greed._look_ahead_match SI	    	[mq=[], sb=['C', '.', 'VAL', '', '+', '', 'B', '.', 'VAL', '', '/', '', '-', '2', '', 'AS', '', 'A_CALCULATION']]
DEBUG      [PD:3  MD:4 ]	....SelectClauseElementSegment                    	Greed._look_ahead_match SC	    	[bsm=None]
INFO       [PD:3  MD:3 ]	...SelectClauseElementSegment                     	Greed.match OUT     	++  	[match=<MatchResult 18/18: 'c.val + b.val /...S a_calculation'>, seg="'c.val + b.val / -2 A...'"]
DEBUG      [PD:3  MD:2 ]	..SelectClauseElementSegment                      	Selec.match OUT     	++  	[match=<MatchResult 1/1: 'c.val + b.val /...S a_calculation'>, seg="'c.val + b.val / -2 A...'"]
DEBUG      [PD:3  MD:2 ]	..SelectClauseSegmentGrammar                      	Ref.match OUT       	++  	[match=<MatchResult 1/1: 'c.val + b.val /...S a_calculation'>, seg="'c.val + b.val / -2 A...'"]
INFO       [PD:3  MD:1 ]	.SelectClauseSegmentGrammar                       	Delim.match OUT     	++  	[match=<MatchResult 28/28: 'tbl.name,\n    b...S a_calculation'>, seg="'tbl.name,\\n    b.valu...'"]
INFO       [PD:3  MD:0 ]	SelectClauseSegmentGrammar                        	Seque.match OUT     	++  	[match=<MatchResult 32/32: 'SELECT\n    tbl....S a_calculation'>, seg="'SELECT\\n    tbl.name,...'"]
DEBUG      [PD:3  MD:0 ]	SelectClauseSegment                               	Ref.match OUT       	++  	[match=<MatchResult 32/32: 'SELECT\n    tbl....S a_calculation'>, seg="'SELECT\\n    tbl.name,...'"]
DEBUG      SelectClauseSegment.parse: Done Parse. Plotting Recursion. Recurse=True
DEBUG      ###
#
# Beginning Parse Depth 4: SelectClauseSegment
#
###
Initial Structure:
[L:  1, P:  1]      |select_clause:
[L:  1, P:  1]      |    keyword:                                                  'SELECT'
[L:  1, P:  7]      |    [META] indent:
[L:  1, P:  7]      |    newline:                                                  '\n'
[L:  2, P:  1]      |    whitespace:                                               '    '
[L:  2, P:  5]      |    select_clause_element:
[L:  2, P:  5]      |        raw:                                                  'tbl'
[L:  2, P:  8]      |        raw:                                                  '.'
[L:  2, P:  9]      |        raw:                                                  'name'
[L:  2, P: 13]      |    comma:                                                    ','
[L:  2, P: 14]      |    newline:                                                  '\n'
[L:  3, P:  1]      |    whitespace:                                               '    '
[L:  3, P:  5]      |    select_clause_element:
[L:  3, P:  5]      |        raw:                                                  'b'
[L:  3, P:  6]      |        raw:                                                  '.'
[L:  3, P:  7]      |        raw:                                                  'value'
[L:  3, P: 12]      |    comma:                                                    ','
[L:  3, P: 13]      |    newline:                                                  '\n'
[L:  4, P:  1]      |    whitespace:                                               '    '
[L:  4, P:  5]      |    comment:                                                  '/*'
[L:  4, P:  7]      |    newline:                                                  '\n'
[L:  5, P:  1]      |    whitespace:                                               '    '
[L:  5, P:  5]      |    comment:                                                  'This is a block comment'
[L:  5, P: 28]      |    newline:                                                  '\n'
[L:  6, P:  1]      |    whitespace:                                               '    '
[L:  6, P:  5]      |    comment:                                                  '*/'
[L:  6, P:  7]      |    newline:                                                  '\n'
[L:  7, P:  1]      |    whitespace:                                               '    '
[L:  7, P:  5]      |    select_clause_element:
[L:  7, P:  5]      |        raw:                                                  'd'
[L:  7, P:  6]      |        raw:                                                  '.'
[L:  7, P:  7]      |        raw:                                                  'something'
[L:  7, P: 16]      |    comma:                                                    ','
[L:  7, P: 17]      |    whitespace:                                               '    '
[L:  7, P: 21]      |    comment:                                                  '-- Which a comment after it'
[L:  7, P: 48]      |    newline:                                                  '\n'
[L:  8, P:  1]      |    whitespace:                                               '    '
[L:  8, P:  5]      |    select_clause_element:
[L:  8, P:  5]      |        raw:                                                  'tbl'
[L:  8, P:  8]      |        raw:                                                  '.'
[L:  8, P:  9]      |        raw:                                                  'foo'
[L:  8, P: 12]      |    comma:                                                    ','
[L:  8, P: 13]      |    newline:                                                  '\n'
[L:  9, P:  1]      |    whitespace:                                               '    '
[L:  9, P:  5]      |    select_clause_element:
[L:  9, P:  5]      |        raw:                                                  'c'
[L:  9, P:  6]      |        raw:                                                  '.'
[L:  9, P:  7]      |        raw:                                                  'val'
[L:  9, P: 10]      |        whitespace:                                           ' '
[L:  9, P: 11]      |        raw:                                                  '+'
[L:  9, P: 12]      |        whitespace:                                           ' '
[L:  9, P: 13]      |        raw:                                                  'b'
[L:  9, P: 14]      |        raw:                                                  '.'
[L:  9, P: 15]      |        raw:                                                  'val'
[L:  9, P: 18]      |        whitespace:                                           ' '
[L:  9, P: 19]      |        raw:                                                  '/'
[L:  9, P: 20]      |        whitespace:                                           ' '
[L:  9, P: 21]      |        raw:                                                  '-'
[L:  9, P: 22]      |        raw:                                                  '2'
[L:  9, P: 23]      |        whitespace:                                           ' '
[L:  9, P: 24]      |        raw:                                                  'AS'
[L:  9, P: 26]      |        whitespace:                                           ' '
[L:  9, P: 27]      |        raw:                                                  'a_calculation'

INFO       [PD:4] Skipping expansion of <KeywordSegment: ([L:  1, P:  1]) 'SELECT'>...
INFO       [PD:4] Skipping expansion of <Indent: ([L:  1, P:  7]) ''>...
INFO       [PD:4] Skipping expansion of <NewlineSegment: ([L:  1, P:  7]) '\n'>...
INFO       [PD:4] Skipping expansion of <WhitespaceSegment: ([L:  2, P:  1]) '    '>...
INFO       
###
#
# Parse Depth 4. Expanding: SelectClauseElementSegment: 'tbl.name'
#
###
INFO       [PD:4  MD:0 ]	SelectClauseElementSegment                        	OneOf.match PRN     	    	[ns=2, ps=0, ms=0, pruned=[], opts=[<Ref: WildcardExpressionSegment>, <Sequence: [<Ref: BaseExpressionElementGrammar>, <Ref: AliasExpressionSegment [opt]>]>]]
INFO       [PD:4  MD:5 ]	.....WildcardIdentifierSegment                    	AnyNu.match PRN     	    	[ns=1, ps=0, ms=0, pruned=[], opts=[<Sequence: [<Ref: SingleIdentifierGrammar>, <Ref: DotSegment>]>]]
INFO       [PD:4  MD:7 ]	.......SingleIdentifierGrammar                    	OneOf.match PRN     	    	[ns=2, ps=0, ms=0, pruned=[], opts=[<Ref: NakedIdentifierSegment>, <Ref: QuotedIdentifierSegment>]]
DEBUG      [PD:4  MD:8 ]	........SingleIdentifierGrammar                   	Ref.match OUT       	+   	[match=<MatchResult 1/3: 'tbl'>, seg="'tbl.name'"]
DEBUG      [PD:4  MD:8 ]	........SingleIdentifierGrammar                   	Ref.match OUT       	    	[match=<MatchResult 0/3: ''>, seg="'tbl.name'"]
INFO       [PD:4  MD:7 ]	.......SingleIdentifierGrammar                    	OneOf.match OUT     	+   	[match=<MatchResult 1/3: 'tbl'>, seg="'tbl.name'"]
DEBUG      [PD:4  MD:7 ]	.......WildcardIdentifierSegment                  	Ref.match OUT       	+   	[match=<MatchResult 1/3: 'tbl'>, seg="'tbl.name'"]
DEBUG      [PD:4  MD:7 ]	.......WildcardIdentifierSegment                  	Ref.match OUT       	+   	[match=<MatchResult 1/2: '.'>, seg="'.name'"]
INFO       [PD:4  MD:6 ]	......WildcardIdentifierSegment                   	Seque.match OUT     	+   	[match=<MatchResult 2/3: 'tbl.'>, seg="'tbl.name'"]
INFO       [PD:4  MD:5 ]	.....WildcardIdentifierSegment                    	AnyNu.match PRN     	    	[ns=1, ps=0, ms=0, pruned=[], opts=[<Sequence: [<Ref: SingleIdentifierGrammar>, <Ref: DotSegment>]>]]
INFO       [PD:4  MD:7 ]	.......SingleIdentifierGrammar                    	OneOf.match PRN     	    	[ns=2, ps=0, ms=0, pruned=[], opts=[<Ref: NakedIdentifierSegment>, <Ref: QuotedIdentifierSegment>]]
DEBUG      [PD:4  MD:8 ]	........SingleIdentifierGrammar                   	Ref.match OUT       	++  	[match=<MatchResult 1/1: 'name'>, seg="'name'"]
INFO       [PD:4  MD:7 ]	.......SingleIdentifierGrammar                    	OneOf.match OUT     	++  	[match=<MatchResult 1/1: 'name'>, seg="'name'"]
DEBUG      [PD:4  MD:7 ]	.......WildcardIdentifierSegment                  	Ref.match OUT       	++  	[match=<MatchResult 1/1: 'name'>, seg="'name'"]
INFO       [PD:4  MD:6 ]	......WildcardIdentifierSegment                   	Seque.match OUT     	    	[match=<MatchResult 0/1: ''>, seg="'name'"]
INFO       [PD:4  MD:5 ]	.....WildcardIdentifierSegment                    	AnyNu.match OUT     	+   	[match=<MatchResult 2/3: 'tbl.'>, seg="'tbl.name'"]
DEBUG      [PD:4  MD:5 ]	.....WildcardIdentifierSegment                    	Ref.match OUT       	    	[match=<MatchResult 0/1: ''>, seg="'name'"]
INFO       [PD:4  MD:4 ]	....WildcardIdentifierSegment                     	Seque.match OUT     	    	[match=<MatchResult 0/3: ''>, seg="'tbl.name'"]
DEBUG      [PD:4  MD:3 ]	...WildcardIdentifierSegment                      	Wildc.match OUT     	    	[match=<MatchResult 0/3: ''>, seg="'tbl.name'"]
DEBUG      [PD:4  MD:3 ]	...WildcardExpressionSegment                      	Ref.match OUT       	    	[match=<MatchResult 0/3: ''>, seg="'tbl.name'"]
INFO       [PD:4  MD:2 ]	..WildcardExpressionSegment                       	Seque.match OUT     	    	[match=<MatchResult 0/3: ''>, seg="'tbl.name'"]
DEBUG      [PD:4  MD:1 ]	.WildcardExpressionSegment                        	Wildc.match OUT     	    	[match=<MatchResult 0/3: ''>, seg="'tbl.name'"]
DEBUG      [PD:4  MD:1 ]	.SelectClauseElementSegment                       	Ref.match OUT       	    	[match=<MatchResult 0/3: ''>, seg="'tbl.name'"]
INFO       [PD:4  MD:2 ]	..BaseExpressionElementGrammar                    	OneOf.match PRN     	    	[ns=5, ps=1, ms=0, pruned=[<Ref: IntervalExpressionSegment>], opts=[<Ref: LiteralGrammar>, <Ref: BareFunctionSegment>, <Ref: FunctionSegment>, <Ref: ColumnReferenceSegment>, <Ref: ExpressionSegment>]]
INFO       [PD:4  MD:3 ]	...LiteralGrammar                                 	OneOf.match PRN     	    	[ns=2, ps=4, ms=0, pruned=[<Ref: BooleanLiteralGrammar>, <Ref: QualifiedNumericLiteralSegment>, <Ref: NullLiteralSegment>, <Ref: DateTimeLiteralGrammar>], opts=[<Ref: QuotedLiteralSegment>, <Ref: NumericLiteralSegment>]]
DEBUG      [PD:4  MD:4 ]	....LiteralGrammar                                	Ref.match OUT       	    	[match=<MatchResult 0/3: ''>, seg="'tbl.name'"]
DEBUG      [PD:4  MD:4 ]	....LiteralGrammar                                	Ref.match OUT       	    	[match=<MatchResult 0/3: ''>, seg="'tbl.name'"]
INFO       [PD:4  MD:3 ]	...LiteralGrammar                                 	OneOf.match OUT     	    	[match=<MatchResult 0/3: ''>, seg="'tbl.name'"]
DEBUG      [PD:4  MD:3 ]	...BaseExpressionElementGrammar                   	Ref.match OUT       	    	[match=<MatchResult 0/3: ''>, seg="'tbl.name'"]
DEBUG      [PD:4  MD:3 ]	...BaseExpressionElementGrammar                   	Ref.match OUT       	    	[match=<MatchResult 0/3: ''>, seg="'tbl.name'"]
INFO       [PD:4  MD:4 ]	....FunctionSegment                               	OneOf.match PRN     	    	[ns=1, ps=1, ms=0, pruned=[<Sequence: [<Sequence: [<Ref: DateAddFunctionNameSeg...]>], opts=[<Sequence: [<Sequence: [<AnyNumberOf: [<Ref: Functio..., <Ref: PostFunctionGrammar [opt]>]>]]
DEBUG      [PD:4  MD:10]	..........DateAddFunctionNameSegment              	Ref.match OUT       	    	[match=<MatchResult 0/3: ''>, seg="'tbl.name'"]
INFO       [PD:4  MD:9 ]	.........DateAddFunctionNameSegment               	Seque.match OUT     	    	[match=<MatchResult 0/3: ''>, seg="'tbl.name'"]
DEBUG      [PD:4  MD:8 ]	........DateAddFunctionNameSegment                	DateA.match OUT     	    	[match=<MatchResult 0/3: ''>, seg="'tbl.name'"]
DEBUG      [PD:4  MD:8 ]	........FunctionSegment                           	Ref.match OUT       	    	[match=<MatchResult 0/3: ''>, seg="'tbl.name'"]
INFO       [PD:4  MD:7 ]	.......FunctionSegment                            	AnyNu.match PRN     	    	[ns=1, ps=0, ms=0, pruned=[], opts=[<Ref: FunctionNameSegment>]]
INFO       [PD:4  MD:10]	..........FunctionNameSegment                     	AnyNu.match PRN     	    	[ns=1, ps=0, ms=0, pruned=[], opts=[<Sequence: [<Ref: SingleIdentifierGrammar>, <Ref: DotSegment>]>]]
INFO       [PD:4  MD:12]	............SingleIdentifierGrammar               	OneOf.match PRN     	    	[ns=2, ps=0, ms=0, pruned=[], opts=[<Ref: NakedIdentifierSegment>, <Ref: QuotedIdentifierSegment>]]
DEBUG      [PD:4  MD:13]	.............SingleIdentifierGrammar              	Ref.match OUT       	+   	[match=<MatchResult 1/3: 'tbl'>, seg="'tbl.name'"]
DEBUG      [PD:4  MD:13]	.............SingleIdentifierGrammar              	Ref.match OUT       	    	[match=<MatchResult 0/3: ''>, seg="'tbl.name'"]
INFO       [PD:4  MD:12]	............SingleIdentifierGrammar               	OneOf.match OUT     	+   	[match=<MatchResult 1/3: 'tbl'>, seg="'tbl.name'"]
DEBUG      [PD:4  MD:12]	............FunctionNameSegment                   	Ref.match OUT       	+   	[match=<MatchResult 1/3: 'tbl'>, seg="'tbl.name'"]
DEBUG      [PD:4  MD:12]	............FunctionNameSegment                   	Ref.match OUT       	+   	[match=<MatchResult 1/2: '.'>, seg="'.name'"]
INFO       [PD:4  MD:11]	...........FunctionNameSegment                    	Seque.match OUT     	+   	[match=<MatchResult 2/3: 'tbl.'>, seg="'tbl.name'"]
INFO       [PD:4  MD:10]	..........FunctionNameSegment                     	AnyNu.match PRN     	    	[ns=1, ps=0, ms=0, pruned=[], opts=[<Sequence: [<Ref: SingleIdentifierGrammar>, <Ref: DotSegment>]>]]
INFO       [PD:4  MD:12]	............SingleIdentifierGrammar               	OneOf.match PRN     	    	[ns=2, ps=0, ms=0, pruned=[], opts=[<Ref: NakedIdentifierSegment>, <Ref: QuotedIdentifierSegment>]]
DEBUG      [PD:4  MD:13]	.............SingleIdentifierGrammar              	Ref.match OUT       	++  	[match=<MatchResult 1/1: 'name'>, seg="'name'"]
INFO       [PD:4  MD:12]	............SingleIdentifierGrammar               	OneOf.match OUT     	++  	[match=<MatchResult 1/1: 'name'>, seg="'name'"]
DEBUG      [PD:4  MD:12]	............FunctionNameSegment                   	Ref.match OUT       	++  	[match=<MatchResult 1/1: 'name'>, seg="'name'"]
INFO       [PD:4  MD:11]	...........FunctionNameSegment                    	Seque.match OUT     	    	[match=<MatchResult 0/1: ''>, seg="'name'"]
INFO       [PD:4  MD:10]	..........FunctionNameSegment                     	AnyNu.match OUT     	+   	[match=<MatchResult 2/3: 'tbl.'>, seg="'tbl.name'"]
INFO       [PD:4  MD:10]	..........FunctionNameSegment                     	OneOf.match PRN     	    	[ns=2, ps=0, ms=0, pruned=[], opts=[<Ref: FunctionNameIdentifierSegment>, <Ref: QuotedIdentifierSegment>]]
DEBUG      [PD:4  MD:11]	...........FunctionNameSegment                    	Ref.match OUT       	++  	[match=<MatchResult 1/1: 'name'>, seg="'name'"]
INFO       [PD:4  MD:10]	..........FunctionNameSegment                     	OneOf.match OUT     	++  	[match=<MatchResult 1/1: 'name'>, seg="'name'"]
INFO       [PD:4  MD:9 ]	.........FunctionNameSegment                      	Seque.match OUT     	++  	[match=<MatchResult 3/3: 'tbl.name'>, seg="'tbl.name'"]
DEBUG      [PD:4  MD:8 ]	........FunctionNameSegment                       	Funct.match OUT     	++  	[match=<MatchResult 1/1: 'tbl.name'>, seg="'tbl.name'"]
DEBUG      [PD:4  MD:8 ]	........FunctionSegment                           	Ref.match OUT       	++  	[match=<MatchResult 1/1: 'tbl.name'>, seg="'tbl.name'"]
INFO       [PD:4  MD:7 ]	.......FunctionSegment                            	AnyNu.match OUT     	++  	[match=<MatchResult 1/1: 'tbl.name'>, seg="'tbl.name'"]
INFO       [PD:4  MD:6 ]	......FunctionSegment                             	Seque.match OUT     	    	[match=<MatchResult 0/3: ''>, seg="'tbl.name'"]
INFO       [PD:4  MD:5 ]	.....FunctionSegment                              	Seque.match OUT     	    	[match=<MatchResult 0/3: ''>, seg="'tbl.name'"]
INFO       [PD:4  MD:4 ]	....FunctionSegment                               	OneOf.match OUT     	    	[match=<MatchResult 0/3: ''>, seg="'tbl.name'"]
DEBUG      [PD:4  MD:3 ]	...FunctionSegment                                	Funct.match OUT     	    	[match=<MatchResult 0/3: ''>, seg="'tbl.name'"]
DEBUG      [PD:4  MD:3 ]	...BaseExpressionElementGrammar                   	Ref.match OUT       	    	[match=<MatchResult 0/3: ''>, seg="'tbl.name'"]
DEBUG      [PD:4  MD:5 ]	.....ColumnReferenceSegment                       	Delim._look_ahead_match IN	    	[ls=3, seg='tbl.name']
DEBUG      [PD:4  MD:5 ]	.....ColumnReferenceSegment                       	Delim._look_ahead_match SI	    	[mq=[(<OneOf: [<Ref: DotSegment>, <Sequence: [<Ref: DotSegment>, <Ref: Dot...]>, 1, '.'), (<OneOf: [<Ref: DotSegment>, <Sequence: [<Ref: DotSegment>, <Ref: Dot...]>, 1, '.')], sb=['TBL', '.', 'NAME']]
INFO       [PD:4  MD:5 ]	.....ColumnReferenceSegment                       	OneOf.match PRN     	    	[ns=0, ps=0, ms=2, pruned=[], opts=[<Ref: DotSegment>, <Sequence: [<Ref: DotSegment>, <Ref: DotSegment>]>]]
DEBUG      [PD:4  MD:6 ]	......ColumnReferenceSegment                      	Ref.match OUT       	+   	[match=<MatchResult 1/2: '.'>, seg="'.name'"]
DEBUG      [PD:4  MD:7 ]	.......ColumnReferenceSegment                     	Ref.match OUT       	+   	[match=<MatchResult 1/2: '.'>, seg="'.name'"]
DEBUG      [PD:4  MD:7 ]	.......ColumnReferenceSegment                     	Ref.match OUT       	    	[match=<MatchResult 0/1: ''>, seg="'name'"]
INFO       [PD:4  MD:6 ]	......ColumnReferenceSegment                      	Seque.match OUT     	    	[match=<MatchResult 0/2: ''>, seg="'.name'"]
INFO       [PD:4  MD:5 ]	.....ColumnReferenceSegment                       	OneOf.match OUT     	+   	[match=<MatchResult 1/2: '.'>, seg="'.name'"]
INFO       [PD:4  MD:5 ]	.....ColumnReferenceSegment                       	OneOf.match PRN     	    	[ns=0, ps=0, ms=2, pruned=[], opts=[<Ref: DotSegment>, <Sequence: [<Ref: DotSegment>, <Ref: DotSegment>]>]]
DEBUG      [PD:4  MD:6 ]	......ColumnReferenceSegment                      	Ref.match OUT       	+   	[match=<MatchResult 1/2: '.'>, seg="'.name'"]
DEBUG      [PD:4  MD:7 ]	.......ColumnReferenceSegment                     	Ref.match OUT       	+   	[match=<MatchResult 1/2: '.'>, seg="'.name'"]
DEBUG      [PD:4  MD:7 ]	.......ColumnReferenceSegment                     	Ref.match OUT       	    	[match=<MatchResult 0/1: ''>, seg="'name'"]
INFO       [PD:4  MD:6 ]	......ColumnReferenceSegment                      	Seque.match OUT     	    	[match=<MatchResult 0/2: ''>, seg="'.name'"]
INFO       [PD:4  MD:5 ]	.....ColumnReferenceSegment                       	OneOf.match OUT     	+   	[match=<MatchResult 1/2: '.'>, seg="'.name'"]
INFO       [PD:4  MD:5 ]	.....ColumnReferenceSegment                       	OneOf.match PRN     	    	[ns=1, ps=10, ms=0, pruned=[<Ref: OnKeywordSegment>, <Ref: AsKeywordSegment>, <Ref: UsingKeywordSegment>, <Ref: CommaSegment>, <Ref: CastOperatorSegment>, <Ref: StartSquareBracketSegment>, <Ref: StartBracketSegment>, <Ref: ColonSegment>, <Ref: DelimiterSegment>, <class 'sqlfluff.core.parser.segments.base.BracketedSegment'>], opts=[<Ref: BinaryOperatorGrammar>]]
INFO       [PD:4  MD:6 ]	......BinaryOperatorGrammar                       	OneOf.match PRN     	    	[ns=1, ps=3, ms=0, pruned=[<Ref: ArithmeticBinaryOperatorGrammar>, <Ref: StringBinaryOperatorGrammar>, <Ref: BooleanBinaryOperatorGrammar>], opts=[<Ref: ComparisonOperatorGrammar>]]
INFO       [PD:4  MD:7 ]	.......ComparisonOperatorGrammar                  	OneOf.match PRN     	    	[ns=1, ps=7, ms=0, pruned=[<Ref: EqualsSegment>, <Ref: GreaterThanSegment>, <Ref: LessThanSegment>, <Ref: GreaterThanOrEqualToSegment>, <Ref: LessThanOrEqualToSegment>, <Ref: NotEqualToSegment_a>, <Ref: NotEqualToSegment_b>], opts=[<Ref: LikeOperatorSegment>]]
DEBUG      [PD:4  MD:8 ]	........ComparisonOperatorGrammar                 	Ref.match OUT       	    	[match=<MatchResult 0/3: ''>, seg="'tbl.name'"]
INFO       [PD:4  MD:7 ]	.......ComparisonOperatorGrammar                  	OneOf.match OUT     	    	[match=<MatchResult 0/3: ''>, seg="'tbl.name'"]
DEBUG      [PD:4  MD:7 ]	.......BinaryOperatorGrammar                      	Ref.match OUT       	    	[match=<MatchResult 0/3: ''>, seg="'tbl.name'"]
INFO       [PD:4  MD:6 ]	......BinaryOperatorGrammar                       	OneOf.match OUT     	    	[match=<MatchResult 0/3: ''>, seg="'tbl.name'"]
DEBUG      [PD:4  MD:6 ]	......ColumnReferenceSegment                      	Ref.match OUT       	    	[match=<MatchResult 0/3: ''>, seg="'tbl.name'"]
INFO       [PD:4  MD:5 ]	.....ColumnReferenceSegment                       	OneOf.match OUT     	    	[match=<MatchResult 0/3: ''>, seg="'tbl.name'"]
DEBUG      [PD:4  MD:5 ]	.....ColumnReferenceSegment                       	NonCo.match OUT     	    	[match=<MatchResult 0/3: ''>, seg="'tbl.name'"]
INFO       [PD:4  MD:5 ]	.....ColumnReferenceSegment                       	OneOf.match PRN     	    	[ns=1, ps=10, ms=0, pruned=[<Ref: OnKeywordSegment>, <Ref: AsKeywordSegment>, <Ref: UsingKeywordSegment>, <Ref: CommaSegment>, <Ref: CastOperatorSegment>, <Ref: StartSquareBracketSegment>, <Ref: StartBracketSegment>, <Ref: ColonSegment>, <Ref: DelimiterSegment>, <class 'sqlfluff.core.parser.segments.base.BracketedSegment'>], opts=[<Ref: BinaryOperatorGrammar>]]
INFO       [PD:4  MD:6 ]	......BinaryOperatorGrammar                       	OneOf.match PRN     	    	[ns=1, ps=3, ms=0, pruned=[<Ref: ArithmeticBinaryOperatorGrammar>, <Ref: StringBinaryOperatorGrammar>, <Ref: BooleanBinaryOperatorGrammar>], opts=[<Ref: ComparisonOperatorGrammar>]]
INFO       [PD:4  MD:7 ]	.......ComparisonOperatorGrammar                  	OneOf.match PRN     	    	[ns=1, ps=7, ms=0, pruned=[<Ref: EqualsSegment>, <Ref: GreaterThanSegment>, <Ref: LessThanSegment>, <Ref: GreaterThanOrEqualToSegment>, <Ref: LessThanOrEqualToSegment>, <Ref: NotEqualToSegment_a>, <Ref: NotEqualToSegment_b>], opts=[<Ref: LikeOperatorSegment>]]
DEBUG      [PD:4  MD:8 ]	........ComparisonOperatorGrammar                 	Ref.match OUT       	    	[match=<MatchResult 0/2: ''>, seg="'.name'"]
INFO       [PD:4  MD:7 ]	.......ComparisonOperatorGrammar                  	OneOf.match OUT     	    	[match=<MatchResult 0/2: ''>, seg="'.name'"]
DEBUG      [PD:4  MD:7 ]	.......BinaryOperatorGrammar                      	Ref.match OUT       	    	[match=<MatchResult 0/2: ''>, seg="'.name'"]
INFO       [PD:4  MD:6 ]	......BinaryOperatorGrammar                       	OneOf.match OUT     	    	[match=<MatchResult 0/2: ''>, seg="'.name'"]
DEBUG      [PD:4  MD:6 ]	......ColumnReferenceSegment                      	Ref.match OUT       	    	[match=<MatchResult 0/2: ''>, seg="'.name'"]
INFO       [PD:4  MD:5 ]	.....ColumnReferenceSegment                       	OneOf.match OUT     	    	[match=<MatchResult 0/2: ''>, seg="'.name'"]
DEBUG      [PD:4  MD:5 ]	.....ColumnReferenceSegment                       	NonCo.match OUT     	    	[match=<MatchResult 0/2: ''>, seg="'.name'"]
INFO       [PD:4  MD:5 ]	.....SingleIdentifierGrammar                      	OneOf.match PRN     	    	[ns=2, ps=0, ms=0, pruned=[], opts=[<Ref: NakedIdentifierSegment>, <Ref: QuotedIdentifierSegment>]]
DEBUG      [PD:4  MD:6 ]	......SingleIdentifierGrammar                     	Ref.match OUT       	++  	[match=<MatchResult 1/1: 'tbl'>, seg="'tbl'"]
INFO       [PD:4  MD:5 ]	.....SingleIdentifierGrammar                      	OneOf.match OUT     	++  	[match=<MatchResult 1/1: 'tbl'>, seg="'tbl'"]
DEBUG      [PD:4  MD:5 ]	.....ColumnReferenceSegment                       	Ref.match OUT       	++  	[match=<MatchResult 1/1: 'tbl'>, seg="'tbl'"]
DEBUG      [PD:4  MD:5 ]	.....ColumnReferenceSegment                       	Delim._look_ahead_match IN	    	[ls=1, seg='name']
DEBUG      [PD:4  MD:5 ]	.....ColumnReferenceSegment                       	Delim._look_ahead_match SI	    	[mq=[], sb=['NAME']]
INFO       [PD:4  MD:5 ]	.....ColumnReferenceSegment                       	OneOf.match PRN     	    	[ns=1, ps=10, ms=0, pruned=[<Ref: OnKeywordSegment>, <Ref: AsKeywordSegment>, <Ref: UsingKeywordSegment>, <Ref: CommaSegment>, <Ref: CastOperatorSegment>, <Ref: StartSquareBracketSegment>, <Ref: StartBracketSegment>, <Ref: ColonSegment>, <Ref: DelimiterSegment>, <class 'sqlfluff.core.parser.segments.base.BracketedSegment'>], opts=[<Ref: BinaryOperatorGrammar>]]
INFO       [PD:4  MD:6 ]	......BinaryOperatorGrammar                       	OneOf.match PRN     	    	[ns=1, ps=3, ms=0, pruned=[<Ref: ArithmeticBinaryOperatorGrammar>, <Ref: StringBinaryOperatorGrammar>, <Ref: BooleanBinaryOperatorGrammar>], opts=[<Ref: ComparisonOperatorGrammar>]]
INFO       [PD:4  MD:7 ]	.......ComparisonOperatorGrammar                  	OneOf.match PRN     	    	[ns=1, ps=7, ms=0, pruned=[<Ref: EqualsSegment>, <Ref: GreaterThanSegment>, <Ref: LessThanSegment>, <Ref: GreaterThanOrEqualToSegment>, <Ref: LessThanOrEqualToSegment>, <Ref: NotEqualToSegment_a>, <Ref: NotEqualToSegment_b>], opts=[<Ref: LikeOperatorSegment>]]
DEBUG      [PD:4  MD:8 ]	........ComparisonOperatorGrammar                 	Ref.match OUT       	    	[match=<MatchResult 0/1: ''>, seg="'name'"]
INFO       [PD:4  MD:7 ]	.......ComparisonOperatorGrammar                  	OneOf.match OUT     	    	[match=<MatchResult 0/1: ''>, seg="'name'"]
DEBUG      [PD:4  MD:7 ]	.......BinaryOperatorGrammar                      	Ref.match OUT       	    	[match=<MatchResult 0/1: ''>, seg="'name'"]
INFO       [PD:4  MD:6 ]	......BinaryOperatorGrammar                       	OneOf.match OUT     	    	[match=<MatchResult 0/1: ''>, seg="'name'"]
DEBUG      [PD:4  MD:6 ]	......ColumnReferenceSegment                      	Ref.match OUT       	    	[match=<MatchResult 0/1: ''>, seg="'name'"]
INFO       [PD:4  MD:5 ]	.....ColumnReferenceSegment                       	OneOf.match OUT     	    	[match=<MatchResult 0/1: ''>, seg="'name'"]
DEBUG      [PD:4  MD:5 ]	.....ColumnReferenceSegment                       	NonCo.match OUT     	    	[match=<MatchResult 0/1: ''>, seg="'name'"]
INFO       [PD:4  MD:5 ]	.....SingleIdentifierGrammar                      	OneOf.match PRN     	    	[ns=2, ps=0, ms=0, pruned=[], opts=[<Ref: NakedIdentifierSegment>, <Ref: QuotedIdentifierSegment>]]
DEBUG      [PD:4  MD:6 ]	......SingleIdentifierGrammar                     	Ref.match OUT       	++  	[match=<MatchResult 1/1: 'name'>, seg="'name'"]
INFO       [PD:4  MD:5 ]	.....SingleIdentifierGrammar                      	OneOf.match OUT     	++  	[match=<MatchResult 1/1: 'name'>, seg="'name'"]
DEBUG      [PD:4  MD:5 ]	.....ColumnReferenceSegment                       	Ref.match OUT       	++  	[match=<MatchResult 1/1: 'name'>, seg="'name'"]
INFO       [PD:4  MD:4 ]	....ColumnReferenceSegment                        	Delim.match OUT     	++  	[match=<MatchResult 3/3: 'tbl.name'>, seg="'tbl.name'"]
DEBUG      [PD:4  MD:3 ]	...ColumnReferenceSegment                         	Colum.match OUT     	++  	[match=<MatchResult 1/1: 'tbl.name'>, seg="'tbl.name'"]
DEBUG      [PD:4  MD:3 ]	...BaseExpressionElementGrammar                   	Ref.match OUT       	++  	[match=<MatchResult 1/1: 'tbl.name'>, seg="'tbl.name'"]
INFO       [PD:4  MD:2 ]	..BaseExpressionElementGrammar                    	OneOf.match OUT     	++  	[match=<MatchResult 1/1: 'tbl.name'>, seg="'tbl.name'"]
DEBUG      [PD:4  MD:2 ]	..SelectClauseElementSegment                      	Ref.match OUT       	++  	[match=<MatchResult 1/1: 'tbl.name'>, seg="'tbl.name'"]
INFO       [PD:4  MD:1 ]	.SelectClauseElementSegment                       	Seque.match OUT     	++  	[match=<MatchResult 1/1: 'tbl.name'>, seg="'tbl.name'"]
INFO       [PD:4  MD:0 ]	SelectClauseElementSegment                        	OneOf.match OUT     	++  	[match=<MatchResult 1/1: 'tbl.name'>, seg="'tbl.name'"]
DEBUG      SelectClauseElementSegment.parse: Done Parse. Plotting Recursion. Recurse=True
DEBUG      ###
#
# Beginning Parse Depth 5: SelectClauseElementSegment
#
###
Initial Structure:
[L:  2, P:  5]      |select_clause_element:
[L:  2, P:  5]      |    column_reference:
[L:  2, P:  5]      |        identifier:                                           'tbl'
[L:  2, P:  8]      |        dot:                                                  '.'
[L:  2, P:  9]      |        identifier:                                           'name'

INFO       [PD:5] Skipping expansion of <ColumnReferenceSegment: ([L:  2, P:  5])>...
INFO       [PD:4] Skipping expansion of <SymbolSegment: ([L:  2, P: 13]) ','>...
INFO       [PD:4] Skipping expansion of <NewlineSegment: ([L:  2, P: 14]) '\n'>...
INFO       [PD:4] Skipping expansion of <WhitespaceSegment: ([L:  3, P:  1]) '    '>...
INFO       
###
#
# Parse Depth 4. Expanding: SelectClauseElementSegment: 'b.value'
#
###
INFO       [PD:4  MD:0 ]	SelectClauseElementSegment                        	OneOf.match PRN     	    	[ns=2, ps=0, ms=0, pruned=[], opts=[<Ref: WildcardExpressionSegment>, <Sequence: [<Ref: BaseExpressionElementGrammar>, <Ref: AliasExpressionSegment [opt]>]>]]
INFO       [PD:4  MD:5 ]	.....WildcardIdentifierSegment                    	AnyNu.match PRN     	    	[ns=1, ps=0, ms=0, pruned=[], opts=[<Sequence: [<Ref: SingleIdentifierGrammar>, <Ref: DotSegment>]>]]
INFO       [PD:4  MD:7 ]	.......SingleIdentifierGrammar                    	OneOf.match PRN     	    	[ns=2, ps=0, ms=0, pruned=[], opts=[<Ref: NakedIdentifierSegment>, <Ref: QuotedIdentifierSegment>]]
DEBUG      [PD:4  MD:8 ]	........SingleIdentifierGrammar                   	Ref.match OUT       	+   	[match=<MatchResult 1/3: 'b'>, seg="'b.value'"]
DEBUG      [PD:4  MD:8 ]	........SingleIdentifierGrammar                   	Ref.match OUT       	    	[match=<MatchResult 0/3: ''>, seg="'b.value'"]
INFO       [PD:4  MD:7 ]	.......SingleIdentifierGrammar                    	OneOf.match OUT     	+   	[match=<MatchResult 1/3: 'b'>, seg="'b.value'"]
DEBUG      [PD:4  MD:7 ]	.......WildcardIdentifierSegment                  	Ref.match OUT       	+   	[match=<MatchResult 1/3: 'b'>, seg="'b.value'"]
DEBUG      [PD:4  MD:7 ]	.......WildcardIdentifierSegment                  	Ref.match OUT       	+   	[match=<MatchResult 1/2: '.'>, seg="'.value'"]
INFO       [PD:4  MD:6 ]	......WildcardIdentifierSegment                   	Seque.match OUT     	+   	[match=<MatchResult 2/3: 'b.'>, seg="'b.value'"]
INFO       [PD:4  MD:5 ]	.....WildcardIdentifierSegment                    	AnyNu.match PRN     	    	[ns=1, ps=0, ms=0, pruned=[], opts=[<Sequence: [<Ref: SingleIdentifierGrammar>, <Ref: DotSegment>]>]]
INFO       [PD:4  MD:7 ]	.......SingleIdentifierGrammar                    	OneOf.match PRN     	    	[ns=2, ps=0, ms=0, pruned=[], opts=[<Ref: NakedIdentifierSegment>, <Ref: QuotedIdentifierSegment>]]
DEBUG      [PD:4  MD:8 ]	........SingleIdentifierGrammar                   	Ref.match OUT       	++  	[match=<MatchResult 1/1: 'value'>, seg="'value'"]
INFO       [PD:4  MD:7 ]	.......SingleIdentifierGrammar                    	OneOf.match OUT     	++  	[match=<MatchResult 1/1: 'value'>, seg="'value'"]
DEBUG      [PD:4  MD:7 ]	.......WildcardIdentifierSegment                  	Ref.match OUT       	++  	[match=<MatchResult 1/1: 'value'>, seg="'value'"]
INFO       [PD:4  MD:6 ]	......WildcardIdentifierSegment                   	Seque.match OUT     	    	[match=<MatchResult 0/1: ''>, seg="'value'"]
INFO       [PD:4  MD:5 ]	.....WildcardIdentifierSegment                    	AnyNu.match OUT     	+   	[match=<MatchResult 2/3: 'b.'>, seg="'b.value'"]
DEBUG      [PD:4  MD:5 ]	.....WildcardIdentifierSegment                    	Ref.match OUT       	    	[match=<MatchResult 0/1: ''>, seg="'value'"]
INFO       [PD:4  MD:4 ]	....WildcardIdentifierSegment                     	Seque.match OUT     	    	[match=<MatchResult 0/3: ''>, seg="'b.value'"]
DEBUG      [PD:4  MD:3 ]	...WildcardIdentifierSegment                      	Wildc.match OUT     	    	[match=<MatchResult 0/3: ''>, seg="'b.value'"]
DEBUG      [PD:4  MD:3 ]	...WildcardExpressionSegment                      	Ref.match OUT       	    	[match=<MatchResult 0/3: ''>, seg="'b.value'"]
INFO       [PD:4  MD:2 ]	..WildcardExpressionSegment                       	Seque.match OUT     	    	[match=<MatchResult 0/3: ''>, seg="'b.value'"]
DEBUG      [PD:4  MD:1 ]	.WildcardExpressionSegment                        	Wildc.match OUT     	    	[match=<MatchResult 0/3: ''>, seg="'b.value'"]
DEBUG      [PD:4  MD:1 ]	.SelectClauseElementSegment                       	Ref.match OUT       	    	[match=<MatchResult 0/3: ''>, seg="'b.value'"]
INFO       [PD:4  MD:2 ]	..BaseExpressionElementGrammar                    	OneOf.match PRN     	    	[ns=5, ps=1, ms=0, pruned=[<Ref: IntervalExpressionSegment>], opts=[<Ref: LiteralGrammar>, <Ref: BareFunctionSegment>, <Ref: FunctionSegment>, <Ref: ColumnReferenceSegment>, <Ref: ExpressionSegment>]]
INFO       [PD:4  MD:3 ]	...LiteralGrammar                                 	OneOf.match PRN     	    	[ns=2, ps=4, ms=0, pruned=[<Ref: BooleanLiteralGrammar>, <Ref: QualifiedNumericLiteralSegment>, <Ref: NullLiteralSegment>, <Ref: DateTimeLiteralGrammar>], opts=[<Ref: QuotedLiteralSegment>, <Ref: NumericLiteralSegment>]]
DEBUG      [PD:4  MD:4 ]	....LiteralGrammar                                	Ref.match OUT       	    	[match=<MatchResult 0/3: ''>, seg="'b.value'"]
DEBUG      [PD:4  MD:4 ]	....LiteralGrammar                                	Ref.match OUT       	    	[match=<MatchResult 0/3: ''>, seg="'b.value'"]
INFO       [PD:4  MD:3 ]	...LiteralGrammar                                 	OneOf.match OUT     	    	[match=<MatchResult 0/3: ''>, seg="'b.value'"]
DEBUG      [PD:4  MD:3 ]	...BaseExpressionElementGrammar                   	Ref.match OUT       	    	[match=<MatchResult 0/3: ''>, seg="'b.value'"]
DEBUG      [PD:4  MD:3 ]	...BaseExpressionElementGrammar                   	Ref.match OUT       	    	[match=<MatchResult 0/3: ''>, seg="'b.value'"]
INFO       [PD:4  MD:4 ]	....FunctionSegment                               	OneOf.match PRN     	    	[ns=1, ps=1, ms=0, pruned=[<Sequence: [<Sequence: [<Ref: DateAddFunctionNameSeg...]>], opts=[<Sequence: [<Sequence: [<AnyNumberOf: [<Ref: Functio..., <Ref: PostFunctionGrammar [opt]>]>]]
DEBUG      [PD:4  MD:10]	..........DateAddFunctionNameSegment              	Ref.match OUT       	    	[match=<MatchResult 0/3: ''>, seg="'b.value'"]
INFO       [PD:4  MD:9 ]	.........DateAddFunctionNameSegment               	Seque.match OUT     	    	[match=<MatchResult 0/3: ''>, seg="'b.value'"]
DEBUG      [PD:4  MD:8 ]	........DateAddFunctionNameSegment                	DateA.match OUT     	    	[match=<MatchResult 0/3: ''>, seg="'b.value'"]
DEBUG      [PD:4  MD:8 ]	........FunctionSegment                           	Ref.match OUT       	    	[match=<MatchResult 0/3: ''>, seg="'b.value'"]
INFO       [PD:4  MD:7 ]	.......FunctionSegment                            	AnyNu.match PRN     	    	[ns=1, ps=0, ms=0, pruned=[], opts=[<Ref: FunctionNameSegment>]]
INFO       [PD:4  MD:10]	..........FunctionNameSegment                     	AnyNu.match PRN     	    	[ns=1, ps=0, ms=0, pruned=[], opts=[<Sequence: [<Ref: SingleIdentifierGrammar>, <Ref: DotSegment>]>]]
INFO       [PD:4  MD:12]	............SingleIdentifierGrammar               	OneOf.match PRN     	    	[ns=2, ps=0, ms=0, pruned=[], opts=[<Ref: NakedIdentifierSegment>, <Ref: QuotedIdentifierSegment>]]
DEBUG      [PD:4  MD:13]	.............SingleIdentifierGrammar              	Ref.match OUT       	+   	[match=<MatchResult 1/3: 'b'>, seg="'b.value'"]
DEBUG      [PD:4  MD:13]	.............SingleIdentifierGrammar              	Ref.match OUT       	    	[match=<MatchResult 0/3: ''>, seg="'b.value'"]
INFO       [PD:4  MD:12]	............SingleIdentifierGrammar               	OneOf.match OUT     	+   	[match=<MatchResult 1/3: 'b'>, seg="'b.value'"]
DEBUG      [PD:4  MD:12]	............FunctionNameSegment                   	Ref.match OUT       	+   	[match=<MatchResult 1/3: 'b'>, seg="'b.value'"]
DEBUG      [PD:4  MD:12]	............FunctionNameSegment                   	Ref.match OUT       	+   	[match=<MatchResult 1/2: '.'>, seg="'.value'"]
INFO       [PD:4  MD:11]	...........FunctionNameSegment                    	Seque.match OUT     	+   	[match=<MatchResult 2/3: 'b.'>, seg="'b.value'"]
INFO       [PD:4  MD:10]	..........FunctionNameSegment                     	AnyNu.match PRN     	    	[ns=1, ps=0, ms=0, pruned=[], opts=[<Sequence: [<Ref: SingleIdentifierGrammar>, <Ref: DotSegment>]>]]
INFO       [PD:4  MD:12]	............SingleIdentifierGrammar               	OneOf.match PRN     	    	[ns=2, ps=0, ms=0, pruned=[], opts=[<Ref: NakedIdentifierSegment>, <Ref: QuotedIdentifierSegment>]]
DEBUG      [PD:4  MD:13]	.............SingleIdentifierGrammar              	Ref.match OUT       	++  	[match=<MatchResult 1/1: 'value'>, seg="'value'"]
INFO       [PD:4  MD:12]	............SingleIdentifierGrammar               	OneOf.match OUT     	++  	[match=<MatchResult 1/1: 'value'>, seg="'value'"]
DEBUG      [PD:4  MD:12]	............FunctionNameSegment                   	Ref.match OUT       	++  	[match=<MatchResult 1/1: 'value'>, seg="'value'"]
INFO       [PD:4  MD:11]	...........FunctionNameSegment                    	Seque.match OUT     	    	[match=<MatchResult 0/1: ''>, seg="'value'"]
INFO       [PD:4  MD:10]	..........FunctionNameSegment                     	AnyNu.match OUT     	+   	[match=<MatchResult 2/3: 'b.'>, seg="'b.value'"]
INFO       [PD:4  MD:10]	..........FunctionNameSegment                     	OneOf.match PRN     	    	[ns=2, ps=0, ms=0, pruned=[], opts=[<Ref: FunctionNameIdentifierSegment>, <Ref: QuotedIdentifierSegment>]]
DEBUG      [PD:4  MD:11]	...........FunctionNameSegment                    	Ref.match OUT       	++  	[match=<MatchResult 1/1: 'value'>, seg="'value'"]
INFO       [PD:4  MD:10]	..........FunctionNameSegment                     	OneOf.match OUT     	++  	[match=<MatchResult 1/1: 'value'>, seg="'value'"]
INFO       [PD:4  MD:9 ]	.........FunctionNameSegment                      	Seque.match OUT     	++  	[match=<MatchResult 3/3: 'b.value'>, seg="'b.value'"]
DEBUG      [PD:4  MD:8 ]	........FunctionNameSegment                       	Funct.match OUT     	++  	[match=<MatchResult 1/1: 'b.value'>, seg="'b.value'"]
DEBUG      [PD:4  MD:8 ]	........FunctionSegment                           	Ref.match OUT       	++  	[match=<MatchResult 1/1: 'b.value'>, seg="'b.value'"]
INFO       [PD:4  MD:7 ]	.......FunctionSegment                            	AnyNu.match OUT     	++  	[match=<MatchResult 1/1: 'b.value'>, seg="'b.value'"]
INFO       [PD:4  MD:6 ]	......FunctionSegment                             	Seque.match OUT     	    	[match=<MatchResult 0/3: ''>, seg="'b.value'"]
INFO       [PD:4  MD:5 ]	.....FunctionSegment                              	Seque.match OUT     	    	[match=<MatchResult 0/3: ''>, seg="'b.value'"]
INFO       [PD:4  MD:4 ]	....FunctionSegment                               	OneOf.match OUT     	    	[match=<MatchResult 0/3: ''>, seg="'b.value'"]
DEBUG      [PD:4  MD:3 ]	...FunctionSegment                                	Funct.match OUT     	    	[match=<MatchResult 0/3: ''>, seg="'b.value'"]
DEBUG      [PD:4  MD:3 ]	...BaseExpressionElementGrammar                   	Ref.match OUT       	    	[match=<MatchResult 0/3: ''>, seg="'b.value'"]
DEBUG      [PD:4  MD:5 ]	.....ColumnReferenceSegment                       	Delim._look_ahead_match IN	    	[ls=3, seg='b.value']
DEBUG      [PD:4  MD:5 ]	.....ColumnReferenceSegment                       	Delim._look_ahead_match SI	    	[mq=[(<OneOf: [<Ref: DotSegment>, <Sequence: [<Ref: DotSegment>, <Ref: Dot...]>, 1, '.'), (<OneOf: [<Ref: DotSegment>, <Sequence: [<Ref: DotSegment>, <Ref: Dot...]>, 1, '.')], sb=['B', '.', 'VALUE']]
INFO       [PD:4  MD:5 ]	.....ColumnReferenceSegment                       	OneOf.match PRN     	    	[ns=0, ps=0, ms=2, pruned=[], opts=[<Ref: DotSegment>, <Sequence: [<Ref: DotSegment>, <Ref: DotSegment>]>]]
DEBUG      [PD:4  MD:6 ]	......ColumnReferenceSegment                      	Ref.match OUT       	+   	[match=<MatchResult 1/2: '.'>, seg="'.value'"]
DEBUG      [PD:4  MD:7 ]	.......ColumnReferenceSegment                     	Ref.match OUT       	+   	[match=<MatchResult 1/2: '.'>, seg="'.value'"]
DEBUG      [PD:4  MD:7 ]	.......ColumnReferenceSegment                     	Ref.match OUT       	    	[match=<MatchResult 0/1: ''>, seg="'value'"]
INFO       [PD:4  MD:6 ]	......ColumnReferenceSegment                      	Seque.match OUT     	    	[match=<MatchResult 0/2: ''>, seg="'.value'"]
INFO       [PD:4  MD:5 ]	.....ColumnReferenceSegment                       	OneOf.match OUT     	+   	[match=<MatchResult 1/2: '.'>, seg="'.value'"]
INFO       [PD:4  MD:5 ]	.....ColumnReferenceSegment                       	OneOf.match PRN     	    	[ns=0, ps=0, ms=2, pruned=[], opts=[<Ref: DotSegment>, <Sequence: [<Ref: DotSegment>, <Ref: DotSegment>]>]]
DEBUG      [PD:4  MD:6 ]	......ColumnReferenceSegment                      	Ref.match OUT       	+   	[match=<MatchResult 1/2: '.'>, seg="'.value'"]
DEBUG      [PD:4  MD:7 ]	.......ColumnReferenceSegment                     	Ref.match OUT       	+   	[match=<MatchResult 1/2: '.'>, seg="'.value'"]
DEBUG      [PD:4  MD:7 ]	.......ColumnReferenceSegment                     	Ref.match OUT       	    	[match=<MatchResult 0/1: ''>, seg="'value'"]
INFO       [PD:4  MD:6 ]	......ColumnReferenceSegment                      	Seque.match OUT     	    	[match=<MatchResult 0/2: ''>, seg="'.value'"]
INFO       [PD:4  MD:5 ]	.....ColumnReferenceSegment                       	OneOf.match OUT     	+   	[match=<MatchResult 1/2: '.'>, seg="'.value'"]
INFO       [PD:4  MD:5 ]	.....ColumnReferenceSegment                       	OneOf.match PRN     	    	[ns=1, ps=10, ms=0, pruned=[<Ref: OnKeywordSegment>, <Ref: AsKeywordSegment>, <Ref: UsingKeywordSegment>, <Ref: CommaSegment>, <Ref: CastOperatorSegment>, <Ref: StartSquareBracketSegment>, <Ref: StartBracketSegment>, <Ref: ColonSegment>, <Ref: DelimiterSegment>, <class 'sqlfluff.core.parser.segments.base.BracketedSegment'>], opts=[<Ref: BinaryOperatorGrammar>]]
INFO       [PD:4  MD:6 ]	......BinaryOperatorGrammar                       	OneOf.match PRN     	    	[ns=1, ps=3, ms=0, pruned=[<Ref: ArithmeticBinaryOperatorGrammar>, <Ref: StringBinaryOperatorGrammar>, <Ref: BooleanBinaryOperatorGrammar>], opts=[<Ref: ComparisonOperatorGrammar>]]
INFO       [PD:4  MD:7 ]	.......ComparisonOperatorGrammar                  	OneOf.match PRN     	    	[ns=1, ps=7, ms=0, pruned=[<Ref: EqualsSegment>, <Ref: GreaterThanSegment>, <Ref: LessThanSegment>, <Ref: GreaterThanOrEqualToSegment>, <Ref: LessThanOrEqualToSegment>, <Ref: NotEqualToSegment_a>, <Ref: NotEqualToSegment_b>], opts=[<Ref: LikeOperatorSegment>]]
DEBUG      [PD:4  MD:8 ]	........ComparisonOperatorGrammar                 	Ref.match OUT       	    	[match=<MatchResult 0/3: ''>, seg="'b.value'"]
INFO       [PD:4  MD:7 ]	.......ComparisonOperatorGrammar                  	OneOf.match OUT     	    	[match=<MatchResult 0/3: ''>, seg="'b.value'"]
DEBUG      [PD:4  MD:7 ]	.......BinaryOperatorGrammar                      	Ref.match OUT       	    	[match=<MatchResult 0/3: ''>, seg="'b.value'"]
INFO       [PD:4  MD:6 ]	......BinaryOperatorGrammar                       	OneOf.match OUT     	    	[match=<MatchResult 0/3: ''>, seg="'b.value'"]
DEBUG      [PD:4  MD:6 ]	......ColumnReferenceSegment                      	Ref.match OUT       	    	[match=<MatchResult 0/3: ''>, seg="'b.value'"]
INFO       [PD:4  MD:5 ]	.....ColumnReferenceSegment                       	OneOf.match OUT     	    	[match=<MatchResult 0/3: ''>, seg="'b.value'"]
DEBUG      [PD:4  MD:5 ]	.....ColumnReferenceSegment                       	NonCo.match OUT     	    	[match=<MatchResult 0/3: ''>, seg="'b.value'"]
INFO       [PD:4  MD:5 ]	.....ColumnReferenceSegment                       	OneOf.match PRN     	    	[ns=1, ps=10, ms=0, pruned=[<Ref: OnKeywordSegment>, <Ref: AsKeywordSegment>, <Ref: UsingKeywordSegment>, <Ref: CommaSegment>, <Ref: CastOperatorSegment>, <Ref: StartSquareBracketSegment>, <Ref: StartBracketSegment>, <Ref: ColonSegment>, <Ref: DelimiterSegment>, <class 'sqlfluff.core.parser.segments.base.BracketedSegment'>], opts=[<Ref: BinaryOperatorGrammar>]]
INFO       [PD:4  MD:6 ]	......BinaryOperatorGrammar                       	OneOf.match PRN     	    	[ns=1, ps=3, ms=0, pruned=[<Ref: ArithmeticBinaryOperatorGrammar>, <Ref: StringBinaryOperatorGrammar>, <Ref: BooleanBinaryOperatorGrammar>], opts=[<Ref: ComparisonOperatorGrammar>]]
INFO       [PD:4  MD:7 ]	.......ComparisonOperatorGrammar                  	OneOf.match PRN     	    	[ns=1, ps=7, ms=0, pruned=[<Ref: EqualsSegment>, <Ref: GreaterThanSegment>, <Ref: LessThanSegment>, <Ref: GreaterThanOrEqualToSegment>, <Ref: LessThanOrEqualToSegment>, <Ref: NotEqualToSegment_a>, <Ref: NotEqualToSegment_b>], opts=[<Ref: LikeOperatorSegment>]]
DEBUG      [PD:4  MD:8 ]	........ComparisonOperatorGrammar                 	Ref.match OUT       	    	[match=<MatchResult 0/2: ''>, seg="'.value'"]
INFO       [PD:4  MD:7 ]	.......ComparisonOperatorGrammar                  	OneOf.match OUT     	    	[match=<MatchResult 0/2: ''>, seg="'.value'"]
DEBUG      [PD:4  MD:7 ]	.......BinaryOperatorGrammar                      	Ref.match OUT       	    	[match=<MatchResult 0/2: ''>, seg="'.value'"]
INFO       [PD:4  MD:6 ]	......BinaryOperatorGrammar                       	OneOf.match OUT     	    	[match=<MatchResult 0/2: ''>, seg="'.value'"]
DEBUG      [PD:4  MD:6 ]	......ColumnReferenceSegment                      	Ref.match OUT       	    	[match=<MatchResult 0/2: ''>, seg="'.value'"]
INFO       [PD:4  MD:5 ]	.....ColumnReferenceSegment                       	OneOf.match OUT     	    	[match=<MatchResult 0/2: ''>, seg="'.value'"]
DEBUG      [PD:4  MD:5 ]	.....ColumnReferenceSegment                       	NonCo.match OUT     	    	[match=<MatchResult 0/2: ''>, seg="'.value'"]
INFO       [PD:4  MD:5 ]	.....SingleIdentifierGrammar                      	OneOf.match PRN     	    	[ns=2, ps=0, ms=0, pruned=[], opts=[<Ref: NakedIdentifierSegment>, <Ref: QuotedIdentifierSegment>]]
DEBUG      [PD:4  MD:6 ]	......SingleIdentifierGrammar                     	Ref.match OUT       	++  	[match=<MatchResult 1/1: 'b'>, seg="'b'"]
INFO       [PD:4  MD:5 ]	.....SingleIdentifierGrammar                      	OneOf.match OUT     	++  	[match=<MatchResult 1/1: 'b'>, seg="'b'"]
DEBUG      [PD:4  MD:5 ]	.....ColumnReferenceSegment                       	Ref.match OUT       	++  	[match=<MatchResult 1/1: 'b'>, seg="'b'"]
DEBUG      [PD:4  MD:5 ]	.....ColumnReferenceSegment                       	Delim._look_ahead_match IN	    	[ls=1, seg='value']
DEBUG      [PD:4  MD:5 ]	.....ColumnReferenceSegment                       	Delim._look_ahead_match SI	    	[mq=[], sb=['VALUE']]
INFO       [PD:4  MD:5 ]	.....ColumnReferenceSegment                       	OneOf.match PRN     	    	[ns=1, ps=10, ms=0, pruned=[<Ref: OnKeywordSegment>, <Ref: AsKeywordSegment>, <Ref: UsingKeywordSegment>, <Ref: CommaSegment>, <Ref: CastOperatorSegment>, <Ref: StartSquareBracketSegment>, <Ref: StartBracketSegment>, <Ref: ColonSegment>, <Ref: DelimiterSegment>, <class 'sqlfluff.core.parser.segments.base.BracketedSegment'>], opts=[<Ref: BinaryOperatorGrammar>]]
INFO       [PD:4  MD:6 ]	......BinaryOperatorGrammar                       	OneOf.match PRN     	    	[ns=1, ps=3, ms=0, pruned=[<Ref: ArithmeticBinaryOperatorGrammar>, <Ref: StringBinaryOperatorGrammar>, <Ref: BooleanBinaryOperatorGrammar>], opts=[<Ref: ComparisonOperatorGrammar>]]
INFO       [PD:4  MD:7 ]	.......ComparisonOperatorGrammar                  	OneOf.match PRN     	    	[ns=1, ps=7, ms=0, pruned=[<Ref: EqualsSegment>, <Ref: GreaterThanSegment>, <Ref: LessThanSegment>, <Ref: GreaterThanOrEqualToSegment>, <Ref: LessThanOrEqualToSegment>, <Ref: NotEqualToSegment_a>, <Ref: NotEqualToSegment_b>], opts=[<Ref: LikeOperatorSegment>]]
DEBUG      [PD:4  MD:8 ]	........ComparisonOperatorGrammar                 	Ref.match OUT       	    	[match=<MatchResult 0/1: ''>, seg="'value'"]
INFO       [PD:4  MD:7 ]	.......ComparisonOperatorGrammar                  	OneOf.match OUT     	    	[match=<MatchResult 0/1: ''>, seg="'value'"]
DEBUG      [PD:4  MD:7 ]	.......BinaryOperatorGrammar                      	Ref.match OUT       	    	[match=<MatchResult 0/1: ''>, seg="'value'"]
INFO       [PD:4  MD:6 ]	......BinaryOperatorGrammar                       	OneOf.match OUT     	    	[match=<MatchResult 0/1: ''>, seg="'value'"]
DEBUG      [PD:4  MD:6 ]	......ColumnReferenceSegment                      	Ref.match OUT       	    	[match=<MatchResult 0/1: ''>, seg="'value'"]
INFO       [PD:4  MD:5 ]	.....ColumnReferenceSegment                       	OneOf.match OUT     	    	[match=<MatchResult 0/1: ''>, seg="'value'"]
DEBUG      [PD:4  MD:5 ]	.....ColumnReferenceSegment                       	NonCo.match OUT     	    	[match=<MatchResult 0/1: ''>, seg="'value'"]
INFO       [PD:4  MD:5 ]	.....SingleIdentifierGrammar                      	OneOf.match PRN     	    	[ns=2, ps=0, ms=0, pruned=[], opts=[<Ref: NakedIdentifierSegment>, <Ref: QuotedIdentifierSegment>]]
DEBUG      [PD:4  MD:6 ]	......SingleIdentifierGrammar                     	Ref.match OUT       	++  	[match=<MatchResult 1/1: 'value'>, seg="'value'"]
INFO       [PD:4  MD:5 ]	.....SingleIdentifierGrammar                      	OneOf.match OUT     	++  	[match=<MatchResult 1/1: 'value'>, seg="'value'"]
DEBUG      [PD:4  MD:5 ]	.....ColumnReferenceSegment                       	Ref.match OUT       	++  	[match=<MatchResult 1/1: 'value'>, seg="'value'"]
INFO       [PD:4  MD:4 ]	....ColumnReferenceSegment                        	Delim.match OUT     	++  	[match=<MatchResult 3/3: 'b.value'>, seg="'b.value'"]
DEBUG      [PD:4  MD:3 ]	...ColumnReferenceSegment                         	Colum.match OUT     	++  	[match=<MatchResult 1/1: 'b.value'>, seg="'b.value'"]
DEBUG      [PD:4  MD:3 ]	...BaseExpressionElementGrammar                   	Ref.match OUT       	++  	[match=<MatchResult 1/1: 'b.value'>, seg="'b.value'"]
INFO       [PD:4  MD:2 ]	..BaseExpressionElementGrammar                    	OneOf.match OUT     	++  	[match=<MatchResult 1/1: 'b.value'>, seg="'b.value'"]
DEBUG      [PD:4  MD:2 ]	..SelectClauseElementSegment                      	Ref.match OUT       	++  	[match=<MatchResult 1/1: 'b.value'>, seg="'b.value'"]
INFO       [PD:4  MD:1 ]	.SelectClauseElementSegment                       	Seque.match OUT     	++  	[match=<MatchResult 1/1: 'b.value'>, seg="'b.value'"]
INFO       [PD:4  MD:0 ]	SelectClauseElementSegment                        	OneOf.match OUT     	++  	[match=<MatchResult 1/1: 'b.value'>, seg="'b.value'"]
DEBUG      SelectClauseElementSegment.parse: Done Parse. Plotting Recursion. Recurse=True
DEBUG      ###
#
# Beginning Parse Depth 5: SelectClauseElementSegment
#
###
Initial Structure:
[L:  3, P:  5]      |select_clause_element:
[L:  3, P:  5]      |    column_reference:
[L:  3, P:  5]      |        identifier:                                           'b'
[L:  3, P:  6]      |        dot:                                                  '.'
[L:  3, P:  7]      |        identifier:                                           'value'

INFO       [PD:5] Skipping expansion of <ColumnReferenceSegment: ([L:  3, P:  5])>...
INFO       [PD:4] Skipping expansion of <SymbolSegment: ([L:  3, P: 12]) ','>...
INFO       [PD:4] Skipping expansion of <NewlineSegment: ([L:  3, P: 13]) '\n'>...
INFO       [PD:4] Skipping expansion of <WhitespaceSegment: ([L:  4, P:  1]) '    '>...
INFO       [PD:4] Skipping expansion of <CommentSegment: ([L:  4, P:  5]) '/*'>...
INFO       [PD:4] Skipping expansion of <NewlineSegment: ([L:  4, P:  7]) '\n'>...
INFO       [PD:4] Skipping expansion of <WhitespaceSegment: ([L:  5, P:  1]) '    '>...
INFO       [PD:4] Skipping expansion of <CommentSegment: ([L:  5, P:  5]) 'This is a block comment'>...
INFO       [PD:4] Skipping expansion of <NewlineSegment: ([L:  5, P: 28]) '\n'>...
INFO       [PD:4] Skipping expansion of <WhitespaceSegment: ([L:  6, P:  1]) '    '>...
INFO       [PD:4] Skipping expansion of <CommentSegment: ([L:  6, P:  5]) '*/'>...
INFO       [PD:4] Skipping expansion of <NewlineSegment: ([L:  6, P:  7]) '\n'>...
INFO       [PD:4] Skipping expansion of <WhitespaceSegment: ([L:  7, P:  1]) '    '>...
INFO       
###
#
# Parse Depth 4. Expanding: SelectClauseElementSegment: 'd.something'
#
###
INFO       [PD:4  MD:0 ]	SelectClauseElementSegment                        	OneOf.match PRN     	    	[ns=2, ps=0, ms=0, pruned=[], opts=[<Ref: WildcardExpressionSegment>, <Sequence: [<Ref: BaseExpressionElementGrammar>, <Ref: AliasExpressionSegment [opt]>]>]]
INFO       [PD:4  MD:5 ]	.....WildcardIdentifierSegment                    	AnyNu.match PRN     	    	[ns=1, ps=0, ms=0, pruned=[], opts=[<Sequence: [<Ref: SingleIdentifierGrammar>, <Ref: DotSegment>]>]]
INFO       [PD:4  MD:7 ]	.......SingleIdentifierGrammar                    	OneOf.match PRN     	    	[ns=2, ps=0, ms=0, pruned=[], opts=[<Ref: NakedIdentifierSegment>, <Ref: QuotedIdentifierSegment>]]
DEBUG      [PD:4  MD:8 ]	........SingleIdentifierGrammar                   	Ref.match OUT       	+   	[match=<MatchResult 1/3: 'd'>, seg="'d.something'"]
DEBUG      [PD:4  MD:8 ]	........SingleIdentifierGrammar                   	Ref.match OUT       	    	[match=<MatchResult 0/3: ''>, seg="'d.something'"]
INFO       [PD:4  MD:7 ]	.......SingleIdentifierGrammar                    	OneOf.match OUT     	+   	[match=<MatchResult 1/3: 'd'>, seg="'d.something'"]
DEBUG      [PD:4  MD:7 ]	.......WildcardIdentifierSegment                  	Ref.match OUT       	+   	[match=<MatchResult 1/3: 'd'>, seg="'d.something'"]
DEBUG      [PD:4  MD:7 ]	.......WildcardIdentifierSegment                  	Ref.match OUT       	+   	[match=<MatchResult 1/2: '.'>, seg="'.something'"]
INFO       [PD:4  MD:6 ]	......WildcardIdentifierSegment                   	Seque.match OUT     	+   	[match=<MatchResult 2/3: 'd.'>, seg="'d.something'"]
INFO       [PD:4  MD:5 ]	.....WildcardIdentifierSegment                    	AnyNu.match PRN     	    	[ns=1, ps=0, ms=0, pruned=[], opts=[<Sequence: [<Ref: SingleIdentifierGrammar>, <Ref: DotSegment>]>]]
INFO       [PD:4  MD:7 ]	.......SingleIdentifierGrammar                    	OneOf.match PRN     	    	[ns=2, ps=0, ms=0, pruned=[], opts=[<Ref: NakedIdentifierSegment>, <Ref: QuotedIdentifierSegment>]]
DEBUG      [PD:4  MD:8 ]	........SingleIdentifierGrammar                   	Ref.match OUT       	++  	[match=<MatchResult 1/1: 'something'>, seg="'something'"]
INFO       [PD:4  MD:7 ]	.......SingleIdentifierGrammar                    	OneOf.match OUT     	++  	[match=<MatchResult 1/1: 'something'>, seg="'something'"]
DEBUG      [PD:4  MD:7 ]	.......WildcardIdentifierSegment                  	Ref.match OUT       	++  	[match=<MatchResult 1/1: 'something'>, seg="'something'"]
INFO       [PD:4  MD:6 ]	......WildcardIdentifierSegment                   	Seque.match OUT     	    	[match=<MatchResult 0/1: ''>, seg="'something'"]
INFO       [PD:4  MD:5 ]	.....WildcardIdentifierSegment                    	AnyNu.match OUT     	+   	[match=<MatchResult 2/3: 'd.'>, seg="'d.something'"]
DEBUG      [PD:4  MD:5 ]	.....WildcardIdentifierSegment                    	Ref.match OUT       	    	[match=<MatchResult 0/1: ''>, seg="'something'"]
INFO       [PD:4  MD:4 ]	....WildcardIdentifierSegment                     	Seque.match OUT     	    	[match=<MatchResult 0/3: ''>, seg="'d.something'"]
DEBUG      [PD:4  MD:3 ]	...WildcardIdentifierSegment                      	Wildc.match OUT     	    	[match=<MatchResult 0/3: ''>, seg="'d.something'"]
DEBUG      [PD:4  MD:3 ]	...WildcardExpressionSegment                      	Ref.match OUT       	    	[match=<MatchResult 0/3: ''>, seg="'d.something'"]
INFO       [PD:4  MD:2 ]	..WildcardExpressionSegment                       	Seque.match OUT     	    	[match=<MatchResult 0/3: ''>, seg="'d.something'"]
DEBUG      [PD:4  MD:1 ]	.WildcardExpressionSegment                        	Wildc.match OUT     	    	[match=<MatchResult 0/3: ''>, seg="'d.something'"]
DEBUG      [PD:4  MD:1 ]	.SelectClauseElementSegment                       	Ref.match OUT       	    	[match=<MatchResult 0/3: ''>, seg="'d.something'"]
INFO       [PD:4  MD:2 ]	..BaseExpressionElementGrammar                    	OneOf.match PRN     	    	[ns=5, ps=1, ms=0, pruned=[<Ref: IntervalExpressionSegment>], opts=[<Ref: LiteralGrammar>, <Ref: BareFunctionSegment>, <Ref: FunctionSegment>, <Ref: ColumnReferenceSegment>, <Ref: ExpressionSegment>]]
INFO       [PD:4  MD:3 ]	...LiteralGrammar                                 	OneOf.match PRN     	    	[ns=2, ps=4, ms=0, pruned=[<Ref: BooleanLiteralGrammar>, <Ref: QualifiedNumericLiteralSegment>, <Ref: NullLiteralSegment>, <Ref: DateTimeLiteralGrammar>], opts=[<Ref: QuotedLiteralSegment>, <Ref: NumericLiteralSegment>]]
DEBUG      [PD:4  MD:4 ]	....LiteralGrammar                                	Ref.match OUT       	    	[match=<MatchResult 0/3: ''>, seg="'d.something'"]
DEBUG      [PD:4  MD:4 ]	....LiteralGrammar                                	Ref.match OUT       	    	[match=<MatchResult 0/3: ''>, seg="'d.something'"]
INFO       [PD:4  MD:3 ]	...LiteralGrammar                                 	OneOf.match OUT     	    	[match=<MatchResult 0/3: ''>, seg="'d.something'"]
DEBUG      [PD:4  MD:3 ]	...BaseExpressionElementGrammar                   	Ref.match OUT       	    	[match=<MatchResult 0/3: ''>, seg="'d.something'"]
DEBUG      [PD:4  MD:3 ]	...BaseExpressionElementGrammar                   	Ref.match OUT       	    	[match=<MatchResult 0/3: ''>, seg="'d.something'"]
INFO       [PD:4  MD:4 ]	....FunctionSegment                               	OneOf.match PRN     	    	[ns=1, ps=1, ms=0, pruned=[<Sequence: [<Sequence: [<Ref: DateAddFunctionNameSeg...]>], opts=[<Sequence: [<Sequence: [<AnyNumberOf: [<Ref: Functio..., <Ref: PostFunctionGrammar [opt]>]>]]
DEBUG      [PD:4  MD:10]	..........DateAddFunctionNameSegment              	Ref.match OUT       	    	[match=<MatchResult 0/3: ''>, seg="'d.something'"]
INFO       [PD:4  MD:9 ]	.........DateAddFunctionNameSegment               	Seque.match OUT     	    	[match=<MatchResult 0/3: ''>, seg="'d.something'"]
DEBUG      [PD:4  MD:8 ]	........DateAddFunctionNameSegment                	DateA.match OUT     	    	[match=<MatchResult 0/3: ''>, seg="'d.something'"]
DEBUG      [PD:4  MD:8 ]	........FunctionSegment                           	Ref.match OUT       	    	[match=<MatchResult 0/3: ''>, seg="'d.something'"]
INFO       [PD:4  MD:7 ]	.......FunctionSegment                            	AnyNu.match PRN     	    	[ns=1, ps=0, ms=0, pruned=[], opts=[<Ref: FunctionNameSegment>]]
INFO       [PD:4  MD:10]	..........FunctionNameSegment                     	AnyNu.match PRN     	    	[ns=1, ps=0, ms=0, pruned=[], opts=[<Sequence: [<Ref: SingleIdentifierGrammar>, <Ref: DotSegment>]>]]
INFO       [PD:4  MD:12]	............SingleIdentifierGrammar               	OneOf.match PRN     	    	[ns=2, ps=0, ms=0, pruned=[], opts=[<Ref: NakedIdentifierSegment>, <Ref: QuotedIdentifierSegment>]]
DEBUG      [PD:4  MD:13]	.............SingleIdentifierGrammar              	Ref.match OUT       	+   	[match=<MatchResult 1/3: 'd'>, seg="'d.something'"]
DEBUG      [PD:4  MD:13]	.............SingleIdentifierGrammar              	Ref.match OUT       	    	[match=<MatchResult 0/3: ''>, seg="'d.something'"]
INFO       [PD:4  MD:12]	............SingleIdentifierGrammar               	OneOf.match OUT     	+   	[match=<MatchResult 1/3: 'd'>, seg="'d.something'"]
DEBUG      [PD:4  MD:12]	............FunctionNameSegment                   	Ref.match OUT       	+   	[match=<MatchResult 1/3: 'd'>, seg="'d.something'"]
DEBUG      [PD:4  MD:12]	............FunctionNameSegment                   	Ref.match OUT       	+   	[match=<MatchResult 1/2: '.'>, seg="'.something'"]
INFO       [PD:4  MD:11]	...........FunctionNameSegment                    	Seque.match OUT     	+   	[match=<MatchResult 2/3: 'd.'>, seg="'d.something'"]
INFO       [PD:4  MD:10]	..........FunctionNameSegment                     	AnyNu.match PRN     	    	[ns=1, ps=0, ms=0, pruned=[], opts=[<Sequence: [<Ref: SingleIdentifierGrammar>, <Ref: DotSegment>]>]]
INFO       [PD:4  MD:12]	............SingleIdentifierGrammar               	OneOf.match PRN     	    	[ns=2, ps=0, ms=0, pruned=[], opts=[<Ref: NakedIdentifierSegment>, <Ref: QuotedIdentifierSegment>]]
DEBUG      [PD:4  MD:13]	.............SingleIdentifierGrammar              	Ref.match OUT       	++  	[match=<MatchResult 1/1: 'something'>, seg="'something'"]
INFO       [PD:4  MD:12]	............SingleIdentifierGrammar               	OneOf.match OUT     	++  	[match=<MatchResult 1/1: 'something'>, seg="'something'"]
DEBUG      [PD:4  MD:12]	............FunctionNameSegment                   	Ref.match OUT       	++  	[match=<MatchResult 1/1: 'something'>, seg="'something'"]
INFO       [PD:4  MD:11]	...........FunctionNameSegment                    	Seque.match OUT     	    	[match=<MatchResult 0/1: ''>, seg="'something'"]
INFO       [PD:4  MD:10]	..........FunctionNameSegment                     	AnyNu.match OUT     	+   	[match=<MatchResult 2/3: 'd.'>, seg="'d.something'"]
INFO       [PD:4  MD:10]	..........FunctionNameSegment                     	OneOf.match PRN     	    	[ns=2, ps=0, ms=0, pruned=[], opts=[<Ref: FunctionNameIdentifierSegment>, <Ref: QuotedIdentifierSegment>]]
DEBUG      [PD:4  MD:11]	...........FunctionNameSegment                    	Ref.match OUT       	++  	[match=<MatchResult 1/1: 'something'>, seg="'something'"]
INFO       [PD:4  MD:10]	..........FunctionNameSegment                     	OneOf.match OUT     	++  	[match=<MatchResult 1/1: 'something'>, seg="'something'"]
INFO       [PD:4  MD:9 ]	.........FunctionNameSegment                      	Seque.match OUT     	++  	[match=<MatchResult 3/3: 'd.something'>, seg="'d.something'"]
DEBUG      [PD:4  MD:8 ]	........FunctionNameSegment                       	Funct.match OUT     	++  	[match=<MatchResult 1/1: 'd.something'>, seg="'d.something'"]
DEBUG      [PD:4  MD:8 ]	........FunctionSegment                           	Ref.match OUT       	++  	[match=<MatchResult 1/1: 'd.something'>, seg="'d.something'"]
INFO       [PD:4  MD:7 ]	.......FunctionSegment                            	AnyNu.match OUT     	++  	[match=<MatchResult 1/1: 'd.something'>, seg="'d.something'"]
INFO       [PD:4  MD:6 ]	......FunctionSegment                             	Seque.match OUT     	    	[match=<MatchResult 0/3: ''>, seg="'d.something'"]
INFO       [PD:4  MD:5 ]	.....FunctionSegment                              	Seque.match OUT     	    	[match=<MatchResult 0/3: ''>, seg="'d.something'"]
INFO       [PD:4  MD:4 ]	....FunctionSegment                               	OneOf.match OUT     	    	[match=<MatchResult 0/3: ''>, seg="'d.something'"]
DEBUG      [PD:4  MD:3 ]	...FunctionSegment                                	Funct.match OUT     	    	[match=<MatchResult 0/3: ''>, seg="'d.something'"]
DEBUG      [PD:4  MD:3 ]	...BaseExpressionElementGrammar                   	Ref.match OUT       	    	[match=<MatchResult 0/3: ''>, seg="'d.something'"]
DEBUG      [PD:4  MD:5 ]	.....ColumnReferenceSegment                       	Delim._look_ahead_match IN	    	[ls=3, seg='d.something']
DEBUG      [PD:4  MD:5 ]	.....ColumnReferenceSegment                       	Delim._look_ahead_match SI	    	[mq=[(<OneOf: [<Ref: DotSegment>, <Sequence: [<Ref: DotSegment>, <Ref: Dot...]>, 1, '.'), (<OneOf: [<Ref: DotSegment>, <Sequence: [<Ref: DotSegment>, <Ref: Dot...]>, 1, '.')], sb=['D', '.', 'SOMETHING']]
INFO       [PD:4  MD:5 ]	.....ColumnReferenceSegment                       	OneOf.match PRN     	    	[ns=0, ps=0, ms=2, pruned=[], opts=[<Ref: DotSegment>, <Sequence: [<Ref: DotSegment>, <Ref: DotSegment>]>]]
DEBUG      [PD:4  MD:6 ]	......ColumnReferenceSegment                      	Ref.match OUT       	+   	[match=<MatchResult 1/2: '.'>, seg="'.something'"]
DEBUG      [PD:4  MD:7 ]	.......ColumnReferenceSegment                     	Ref.match OUT       	+   	[match=<MatchResult 1/2: '.'>, seg="'.something'"]
DEBUG      [PD:4  MD:7 ]	.......ColumnReferenceSegment                     	Ref.match OUT       	    	[match=<MatchResult 0/1: ''>, seg="'something'"]
INFO       [PD:4  MD:6 ]	......ColumnReferenceSegment                      	Seque.match OUT     	    	[match=<MatchResult 0/2: ''>, seg="'.something'"]
INFO       [PD:4  MD:5 ]	.....ColumnReferenceSegment                       	OneOf.match OUT     	+   	[match=<MatchResult 1/2: '.'>, seg="'.something'"]
INFO       [PD:4  MD:5 ]	.....ColumnReferenceSegment                       	OneOf.match PRN     	    	[ns=0, ps=0, ms=2, pruned=[], opts=[<Ref: DotSegment>, <Sequence: [<Ref: DotSegment>, <Ref: DotSegment>]>]]
DEBUG      [PD:4  MD:6 ]	......ColumnReferenceSegment                      	Ref.match OUT       	+   	[match=<MatchResult 1/2: '.'>, seg="'.something'"]
DEBUG      [PD:4  MD:7 ]	.......ColumnReferenceSegment                     	Ref.match OUT       	+   	[match=<MatchResult 1/2: '.'>, seg="'.something'"]
DEBUG      [PD:4  MD:7 ]	.......ColumnReferenceSegment                     	Ref.match OUT       	    	[match=<MatchResult 0/1: ''>, seg="'something'"]
INFO       [PD:4  MD:6 ]	......ColumnReferenceSegment                      	Seque.match OUT     	    	[match=<MatchResult 0/2: ''>, seg="'.something'"]
INFO       [PD:4  MD:5 ]	.....ColumnReferenceSegment                       	OneOf.match OUT     	+   	[match=<MatchResult 1/2: '.'>, seg="'.something'"]
INFO       [PD:4  MD:5 ]	.....ColumnReferenceSegment                       	OneOf.match PRN     	    	[ns=1, ps=10, ms=0, pruned=[<Ref: OnKeywordSegment>, <Ref: AsKeywordSegment>, <Ref: UsingKeywordSegment>, <Ref: CommaSegment>, <Ref: CastOperatorSegment>, <Ref: StartSquareBracketSegment>, <Ref: StartBracketSegment>, <Ref: ColonSegment>, <Ref: DelimiterSegment>, <class 'sqlfluff.core.parser.segments.base.BracketedSegment'>], opts=[<Ref: BinaryOperatorGrammar>]]
INFO       [PD:4  MD:6 ]	......BinaryOperatorGrammar                       	OneOf.match PRN     	    	[ns=1, ps=3, ms=0, pruned=[<Ref: ArithmeticBinaryOperatorGrammar>, <Ref: StringBinaryOperatorGrammar>, <Ref: BooleanBinaryOperatorGrammar>], opts=[<Ref: ComparisonOperatorGrammar>]]
INFO       [PD:4  MD:7 ]	.......ComparisonOperatorGrammar                  	OneOf.match PRN     	    	[ns=1, ps=7, ms=0, pruned=[<Ref: EqualsSegment>, <Ref: GreaterThanSegment>, <Ref: LessThanSegment>, <Ref: GreaterThanOrEqualToSegment>, <Ref: LessThanOrEqualToSegment>, <Ref: NotEqualToSegment_a>, <Ref: NotEqualToSegment_b>], opts=[<Ref: LikeOperatorSegment>]]
DEBUG      [PD:4  MD:8 ]	........ComparisonOperatorGrammar                 	Ref.match OUT       	    	[match=<MatchResult 0/3: ''>, seg="'d.something'"]
INFO       [PD:4  MD:7 ]	.......ComparisonOperatorGrammar                  	OneOf.match OUT     	    	[match=<MatchResult 0/3: ''>, seg="'d.something'"]
DEBUG      [PD:4  MD:7 ]	.......BinaryOperatorGrammar                      	Ref.match OUT       	    	[match=<MatchResult 0/3: ''>, seg="'d.something'"]
INFO       [PD:4  MD:6 ]	......BinaryOperatorGrammar                       	OneOf.match OUT     	    	[match=<MatchResult 0/3: ''>, seg="'d.something'"]
DEBUG      [PD:4  MD:6 ]	......ColumnReferenceSegment                      	Ref.match OUT       	    	[match=<MatchResult 0/3: ''>, seg="'d.something'"]
INFO       [PD:4  MD:5 ]	.....ColumnReferenceSegment                       	OneOf.match OUT     	    	[match=<MatchResult 0/3: ''>, seg="'d.something'"]
DEBUG      [PD:4  MD:5 ]	.....ColumnReferenceSegment                       	NonCo.match OUT     	    	[match=<MatchResult 0/3: ''>, seg="'d.something'"]
INFO       [PD:4  MD:5 ]	.....ColumnReferenceSegment                       	OneOf.match PRN     	    	[ns=1, ps=10, ms=0, pruned=[<Ref: OnKeywordSegment>, <Ref: AsKeywordSegment>, <Ref: UsingKeywordSegment>, <Ref: CommaSegment>, <Ref: CastOperatorSegment>, <Ref: StartSquareBracketSegment>, <Ref: StartBracketSegment>, <Ref: ColonSegment>, <Ref: DelimiterSegment>, <class 'sqlfluff.core.parser.segments.base.BracketedSegment'>], opts=[<Ref: BinaryOperatorGrammar>]]
INFO       [PD:4  MD:6 ]	......BinaryOperatorGrammar                       	OneOf.match PRN     	    	[ns=1, ps=3, ms=0, pruned=[<Ref: ArithmeticBinaryOperatorGrammar>, <Ref: StringBinaryOperatorGrammar>, <Ref: BooleanBinaryOperatorGrammar>], opts=[<Ref: ComparisonOperatorGrammar>]]
INFO       [PD:4  MD:7 ]	.......ComparisonOperatorGrammar                  	OneOf.match PRN     	    	[ns=1, ps=7, ms=0, pruned=[<Ref: EqualsSegment>, <Ref: GreaterThanSegment>, <Ref: LessThanSegment>, <Ref: GreaterThanOrEqualToSegment>, <Ref: LessThanOrEqualToSegment>, <Ref: NotEqualToSegment_a>, <Ref: NotEqualToSegment_b>], opts=[<Ref: LikeOperatorSegment>]]
DEBUG      [PD:4  MD:8 ]	........ComparisonOperatorGrammar                 	Ref.match OUT       	    	[match=<MatchResult 0/2: ''>, seg="'.something'"]
INFO       [PD:4  MD:7 ]	.......ComparisonOperatorGrammar                  	OneOf.match OUT     	    	[match=<MatchResult 0/2: ''>, seg="'.something'"]
DEBUG      [PD:4  MD:7 ]	.......BinaryOperatorGrammar                      	Ref.match OUT       	    	[match=<MatchResult 0/2: ''>, seg="'.something'"]
INFO       [PD:4  MD:6 ]	......BinaryOperatorGrammar                       	OneOf.match OUT     	    	[match=<MatchResult 0/2: ''>, seg="'.something'"]
DEBUG      [PD:4  MD:6 ]	......ColumnReferenceSegment                      	Ref.match OUT       	    	[match=<MatchResult 0/2: ''>, seg="'.something'"]
INFO       [PD:4  MD:5 ]	.....ColumnReferenceSegment                       	OneOf.match OUT     	    	[match=<MatchResult 0/2: ''>, seg="'.something'"]
DEBUG      [PD:4  MD:5 ]	.....ColumnReferenceSegment                       	NonCo.match OUT     	    	[match=<MatchResult 0/2: ''>, seg="'.something'"]
INFO       [PD:4  MD:5 ]	.....SingleIdentifierGrammar                      	OneOf.match PRN     	    	[ns=2, ps=0, ms=0, pruned=[], opts=[<Ref: NakedIdentifierSegment>, <Ref: QuotedIdentifierSegment>]]
DEBUG      [PD:4  MD:6 ]	......SingleIdentifierGrammar                     	Ref.match OUT       	++  	[match=<MatchResult 1/1: 'd'>, seg="'d'"]
INFO       [PD:4  MD:5 ]	.....SingleIdentifierGrammar                      	OneOf.match OUT     	++  	[match=<MatchResult 1/1: 'd'>, seg="'d'"]
DEBUG      [PD:4  MD:5 ]	.....ColumnReferenceSegment                       	Ref.match OUT       	++  	[match=<MatchResult 1/1: 'd'>, seg="'d'"]
DEBUG      [PD:4  MD:5 ]	.....ColumnReferenceSegment                       	Delim._look_ahead_match IN	    	[ls=1, seg='something']
DEBUG      [PD:4  MD:5 ]	.....ColumnReferenceSegment                       	Delim._look_ahead_match SI	    	[mq=[], sb=['SOMETHING']]
INFO       [PD:4  MD:5 ]	.....ColumnReferenceSegment                       	OneOf.match PRN     	    	[ns=1, ps=10, ms=0, pruned=[<Ref: OnKeywordSegment>, <Ref: AsKeywordSegment>, <Ref: UsingKeywordSegment>, <Ref: CommaSegment>, <Ref: CastOperatorSegment>, <Ref: StartSquareBracketSegment>, <Ref: StartBracketSegment>, <Ref: ColonSegment>, <Ref: DelimiterSegment>, <class 'sqlfluff.core.parser.segments.base.BracketedSegment'>], opts=[<Ref: BinaryOperatorGrammar>]]
INFO       [PD:4  MD:6 ]	......BinaryOperatorGrammar                       	OneOf.match PRN     	    	[ns=1, ps=3, ms=0, pruned=[<Ref: ArithmeticBinaryOperatorGrammar>, <Ref: StringBinaryOperatorGrammar>, <Ref: BooleanBinaryOperatorGrammar>], opts=[<Ref: ComparisonOperatorGrammar>]]
INFO       [PD:4  MD:7 ]	.......ComparisonOperatorGrammar                  	OneOf.match PRN     	    	[ns=1, ps=7, ms=0, pruned=[<Ref: EqualsSegment>, <Ref: GreaterThanSegment>, <Ref: LessThanSegment>, <Ref: GreaterThanOrEqualToSegment>, <Ref: LessThanOrEqualToSegment>, <Ref: NotEqualToSegment_a>, <Ref: NotEqualToSegment_b>], opts=[<Ref: LikeOperatorSegment>]]
DEBUG      [PD:4  MD:8 ]	........ComparisonOperatorGrammar                 	Ref.match OUT       	    	[match=<MatchResult 0/1: ''>, seg="'something'"]
INFO       [PD:4  MD:7 ]	.......ComparisonOperatorGrammar                  	OneOf.match OUT     	    	[match=<MatchResult 0/1: ''>, seg="'something'"]
DEBUG      [PD:4  MD:7 ]	.......BinaryOperatorGrammar                      	Ref.match OUT       	    	[match=<MatchResult 0/1: ''>, seg="'something'"]
INFO       [PD:4  MD:6 ]	......BinaryOperatorGrammar                       	OneOf.match OUT     	    	[match=<MatchResult 0/1: ''>, seg="'something'"]
DEBUG      [PD:4  MD:6 ]	......ColumnReferenceSegment                      	Ref.match OUT       	    	[match=<MatchResult 0/1: ''>, seg="'something'"]
INFO       [PD:4  MD:5 ]	.....ColumnReferenceSegment                       	OneOf.match OUT     	    	[match=<MatchResult 0/1: ''>, seg="'something'"]
DEBUG      [PD:4  MD:5 ]	.....ColumnReferenceSegment                       	NonCo.match OUT     	    	[match=<MatchResult 0/1: ''>, seg="'something'"]
INFO       [PD:4  MD:5 ]	.....SingleIdentifierGrammar                      	OneOf.match PRN     	    	[ns=2, ps=0, ms=0, pruned=[], opts=[<Ref: NakedIdentifierSegment>, <Ref: QuotedIdentifierSegment>]]
DEBUG      [PD:4  MD:6 ]	......SingleIdentifierGrammar                     	Ref.match OUT       	++  	[match=<MatchResult 1/1: 'something'>, seg="'something'"]
INFO       [PD:4  MD:5 ]	.....SingleIdentifierGrammar                      	OneOf.match OUT     	++  	[match=<MatchResult 1/1: 'something'>, seg="'something'"]
DEBUG      [PD:4  MD:5 ]	.....ColumnReferenceSegment                       	Ref.match OUT       	++  	[match=<MatchResult 1/1: 'something'>, seg="'something'"]
INFO       [PD:4  MD:4 ]	....ColumnReferenceSegment                        	Delim.match OUT     	++  	[match=<MatchResult 3/3: 'd.something'>, seg="'d.something'"]
DEBUG      [PD:4  MD:3 ]	...ColumnReferenceSegment                         	Colum.match OUT     	++  	[match=<MatchResult 1/1: 'd.something'>, seg="'d.something'"]
DEBUG      [PD:4  MD:3 ]	...BaseExpressionElementGrammar                   	Ref.match OUT       	++  	[match=<MatchResult 1/1: 'd.something'>, seg="'d.something'"]
INFO       [PD:4  MD:2 ]	..BaseExpressionElementGrammar                    	OneOf.match OUT     	++  	[match=<MatchResult 1/1: 'd.something'>, seg="'d.something'"]
DEBUG      [PD:4  MD:2 ]	..SelectClauseElementSegment                      	Ref.match OUT       	++  	[match=<MatchResult 1/1: 'd.something'>, seg="'d.something'"]
INFO       [PD:4  MD:1 ]	.SelectClauseElementSegment                       	Seque.match OUT     	++  	[match=<MatchResult 1/1: 'd.something'>, seg="'d.something'"]
INFO       [PD:4  MD:0 ]	SelectClauseElementSegment                        	OneOf.match OUT     	++  	[match=<MatchResult 1/1: 'd.something'>, seg="'d.something'"]
DEBUG      SelectClauseElementSegment.parse: Done Parse. Plotting Recursion. Recurse=True
DEBUG      ###
#
# Beginning Parse Depth 5: SelectClauseElementSegment
#
###
Initial Structure:
[L:  7, P:  5]      |select_clause_element:
[L:  7, P:  5]      |    column_reference:
[L:  7, P:  5]      |        identifier:                                           'd'
[L:  7, P:  6]      |        dot:                                                  '.'
[L:  7, P:  7]      |        identifier:                                           'something'

INFO       [PD:5] Skipping expansion of <ColumnReferenceSegment: ([L:  7, P:  5])>...
INFO       [PD:4] Skipping expansion of <SymbolSegment: ([L:  7, P: 16]) ','>...
INFO       [PD:4] Skipping expansion of <WhitespaceSegment: ([L:  7, P: 17]) '    '>...
INFO       [PD:4] Skipping expansion of <CommentSegment: ([L:  7, P: 21]) '-- Which a comment after it'>...
INFO       [PD:4] Skipping expansion of <NewlineSegment: ([L:  7, P: 48]) '\n'>...
INFO       [PD:4] Skipping expansion of <WhitespaceSegment: ([L:  8, P:  1]) '    '>...
INFO       
###
#
# Parse Depth 4. Expanding: SelectClauseElementSegment: 'tbl.foo'
#
###
INFO       [PD:4  MD:0 ]	SelectClauseElementSegment                        	OneOf.match PRN     	    	[ns=2, ps=0, ms=0, pruned=[], opts=[<Ref: WildcardExpressionSegment>, <Sequence: [<Ref: BaseExpressionElementGrammar>, <Ref: AliasExpressionSegment [opt]>]>]]
INFO       [PD:4  MD:5 ]	.....WildcardIdentifierSegment                    	AnyNu.match PRN     	    	[ns=1, ps=0, ms=0, pruned=[], opts=[<Sequence: [<Ref: SingleIdentifierGrammar>, <Ref: DotSegment>]>]]
INFO       [PD:4  MD:7 ]	.......SingleIdentifierGrammar                    	OneOf.match PRN     	    	[ns=2, ps=0, ms=0, pruned=[], opts=[<Ref: NakedIdentifierSegment>, <Ref: QuotedIdentifierSegment>]]
DEBUG      [PD:4  MD:8 ]	........SingleIdentifierGrammar                   	Ref.match OUT       	+   	[match=<MatchResult 1/3: 'tbl'>, seg="'tbl.foo'"]
DEBUG      [PD:4  MD:8 ]	........SingleIdentifierGrammar                   	Ref.match OUT       	    	[match=<MatchResult 0/3: ''>, seg="'tbl.foo'"]
INFO       [PD:4  MD:7 ]	.......SingleIdentifierGrammar                    	OneOf.match OUT     	+   	[match=<MatchResult 1/3: 'tbl'>, seg="'tbl.foo'"]
DEBUG      [PD:4  MD:7 ]	.......WildcardIdentifierSegment                  	Ref.match OUT       	+   	[match=<MatchResult 1/3: 'tbl'>, seg="'tbl.foo'"]
DEBUG      [PD:4  MD:7 ]	.......WildcardIdentifierSegment                  	Ref.match OUT       	+   	[match=<MatchResult 1/2: '.'>, seg="'.foo'"]
INFO       [PD:4  MD:6 ]	......WildcardIdentifierSegment                   	Seque.match OUT     	+   	[match=<MatchResult 2/3: 'tbl.'>, seg="'tbl.foo'"]
INFO       [PD:4  MD:5 ]	.....WildcardIdentifierSegment                    	AnyNu.match PRN     	    	[ns=1, ps=0, ms=0, pruned=[], opts=[<Sequence: [<Ref: SingleIdentifierGrammar>, <Ref: DotSegment>]>]]
INFO       [PD:4  MD:7 ]	.......SingleIdentifierGrammar                    	OneOf.match PRN     	    	[ns=2, ps=0, ms=0, pruned=[], opts=[<Ref: NakedIdentifierSegment>, <Ref: QuotedIdentifierSegment>]]
DEBUG      [PD:4  MD:8 ]	........SingleIdentifierGrammar                   	Ref.match OUT       	++  	[match=<MatchResult 1/1: 'foo'>, seg="'foo'"]
INFO       [PD:4  MD:7 ]	.......SingleIdentifierGrammar                    	OneOf.match OUT     	++  	[match=<MatchResult 1/1: 'foo'>, seg="'foo'"]
DEBUG      [PD:4  MD:7 ]	.......WildcardIdentifierSegment                  	Ref.match OUT       	++  	[match=<MatchResult 1/1: 'foo'>, seg="'foo'"]
INFO       [PD:4  MD:6 ]	......WildcardIdentifierSegment                   	Seque.match OUT     	    	[match=<MatchResult 0/1: ''>, seg="'foo'"]
INFO       [PD:4  MD:5 ]	.....WildcardIdentifierSegment                    	AnyNu.match OUT     	+   	[match=<MatchResult 2/3: 'tbl.'>, seg="'tbl.foo'"]
DEBUG      [PD:4  MD:5 ]	.....WildcardIdentifierSegment                    	Ref.match OUT       	    	[match=<MatchResult 0/1: ''>, seg="'foo'"]
INFO       [PD:4  MD:4 ]	....WildcardIdentifierSegment                     	Seque.match OUT     	    	[match=<MatchResult 0/3: ''>, seg="'tbl.foo'"]
DEBUG      [PD:4  MD:3 ]	...WildcardIdentifierSegment                      	Wildc.match OUT     	    	[match=<MatchResult 0/3: ''>, seg="'tbl.foo'"]
DEBUG      [PD:4  MD:3 ]	...WildcardExpressionSegment                      	Ref.match OUT       	    	[match=<MatchResult 0/3: ''>, seg="'tbl.foo'"]
INFO       [PD:4  MD:2 ]	..WildcardExpressionSegment                       	Seque.match OUT     	    	[match=<MatchResult 0/3: ''>, seg="'tbl.foo'"]
DEBUG      [PD:4  MD:1 ]	.WildcardExpressionSegment                        	Wildc.match OUT     	    	[match=<MatchResult 0/3: ''>, seg="'tbl.foo'"]
DEBUG      [PD:4  MD:1 ]	.SelectClauseElementSegment                       	Ref.match OUT       	    	[match=<MatchResult 0/3: ''>, seg="'tbl.foo'"]
INFO       [PD:4  MD:2 ]	..BaseExpressionElementGrammar                    	OneOf.match PRN     	    	[ns=5, ps=1, ms=0, pruned=[<Ref: IntervalExpressionSegment>], opts=[<Ref: LiteralGrammar>, <Ref: BareFunctionSegment>, <Ref: FunctionSegment>, <Ref: ColumnReferenceSegment>, <Ref: ExpressionSegment>]]
INFO       [PD:4  MD:3 ]	...LiteralGrammar                                 	OneOf.match PRN     	    	[ns=2, ps=4, ms=0, pruned=[<Ref: BooleanLiteralGrammar>, <Ref: QualifiedNumericLiteralSegment>, <Ref: NullLiteralSegment>, <Ref: DateTimeLiteralGrammar>], opts=[<Ref: QuotedLiteralSegment>, <Ref: NumericLiteralSegment>]]
DEBUG      [PD:4  MD:4 ]	....LiteralGrammar                                	Ref.match OUT       	    	[match=<MatchResult 0/3: ''>, seg="'tbl.foo'"]
DEBUG      [PD:4  MD:4 ]	....LiteralGrammar                                	Ref.match OUT       	    	[match=<MatchResult 0/3: ''>, seg="'tbl.foo'"]
INFO       [PD:4  MD:3 ]	...LiteralGrammar                                 	OneOf.match OUT     	    	[match=<MatchResult 0/3: ''>, seg="'tbl.foo'"]
DEBUG      [PD:4  MD:3 ]	...BaseExpressionElementGrammar                   	Ref.match OUT       	    	[match=<MatchResult 0/3: ''>, seg="'tbl.foo'"]
DEBUG      [PD:4  MD:3 ]	...BaseExpressionElementGrammar                   	Ref.match OUT       	    	[match=<MatchResult 0/3: ''>, seg="'tbl.foo'"]
INFO       [PD:4  MD:4 ]	....FunctionSegment                               	OneOf.match PRN     	    	[ns=1, ps=1, ms=0, pruned=[<Sequence: [<Sequence: [<Ref: DateAddFunctionNameSeg...]>], opts=[<Sequence: [<Sequence: [<AnyNumberOf: [<Ref: Functio..., <Ref: PostFunctionGrammar [opt]>]>]]
DEBUG      [PD:4  MD:10]	..........DateAddFunctionNameSegment              	Ref.match OUT       	    	[match=<MatchResult 0/3: ''>, seg="'tbl.foo'"]
INFO       [PD:4  MD:9 ]	.........DateAddFunctionNameSegment               	Seque.match OUT     	    	[match=<MatchResult 0/3: ''>, seg="'tbl.foo'"]
DEBUG      [PD:4  MD:8 ]	........DateAddFunctionNameSegment                	DateA.match OUT     	    	[match=<MatchResult 0/3: ''>, seg="'tbl.foo'"]
DEBUG      [PD:4  MD:8 ]	........FunctionSegment                           	Ref.match OUT       	    	[match=<MatchResult 0/3: ''>, seg="'tbl.foo'"]
INFO       [PD:4  MD:7 ]	.......FunctionSegment                            	AnyNu.match PRN     	    	[ns=1, ps=0, ms=0, pruned=[], opts=[<Ref: FunctionNameSegment>]]
INFO       [PD:4  MD:10]	..........FunctionNameSegment                     	AnyNu.match PRN     	    	[ns=1, ps=0, ms=0, pruned=[], opts=[<Sequence: [<Ref: SingleIdentifierGrammar>, <Ref: DotSegment>]>]]
INFO       [PD:4  MD:12]	............SingleIdentifierGrammar               	OneOf.match PRN     	    	[ns=2, ps=0, ms=0, pruned=[], opts=[<Ref: NakedIdentifierSegment>, <Ref: QuotedIdentifierSegment>]]
DEBUG      [PD:4  MD:13]	.............SingleIdentifierGrammar              	Ref.match OUT       	+   	[match=<MatchResult 1/3: 'tbl'>, seg="'tbl.foo'"]
DEBUG      [PD:4  MD:13]	.............SingleIdentifierGrammar              	Ref.match OUT       	    	[match=<MatchResult 0/3: ''>, seg="'tbl.foo'"]
INFO       [PD:4  MD:12]	............SingleIdentifierGrammar               	OneOf.match OUT     	+   	[match=<MatchResult 1/3: 'tbl'>, seg="'tbl.foo'"]
DEBUG      [PD:4  MD:12]	............FunctionNameSegment                   	Ref.match OUT       	+   	[match=<MatchResult 1/3: 'tbl'>, seg="'tbl.foo'"]
DEBUG      [PD:4  MD:12]	............FunctionNameSegment                   	Ref.match OUT       	+   	[match=<MatchResult 1/2: '.'>, seg="'.foo'"]
INFO       [PD:4  MD:11]	...........FunctionNameSegment                    	Seque.match OUT     	+   	[match=<MatchResult 2/3: 'tbl.'>, seg="'tbl.foo'"]
INFO       [PD:4  MD:10]	..........FunctionNameSegment                     	AnyNu.match PRN     	    	[ns=1, ps=0, ms=0, pruned=[], opts=[<Sequence: [<Ref: SingleIdentifierGrammar>, <Ref: DotSegment>]>]]
INFO       [PD:4  MD:12]	............SingleIdentifierGrammar               	OneOf.match PRN     	    	[ns=2, ps=0, ms=0, pruned=[], opts=[<Ref: NakedIdentifierSegment>, <Ref: QuotedIdentifierSegment>]]
DEBUG      [PD:4  MD:13]	.............SingleIdentifierGrammar              	Ref.match OUT       	++  	[match=<MatchResult 1/1: 'foo'>, seg="'foo'"]
INFO       [PD:4  MD:12]	............SingleIdentifierGrammar               	OneOf.match OUT     	++  	[match=<MatchResult 1/1: 'foo'>, seg="'foo'"]
DEBUG      [PD:4  MD:12]	............FunctionNameSegment                   	Ref.match OUT       	++  	[match=<MatchResult 1/1: 'foo'>, seg="'foo'"]
INFO       [PD:4  MD:11]	...........FunctionNameSegment                    	Seque.match OUT     	    	[match=<MatchResult 0/1: ''>, seg="'foo'"]
INFO       [PD:4  MD:10]	..........FunctionNameSegment                     	AnyNu.match OUT     	+   	[match=<MatchResult 2/3: 'tbl.'>, seg="'tbl.foo'"]
INFO       [PD:4  MD:10]	..........FunctionNameSegment                     	OneOf.match PRN     	    	[ns=2, ps=0, ms=0, pruned=[], opts=[<Ref: FunctionNameIdentifierSegment>, <Ref: QuotedIdentifierSegment>]]
DEBUG      [PD:4  MD:11]	...........FunctionNameSegment                    	Ref.match OUT       	++  	[match=<MatchResult 1/1: 'foo'>, seg="'foo'"]
INFO       [PD:4  MD:10]	..........FunctionNameSegment                     	OneOf.match OUT     	++  	[match=<MatchResult 1/1: 'foo'>, seg="'foo'"]
INFO       [PD:4  MD:9 ]	.........FunctionNameSegment                      	Seque.match OUT     	++  	[match=<MatchResult 3/3: 'tbl.foo'>, seg="'tbl.foo'"]
DEBUG      [PD:4  MD:8 ]	........FunctionNameSegment                       	Funct.match OUT     	++  	[match=<MatchResult 1/1: 'tbl.foo'>, seg="'tbl.foo'"]
DEBUG      [PD:4  MD:8 ]	........FunctionSegment                           	Ref.match OUT       	++  	[match=<MatchResult 1/1: 'tbl.foo'>, seg="'tbl.foo'"]
INFO       [PD:4  MD:7 ]	.......FunctionSegment                            	AnyNu.match OUT     	++  	[match=<MatchResult 1/1: 'tbl.foo'>, seg="'tbl.foo'"]
INFO       [PD:4  MD:6 ]	......FunctionSegment                             	Seque.match OUT     	    	[match=<MatchResult 0/3: ''>, seg="'tbl.foo'"]
INFO       [PD:4  MD:5 ]	.....FunctionSegment                              	Seque.match OUT     	    	[match=<MatchResult 0/3: ''>, seg="'tbl.foo'"]
INFO       [PD:4  MD:4 ]	....FunctionSegment                               	OneOf.match OUT     	    	[match=<MatchResult 0/3: ''>, seg="'tbl.foo'"]
DEBUG      [PD:4  MD:3 ]	...FunctionSegment                                	Funct.match OUT     	    	[match=<MatchResult 0/3: ''>, seg="'tbl.foo'"]
DEBUG      [PD:4  MD:3 ]	...BaseExpressionElementGrammar                   	Ref.match OUT       	    	[match=<MatchResult 0/3: ''>, seg="'tbl.foo'"]
DEBUG      [PD:4  MD:5 ]	.....ColumnReferenceSegment                       	Delim._look_ahead_match IN	    	[ls=3, seg='tbl.foo']
DEBUG      [PD:4  MD:5 ]	.....ColumnReferenceSegment                       	Delim._look_ahead_match SI	    	[mq=[(<OneOf: [<Ref: DotSegment>, <Sequence: [<Ref: DotSegment>, <Ref: Dot...]>, 1, '.'), (<OneOf: [<Ref: DotSegment>, <Sequence: [<Ref: DotSegment>, <Ref: Dot...]>, 1, '.')], sb=['TBL', '.', 'FOO']]
INFO       [PD:4  MD:5 ]	.....ColumnReferenceSegment                       	OneOf.match PRN     	    	[ns=0, ps=0, ms=2, pruned=[], opts=[<Ref: DotSegment>, <Sequence: [<Ref: DotSegment>, <Ref: DotSegment>]>]]
DEBUG      [PD:4  MD:6 ]	......ColumnReferenceSegment                      	Ref.match OUT       	+   	[match=<MatchResult 1/2: '.'>, seg="'.foo'"]
DEBUG      [PD:4  MD:7 ]	.......ColumnReferenceSegment                     	Ref.match OUT       	+   	[match=<MatchResult 1/2: '.'>, seg="'.foo'"]
DEBUG      [PD:4  MD:7 ]	.......ColumnReferenceSegment                     	Ref.match OUT       	    	[match=<MatchResult 0/1: ''>, seg="'foo'"]
INFO       [PD:4  MD:6 ]	......ColumnReferenceSegment                      	Seque.match OUT     	    	[match=<MatchResult 0/2: ''>, seg="'.foo'"]
INFO       [PD:4  MD:5 ]	.....ColumnReferenceSegment                       	OneOf.match OUT     	+   	[match=<MatchResult 1/2: '.'>, seg="'.foo'"]
INFO       [PD:4  MD:5 ]	.....ColumnReferenceSegment                       	OneOf.match PRN     	    	[ns=0, ps=0, ms=2, pruned=[], opts=[<Ref: DotSegment>, <Sequence: [<Ref: DotSegment>, <Ref: DotSegment>]>]]
DEBUG      [PD:4  MD:6 ]	......ColumnReferenceSegment                      	Ref.match OUT       	+   	[match=<MatchResult 1/2: '.'>, seg="'.foo'"]
DEBUG      [PD:4  MD:7 ]	.......ColumnReferenceSegment                     	Ref.match OUT       	+   	[match=<MatchResult 1/2: '.'>, seg="'.foo'"]
DEBUG      [PD:4  MD:7 ]	.......ColumnReferenceSegment                     	Ref.match OUT       	    	[match=<MatchResult 0/1: ''>, seg="'foo'"]
INFO       [PD:4  MD:6 ]	......ColumnReferenceSegment                      	Seque.match OUT     	    	[match=<MatchResult 0/2: ''>, seg="'.foo'"]
INFO       [PD:4  MD:5 ]	.....ColumnReferenceSegment                       	OneOf.match OUT     	+   	[match=<MatchResult 1/2: '.'>, seg="'.foo'"]
INFO       [PD:4  MD:5 ]	.....ColumnReferenceSegment                       	OneOf.match PRN     	    	[ns=1, ps=10, ms=0, pruned=[<Ref: OnKeywordSegment>, <Ref: AsKeywordSegment>, <Ref: UsingKeywordSegment>, <Ref: CommaSegment>, <Ref: CastOperatorSegment>, <Ref: StartSquareBracketSegment>, <Ref: StartBracketSegment>, <Ref: ColonSegment>, <Ref: DelimiterSegment>, <class 'sqlfluff.core.parser.segments.base.BracketedSegment'>], opts=[<Ref: BinaryOperatorGrammar>]]
INFO       [PD:4  MD:6 ]	......BinaryOperatorGrammar                       	OneOf.match PRN     	    	[ns=1, ps=3, ms=0, pruned=[<Ref: ArithmeticBinaryOperatorGrammar>, <Ref: StringBinaryOperatorGrammar>, <Ref: BooleanBinaryOperatorGrammar>], opts=[<Ref: ComparisonOperatorGrammar>]]
INFO       [PD:4  MD:7 ]	.......ComparisonOperatorGrammar                  	OneOf.match PRN     	    	[ns=1, ps=7, ms=0, pruned=[<Ref: EqualsSegment>, <Ref: GreaterThanSegment>, <Ref: LessThanSegment>, <Ref: GreaterThanOrEqualToSegment>, <Ref: LessThanOrEqualToSegment>, <Ref: NotEqualToSegment_a>, <Ref: NotEqualToSegment_b>], opts=[<Ref: LikeOperatorSegment>]]
DEBUG      [PD:4  MD:8 ]	........ComparisonOperatorGrammar                 	Ref.match OUT       	    	[match=<MatchResult 0/3: ''>, seg="'tbl.foo'"]
INFO       [PD:4  MD:7 ]	.......ComparisonOperatorGrammar                  	OneOf.match OUT     	    	[match=<MatchResult 0/3: ''>, seg="'tbl.foo'"]
DEBUG      [PD:4  MD:7 ]	.......BinaryOperatorGrammar                      	Ref.match OUT       	    	[match=<MatchResult 0/3: ''>, seg="'tbl.foo'"]
INFO       [PD:4  MD:6 ]	......BinaryOperatorGrammar                       	OneOf.match OUT     	    	[match=<MatchResult 0/3: ''>, seg="'tbl.foo'"]
DEBUG      [PD:4  MD:6 ]	......ColumnReferenceSegment                      	Ref.match OUT       	    	[match=<MatchResult 0/3: ''>, seg="'tbl.foo'"]
INFO       [PD:4  MD:5 ]	.....ColumnReferenceSegment                       	OneOf.match OUT     	    	[match=<MatchResult 0/3: ''>, seg="'tbl.foo'"]
DEBUG      [PD:4  MD:5 ]	.....ColumnReferenceSegment                       	NonCo.match OUT     	    	[match=<MatchResult 0/3: ''>, seg="'tbl.foo'"]
INFO       [PD:4  MD:5 ]	.....ColumnReferenceSegment                       	OneOf.match PRN     	    	[ns=1, ps=10, ms=0, pruned=[<Ref: OnKeywordSegment>, <Ref: AsKeywordSegment>, <Ref: UsingKeywordSegment>, <Ref: CommaSegment>, <Ref: CastOperatorSegment>, <Ref: StartSquareBracketSegment>, <Ref: StartBracketSegment>, <Ref: ColonSegment>, <Ref: DelimiterSegment>, <class 'sqlfluff.core.parser.segments.base.BracketedSegment'>], opts=[<Ref: BinaryOperatorGrammar>]]
INFO       [PD:4  MD:6 ]	......BinaryOperatorGrammar                       	OneOf.match PRN     	    	[ns=1, ps=3, ms=0, pruned=[<Ref: ArithmeticBinaryOperatorGrammar>, <Ref: StringBinaryOperatorGrammar>, <Ref: BooleanBinaryOperatorGrammar>], opts=[<Ref: ComparisonOperatorGrammar>]]
INFO       [PD:4  MD:7 ]	.......ComparisonOperatorGrammar                  	OneOf.match PRN     	    	[ns=1, ps=7, ms=0, pruned=[<Ref: EqualsSegment>, <Ref: GreaterThanSegment>, <Ref: LessThanSegment>, <Ref: GreaterThanOrEqualToSegment>, <Ref: LessThanOrEqualToSegment>, <Ref: NotEqualToSegment_a>, <Ref: NotEqualToSegment_b>], opts=[<Ref: LikeOperatorSegment>]]
DEBUG      [PD:4  MD:8 ]	........ComparisonOperatorGrammar                 	Ref.match OUT       	    	[match=<MatchResult 0/2: ''>, seg="'.foo'"]
INFO       [PD:4  MD:7 ]	.......ComparisonOperatorGrammar                  	OneOf.match OUT     	    	[match=<MatchResult 0/2: ''>, seg="'.foo'"]
DEBUG      [PD:4  MD:7 ]	.......BinaryOperatorGrammar                      	Ref.match OUT       	    	[match=<MatchResult 0/2: ''>, seg="'.foo'"]
INFO       [PD:4  MD:6 ]	......BinaryOperatorGrammar                       	OneOf.match OUT     	    	[match=<MatchResult 0/2: ''>, seg="'.foo'"]
DEBUG      [PD:4  MD:6 ]	......ColumnReferenceSegment                      	Ref.match OUT       	    	[match=<MatchResult 0/2: ''>, seg="'.foo'"]
INFO       [PD:4  MD:5 ]	.....ColumnReferenceSegment                       	OneOf.match OUT     	    	[match=<MatchResult 0/2: ''>, seg="'.foo'"]
DEBUG      [PD:4  MD:5 ]	.....ColumnReferenceSegment                       	NonCo.match OUT     	    	[match=<MatchResult 0/2: ''>, seg="'.foo'"]
INFO       [PD:4  MD:5 ]	.....SingleIdentifierGrammar                      	OneOf.match PRN     	    	[ns=2, ps=0, ms=0, pruned=[], opts=[<Ref: NakedIdentifierSegment>, <Ref: QuotedIdentifierSegment>]]
DEBUG      [PD:4  MD:6 ]	......SingleIdentifierGrammar                     	Ref.match OUT       	++  	[match=<MatchResult 1/1: 'tbl'>, seg="'tbl'"]
INFO       [PD:4  MD:5 ]	.....SingleIdentifierGrammar                      	OneOf.match OUT     	++  	[match=<MatchResult 1/1: 'tbl'>, seg="'tbl'"]
DEBUG      [PD:4  MD:5 ]	.....ColumnReferenceSegment                       	Ref.match OUT       	++  	[match=<MatchResult 1/1: 'tbl'>, seg="'tbl'"]
DEBUG      [PD:4  MD:5 ]	.....ColumnReferenceSegment                       	Delim._look_ahead_match IN	    	[ls=1, seg='foo']
DEBUG      [PD:4  MD:5 ]	.....ColumnReferenceSegment                       	Delim._look_ahead_match SI	    	[mq=[], sb=['FOO']]
INFO       [PD:4  MD:5 ]	.....ColumnReferenceSegment                       	OneOf.match PRN     	    	[ns=1, ps=10, ms=0, pruned=[<Ref: OnKeywordSegment>, <Ref: AsKeywordSegment>, <Ref: UsingKeywordSegment>, <Ref: CommaSegment>, <Ref: CastOperatorSegment>, <Ref: StartSquareBracketSegment>, <Ref: StartBracketSegment>, <Ref: ColonSegment>, <Ref: DelimiterSegment>, <class 'sqlfluff.core.parser.segments.base.BracketedSegment'>], opts=[<Ref: BinaryOperatorGrammar>]]
INFO       [PD:4  MD:6 ]	......BinaryOperatorGrammar                       	OneOf.match PRN     	    	[ns=1, ps=3, ms=0, pruned=[<Ref: ArithmeticBinaryOperatorGrammar>, <Ref: StringBinaryOperatorGrammar>, <Ref: BooleanBinaryOperatorGrammar>], opts=[<Ref: ComparisonOperatorGrammar>]]
INFO       [PD:4  MD:7 ]	.......ComparisonOperatorGrammar                  	OneOf.match PRN     	    	[ns=1, ps=7, ms=0, pruned=[<Ref: EqualsSegment>, <Ref: GreaterThanSegment>, <Ref: LessThanSegment>, <Ref: GreaterThanOrEqualToSegment>, <Ref: LessThanOrEqualToSegment>, <Ref: NotEqualToSegment_a>, <Ref: NotEqualToSegment_b>], opts=[<Ref: LikeOperatorSegment>]]
DEBUG      [PD:4  MD:8 ]	........ComparisonOperatorGrammar                 	Ref.match OUT       	    	[match=<MatchResult 0/1: ''>, seg="'foo'"]
INFO       [PD:4  MD:7 ]	.......ComparisonOperatorGrammar                  	OneOf.match OUT     	    	[match=<MatchResult 0/1: ''>, seg="'foo'"]
DEBUG      [PD:4  MD:7 ]	.......BinaryOperatorGrammar                      	Ref.match OUT       	    	[match=<MatchResult 0/1: ''>, seg="'foo'"]
INFO       [PD:4  MD:6 ]	......BinaryOperatorGrammar                       	OneOf.match OUT     	    	[match=<MatchResult 0/1: ''>, seg="'foo'"]
DEBUG      [PD:4  MD:6 ]	......ColumnReferenceSegment                      	Ref.match OUT       	    	[match=<MatchResult 0/1: ''>, seg="'foo'"]
INFO       [PD:4  MD:5 ]	.....ColumnReferenceSegment                       	OneOf.match OUT     	    	[match=<MatchResult 0/1: ''>, seg="'foo'"]
DEBUG      [PD:4  MD:5 ]	.....ColumnReferenceSegment                       	NonCo.match OUT     	    	[match=<MatchResult 0/1: ''>, seg="'foo'"]
INFO       [PD:4  MD:5 ]	.....SingleIdentifierGrammar                      	OneOf.match PRN     	    	[ns=2, ps=0, ms=0, pruned=[], opts=[<Ref: NakedIdentifierSegment>, <Ref: QuotedIdentifierSegment>]]
DEBUG      [PD:4  MD:6 ]	......SingleIdentifierGrammar                     	Ref.match OUT       	++  	[match=<MatchResult 1/1: 'foo'>, seg="'foo'"]
INFO       [PD:4  MD:5 ]	.....SingleIdentifierGrammar                      	OneOf.match OUT     	++  	[match=<MatchResult 1/1: 'foo'>, seg="'foo'"]
DEBUG      [PD:4  MD:5 ]	.....ColumnReferenceSegment                       	Ref.match OUT       	++  	[match=<MatchResult 1/1: 'foo'>, seg="'foo'"]
INFO       [PD:4  MD:4 ]	....ColumnReferenceSegment                        	Delim.match OUT     	++  	[match=<MatchResult 3/3: 'tbl.foo'>, seg="'tbl.foo'"]
DEBUG      [PD:4  MD:3 ]	...ColumnReferenceSegment                         	Colum.match OUT     	++  	[match=<MatchResult 1/1: 'tbl.foo'>, seg="'tbl.foo'"]
DEBUG      [PD:4  MD:3 ]	...BaseExpressionElementGrammar                   	Ref.match OUT       	++  	[match=<MatchResult 1/1: 'tbl.foo'>, seg="'tbl.foo'"]
INFO       [PD:4  MD:2 ]	..BaseExpressionElementGrammar                    	OneOf.match OUT     	++  	[match=<MatchResult 1/1: 'tbl.foo'>, seg="'tbl.foo'"]
DEBUG      [PD:4  MD:2 ]	..SelectClauseElementSegment                      	Ref.match OUT       	++  	[match=<MatchResult 1/1: 'tbl.foo'>, seg="'tbl.foo'"]
INFO       [PD:4  MD:1 ]	.SelectClauseElementSegment                       	Seque.match OUT     	++  	[match=<MatchResult 1/1: 'tbl.foo'>, seg="'tbl.foo'"]
INFO       [PD:4  MD:0 ]	SelectClauseElementSegment                        	OneOf.match OUT     	++  	[match=<MatchResult 1/1: 'tbl.foo'>, seg="'tbl.foo'"]
DEBUG      SelectClauseElementSegment.parse: Done Parse. Plotting Recursion. Recurse=True
DEBUG      ###
#
# Beginning Parse Depth 5: SelectClauseElementSegment
#
###
Initial Structure:
[L:  8, P:  5]      |select_clause_element:
[L:  8, P:  5]      |    column_reference:
[L:  8, P:  5]      |        identifier:                                           'tbl'
[L:  8, P:  8]      |        dot:                                                  '.'
[L:  8, P:  9]      |        identifier:                                           'foo'

INFO       [PD:5] Skipping expansion of <ColumnReferenceSegment: ([L:  8, P:  5])>...
INFO       [PD:4] Skipping expansion of <SymbolSegment: ([L:  8, P: 12]) ','>...
INFO       [PD:4] Skipping expansion of <NewlineSegment: ([L:  8, P: 13]) '\n'>...
INFO       [PD:4] Skipping expansion of <WhitespaceSegment: ([L:  9, P:  1]) '    '>...
INFO       
###
#
# Parse Depth 4. Expanding: SelectClauseElementSegment: 'c.val + b.val / -2 AS a_calculation'
#
###
INFO       [PD:4  MD:0 ]	SelectClauseElementSegment                        	OneOf.match PRN     	    	[ns=2, ps=0, ms=0, pruned=[], opts=[<Ref: WildcardExpressionSegment>, <Sequence: [<Ref: BaseExpressionElementGrammar>, <Ref: AliasExpressionSegment [opt]>]>]]
INFO       [PD:4  MD:5 ]	.....WildcardIdentifierSegment                    	AnyNu.match PRN     	    	[ns=1, ps=0, ms=0, pruned=[], opts=[<Sequence: [<Ref: SingleIdentifierGrammar>, <Ref: DotSegment>]>]]
INFO       [PD:4  MD:7 ]	.......SingleIdentifierGrammar                    	OneOf.match PRN     	    	[ns=2, ps=0, ms=0, pruned=[], opts=[<Ref: NakedIdentifierSegment>, <Ref: QuotedIdentifierSegment>]]
DEBUG      [PD:4  MD:8 ]	........SingleIdentifierGrammar                   	Ref.match OUT       	+   	[match=<MatchResult 1/18: 'c'>, seg="'c.val + b.val / -2 A...'"]
DEBUG      [PD:4  MD:8 ]	........SingleIdentifierGrammar                   	Ref.match OUT       	    	[match=<MatchResult 0/18: ''>, seg="'c.val + b.val / -2 A...'"]
INFO       [PD:4  MD:7 ]	.......SingleIdentifierGrammar                    	OneOf.match OUT     	+   	[match=<MatchResult 1/18: 'c'>, seg="'c.val + b.val / -2 A...'"]
DEBUG      [PD:4  MD:7 ]	.......WildcardIdentifierSegment                  	Ref.match OUT       	+   	[match=<MatchResult 1/18: 'c'>, seg="'c.val + b.val / -2 A...'"]
DEBUG      [PD:4  MD:7 ]	.......WildcardIdentifierSegment                  	Ref.match OUT       	+   	[match=<MatchResult 1/17: '.'>, seg="'.val + b.val / -2 AS...'"]
INFO       [PD:4  MD:6 ]	......WildcardIdentifierSegment                   	Seque.match OUT     	+   	[match=<MatchResult 2/18: 'c.'>, seg="'c.val + b.val / -2 A...'"]
INFO       [PD:4  MD:5 ]	.....WildcardIdentifierSegment                    	AnyNu.match PRN     	    	[ns=1, ps=0, ms=0, pruned=[], opts=[<Sequence: [<Ref: SingleIdentifierGrammar>, <Ref: DotSegment>]>]]
INFO       [PD:4  MD:7 ]	.......SingleIdentifierGrammar                    	OneOf.match PRN     	    	[ns=2, ps=0, ms=0, pruned=[], opts=[<Ref: NakedIdentifierSegment>, <Ref: QuotedIdentifierSegment>]]
DEBUG      [PD:4  MD:8 ]	........SingleIdentifierGrammar                   	Ref.match OUT       	+   	[match=<MatchResult 1/16: 'val'>, seg="'val + b.val / -2 AS ...'"]
DEBUG      [PD:4  MD:8 ]	........SingleIdentifierGrammar                   	Ref.match OUT       	    	[match=<MatchResult 0/16: ''>, seg="'val + b.val / -2 AS ...'"]
INFO       [PD:4  MD:7 ]	.......SingleIdentifierGrammar                    	OneOf.match OUT     	+   	[match=<MatchResult 1/16: 'val'>, seg="'val + b.val / -2 AS ...'"]
DEBUG      [PD:4  MD:7 ]	.......WildcardIdentifierSegment                  	Ref.match OUT       	+   	[match=<MatchResult 1/16: 'val'>, seg="'val + b.val / -2 AS ...'"]
DEBUG      [PD:4  MD:7 ]	.......WildcardIdentifierSegment                  	Ref.match OUT       	    	[match=<MatchResult 0/14: ''>, seg="'+ b.val / -2 AS a_ca...'"]
INFO       [PD:4  MD:6 ]	......WildcardIdentifierSegment                   	Seque.match OUT     	    	[match=<MatchResult 0/16: ''>, seg="'val + b.val / -2 AS ...'"]
INFO       [PD:4  MD:5 ]	.....WildcardIdentifierSegment                    	AnyNu.match OUT     	+   	[match=<MatchResult 2/18: 'c.'>, seg="'c.val + b.val / -2 A...'"]
DEBUG      [PD:4  MD:5 ]	.....WildcardIdentifierSegment                    	Ref.match OUT       	    	[match=<MatchResult 0/16: ''>, seg="'val + b.val / -2 AS ...'"]
INFO       [PD:4  MD:4 ]	....WildcardIdentifierSegment                     	Seque.match OUT     	    	[match=<MatchResult 0/18: ''>, seg="'c.val + b.val / -2 A...'"]
DEBUG      [PD:4  MD:3 ]	...WildcardIdentifierSegment                      	Wildc.match OUT     	    	[match=<MatchResult 0/18: ''>, seg="'c.val + b.val / -2 A...'"]
DEBUG      [PD:4  MD:3 ]	...WildcardExpressionSegment                      	Ref.match OUT       	    	[match=<MatchResult 0/18: ''>, seg="'c.val + b.val / -2 A...'"]
INFO       [PD:4  MD:2 ]	..WildcardExpressionSegment                       	Seque.match OUT     	    	[match=<MatchResult 0/18: ''>, seg="'c.val + b.val / -2 A...'"]
DEBUG      [PD:4  MD:1 ]	.WildcardExpressionSegment                        	Wildc.match OUT     	    	[match=<MatchResult 0/18: ''>, seg="'c.val + b.val / -2 A...'"]
DEBUG      [PD:4  MD:1 ]	.SelectClauseElementSegment                       	Ref.match OUT       	    	[match=<MatchResult 0/18: ''>, seg="'c.val + b.val / -2 A...'"]
INFO       [PD:4  MD:2 ]	..BaseExpressionElementGrammar                    	OneOf.match PRN     	    	[ns=5, ps=1, ms=0, pruned=[<Ref: IntervalExpressionSegment>], opts=[<Ref: LiteralGrammar>, <Ref: BareFunctionSegment>, <Ref: FunctionSegment>, <Ref: ColumnReferenceSegment>, <Ref: ExpressionSegment>]]
INFO       [PD:4  MD:3 ]	...LiteralGrammar                                 	OneOf.match PRN     	    	[ns=2, ps=4, ms=0, pruned=[<Ref: BooleanLiteralGrammar>, <Ref: QualifiedNumericLiteralSegment>, <Ref: NullLiteralSegment>, <Ref: DateTimeLiteralGrammar>], opts=[<Ref: QuotedLiteralSegment>, <Ref: NumericLiteralSegment>]]
DEBUG      [PD:4  MD:4 ]	....LiteralGrammar                                	Ref.match OUT       	    	[match=<MatchResult 0/18: ''>, seg="'c.val + b.val / -2 A...'"]
DEBUG      [PD:4  MD:4 ]	....LiteralGrammar                                	Ref.match OUT       	    	[match=<MatchResult 0/18: ''>, seg="'c.val + b.val / -2 A...'"]
INFO       [PD:4  MD:3 ]	...LiteralGrammar                                 	OneOf.match OUT     	    	[match=<MatchResult 0/18: ''>, seg="'c.val + b.val / -2 A...'"]
DEBUG      [PD:4  MD:3 ]	...BaseExpressionElementGrammar                   	Ref.match OUT       	    	[match=<MatchResult 0/18: ''>, seg="'c.val + b.val / -2 A...'"]
DEBUG      [PD:4  MD:3 ]	...BaseExpressionElementGrammar                   	Ref.match OUT       	    	[match=<MatchResult 0/18: ''>, seg="'c.val + b.val / -2 A...'"]
INFO       [PD:4  MD:4 ]	....FunctionSegment                               	OneOf.match PRN     	    	[ns=1, ps=1, ms=0, pruned=[<Sequence: [<Sequence: [<Ref: DateAddFunctionNameSeg...]>], opts=[<Sequence: [<Sequence: [<AnyNumberOf: [<Ref: Functio..., <Ref: PostFunctionGrammar [opt]>]>]]
DEBUG      [PD:4  MD:10]	..........DateAddFunctionNameSegment              	Ref.match OUT       	    	[match=<MatchResult 0/18: ''>, seg="'c.val + b.val / -2 A...'"]
INFO       [PD:4  MD:9 ]	.........DateAddFunctionNameSegment               	Seque.match OUT     	    	[match=<MatchResult 0/18: ''>, seg="'c.val + b.val / -2 A...'"]
DEBUG      [PD:4  MD:8 ]	........DateAddFunctionNameSegment                	DateA.match OUT     	    	[match=<MatchResult 0/18: ''>, seg="'c.val + b.val / -2 A...'"]
DEBUG      [PD:4  MD:8 ]	........FunctionSegment                           	Ref.match OUT       	    	[match=<MatchResult 0/18: ''>, seg="'c.val + b.val / -2 A...'"]
INFO       [PD:4  MD:7 ]	.......FunctionSegment                            	AnyNu.match PRN     	    	[ns=1, ps=0, ms=0, pruned=[], opts=[<Ref: FunctionNameSegment>]]
INFO       [PD:4  MD:10]	..........FunctionNameSegment                     	AnyNu.match PRN     	    	[ns=1, ps=0, ms=0, pruned=[], opts=[<Sequence: [<Ref: SingleIdentifierGrammar>, <Ref: DotSegment>]>]]
INFO       [PD:4  MD:12]	............SingleIdentifierGrammar               	OneOf.match PRN     	    	[ns=2, ps=0, ms=0, pruned=[], opts=[<Ref: NakedIdentifierSegment>, <Ref: QuotedIdentifierSegment>]]
DEBUG      [PD:4  MD:13]	.............SingleIdentifierGrammar              	Ref.match OUT       	+   	[match=<MatchResult 1/18: 'c'>, seg="'c.val + b.val / -2 A...'"]
DEBUG      [PD:4  MD:13]	.............SingleIdentifierGrammar              	Ref.match OUT       	    	[match=<MatchResult 0/18: ''>, seg="'c.val + b.val / -2 A...'"]
INFO       [PD:4  MD:12]	............SingleIdentifierGrammar               	OneOf.match OUT     	+   	[match=<MatchResult 1/18: 'c'>, seg="'c.val + b.val / -2 A...'"]
DEBUG      [PD:4  MD:12]	............FunctionNameSegment                   	Ref.match OUT       	+   	[match=<MatchResult 1/18: 'c'>, seg="'c.val + b.val / -2 A...'"]
DEBUG      [PD:4  MD:12]	............FunctionNameSegment                   	Ref.match OUT       	+   	[match=<MatchResult 1/17: '.'>, seg="'.val + b.val / -2 AS...'"]
INFO       [PD:4  MD:11]	...........FunctionNameSegment                    	Seque.match OUT     	+   	[match=<MatchResult 2/18: 'c.'>, seg="'c.val + b.val / -2 A...'"]
INFO       [PD:4  MD:10]	..........FunctionNameSegment                     	AnyNu.match PRN     	    	[ns=1, ps=0, ms=0, pruned=[], opts=[<Sequence: [<Ref: SingleIdentifierGrammar>, <Ref: DotSegment>]>]]
INFO       [PD:4  MD:12]	............SingleIdentifierGrammar               	OneOf.match PRN     	    	[ns=2, ps=0, ms=0, pruned=[], opts=[<Ref: NakedIdentifierSegment>, <Ref: QuotedIdentifierSegment>]]
DEBUG      [PD:4  MD:13]	.............SingleIdentifierGrammar              	Ref.match OUT       	+   	[match=<MatchResult 1/16: 'val'>, seg="'val + b.val / -2 AS ...'"]
DEBUG      [PD:4  MD:13]	.............SingleIdentifierGrammar              	Ref.match OUT       	    	[match=<MatchResult 0/16: ''>, seg="'val + b.val / -2 AS ...'"]
INFO       [PD:4  MD:12]	............SingleIdentifierGrammar               	OneOf.match OUT     	+   	[match=<MatchResult 1/16: 'val'>, seg="'val + b.val / -2 AS ...'"]
DEBUG      [PD:4  MD:12]	............FunctionNameSegment                   	Ref.match OUT       	+   	[match=<MatchResult 1/16: 'val'>, seg="'val + b.val / -2 AS ...'"]
DEBUG      [PD:4  MD:12]	............FunctionNameSegment                   	Ref.match OUT       	    	[match=<MatchResult 0/14: ''>, seg="'+ b.val / -2 AS a_ca...'"]
INFO       [PD:4  MD:11]	...........FunctionNameSegment                    	Seque.match OUT     	    	[match=<MatchResult 0/16: ''>, seg="'val + b.val / -2 AS ...'"]
INFO       [PD:4  MD:10]	..........FunctionNameSegment                     	AnyNu.match OUT     	+   	[match=<MatchResult 2/18: 'c.'>, seg="'c.val + b.val / -2 A...'"]
INFO       [PD:4  MD:10]	..........FunctionNameSegment                     	OneOf.match PRN     	    	[ns=2, ps=0, ms=0, pruned=[], opts=[<Ref: FunctionNameIdentifierSegment>, <Ref: QuotedIdentifierSegment>]]
DEBUG      [PD:4  MD:11]	...........FunctionNameSegment                    	Ref.match OUT       	+   	[match=<MatchResult 1/16: 'val'>, seg="'val + b.val / -2 AS ...'"]
DEBUG      [PD:4  MD:11]	...........FunctionNameSegment                    	Ref.match OUT       	    	[match=<MatchResult 0/16: ''>, seg="'val + b.val / -2 AS ...'"]
INFO       [PD:4  MD:10]	..........FunctionNameSegment                     	OneOf.match OUT     	+   	[match=<MatchResult 1/16: 'val'>, seg="'val + b.val / -2 AS ...'"]
INFO       [PD:4  MD:9 ]	.........FunctionNameSegment                      	Seque.match OUT     	+   	[match=<MatchResult 3/18: 'c.val'>, seg="'c.val + b.val / -2 A...'"]
DEBUG      [PD:4  MD:8 ]	........FunctionNameSegment                       	Funct.match OUT     	+   	[match=<MatchResult 1/16: 'c.val'>, seg="'c.val + b.val / -2 A...'"]
DEBUG      [PD:4  MD:8 ]	........FunctionSegment                           	Ref.match OUT       	+   	[match=<MatchResult 1/16: 'c.val'>, seg="'c.val + b.val / -2 A...'"]
INFO       [PD:4  MD:7 ]	.......FunctionSegment                            	AnyNu.match OUT     	+   	[match=<MatchResult 1/16: 'c.val'>, seg="'c.val + b.val / -2 A...'"]
INFO       [PD:4  MD:7 ]	.......FunctionSegment                            	Brack.match OUT     	    	[match=<MatchResult 0/14: ''>, seg="'+ b.val / -2 AS a_ca...'"]
INFO       [PD:4  MD:6 ]	......FunctionSegment                             	Seque.match OUT     	    	[match=<MatchResult 0/18: ''>, seg="'c.val + b.val / -2 A...'"]
INFO       [PD:4  MD:5 ]	.....FunctionSegment                              	Seque.match OUT     	    	[match=<MatchResult 0/18: ''>, seg="'c.val + b.val / -2 A...'"]
INFO       [PD:4  MD:4 ]	....FunctionSegment                               	OneOf.match OUT     	    	[match=<MatchResult 0/18: ''>, seg="'c.val + b.val / -2 A...'"]
DEBUG      [PD:4  MD:3 ]	...FunctionSegment                                	Funct.match OUT     	    	[match=<MatchResult 0/18: ''>, seg="'c.val + b.val / -2 A...'"]
DEBUG      [PD:4  MD:3 ]	...BaseExpressionElementGrammar                   	Ref.match OUT       	    	[match=<MatchResult 0/18: ''>, seg="'c.val + b.val / -2 A...'"]
DEBUG      [PD:4  MD:5 ]	.....ColumnReferenceSegment                       	Delim._look_ahead_match IN	    	[ls=18, seg='c.val + b.val / -2 A...']
DEBUG      [PD:4  MD:5 ]	.....ColumnReferenceSegment                       	Delim._look_ahead_match SI	    	[mq=[(<OneOf: [<Ref: DotSegment>, <Sequence: [<Ref: DotSegment>, <Ref: Dot...]>, 1, '.'), (<OneOf: [<Ref: DotSegment>, <Sequence: [<Ref: DotSegment>, <Ref: Dot...]>, 1, '.'), (<OneOf: [<Ref: DotSegment>, <Sequence: [<Ref: DotSegment>, <Ref: Dot...]>, 7, '.'), (<OneOf: [<Ref: DotSegment>, <Sequence: [<Ref: DotSegment>, <Ref: Dot...]>, 7, '.')], sb=['C', '.', 'VAL', '', '+', '', 'B', '.', 'VAL', '', '/', '', '-', '2', '', 'AS', '', 'A_CALCULATION']]
INFO       [PD:4  MD:5 ]	.....ColumnReferenceSegment                       	OneOf.match PRN     	    	[ns=0, ps=0, ms=2, pruned=[], opts=[<Ref: DotSegment>, <Sequence: [<Ref: DotSegment>, <Ref: DotSegment>]>]]
DEBUG      [PD:4  MD:6 ]	......ColumnReferenceSegment                      	Ref.match OUT       	+   	[match=<MatchResult 1/11: '.'>, seg="'.val / -2 AS a_calcu...'"]
DEBUG      [PD:4  MD:7 ]	.......ColumnReferenceSegment                     	Ref.match OUT       	+   	[match=<MatchResult 1/11: '.'>, seg="'.val / -2 AS a_calcu...'"]
DEBUG      [PD:4  MD:7 ]	.......ColumnReferenceSegment                     	Ref.match OUT       	    	[match=<MatchResult 0/10: ''>, seg="'val / -2 AS a_calcul...'"]
INFO       [PD:4  MD:6 ]	......ColumnReferenceSegment                      	Seque.match OUT     	    	[match=<MatchResult 0/11: ''>, seg="'.val / -2 AS a_calcu...'"]
INFO       [PD:4  MD:5 ]	.....ColumnReferenceSegment                       	OneOf.match OUT     	+   	[match=<MatchResult 1/11: '.'>, seg="'.val / -2 AS a_calcu...'"]
INFO       [PD:4  MD:5 ]	.....ColumnReferenceSegment                       	OneOf.match PRN     	    	[ns=0, ps=0, ms=2, pruned=[], opts=[<Ref: DotSegment>, <Sequence: [<Ref: DotSegment>, <Ref: DotSegment>]>]]
DEBUG      [PD:4  MD:6 ]	......ColumnReferenceSegment                      	Ref.match OUT       	+   	[match=<MatchResult 1/11: '.'>, seg="'.val / -2 AS a_calcu...'"]
DEBUG      [PD:4  MD:7 ]	.......ColumnReferenceSegment                     	Ref.match OUT       	+   	[match=<MatchResult 1/11: '.'>, seg="'.val / -2 AS a_calcu...'"]
DEBUG      [PD:4  MD:7 ]	.......ColumnReferenceSegment                     	Ref.match OUT       	    	[match=<MatchResult 0/10: ''>, seg="'val / -2 AS a_calcul...'"]
INFO       [PD:4  MD:6 ]	......ColumnReferenceSegment                      	Seque.match OUT     	    	[match=<MatchResult 0/11: ''>, seg="'.val / -2 AS a_calcu...'"]
INFO       [PD:4  MD:5 ]	.....ColumnReferenceSegment                       	OneOf.match OUT     	+   	[match=<MatchResult 1/11: '.'>, seg="'.val / -2 AS a_calcu...'"]
INFO       [PD:4  MD:5 ]	.....ColumnReferenceSegment                       	OneOf.match PRN     	    	[ns=0, ps=0, ms=2, pruned=[], opts=[<Ref: DotSegment>, <Sequence: [<Ref: DotSegment>, <Ref: DotSegment>]>]]
DEBUG      [PD:4  MD:6 ]	......ColumnReferenceSegment                      	Ref.match OUT       	+   	[match=<MatchResult 1/17: '.'>, seg="'.val + b.val / -2 AS...'"]
DEBUG      [PD:4  MD:7 ]	.......ColumnReferenceSegment                     	Ref.match OUT       	+   	[match=<MatchResult 1/17: '.'>, seg="'.val + b.val / -2 AS...'"]
DEBUG      [PD:4  MD:7 ]	.......ColumnReferenceSegment                     	Ref.match OUT       	    	[match=<MatchResult 0/16: ''>, seg="'val + b.val / -2 AS ...'"]
INFO       [PD:4  MD:6 ]	......ColumnReferenceSegment                      	Seque.match OUT     	    	[match=<MatchResult 0/17: ''>, seg="'.val + b.val / -2 AS...'"]
INFO       [PD:4  MD:5 ]	.....ColumnReferenceSegment                       	OneOf.match OUT     	+   	[match=<MatchResult 1/17: '.'>, seg="'.val + b.val / -2 AS...'"]
INFO       [PD:4  MD:5 ]	.....ColumnReferenceSegment                       	OneOf.match PRN     	    	[ns=0, ps=0, ms=2, pruned=[], opts=[<Ref: DotSegment>, <Sequence: [<Ref: DotSegment>, <Ref: DotSegment>]>]]
DEBUG      [PD:4  MD:6 ]	......ColumnReferenceSegment                      	Ref.match OUT       	+   	[match=<MatchResult 1/17: '.'>, seg="'.val + b.val / -2 AS...'"]
DEBUG      [PD:4  MD:7 ]	.......ColumnReferenceSegment                     	Ref.match OUT       	+   	[match=<MatchResult 1/17: '.'>, seg="'.val + b.val / -2 AS...'"]
DEBUG      [PD:4  MD:7 ]	.......ColumnReferenceSegment                     	Ref.match OUT       	    	[match=<MatchResult 0/16: ''>, seg="'val + b.val / -2 AS ...'"]
INFO       [PD:4  MD:6 ]	......ColumnReferenceSegment                      	Seque.match OUT     	    	[match=<MatchResult 0/17: ''>, seg="'.val + b.val / -2 AS...'"]
INFO       [PD:4  MD:5 ]	.....ColumnReferenceSegment                       	OneOf.match OUT     	+   	[match=<MatchResult 1/17: '.'>, seg="'.val + b.val / -2 AS...'"]
INFO       [PD:4  MD:5 ]	.....ColumnReferenceSegment                       	OneOf.match PRN     	    	[ns=1, ps=10, ms=0, pruned=[<Ref: OnKeywordSegment>, <Ref: AsKeywordSegment>, <Ref: UsingKeywordSegment>, <Ref: CommaSegment>, <Ref: CastOperatorSegment>, <Ref: StartSquareBracketSegment>, <Ref: StartBracketSegment>, <Ref: ColonSegment>, <Ref: DelimiterSegment>, <class 'sqlfluff.core.parser.segments.base.BracketedSegment'>], opts=[<Ref: BinaryOperatorGrammar>]]
INFO       [PD:4  MD:6 ]	......BinaryOperatorGrammar                       	OneOf.match PRN     	    	[ns=1, ps=3, ms=0, pruned=[<Ref: ArithmeticBinaryOperatorGrammar>, <Ref: StringBinaryOperatorGrammar>, <Ref: BooleanBinaryOperatorGrammar>], opts=[<Ref: ComparisonOperatorGrammar>]]
INFO       [PD:4  MD:7 ]	.......ComparisonOperatorGrammar                  	OneOf.match PRN     	    	[ns=1, ps=7, ms=0, pruned=[<Ref: EqualsSegment>, <Ref: GreaterThanSegment>, <Ref: LessThanSegment>, <Ref: GreaterThanOrEqualToSegment>, <Ref: LessThanOrEqualToSegment>, <Ref: NotEqualToSegment_a>, <Ref: NotEqualToSegment_b>], opts=[<Ref: LikeOperatorSegment>]]
DEBUG      [PD:4  MD:8 ]	........ComparisonOperatorGrammar                 	Ref.match OUT       	    	[match=<MatchResult 0/18: ''>, seg="'c.val + b.val / -2 A...'"]
INFO       [PD:4  MD:7 ]	.......ComparisonOperatorGrammar                  	OneOf.match OUT     	    	[match=<MatchResult 0/18: ''>, seg="'c.val + b.val / -2 A...'"]
DEBUG      [PD:4  MD:7 ]	.......BinaryOperatorGrammar                      	Ref.match OUT       	    	[match=<MatchResult 0/18: ''>, seg="'c.val + b.val / -2 A...'"]
INFO       [PD:4  MD:6 ]	......BinaryOperatorGrammar                       	OneOf.match OUT     	    	[match=<MatchResult 0/18: ''>, seg="'c.val + b.val / -2 A...'"]
DEBUG      [PD:4  MD:6 ]	......ColumnReferenceSegment                      	Ref.match OUT       	    	[match=<MatchResult 0/18: ''>, seg="'c.val + b.val / -2 A...'"]
INFO       [PD:4  MD:5 ]	.....ColumnReferenceSegment                       	OneOf.match OUT     	    	[match=<MatchResult 0/18: ''>, seg="'c.val + b.val / -2 A...'"]
DEBUG      [PD:4  MD:5 ]	.....ColumnReferenceSegment                       	NonCo.match OUT     	    	[match=<MatchResult 0/18: ''>, seg="'c.val + b.val / -2 A...'"]
INFO       [PD:4  MD:5 ]	.....ColumnReferenceSegment                       	OneOf.match PRN     	    	[ns=1, ps=10, ms=0, pruned=[<Ref: OnKeywordSegment>, <Ref: AsKeywordSegment>, <Ref: UsingKeywordSegment>, <Ref: CommaSegment>, <Ref: CastOperatorSegment>, <Ref: StartSquareBracketSegment>, <Ref: StartBracketSegment>, <Ref: ColonSegment>, <Ref: DelimiterSegment>, <class 'sqlfluff.core.parser.segments.base.BracketedSegment'>], opts=[<Ref: BinaryOperatorGrammar>]]
INFO       [PD:4  MD:6 ]	......BinaryOperatorGrammar                       	OneOf.match PRN     	    	[ns=1, ps=3, ms=0, pruned=[<Ref: ArithmeticBinaryOperatorGrammar>, <Ref: StringBinaryOperatorGrammar>, <Ref: BooleanBinaryOperatorGrammar>], opts=[<Ref: ComparisonOperatorGrammar>]]
INFO       [PD:4  MD:7 ]	.......ComparisonOperatorGrammar                  	OneOf.match PRN     	    	[ns=1, ps=7, ms=0, pruned=[<Ref: EqualsSegment>, <Ref: GreaterThanSegment>, <Ref: LessThanSegment>, <Ref: GreaterThanOrEqualToSegment>, <Ref: LessThanOrEqualToSegment>, <Ref: NotEqualToSegment_a>, <Ref: NotEqualToSegment_b>], opts=[<Ref: LikeOperatorSegment>]]
DEBUG      [PD:4  MD:8 ]	........ComparisonOperatorGrammar                 	Ref.match OUT       	    	[match=<MatchResult 0/17: ''>, seg="'.val + b.val / -2 AS...'"]
INFO       [PD:4  MD:7 ]	.......ComparisonOperatorGrammar                  	OneOf.match OUT     	    	[match=<MatchResult 0/17: ''>, seg="'.val + b.val / -2 AS...'"]
DEBUG      [PD:4  MD:7 ]	.......BinaryOperatorGrammar                      	Ref.match OUT       	    	[match=<MatchResult 0/17: ''>, seg="'.val + b.val / -2 AS...'"]
INFO       [PD:4  MD:6 ]	......BinaryOperatorGrammar                       	OneOf.match OUT     	    	[match=<MatchResult 0/17: ''>, seg="'.val + b.val / -2 AS...'"]
DEBUG      [PD:4  MD:6 ]	......ColumnReferenceSegment                      	Ref.match OUT       	    	[match=<MatchResult 0/17: ''>, seg="'.val + b.val / -2 AS...'"]
INFO       [PD:4  MD:5 ]	.....ColumnReferenceSegment                       	OneOf.match OUT     	    	[match=<MatchResult 0/17: ''>, seg="'.val + b.val / -2 AS...'"]
DEBUG      [PD:4  MD:5 ]	.....ColumnReferenceSegment                       	NonCo.match OUT     	    	[match=<MatchResult 0/17: ''>, seg="'.val + b.val / -2 AS...'"]
INFO       [PD:4  MD:5 ]	.....SingleIdentifierGrammar                      	OneOf.match PRN     	    	[ns=2, ps=0, ms=0, pruned=[], opts=[<Ref: NakedIdentifierSegment>, <Ref: QuotedIdentifierSegment>]]
DEBUG      [PD:4  MD:6 ]	......SingleIdentifierGrammar                     	Ref.match OUT       	++  	[match=<MatchResult 1/1: 'c'>, seg="'c'"]
INFO       [PD:4  MD:5 ]	.....SingleIdentifierGrammar                      	OneOf.match OUT     	++  	[match=<MatchResult 1/1: 'c'>, seg="'c'"]
DEBUG      [PD:4  MD:5 ]	.....ColumnReferenceSegment                       	Ref.match OUT       	++  	[match=<MatchResult 1/1: 'c'>, seg="'c'"]
DEBUG      [PD:4  MD:5 ]	.....ColumnReferenceSegment                       	Delim._look_ahead_match IN	    	[ls=16, seg='val + b.val / -2 AS ...']
DEBUG      [PD:4  MD:5 ]	.....ColumnReferenceSegment                       	Delim._look_ahead_match SI	    	[mq=[(<OneOf: [<Ref: DotSegment>, <Sequence: [<Ref: DotSegment>, <Ref: Dot...]>, 5, '.'), (<OneOf: [<Ref: DotSegment>, <Sequence: [<Ref: DotSegment>, <Ref: Dot...]>, 5, '.')], sb=['VAL', '', '+', '', 'B', '.', 'VAL', '', '/', '', '-', '2', '', 'AS', '', 'A_CALCULATION']]
INFO       [PD:4  MD:5 ]	.....ColumnReferenceSegment                       	OneOf.match PRN     	    	[ns=0, ps=0, ms=2, pruned=[], opts=[<Ref: DotSegment>, <Sequence: [<Ref: DotSegment>, <Ref: DotSegment>]>]]
DEBUG      [PD:4  MD:6 ]	......ColumnReferenceSegment                      	Ref.match OUT       	+   	[match=<MatchResult 1/11: '.'>, seg="'.val / -2 AS a_calcu...'"]
DEBUG      [PD:4  MD:7 ]	.......ColumnReferenceSegment                     	Ref.match OUT       	+   	[match=<MatchResult 1/11: '.'>, seg="'.val / -2 AS a_calcu...'"]
DEBUG      [PD:4  MD:7 ]	.......ColumnReferenceSegment                     	Ref.match OUT       	    	[match=<MatchResult 0/10: ''>, seg="'val / -2 AS a_calcul...'"]
INFO       [PD:4  MD:6 ]	......ColumnReferenceSegment                      	Seque.match OUT     	    	[match=<MatchResult 0/11: ''>, seg="'.val / -2 AS a_calcu...'"]
INFO       [PD:4  MD:5 ]	.....ColumnReferenceSegment                       	OneOf.match OUT     	+   	[match=<MatchResult 1/11: '.'>, seg="'.val / -2 AS a_calcu...'"]
INFO       [PD:4  MD:5 ]	.....ColumnReferenceSegment                       	OneOf.match PRN     	    	[ns=0, ps=0, ms=2, pruned=[], opts=[<Ref: DotSegment>, <Sequence: [<Ref: DotSegment>, <Ref: DotSegment>]>]]
DEBUG      [PD:4  MD:6 ]	......ColumnReferenceSegment                      	Ref.match OUT       	+   	[match=<MatchResult 1/11: '.'>, seg="'.val / -2 AS a_calcu...'"]
DEBUG      [PD:4  MD:7 ]	.......ColumnReferenceSegment                     	Ref.match OUT       	+   	[match=<MatchResult 1/11: '.'>, seg="'.val / -2 AS a_calcu...'"]
DEBUG      [PD:4  MD:7 ]	.......ColumnReferenceSegment                     	Ref.match OUT       	    	[match=<MatchResult 0/10: ''>, seg="'val / -2 AS a_calcul...'"]
INFO       [PD:4  MD:6 ]	......ColumnReferenceSegment                      	Seque.match OUT     	    	[match=<MatchResult 0/11: ''>, seg="'.val / -2 AS a_calcu...'"]
INFO       [PD:4  MD:5 ]	.....ColumnReferenceSegment                       	OneOf.match OUT     	+   	[match=<MatchResult 1/11: '.'>, seg="'.val / -2 AS a_calcu...'"]
INFO       [PD:4  MD:5 ]	.....ColumnReferenceSegment                       	OneOf.match PRN     	    	[ns=1, ps=10, ms=0, pruned=[<Ref: OnKeywordSegment>, <Ref: AsKeywordSegment>, <Ref: UsingKeywordSegment>, <Ref: CommaSegment>, <Ref: CastOperatorSegment>, <Ref: StartSquareBracketSegment>, <Ref: StartBracketSegment>, <Ref: ColonSegment>, <Ref: DelimiterSegment>, <class 'sqlfluff.core.parser.segments.base.BracketedSegment'>], opts=[<Ref: BinaryOperatorGrammar>]]
INFO       [PD:4  MD:6 ]	......BinaryOperatorGrammar                       	OneOf.match PRN     	    	[ns=1, ps=3, ms=0, pruned=[<Ref: ArithmeticBinaryOperatorGrammar>, <Ref: StringBinaryOperatorGrammar>, <Ref: BooleanBinaryOperatorGrammar>], opts=[<Ref: ComparisonOperatorGrammar>]]
INFO       [PD:4  MD:7 ]	.......ComparisonOperatorGrammar                  	OneOf.match PRN     	    	[ns=1, ps=7, ms=0, pruned=[<Ref: EqualsSegment>, <Ref: GreaterThanSegment>, <Ref: LessThanSegment>, <Ref: GreaterThanOrEqualToSegment>, <Ref: LessThanOrEqualToSegment>, <Ref: NotEqualToSegment_a>, <Ref: NotEqualToSegment_b>], opts=[<Ref: LikeOperatorSegment>]]
DEBUG      [PD:4  MD:8 ]	........ComparisonOperatorGrammar                 	Ref.match OUT       	    	[match=<MatchResult 0/16: ''>, seg="'val + b.val / -2 AS ...'"]
INFO       [PD:4  MD:7 ]	.......ComparisonOperatorGrammar                  	OneOf.match OUT     	    	[match=<MatchResult 0/16: ''>, seg="'val + b.val / -2 AS ...'"]
DEBUG      [PD:4  MD:7 ]	.......BinaryOperatorGrammar                      	Ref.match OUT       	    	[match=<MatchResult 0/16: ''>, seg="'val + b.val / -2 AS ...'"]
INFO       [PD:4  MD:6 ]	......BinaryOperatorGrammar                       	OneOf.match OUT     	    	[match=<MatchResult 0/16: ''>, seg="'val + b.val / -2 AS ...'"]
DEBUG      [PD:4  MD:6 ]	......ColumnReferenceSegment                      	Ref.match OUT       	    	[match=<MatchResult 0/16: ''>, seg="'val + b.val / -2 AS ...'"]
INFO       [PD:4  MD:5 ]	.....ColumnReferenceSegment                       	OneOf.match OUT     	    	[match=<MatchResult 0/16: ''>, seg="'val + b.val / -2 AS ...'"]
DEBUG      [PD:4  MD:5 ]	.....ColumnReferenceSegment                       	NonCo.match OUT     	    	[match=<MatchResult 0/16: ''>, seg="'val + b.val / -2 AS ...'"]
INFO       [PD:4  MD:5 ]	.....ColumnReferenceSegment                       	OneOf.match PRN     	    	[ns=1, ps=10, ms=0, pruned=[<Ref: OnKeywordSegment>, <Ref: AsKeywordSegment>, <Ref: UsingKeywordSegment>, <Ref: CommaSegment>, <Ref: CastOperatorSegment>, <Ref: StartSquareBracketSegment>, <Ref: StartBracketSegment>, <Ref: ColonSegment>, <Ref: DelimiterSegment>, <class 'sqlfluff.core.parser.segments.base.BracketedSegment'>], opts=[<Ref: BinaryOperatorGrammar>]]
INFO       [PD:4  MD:6 ]	......BinaryOperatorGrammar                       	OneOf.match PRN     	    	[ns=1, ps=2, ms=1, pruned=[<Ref: StringBinaryOperatorGrammar>, <Ref: BooleanBinaryOperatorGrammar>], opts=[<Ref: ArithmeticBinaryOperatorGrammar>, <Ref: ComparisonOperatorGrammar>]]
INFO       [PD:4  MD:7 ]	.......ArithmeticBinaryOperatorGrammar            	OneOf.match PRN     	    	[ns=0, ps=9, ms=1, pruned=[<Ref: MinusSegment>, <Ref: DivideSegment>, <Ref: MultiplySegment>, <Ref: ModuloSegment>, <Ref: BitwiseAndSegment>, <Ref: BitwiseOrSegment>, <Ref: BitwiseXorSegment>, <Ref: BitwiseLShiftSegment>, <Ref: BitwiseRShiftSegment>], opts=[<Ref: PlusSegment>]]
DEBUG      [PD:4  MD:8 ]	........ArithmeticBinaryOperatorGrammar           	Ref.match OUT       	    	[match=<MatchResult 0/15: ''>, seg="' + b.val / -2 AS a_c...'"]
INFO       [PD:4  MD:7 ]	.......ArithmeticBinaryOperatorGrammar            	OneOf.match OUT     	    	[match=<MatchResult 0/15: ''>, seg="' + b.val / -2 AS a_c...'"]
DEBUG      [PD:4  MD:7 ]	.......BinaryOperatorGrammar                      	Ref.match OUT       	    	[match=<MatchResult 0/15: ''>, seg="' + b.val / -2 AS a_c...'"]
INFO       [PD:4  MD:7 ]	.......ComparisonOperatorGrammar                  	OneOf.match PRN     	    	[ns=1, ps=7, ms=0, pruned=[<Ref: EqualsSegment>, <Ref: GreaterThanSegment>, <Ref: LessThanSegment>, <Ref: GreaterThanOrEqualToSegment>, <Ref: LessThanOrEqualToSegment>, <Ref: NotEqualToSegment_a>, <Ref: NotEqualToSegment_b>], opts=[<Ref: LikeOperatorSegment>]]
DEBUG      [PD:4  MD:8 ]	........ComparisonOperatorGrammar                 	Ref.match OUT       	    	[match=<MatchResult 0/15: ''>, seg="' + b.val / -2 AS a_c...'"]
INFO       [PD:4  MD:7 ]	.......ComparisonOperatorGrammar                  	OneOf.match OUT     	    	[match=<MatchResult 0/15: ''>, seg="' + b.val / -2 AS a_c...'"]
DEBUG      [PD:4  MD:7 ]	.......BinaryOperatorGrammar                      	Ref.match OUT       	    	[match=<MatchResult 0/15: ''>, seg="' + b.val / -2 AS a_c...'"]
INFO       [PD:4  MD:6 ]	......BinaryOperatorGrammar                       	OneOf.match OUT     	    	[match=<MatchResult 0/15: ''>, seg="' + b.val / -2 AS a_c...'"]
DEBUG      [PD:4  MD:6 ]	......ColumnReferenceSegment                      	Ref.match OUT       	    	[match=<MatchResult 0/15: ''>, seg="' + b.val / -2 AS a_c...'"]
INFO       [PD:4  MD:5 ]	.....ColumnReferenceSegment                       	OneOf.match OUT     	    	[match=<MatchResult 0/15: ''>, seg="' + b.val / -2 AS a_c...'"]
DEBUG      [PD:4  MD:5 ]	.....ColumnReferenceSegment                       	NonCo.match OUT     	+   	[match=<MatchResult 1/15: ' '>, seg="' + b.val / -2 AS a_c...'"]
INFO       [PD:4  MD:5 ]	.....SingleIdentifierGrammar                      	OneOf.match PRN     	    	[ns=2, ps=0, ms=0, pruned=[], opts=[<Ref: NakedIdentifierSegment>, <Ref: QuotedIdentifierSegment>]]
DEBUG      [PD:4  MD:6 ]	......SingleIdentifierGrammar                     	Ref.match OUT       	++  	[match=<MatchResult 1/1: 'val'>, seg="'val'"]
INFO       [PD:4  MD:5 ]	.....SingleIdentifierGrammar                      	OneOf.match OUT     	++  	[match=<MatchResult 1/1: 'val'>, seg="'val'"]
DEBUG      [PD:4  MD:5 ]	.....ColumnReferenceSegment                       	Ref.match OUT       	++  	[match=<MatchResult 1/1: 'val'>, seg="'val'"]
INFO       [PD:4  MD:4 ]	....ColumnReferenceSegment                        	Delim.match OUT     	+   	[match=<MatchResult 3/18: 'c.val'>, seg="'c.val + b.val / -2 A...'"]
DEBUG      [PD:4  MD:3 ]	...ColumnReferenceSegment                         	Colum.match OUT     	+   	[match=<MatchResult 1/16: 'c.val'>, seg="'c.val + b.val / -2 A...'"]
DEBUG      [PD:4  MD:3 ]	...BaseExpressionElementGrammar                   	Ref.match OUT       	+   	[match=<MatchResult 1/16: 'c.val'>, seg="'c.val + b.val / -2 A...'"]
INFO       [PD:4  MD:5 ]	.....Expression_A_Grammar                         	OneOf.match PRN     	    	[ns=1, ps=1, ms=0, pruned=[<Sequence: [<OneOf: [<Ref: PositiveSegment>, <Ref: N..., <Ref: Expression_C_Grammar>]>], opts=[<Ref: Expression_C_Grammar>]]
INFO       [PD:4  MD:6 ]	......Expression_C_Grammar                        	OneOf.match PRN     	    	[ns=1, ps=2, ms=0, pruned=[<Sequence: [<Ref: ExistsKeywordSegment>, <Bracketed: [<Ref: SelectStatementSegmen...]>, <Ref: CaseExpressionSegment>], opts=[<Ref: Expression_D_Grammar>]]
INFO       [PD:4  MD:8 ]	........Expression_D_Grammar                      	OneOf.match PRN     	    	[ns=6, ps=3, ms=0, pruned=[<Bracketed: [<OneOf: [<Ref: ExpressionSegment>, <Ref:...]>, <Ref: SelectStatementSegment>, <Ref: IntervalExpressionSegment>], opts=[<Ref: BareFunctionSegment>, <Ref: FunctionSegment>, <Ref: LiteralGrammar>, <Ref: ColumnReferenceSegment>, <Sequence: [<Ref: SimpleArrayTypeGrammar [opt]>, <Ref: ArrayLiteralSegment>]>, <Sequence: [<Ref: DatatypeSegment>, <OneOf: [<Ref: QuotedLiteralSegment>, <R...]>]]
DEBUG      [PD:4  MD:9 ]	.........Expression_D_Grammar                     	Ref.match OUT       	    	[match=<MatchResult 0/18: ''>, seg="'c.val + b.val / -2 A...'"]
INFO       [PD:4  MD:10]	..........FunctionSegment                         	OneOf.match PRN     	    	[ns=1, ps=1, ms=0, pruned=[<Sequence: [<Sequence: [<Ref: DateAddFunctionNameSeg...]>], opts=[<Sequence: [<Sequence: [<AnyNumberOf: [<Ref: Functio..., <Ref: PostFunctionGrammar [opt]>]>]]
DEBUG      [PD:4  MD:16]	................DateAddFunctionNameSegment        	Ref.match OUT       	    	[match=<MatchResult 0/18: ''>, seg="'c.val + b.val / -2 A...'"]
INFO       [PD:4  MD:15]	...............DateAddFunctionNameSegment         	Seque.match OUT     	    	[match=<MatchResult 0/18: ''>, seg="'c.val + b.val / -2 A...'"]
DEBUG      [PD:4  MD:14]	..............DateAddFunctionNameSegment          	DateA.match OUT     	    	[match=<MatchResult 0/18: ''>, seg="'c.val + b.val / -2 A...'"]
DEBUG      [PD:4  MD:14]	..............FunctionSegment                     	Ref.match OUT       	    	[match=<MatchResult 0/18: ''>, seg="'c.val + b.val / -2 A...'"]
INFO       [PD:4  MD:13]	.............FunctionSegment                      	AnyNu.match PRN     	    	[ns=1, ps=0, ms=0, pruned=[], opts=[<Ref: FunctionNameSegment>]]
INFO       [PD:4  MD:16]	................FunctionNameSegment               	AnyNu.match PRN     	    	[ns=1, ps=0, ms=0, pruned=[], opts=[<Sequence: [<Ref: SingleIdentifierGrammar>, <Ref: DotSegment>]>]]
INFO       [PD:4  MD:18]	..................SingleIdentifierGrammar         	OneOf.match PRN     	    	[ns=2, ps=0, ms=0, pruned=[], opts=[<Ref: NakedIdentifierSegment>, <Ref: QuotedIdentifierSegment>]]
DEBUG      [PD:4  MD:19]	...................SingleIdentifierGrammar        	Ref.match OUT       	+   	[match=<MatchResult 1/18: 'c'>, seg="'c.val + b.val / -2 A...'"]
DEBUG      [PD:4  MD:19]	...................SingleIdentifierGrammar        	Ref.match OUT       	    	[match=<MatchResult 0/18: ''>, seg="'c.val + b.val / -2 A...'"]
INFO       [PD:4  MD:18]	..................SingleIdentifierGrammar         	OneOf.match OUT     	+   	[match=<MatchResult 1/18: 'c'>, seg="'c.val + b.val / -2 A...'"]
DEBUG      [PD:4  MD:18]	..................FunctionNameSegment             	Ref.match OUT       	+   	[match=<MatchResult 1/18: 'c'>, seg="'c.val + b.val / -2 A...'"]
DEBUG      [PD:4  MD:18]	..................FunctionNameSegment             	Ref.match OUT       	+   	[match=<MatchResult 1/17: '.'>, seg="'.val + b.val / -2 AS...'"]
INFO       [PD:4  MD:17]	.................FunctionNameSegment              	Seque.match OUT     	+   	[match=<MatchResult 2/18: 'c.'>, seg="'c.val + b.val / -2 A...'"]
INFO       [PD:4  MD:16]	................FunctionNameSegment               	AnyNu.match PRN     	    	[ns=1, ps=0, ms=0, pruned=[], opts=[<Sequence: [<Ref: SingleIdentifierGrammar>, <Ref: DotSegment>]>]]
INFO       [PD:4  MD:18]	..................SingleIdentifierGrammar         	OneOf.match PRN     	    	[ns=2, ps=0, ms=0, pruned=[], opts=[<Ref: NakedIdentifierSegment>, <Ref: QuotedIdentifierSegment>]]
DEBUG      [PD:4  MD:19]	...................SingleIdentifierGrammar        	Ref.match OUT       	+   	[match=<MatchResult 1/16: 'val'>, seg="'val + b.val / -2 AS ...'"]
DEBUG      [PD:4  MD:19]	...................SingleIdentifierGrammar        	Ref.match OUT       	    	[match=<MatchResult 0/16: ''>, seg="'val + b.val / -2 AS ...'"]
INFO       [PD:4  MD:18]	..................SingleIdentifierGrammar         	OneOf.match OUT     	+   	[match=<MatchResult 1/16: 'val'>, seg="'val + b.val / -2 AS ...'"]
DEBUG      [PD:4  MD:18]	..................FunctionNameSegment             	Ref.match OUT       	+   	[match=<MatchResult 1/16: 'val'>, seg="'val + b.val / -2 AS ...'"]
DEBUG      [PD:4  MD:18]	..................FunctionNameSegment             	Ref.match OUT       	    	[match=<MatchResult 0/14: ''>, seg="'+ b.val / -2 AS a_ca...'"]
INFO       [PD:4  MD:17]	.................FunctionNameSegment              	Seque.match OUT     	    	[match=<MatchResult 0/16: ''>, seg="'val + b.val / -2 AS ...'"]
INFO       [PD:4  MD:16]	................FunctionNameSegment               	AnyNu.match OUT     	+   	[match=<MatchResult 2/18: 'c.'>, seg="'c.val + b.val / -2 A...'"]
INFO       [PD:4  MD:16]	................FunctionNameSegment               	OneOf.match PRN     	    	[ns=2, ps=0, ms=0, pruned=[], opts=[<Ref: FunctionNameIdentifierSegment>, <Ref: QuotedIdentifierSegment>]]
DEBUG      [PD:4  MD:17]	.................FunctionNameSegment              	Ref.match OUT       	+   	[match=<MatchResult 1/16: 'val'>, seg="'val + b.val / -2 AS ...'"]
DEBUG      [PD:4  MD:17]	.................FunctionNameSegment              	Ref.match OUT       	    	[match=<MatchResult 0/16: ''>, seg="'val + b.val / -2 AS ...'"]
INFO       [PD:4  MD:16]	................FunctionNameSegment               	OneOf.match OUT     	+   	[match=<MatchResult 1/16: 'val'>, seg="'val + b.val / -2 AS ...'"]
INFO       [PD:4  MD:15]	...............FunctionNameSegment                	Seque.match OUT     	+   	[match=<MatchResult 3/18: 'c.val'>, seg="'c.val + b.val / -2 A...'"]
DEBUG      [PD:4  MD:14]	..............FunctionNameSegment                 	Funct.match OUT     	+   	[match=<MatchResult 1/16: 'c.val'>, seg="'c.val + b.val / -2 A...'"]
DEBUG      [PD:4  MD:14]	..............FunctionSegment                     	Ref.match OUT       	+   	[match=<MatchResult 1/16: 'c.val'>, seg="'c.val + b.val / -2 A...'"]
INFO       [PD:4  MD:13]	.............FunctionSegment                      	AnyNu.match OUT     	+   	[match=<MatchResult 1/16: 'c.val'>, seg="'c.val + b.val / -2 A...'"]
INFO       [PD:4  MD:13]	.............FunctionSegment                      	Brack.match OUT     	    	[match=<MatchResult 0/14: ''>, seg="'+ b.val / -2 AS a_ca...'"]
INFO       [PD:4  MD:12]	............FunctionSegment                       	Seque.match OUT     	    	[match=<MatchResult 0/18: ''>, seg="'c.val + b.val / -2 A...'"]
INFO       [PD:4  MD:11]	...........FunctionSegment                        	Seque.match OUT     	    	[match=<MatchResult 0/18: ''>, seg="'c.val + b.val / -2 A...'"]
INFO       [PD:4  MD:10]	..........FunctionSegment                         	OneOf.match OUT     	    	[match=<MatchResult 0/18: ''>, seg="'c.val + b.val / -2 A...'"]
DEBUG      [PD:4  MD:9 ]	.........FunctionSegment                          	Funct.match OUT     	    	[match=<MatchResult 0/18: ''>, seg="'c.val + b.val / -2 A...'"]
DEBUG      [PD:4  MD:9 ]	.........Expression_D_Grammar                     	Ref.match OUT       	    	[match=<MatchResult 0/18: ''>, seg="'c.val + b.val / -2 A...'"]
INFO       [PD:4  MD:9 ]	.........LiteralGrammar                           	OneOf.match PRN     	    	[ns=2, ps=4, ms=0, pruned=[<Ref: BooleanLiteralGrammar>, <Ref: QualifiedNumericLiteralSegment>, <Ref: NullLiteralSegment>, <Ref: DateTimeLiteralGrammar>], opts=[<Ref: QuotedLiteralSegment>, <Ref: NumericLiteralSegment>]]
DEBUG      [PD:4  MD:10]	..........LiteralGrammar                          	Ref.match OUT       	    	[match=<MatchResult 0/18: ''>, seg="'c.val + b.val / -2 A...'"]
DEBUG      [PD:4  MD:10]	..........LiteralGrammar                          	Ref.match OUT       	    	[match=<MatchResult 0/18: ''>, seg="'c.val + b.val / -2 A...'"]
INFO       [PD:4  MD:9 ]	.........LiteralGrammar                           	OneOf.match OUT     	    	[match=<MatchResult 0/18: ''>, seg="'c.val + b.val / -2 A...'"]
DEBUG      [PD:4  MD:9 ]	.........Expression_D_Grammar                     	Ref.match OUT       	    	[match=<MatchResult 0/18: ''>, seg="'c.val + b.val / -2 A...'"]
DEBUG      [PD:4  MD:11]	...........ColumnReferenceSegment                 	Delim._look_ahead_match IN	    	[ls=18, seg='c.val + b.val / -2 A...']
DEBUG      [PD:4  MD:11]	...........ColumnReferenceSegment                 	Delim._look_ahead_match SI	    	[mq=[(<OneOf: [<Ref: DotSegment>, <Sequence: [<Ref: DotSegment>, <Ref: Dot...]>, 1, '.'), (<OneOf: [<Ref: DotSegment>, <Sequence: [<Ref: DotSegment>, <Ref: Dot...]>, 1, '.'), (<OneOf: [<Ref: DotSegment>, <Sequence: [<Ref: DotSegment>, <Ref: Dot...]>, 7, '.'), (<OneOf: [<Ref: DotSegment>, <Sequence: [<Ref: DotSegment>, <Ref: Dot...]>, 7, '.')], sb=['C', '.', 'VAL', '', '+', '', 'B', '.', 'VAL', '', '/', '', '-', '2', '', 'AS', '', 'A_CALCULATION']]
INFO       [PD:4  MD:11]	...........ColumnReferenceSegment                 	OneOf.match PRN     	    	[ns=0, ps=0, ms=2, pruned=[], opts=[<Ref: DotSegment>, <Sequence: [<Ref: DotSegment>, <Ref: DotSegment>]>]]
DEBUG      [PD:4  MD:12]	............ColumnReferenceSegment                	Ref.match OUT       	+   	[match=<MatchResult 1/11: '.'>, seg="'.val / -2 AS a_calcu...'"]
DEBUG      [PD:4  MD:13]	.............ColumnReferenceSegment               	Ref.match OUT       	+   	[match=<MatchResult 1/11: '.'>, seg="'.val / -2 AS a_calcu...'"]
DEBUG      [PD:4  MD:13]	.............ColumnReferenceSegment               	Ref.match OUT       	    	[match=<MatchResult 0/10: ''>, seg="'val / -2 AS a_calcul...'"]
INFO       [PD:4  MD:12]	............ColumnReferenceSegment                	Seque.match OUT     	    	[match=<MatchResult 0/11: ''>, seg="'.val / -2 AS a_calcu...'"]
INFO       [PD:4  MD:11]	...........ColumnReferenceSegment                 	OneOf.match OUT     	+   	[match=<MatchResult 1/11: '.'>, seg="'.val / -2 AS a_calcu...'"]
INFO       [PD:4  MD:11]	...........ColumnReferenceSegment                 	OneOf.match PRN     	    	[ns=0, ps=0, ms=2, pruned=[], opts=[<Ref: DotSegment>, <Sequence: [<Ref: DotSegment>, <Ref: DotSegment>]>]]
DEBUG      [PD:4  MD:12]	............ColumnReferenceSegment                	Ref.match OUT       	+   	[match=<MatchResult 1/11: '.'>, seg="'.val / -2 AS a_calcu...'"]
DEBUG      [PD:4  MD:13]	.............ColumnReferenceSegment               	Ref.match OUT       	+   	[match=<MatchResult 1/11: '.'>, seg="'.val / -2 AS a_calcu...'"]
DEBUG      [PD:4  MD:13]	.............ColumnReferenceSegment               	Ref.match OUT       	    	[match=<MatchResult 0/10: ''>, seg="'val / -2 AS a_calcul...'"]
INFO       [PD:4  MD:12]	............ColumnReferenceSegment                	Seque.match OUT     	    	[match=<MatchResult 0/11: ''>, seg="'.val / -2 AS a_calcu...'"]
INFO       [PD:4  MD:11]	...........ColumnReferenceSegment                 	OneOf.match OUT     	+   	[match=<MatchResult 1/11: '.'>, seg="'.val / -2 AS a_calcu...'"]
INFO       [PD:4  MD:11]	...........ColumnReferenceSegment                 	OneOf.match PRN     	    	[ns=0, ps=0, ms=2, pruned=[], opts=[<Ref: DotSegment>, <Sequence: [<Ref: DotSegment>, <Ref: DotSegment>]>]]
DEBUG      [PD:4  MD:12]	............ColumnReferenceSegment                	Ref.match OUT       	+   	[match=<MatchResult 1/17: '.'>, seg="'.val + b.val / -2 AS...'"]
DEBUG      [PD:4  MD:13]	.............ColumnReferenceSegment               	Ref.match OUT       	+   	[match=<MatchResult 1/17: '.'>, seg="'.val + b.val / -2 AS...'"]
DEBUG      [PD:4  MD:13]	.............ColumnReferenceSegment               	Ref.match OUT       	    	[match=<MatchResult 0/16: ''>, seg="'val + b.val / -2 AS ...'"]
INFO       [PD:4  MD:12]	............ColumnReferenceSegment                	Seque.match OUT     	    	[match=<MatchResult 0/17: ''>, seg="'.val + b.val / -2 AS...'"]
INFO       [PD:4  MD:11]	...........ColumnReferenceSegment                 	OneOf.match OUT     	+   	[match=<MatchResult 1/17: '.'>, seg="'.val + b.val / -2 AS...'"]
INFO       [PD:4  MD:11]	...........ColumnReferenceSegment                 	OneOf.match PRN     	    	[ns=0, ps=0, ms=2, pruned=[], opts=[<Ref: DotSegment>, <Sequence: [<Ref: DotSegment>, <Ref: DotSegment>]>]]
DEBUG      [PD:4  MD:12]	............ColumnReferenceSegment                	Ref.match OUT       	+   	[match=<MatchResult 1/17: '.'>, seg="'.val + b.val / -2 AS...'"]
DEBUG      [PD:4  MD:13]	.............ColumnReferenceSegment               	Ref.match OUT       	+   	[match=<MatchResult 1/17: '.'>, seg="'.val + b.val / -2 AS...'"]
DEBUG      [PD:4  MD:13]	.............ColumnReferenceSegment               	Ref.match OUT       	    	[match=<MatchResult 0/16: ''>, seg="'val + b.val / -2 AS ...'"]
INFO       [PD:4  MD:12]	............ColumnReferenceSegment                	Seque.match OUT     	    	[match=<MatchResult 0/17: ''>, seg="'.val + b.val / -2 AS...'"]
INFO       [PD:4  MD:11]	...........ColumnReferenceSegment                 	OneOf.match OUT     	+   	[match=<MatchResult 1/17: '.'>, seg="'.val + b.val / -2 AS...'"]
INFO       [PD:4  MD:11]	...........ColumnReferenceSegment                 	OneOf.match PRN     	    	[ns=1, ps=10, ms=0, pruned=[<Ref: OnKeywordSegment>, <Ref: AsKeywordSegment>, <Ref: UsingKeywordSegment>, <Ref: CommaSegment>, <Ref: CastOperatorSegment>, <Ref: StartSquareBracketSegment>, <Ref: StartBracketSegment>, <Ref: ColonSegment>, <Ref: DelimiterSegment>, <class 'sqlfluff.core.parser.segments.base.BracketedSegment'>], opts=[<Ref: BinaryOperatorGrammar>]]
INFO       [PD:4  MD:12]	............BinaryOperatorGrammar                 	OneOf.match PRN     	    	[ns=1, ps=3, ms=0, pruned=[<Ref: ArithmeticBinaryOperatorGrammar>, <Ref: StringBinaryOperatorGrammar>, <Ref: BooleanBinaryOperatorGrammar>], opts=[<Ref: ComparisonOperatorGrammar>]]
INFO       [PD:4  MD:13]	.............ComparisonOperatorGrammar            	OneOf.match PRN     	    	[ns=1, ps=7, ms=0, pruned=[<Ref: EqualsSegment>, <Ref: GreaterThanSegment>, <Ref: LessThanSegment>, <Ref: GreaterThanOrEqualToSegment>, <Ref: LessThanOrEqualToSegment>, <Ref: NotEqualToSegment_a>, <Ref: NotEqualToSegment_b>], opts=[<Ref: LikeOperatorSegment>]]
DEBUG      [PD:4  MD:14]	..............ComparisonOperatorGrammar           	Ref.match OUT       	    	[match=<MatchResult 0/18: ''>, seg="'c.val + b.val / -2 A...'"]
INFO       [PD:4  MD:13]	.............ComparisonOperatorGrammar            	OneOf.match OUT     	    	[match=<MatchResult 0/18: ''>, seg="'c.val + b.val / -2 A...'"]
DEBUG      [PD:4  MD:13]	.............BinaryOperatorGrammar                	Ref.match OUT       	    	[match=<MatchResult 0/18: ''>, seg="'c.val + b.val / -2 A...'"]
INFO       [PD:4  MD:12]	............BinaryOperatorGrammar                 	OneOf.match OUT     	    	[match=<MatchResult 0/18: ''>, seg="'c.val + b.val / -2 A...'"]
DEBUG      [PD:4  MD:12]	............ColumnReferenceSegment                	Ref.match OUT       	    	[match=<MatchResult 0/18: ''>, seg="'c.val + b.val / -2 A...'"]
INFO       [PD:4  MD:11]	...........ColumnReferenceSegment                 	OneOf.match OUT     	    	[match=<MatchResult 0/18: ''>, seg="'c.val + b.val / -2 A...'"]
DEBUG      [PD:4  MD:11]	...........ColumnReferenceSegment                 	NonCo.match OUT     	    	[match=<MatchResult 0/18: ''>, seg="'c.val + b.val / -2 A...'"]
INFO       [PD:4  MD:11]	...........ColumnReferenceSegment                 	OneOf.match PRN     	    	[ns=1, ps=10, ms=0, pruned=[<Ref: OnKeywordSegment>, <Ref: AsKeywordSegment>, <Ref: UsingKeywordSegment>, <Ref: CommaSegment>, <Ref: CastOperatorSegment>, <Ref: StartSquareBracketSegment>, <Ref: StartBracketSegment>, <Ref: ColonSegment>, <Ref: DelimiterSegment>, <class 'sqlfluff.core.parser.segments.base.BracketedSegment'>], opts=[<Ref: BinaryOperatorGrammar>]]
INFO       [PD:4  MD:12]	............BinaryOperatorGrammar                 	OneOf.match PRN     	    	[ns=1, ps=3, ms=0, pruned=[<Ref: ArithmeticBinaryOperatorGrammar>, <Ref: StringBinaryOperatorGrammar>, <Ref: BooleanBinaryOperatorGrammar>], opts=[<Ref: ComparisonOperatorGrammar>]]
INFO       [PD:4  MD:13]	.............ComparisonOperatorGrammar            	OneOf.match PRN     	    	[ns=1, ps=7, ms=0, pruned=[<Ref: EqualsSegment>, <Ref: GreaterThanSegment>, <Ref: LessThanSegment>, <Ref: GreaterThanOrEqualToSegment>, <Ref: LessThanOrEqualToSegment>, <Ref: NotEqualToSegment_a>, <Ref: NotEqualToSegment_b>], opts=[<Ref: LikeOperatorSegment>]]
DEBUG      [PD:4  MD:14]	..............ComparisonOperatorGrammar           	Ref.match OUT       	    	[match=<MatchResult 0/17: ''>, seg="'.val + b.val / -2 AS...'"]
INFO       [PD:4  MD:13]	.............ComparisonOperatorGrammar            	OneOf.match OUT     	    	[match=<MatchResult 0/17: ''>, seg="'.val + b.val / -2 AS...'"]
DEBUG      [PD:4  MD:13]	.............BinaryOperatorGrammar                	Ref.match OUT       	    	[match=<MatchResult 0/17: ''>, seg="'.val + b.val / -2 AS...'"]
INFO       [PD:4  MD:12]	............BinaryOperatorGrammar                 	OneOf.match OUT     	    	[match=<MatchResult 0/17: ''>, seg="'.val + b.val / -2 AS...'"]
DEBUG      [PD:4  MD:12]	............ColumnReferenceSegment                	Ref.match OUT       	    	[match=<MatchResult 0/17: ''>, seg="'.val + b.val / -2 AS...'"]
INFO       [PD:4  MD:11]	...........ColumnReferenceSegment                 	OneOf.match OUT     	    	[match=<MatchResult 0/17: ''>, seg="'.val + b.val / -2 AS...'"]
DEBUG      [PD:4  MD:11]	...........ColumnReferenceSegment                 	NonCo.match OUT     	    	[match=<MatchResult 0/17: ''>, seg="'.val + b.val / -2 AS...'"]
INFO       [PD:4  MD:11]	...........SingleIdentifierGrammar                	OneOf.match PRN     	    	[ns=2, ps=0, ms=0, pruned=[], opts=[<Ref: NakedIdentifierSegment>, <Ref: QuotedIdentifierSegment>]]
DEBUG      [PD:4  MD:12]	............SingleIdentifierGrammar               	Ref.match OUT       	++  	[match=<MatchResult 1/1: 'c'>, seg="'c'"]
INFO       [PD:4  MD:11]	...........SingleIdentifierGrammar                	OneOf.match OUT     	++  	[match=<MatchResult 1/1: 'c'>, seg="'c'"]
DEBUG      [PD:4  MD:11]	...........ColumnReferenceSegment                 	Ref.match OUT       	++  	[match=<MatchResult 1/1: 'c'>, seg="'c'"]
DEBUG      [PD:4  MD:11]	...........ColumnReferenceSegment                 	Delim._look_ahead_match IN	    	[ls=16, seg='val + b.val / -2 AS ...']
DEBUG      [PD:4  MD:11]	...........ColumnReferenceSegment                 	Delim._look_ahead_match SI	    	[mq=[(<OneOf: [<Ref: DotSegment>, <Sequence: [<Ref: DotSegment>, <Ref: Dot...]>, 5, '.'), (<OneOf: [<Ref: DotSegment>, <Sequence: [<Ref: DotSegment>, <Ref: Dot...]>, 5, '.')], sb=['VAL', '', '+', '', 'B', '.', 'VAL', '', '/', '', '-', '2', '', 'AS', '', 'A_CALCULATION']]
INFO       [PD:4  MD:11]	...........ColumnReferenceSegment                 	OneOf.match PRN     	    	[ns=0, ps=0, ms=2, pruned=[], opts=[<Ref: DotSegment>, <Sequence: [<Ref: DotSegment>, <Ref: DotSegment>]>]]
DEBUG      [PD:4  MD:12]	............ColumnReferenceSegment                	Ref.match OUT       	+   	[match=<MatchResult 1/11: '.'>, seg="'.val / -2 AS a_calcu...'"]
DEBUG      [PD:4  MD:13]	.............ColumnReferenceSegment               	Ref.match OUT       	+   	[match=<MatchResult 1/11: '.'>, seg="'.val / -2 AS a_calcu...'"]
DEBUG      [PD:4  MD:13]	.............ColumnReferenceSegment               	Ref.match OUT       	    	[match=<MatchResult 0/10: ''>, seg="'val / -2 AS a_calcul...'"]
INFO       [PD:4  MD:12]	............ColumnReferenceSegment                	Seque.match OUT     	    	[match=<MatchResult 0/11: ''>, seg="'.val / -2 AS a_calcu...'"]
INFO       [PD:4  MD:11]	...........ColumnReferenceSegment                 	OneOf.match OUT     	+   	[match=<MatchResult 1/11: '.'>, seg="'.val / -2 AS a_calcu...'"]
INFO       [PD:4  MD:11]	...........ColumnReferenceSegment                 	OneOf.match PRN     	    	[ns=0, ps=0, ms=2, pruned=[], opts=[<Ref: DotSegment>, <Sequence: [<Ref: DotSegment>, <Ref: DotSegment>]>]]
DEBUG      [PD:4  MD:12]	............ColumnReferenceSegment                	Ref.match OUT       	+   	[match=<MatchResult 1/11: '.'>, seg="'.val / -2 AS a_calcu...'"]
DEBUG      [PD:4  MD:13]	.............ColumnReferenceSegment               	Ref.match OUT       	+   	[match=<MatchResult 1/11: '.'>, seg="'.val / -2 AS a_calcu...'"]
DEBUG      [PD:4  MD:13]	.............ColumnReferenceSegment               	Ref.match OUT       	    	[match=<MatchResult 0/10: ''>, seg="'val / -2 AS a_calcul...'"]
INFO       [PD:4  MD:12]	............ColumnReferenceSegment                	Seque.match OUT     	    	[match=<MatchResult 0/11: ''>, seg="'.val / -2 AS a_calcu...'"]
INFO       [PD:4  MD:11]	...........ColumnReferenceSegment                 	OneOf.match OUT     	+   	[match=<MatchResult 1/11: '.'>, seg="'.val / -2 AS a_calcu...'"]
INFO       [PD:4  MD:11]	...........ColumnReferenceSegment                 	OneOf.match PRN     	    	[ns=1, ps=10, ms=0, pruned=[<Ref: OnKeywordSegment>, <Ref: AsKeywordSegment>, <Ref: UsingKeywordSegment>, <Ref: CommaSegment>, <Ref: CastOperatorSegment>, <Ref: StartSquareBracketSegment>, <Ref: StartBracketSegment>, <Ref: ColonSegment>, <Ref: DelimiterSegment>, <class 'sqlfluff.core.parser.segments.base.BracketedSegment'>], opts=[<Ref: BinaryOperatorGrammar>]]
INFO       [PD:4  MD:12]	............BinaryOperatorGrammar                 	OneOf.match PRN     	    	[ns=1, ps=3, ms=0, pruned=[<Ref: ArithmeticBinaryOperatorGrammar>, <Ref: StringBinaryOperatorGrammar>, <Ref: BooleanBinaryOperatorGrammar>], opts=[<Ref: ComparisonOperatorGrammar>]]
INFO       [PD:4  MD:13]	.............ComparisonOperatorGrammar            	OneOf.match PRN     	    	[ns=1, ps=7, ms=0, pruned=[<Ref: EqualsSegment>, <Ref: GreaterThanSegment>, <Ref: LessThanSegment>, <Ref: GreaterThanOrEqualToSegment>, <Ref: LessThanOrEqualToSegment>, <Ref: NotEqualToSegment_a>, <Ref: NotEqualToSegment_b>], opts=[<Ref: LikeOperatorSegment>]]
DEBUG      [PD:4  MD:14]	..............ComparisonOperatorGrammar           	Ref.match OUT       	    	[match=<MatchResult 0/16: ''>, seg="'val + b.val / -2 AS ...'"]
INFO       [PD:4  MD:13]	.............ComparisonOperatorGrammar            	OneOf.match OUT     	    	[match=<MatchResult 0/16: ''>, seg="'val + b.val / -2 AS ...'"]
DEBUG      [PD:4  MD:13]	.............BinaryOperatorGrammar                	Ref.match OUT       	    	[match=<MatchResult 0/16: ''>, seg="'val + b.val / -2 AS ...'"]
INFO       [PD:4  MD:12]	............BinaryOperatorGrammar                 	OneOf.match OUT     	    	[match=<MatchResult 0/16: ''>, seg="'val + b.val / -2 AS ...'"]
DEBUG      [PD:4  MD:12]	............ColumnReferenceSegment                	Ref.match OUT       	    	[match=<MatchResult 0/16: ''>, seg="'val + b.val / -2 AS ...'"]
INFO       [PD:4  MD:11]	...........ColumnReferenceSegment                 	OneOf.match OUT     	    	[match=<MatchResult 0/16: ''>, seg="'val + b.val / -2 AS ...'"]
DEBUG      [PD:4  MD:11]	...........ColumnReferenceSegment                 	NonCo.match OUT     	    	[match=<MatchResult 0/16: ''>, seg="'val + b.val / -2 AS ...'"]
INFO       [PD:4  MD:11]	...........ColumnReferenceSegment                 	OneOf.match PRN     	    	[ns=1, ps=10, ms=0, pruned=[<Ref: OnKeywordSegment>, <Ref: AsKeywordSegment>, <Ref: UsingKeywordSegment>, <Ref: CommaSegment>, <Ref: CastOperatorSegment>, <Ref: StartSquareBracketSegment>, <Ref: StartBracketSegment>, <Ref: ColonSegment>, <Ref: DelimiterSegment>, <class 'sqlfluff.core.parser.segments.base.BracketedSegment'>], opts=[<Ref: BinaryOperatorGrammar>]]
INFO       [PD:4  MD:12]	............BinaryOperatorGrammar                 	OneOf.match PRN     	    	[ns=1, ps=2, ms=1, pruned=[<Ref: StringBinaryOperatorGrammar>, <Ref: BooleanBinaryOperatorGrammar>], opts=[<Ref: ArithmeticBinaryOperatorGrammar>, <Ref: ComparisonOperatorGrammar>]]
INFO       [PD:4  MD:13]	.............ArithmeticBinaryOperatorGrammar      	OneOf.match PRN     	    	[ns=0, ps=9, ms=1, pruned=[<Ref: MinusSegment>, <Ref: DivideSegment>, <Ref: MultiplySegment>, <Ref: ModuloSegment>, <Ref: BitwiseAndSegment>, <Ref: BitwiseOrSegment>, <Ref: BitwiseXorSegment>, <Ref: BitwiseLShiftSegment>, <Ref: BitwiseRShiftSegment>], opts=[<Ref: PlusSegment>]]
DEBUG      [PD:4  MD:14]	..............ArithmeticBinaryOperatorGrammar     	Ref.match OUT       	    	[match=<MatchResult 0/15: ''>, seg="' + b.val / -2 AS a_c...'"]
INFO       [PD:4  MD:13]	.............ArithmeticBinaryOperatorGrammar      	OneOf.match OUT     	    	[match=<MatchResult 0/15: ''>, seg="' + b.val / -2 AS a_c...'"]
DEBUG      [PD:4  MD:13]	.............BinaryOperatorGrammar                	Ref.match OUT       	    	[match=<MatchResult 0/15: ''>, seg="' + b.val / -2 AS a_c...'"]
INFO       [PD:4  MD:13]	.............ComparisonOperatorGrammar            	OneOf.match PRN     	    	[ns=1, ps=7, ms=0, pruned=[<Ref: EqualsSegment>, <Ref: GreaterThanSegment>, <Ref: LessThanSegment>, <Ref: GreaterThanOrEqualToSegment>, <Ref: LessThanOrEqualToSegment>, <Ref: NotEqualToSegment_a>, <Ref: NotEqualToSegment_b>], opts=[<Ref: LikeOperatorSegment>]]
DEBUG      [PD:4  MD:14]	..............ComparisonOperatorGrammar           	Ref.match OUT       	    	[match=<MatchResult 0/15: ''>, seg="' + b.val / -2 AS a_c...'"]
INFO       [PD:4  MD:13]	.............ComparisonOperatorGrammar            	OneOf.match OUT     	    	[match=<MatchResult 0/15: ''>, seg="' + b.val / -2 AS a_c...'"]
DEBUG      [PD:4  MD:13]	.............BinaryOperatorGrammar                	Ref.match OUT       	    	[match=<MatchResult 0/15: ''>, seg="' + b.val / -2 AS a_c...'"]
INFO       [PD:4  MD:12]	............BinaryOperatorGrammar                 	OneOf.match OUT     	    	[match=<MatchResult 0/15: ''>, seg="' + b.val / -2 AS a_c...'"]
DEBUG      [PD:4  MD:12]	............ColumnReferenceSegment                	Ref.match OUT       	    	[match=<MatchResult 0/15: ''>, seg="' + b.val / -2 AS a_c...'"]
INFO       [PD:4  MD:11]	...........ColumnReferenceSegment                 	OneOf.match OUT     	    	[match=<MatchResult 0/15: ''>, seg="' + b.val / -2 AS a_c...'"]
DEBUG      [PD:4  MD:11]	...........ColumnReferenceSegment                 	NonCo.match OUT     	+   	[match=<MatchResult 1/15: ' '>, seg="' + b.val / -2 AS a_c...'"]
INFO       [PD:4  MD:11]	...........SingleIdentifierGrammar                	OneOf.match PRN     	    	[ns=2, ps=0, ms=0, pruned=[], opts=[<Ref: NakedIdentifierSegment>, <Ref: QuotedIdentifierSegment>]]
DEBUG      [PD:4  MD:12]	............SingleIdentifierGrammar               	Ref.match OUT       	++  	[match=<MatchResult 1/1: 'val'>, seg="'val'"]
INFO       [PD:4  MD:11]	...........SingleIdentifierGrammar                	OneOf.match OUT     	++  	[match=<MatchResult 1/1: 'val'>, seg="'val'"]
DEBUG      [PD:4  MD:11]	...........ColumnReferenceSegment                 	Ref.match OUT       	++  	[match=<MatchResult 1/1: 'val'>, seg="'val'"]
INFO       [PD:4  MD:10]	..........ColumnReferenceSegment                  	Delim.match OUT     	+   	[match=<MatchResult 3/18: 'c.val'>, seg="'c.val + b.val / -2 A...'"]
DEBUG      [PD:4  MD:9 ]	.........ColumnReferenceSegment                   	Colum.match OUT     	+   	[match=<MatchResult 1/16: 'c.val'>, seg="'c.val + b.val / -2 A...'"]
DEBUG      [PD:4  MD:9 ]	.........Expression_D_Grammar                     	Ref.match OUT       	+   	[match=<MatchResult 1/16: 'c.val'>, seg="'c.val + b.val / -2 A...'"]
DEBUG      [PD:4  MD:10]	..........Expression_D_Grammar                    	Ref.match OUT       	    	[match=<MatchResult 0/18: ''>, seg="'c.val + b.val / -2 A...'"]
INFO       [PD:4  MD:11]	...........ArrayLiteralSegment                    	Brack.match OUT     	    	[match=<MatchResult 0/18: ''>, seg="'c.val + b.val / -2 A...'"]
DEBUG      [PD:4  MD:10]	..........ArrayLiteralSegment                     	Array.match OUT     	    	[match=<MatchResult 0/18: ''>, seg="'c.val + b.val / -2 A...'"]
DEBUG      [PD:4  MD:10]	..........Expression_D_Grammar                    	Ref.match OUT       	    	[match=<MatchResult 0/18: ''>, seg="'c.val + b.val / -2 A...'"]
INFO       [PD:4  MD:9 ]	.........Expression_D_Grammar                     	Seque.match OUT     	    	[match=<MatchResult 0/18: ''>, seg="'c.val + b.val / -2 A...'"]
INFO       [PD:4  MD:11]	...........DatatypeSegment                        	OneOf.match PRN     	    	[ns=1, ps=2, ms=0, pruned=[<Sequence: [<OneOf: [<Ref: TimeKeywordSegment>, <Ref..., <Bracketed: [<Ref: NumericLiteralSegment..., <Sequence:...]>, <Sequence: [<Ref: DoubleKeywordSegment>, <Ref: PrecisionKeywordSegment>]>], opts=[<Sequence: [<OneOf: [<Sequence: [<OneOf: [<Ref: Char..., <Bracketed: [<OneOf: [<Delimited: [<Ref:..., <Ref: Char...]>]]
INFO       [PD:4  MD:13]	.............DatatypeSegment                      	OneOf.match PRN     	    	[ns=1, ps=1, ms=0, pruned=[<Sequence: [<OneOf: [<Ref: CharacterKeywordSegment>,..., <OneOf: [<Ref: VaryingKeywordSegment>, <...]>], opts=[<Sequence: [<Sequence: [<Ref: SingleIdentifierGramma..., <Ref: DatatypeIdentifierSegment>]>]]
INFO       [PD:4  MD:16]	................SingleIdentifierGrammar           	OneOf.match PRN     	    	[ns=2, ps=0, ms=0, pruned=[], opts=[<Ref: NakedIdentifierSegment>, <Ref: QuotedIdentifierSegment>]]
DEBUG      [PD:4  MD:17]	.................SingleIdentifierGrammar          	Ref.match OUT       	+   	[match=<MatchResult 1/18: 'c'>, seg="'c.val + b.val / -2 A...'"]
DEBUG      [PD:4  MD:17]	.................SingleIdentifierGrammar          	Ref.match OUT       	    	[match=<MatchResult 0/18: ''>, seg="'c.val + b.val / -2 A...'"]
INFO       [PD:4  MD:16]	................SingleIdentifierGrammar           	OneOf.match OUT     	+   	[match=<MatchResult 1/18: 'c'>, seg="'c.val + b.val / -2 A...'"]
DEBUG      [PD:4  MD:16]	................DatatypeSegment                   	Ref.match OUT       	+   	[match=<MatchResult 1/18: 'c'>, seg="'c.val + b.val / -2 A...'"]
DEBUG      [PD:4  MD:16]	................DatatypeSegment                   	Ref.match OUT       	+   	[match=<MatchResult 1/17: '.'>, seg="'.val + b.val / -2 AS...'"]
INFO       [PD:4  MD:15]	...............DatatypeSegment                    	Seque.match OUT     	+   	[match=<MatchResult 2/18: 'c.'>, seg="'c.val + b.val / -2 A...'"]
DEBUG      [PD:4  MD:15]	...............DatatypeSegment                    	Ref.match OUT       	+   	[match=<MatchResult 1/16: 'val'>, seg="'val + b.val / -2 AS ...'"]
INFO       [PD:4  MD:14]	..............DatatypeSegment                     	Seque.match OUT     	+   	[match=<MatchResult 3/18: 'c.val'>, seg="'c.val + b.val / -2 A...'"]
INFO       [PD:4  MD:13]	.............DatatypeSegment                      	OneOf.match OUT     	+   	[match=<MatchResult 3/18: 'c.val'>, seg="'c.val + b.val / -2 A...'"]
INFO       [PD:4  MD:13]	.............DatatypeSegment                      	Brack.match OUT     	    	[match=<MatchResult 0/14: ''>, seg="'+ b.val / -2 AS a_ca...'"]
DEBUG      [PD:4  MD:13]	.............DatatypeSegment                      	Ref.match OUT       	    	[match=<MatchResult 0/14: ''>, seg="'+ b.val / -2 AS a_ca...'"]
INFO       [PD:4  MD:12]	............DatatypeSegment                       	Seque.match OUT     	+   	[match=<MatchResult 3/18: 'c.val'>, seg="'c.val + b.val / -2 A...'"]
INFO       [PD:4  MD:11]	...........DatatypeSegment                        	OneOf.match OUT     	+   	[match=<MatchResult 3/18: 'c.val'>, seg="'c.val + b.val / -2 A...'"]
DEBUG      [PD:4  MD:10]	..........DatatypeSegment                         	Datat.match OUT     	+   	[match=<MatchResult 1/16: 'c.val'>, seg="'c.val + b.val / -2 A...'"]
DEBUG      [PD:4  MD:10]	..........Expression_D_Grammar                    	Ref.match OUT       	+   	[match=<MatchResult 1/16: 'c.val'>, seg="'c.val + b.val / -2 A...'"]
INFO       [PD:4  MD:10]	..........Expression_D_Grammar                    	OneOf.match PRN     	    	[ns=2, ps=3, ms=0, pruned=[<Ref: BooleanLiteralGrammar>, <Ref: NullLiteralSegment>, <Ref: DateTimeLiteralGrammar>], opts=[<Ref: QuotedLiteralSegment>, <Ref: NumericLiteralSegment>]]
DEBUG      [PD:4  MD:11]	...........Expression_D_Grammar                   	Ref.match OUT       	    	[match=<MatchResult 0/14: ''>, seg="'+ b.val / -2 AS a_ca...'"]
DEBUG      [PD:4  MD:11]	...........Expression_D_Grammar                   	Ref.match OUT       	    	[match=<MatchResult 0/14: ''>, seg="'+ b.val / -2 AS a_ca...'"]
INFO       [PD:4  MD:10]	..........Expression_D_Grammar                    	OneOf.match OUT     	    	[match=<MatchResult 0/14: ''>, seg="'+ b.val / -2 AS a_ca...'"]
INFO       [PD:4  MD:9 ]	.........Expression_D_Grammar                     	Seque.match OUT     	    	[match=<MatchResult 0/18: ''>, seg="'c.val + b.val / -2 A...'"]
INFO       [PD:4  MD:8 ]	........Expression_D_Grammar                      	OneOf.match OUT     	+   	[match=<MatchResult 1/16: 'c.val'>, seg="'c.val + b.val / -2 A...'"]
INFO       [PD:4  MD:8 ]	........Accessor_Grammar                          	AnyNu.match PRN     	    	[ns=0, ps=1, ms=0, pruned=[<Ref: ArrayAccessorSegment>], opts='ALL']
INFO       [PD:4  MD:8 ]	........Accessor_Grammar                          	AnyNu.match OUT     	    	[match=<MatchResult 0/14: ''>, seg="'+ b.val / -2 AS a_ca...'"]
DEBUG      [PD:4  MD:8 ]	........Expression_D_Grammar                      	Ref.match OUT       	    	[match=<MatchResult 0/14: ''>, seg="'+ b.val / -2 AS a_ca...'"]
INFO       [PD:4  MD:8 ]	........Expression_D_Grammar                      	AnyNu.match PRN     	    	[ns=0, ps=1, ms=0, pruned=[<Ref: ShorthandCastSegment>], opts='ALL']
INFO       [PD:4  MD:8 ]	........Expression_D_Grammar                      	AnyNu.match OUT     	    	[match=<MatchResult 0/14: ''>, seg="'+ b.val / -2 AS a_ca...'"]
INFO       [PD:4  MD:7 ]	.......Expression_D_Grammar                       	Seque.match OUT     	+   	[match=<MatchResult 1/16: 'c.val'>, seg="'c.val + b.val / -2 A...'"]
DEBUG      [PD:4  MD:7 ]	.......Expression_C_Grammar                       	Ref.match OUT       	+   	[match=<MatchResult 1/16: 'c.val'>, seg="'c.val + b.val / -2 A...'"]
INFO       [PD:4  MD:6 ]	......Expression_C_Grammar                        	OneOf.match OUT     	+   	[match=<MatchResult 1/16: 'c.val'>, seg="'c.val + b.val / -2 A...'"]
DEBUG      [PD:4  MD:6 ]	......Expression_A_Grammar                        	Ref.match OUT       	+   	[match=<MatchResult 1/16: 'c.val'>, seg="'c.val + b.val / -2 A...'"]
INFO       [PD:4  MD:5 ]	.....Expression_A_Grammar                         	OneOf.match OUT     	+   	[match=<MatchResult 1/16: 'c.val'>, seg="'c.val + b.val / -2 A...'"]
INFO       [PD:4  MD:5 ]	.....Expression_A_Grammar                         	AnyNu.match PRN     	    	[ns=1, ps=0, ms=0, pruned=[], opts=[<OneOf: [<Sequence: [<OneOf: [<Sequence: [<Ref: N..., <Sequence: [<Ref: NotKeywordSegment [opt..., <Sequence:...]>]]
INFO       [PD:4  MD:6 ]	......Expression_A_Grammar                        	OneOf.match PRN     	    	[ns=3, ps=5, ms=0, pruned=[<Sequence: [<Ref: NotKeywordSegment [opt]>, <Ref: InKeywordSegment>, <Bracketed: [<OneOf: [<Delimited: [<Ref:...]>, <Sequence: [<Ref: NotKeywordSegment [opt]>, <Ref: InKeywordSegment>, <Ref: FunctionSegment>]>, <Sequence: [<Ref: IsKeywordSegment>, <Ref: NotKeywordSegment [opt]>, <Ref: IsClauseGrammar>]>, <Sequence: [<Ref: NotKeywordSegment>, <Ref: Expression_C_Grammar>]>, <Sequence: [<Ref: NotKeywordSegment [opt]>, <Ref: BetweenKeywordSegment>, <Ref: Expression_C_Grammar>, <AnyNumbe...]>], opts=[<Sequence: [<OneOf: [<Sequence: [<Ref: NotKeywordSeg..., <Ref: Expression_C_Grammar>, <Sequence: [<Ref: EscapeKe...]>, <Ref: IsNullGrammar>, <Ref: NotNullGrammar>]]
INFO       [PD:4  MD:8 ]	........Expression_A_Grammar                      	OneOf.match PRN     	    	[ns=1, ps=1, ms=0, pruned=[<Sequence: [<Ref: NotKeywordSegment [opt]>, <Ref: LikeGrammar>]>], opts=[<Sequence: [<Ref: BinaryOperatorGrammar>, <Ref: NotKeywordSegment [opt]>]>]]
INFO       [PD:4  MD:10]	..........BinaryOperatorGrammar                   	OneOf.match PRN     	    	[ns=1, ps=2, ms=1, pruned=[<Ref: StringBinaryOperatorGrammar>, <Ref: BooleanBinaryOperatorGrammar>], opts=[<Ref: ArithmeticBinaryOperatorGrammar>, <Ref: ComparisonOperatorGrammar>]]
INFO       [PD:4  MD:11]	...........ArithmeticBinaryOperatorGrammar        	OneOf.match PRN     	    	[ns=0, ps=9, ms=1, pruned=[<Ref: MinusSegment>, <Ref: DivideSegment>, <Ref: MultiplySegment>, <Ref: ModuloSegment>, <Ref: BitwiseAndSegment>, <Ref: BitwiseOrSegment>, <Ref: BitwiseXorSegment>, <Ref: BitwiseLShiftSegment>, <Ref: BitwiseRShiftSegment>], opts=[<Ref: PlusSegment>]]
DEBUG      [PD:4  MD:12]	............ArithmeticBinaryOperatorGrammar       	Ref.match OUT       	+   	[match=<MatchResult 1/14: '+'>, seg="'+ b.val / -2 AS a_ca...'"]
INFO       [PD:4  MD:11]	...........ArithmeticBinaryOperatorGrammar        	OneOf.match OUT     	+   	[match=<MatchResult 1/14: '+'>, seg="'+ b.val / -2 AS a_ca...'"]
DEBUG      [PD:4  MD:11]	...........BinaryOperatorGrammar                  	Ref.match OUT       	+   	[match=<MatchResult 1/14: '+'>, seg="'+ b.val / -2 AS a_ca...'"]
INFO       [PD:4  MD:11]	...........ComparisonOperatorGrammar              	OneOf.match PRN     	    	[ns=1, ps=7, ms=0, pruned=[<Ref: EqualsSegment>, <Ref: GreaterThanSegment>, <Ref: LessThanSegment>, <Ref: GreaterThanOrEqualToSegment>, <Ref: LessThanOrEqualToSegment>, <Ref: NotEqualToSegment_a>, <Ref: NotEqualToSegment_b>], opts=[<Ref: LikeOperatorSegment>]]
DEBUG      [PD:4  MD:12]	............ComparisonOperatorGrammar             	Ref.match OUT       	    	[match=<MatchResult 0/14: ''>, seg="'+ b.val / -2 AS a_ca...'"]
INFO       [PD:4  MD:11]	...........ComparisonOperatorGrammar              	OneOf.match OUT     	    	[match=<MatchResult 0/14: ''>, seg="'+ b.val / -2 AS a_ca...'"]
DEBUG      [PD:4  MD:11]	...........BinaryOperatorGrammar                  	Ref.match OUT       	    	[match=<MatchResult 0/14: ''>, seg="'+ b.val / -2 AS a_ca...'"]
INFO       [PD:4  MD:10]	..........BinaryOperatorGrammar                   	OneOf.match OUT     	+   	[match=<MatchResult 1/14: '+'>, seg="'+ b.val / -2 AS a_ca...'"]
DEBUG      [PD:4  MD:10]	..........Expression_A_Grammar                    	Ref.match OUT       	+   	[match=<MatchResult 1/14: '+'>, seg="'+ b.val / -2 AS a_ca...'"]
DEBUG      [PD:4  MD:10]	..........Expression_A_Grammar                    	Ref.match OUT       	    	[match=<MatchResult 0/12: ''>, seg="'b.val / -2 AS a_calc...'"]
INFO       [PD:4  MD:9 ]	.........Expression_A_Grammar                     	Seque.match OUT     	+   	[match=<MatchResult 1/14: '+'>, seg="'+ b.val / -2 AS a_ca...'"]
INFO       [PD:4  MD:8 ]	........Expression_A_Grammar                      	OneOf.match OUT     	+   	[match=<MatchResult 1/14: '+'>, seg="'+ b.val / -2 AS a_ca...'"]
INFO       [PD:4  MD:8 ]	........Expression_C_Grammar                      	OneOf.match PRN     	    	[ns=1, ps=2, ms=0, pruned=[<Sequence: [<Ref: ExistsKeywordSegment>, <Bracketed: [<Ref: SelectStatementSegmen...]>, <Ref: CaseExpressionSegment>], opts=[<Ref: Expression_D_Grammar>]]
INFO       [PD:4  MD:10]	..........Expression_D_Grammar                    	OneOf.match PRN     	    	[ns=6, ps=3, ms=0, pruned=[<Bracketed: [<OneOf: [<Ref: ExpressionSegment>, <Ref:...]>, <Ref: SelectStatementSegment>, <Ref: IntervalExpressionSegment>], opts=[<Ref: BareFunctionSegment>, <Ref: FunctionSegment>, <Ref: LiteralGrammar>, <Ref: ColumnReferenceSegment>, <Sequence: [<Ref: SimpleArrayTypeGrammar [opt]>, <Ref: ArrayLiteralSegment>]>, <Sequence: [<Ref: DatatypeSegment>, <OneOf: [<Ref: QuotedLiteralSegment>, <R...]>]]
DEBUG      [PD:4  MD:11]	...........Expression_D_Grammar                   	Ref.match OUT       	    	[match=<MatchResult 0/12: ''>, seg="'b.val / -2 AS a_calc...'"]
INFO       [PD:4  MD:12]	............FunctionSegment                       	OneOf.match PRN     	    	[ns=1, ps=1, ms=0, pruned=[<Sequence: [<Sequence: [<Ref: DateAddFunctionNameSeg...]>], opts=[<Sequence: [<Sequence: [<AnyNumberOf: [<Ref: Functio..., <Ref: PostFunctionGrammar [opt]>]>]]
DEBUG      [PD:4  MD:18]	..................DateAddFunctionNameSegment      	Ref.match OUT       	    	[match=<MatchResult 0/12: ''>, seg="'b.val / -2 AS a_calc...'"]
INFO       [PD:4  MD:17]	.................DateAddFunctionNameSegment       	Seque.match OUT     	    	[match=<MatchResult 0/12: ''>, seg="'b.val / -2 AS a_calc...'"]
DEBUG      [PD:4  MD:16]	................DateAddFunctionNameSegment        	DateA.match OUT     	    	[match=<MatchResult 0/12: ''>, seg="'b.val / -2 AS a_calc...'"]
DEBUG      [PD:4  MD:16]	................FunctionSegment                   	Ref.match OUT       	    	[match=<MatchResult 0/12: ''>, seg="'b.val / -2 AS a_calc...'"]
INFO       [PD:4  MD:15]	...............FunctionSegment                    	AnyNu.match PRN     	    	[ns=1, ps=0, ms=0, pruned=[], opts=[<Ref: FunctionNameSegment>]]
INFO       [PD:4  MD:18]	..................FunctionNameSegment             	AnyNu.match PRN     	    	[ns=1, ps=0, ms=0, pruned=[], opts=[<Sequence: [<Ref: SingleIdentifierGrammar>, <Ref: DotSegment>]>]]
INFO       [PD:4  MD:20]	....................SingleIdentifierGrammar       	OneOf.match PRN     	    	[ns=2, ps=0, ms=0, pruned=[], opts=[<Ref: NakedIdentifierSegment>, <Ref: QuotedIdentifierSegment>]]
DEBUG      [PD:4  MD:21]	.....................SingleIdentifierGrammar      	Ref.match OUT       	+   	[match=<MatchResult 1/12: 'b'>, seg="'b.val / -2 AS a_calc...'"]
DEBUG      [PD:4  MD:21]	.....................SingleIdentifierGrammar      	Ref.match OUT       	    	[match=<MatchResult 0/12: ''>, seg="'b.val / -2 AS a_calc...'"]
INFO       [PD:4  MD:20]	....................SingleIdentifierGrammar       	OneOf.match OUT     	+   	[match=<MatchResult 1/12: 'b'>, seg="'b.val / -2 AS a_calc...'"]
DEBUG      [PD:4  MD:20]	....................FunctionNameSegment           	Ref.match OUT       	+   	[match=<MatchResult 1/12: 'b'>, seg="'b.val / -2 AS a_calc...'"]
DEBUG      [PD:4  MD:20]	....................FunctionNameSegment           	Ref.match OUT       	+   	[match=<MatchResult 1/11: '.'>, seg="'.val / -2 AS a_calcu...'"]
INFO       [PD:4  MD:19]	...................FunctionNameSegment            	Seque.match OUT     	+   	[match=<MatchResult 2/12: 'b.'>, seg="'b.val / -2 AS a_calc...'"]
INFO       [PD:4  MD:18]	..................FunctionNameSegment             	AnyNu.match PRN     	    	[ns=1, ps=0, ms=0, pruned=[], opts=[<Sequence: [<Ref: SingleIdentifierGrammar>, <Ref: DotSegment>]>]]
INFO       [PD:4  MD:20]	....................SingleIdentifierGrammar       	OneOf.match PRN     	    	[ns=2, ps=0, ms=0, pruned=[], opts=[<Ref: NakedIdentifierSegment>, <Ref: QuotedIdentifierSegment>]]
DEBUG      [PD:4  MD:21]	.....................SingleIdentifierGrammar      	Ref.match OUT       	+   	[match=<MatchResult 1/10: 'val'>, seg="'val / -2 AS a_calcul...'"]
DEBUG      [PD:4  MD:21]	.....................SingleIdentifierGrammar      	Ref.match OUT       	    	[match=<MatchResult 0/10: ''>, seg="'val / -2 AS a_calcul...'"]
INFO       [PD:4  MD:20]	....................SingleIdentifierGrammar       	OneOf.match OUT     	+   	[match=<MatchResult 1/10: 'val'>, seg="'val / -2 AS a_calcul...'"]
DEBUG      [PD:4  MD:20]	....................FunctionNameSegment           	Ref.match OUT       	+   	[match=<MatchResult 1/10: 'val'>, seg="'val / -2 AS a_calcul...'"]
DEBUG      [PD:4  MD:20]	....................FunctionNameSegment           	Ref.match OUT       	    	[match=<MatchResult 0/8: ''>, seg="'/ -2 AS a_calculatio...'"]
INFO       [PD:4  MD:19]	...................FunctionNameSegment            	Seque.match OUT     	    	[match=<MatchResult 0/10: ''>, seg="'val / -2 AS a_calcul...'"]
INFO       [PD:4  MD:18]	..................FunctionNameSegment             	AnyNu.match OUT     	+   	[match=<MatchResult 2/12: 'b.'>, seg="'b.val / -2 AS a_calc...'"]
INFO       [PD:4  MD:18]	..................FunctionNameSegment             	OneOf.match PRN     	    	[ns=2, ps=0, ms=0, pruned=[], opts=[<Ref: FunctionNameIdentifierSegment>, <Ref: QuotedIdentifierSegment>]]
DEBUG      [PD:4  MD:19]	...................FunctionNameSegment            	Ref.match OUT       	+   	[match=<MatchResult 1/10: 'val'>, seg="'val / -2 AS a_calcul...'"]
DEBUG      [PD:4  MD:19]	...................FunctionNameSegment            	Ref.match OUT       	    	[match=<MatchResult 0/10: ''>, seg="'val / -2 AS a_calcul...'"]
INFO       [PD:4  MD:18]	..................FunctionNameSegment             	OneOf.match OUT     	+   	[match=<MatchResult 1/10: 'val'>, seg="'val / -2 AS a_calcul...'"]
INFO       [PD:4  MD:17]	.................FunctionNameSegment              	Seque.match OUT     	+   	[match=<MatchResult 3/12: 'b.val'>, seg="'b.val / -2 AS a_calc...'"]
DEBUG      [PD:4  MD:16]	................FunctionNameSegment               	Funct.match OUT     	+   	[match=<MatchResult 1/10: 'b.val'>, seg="'b.val / -2 AS a_calc...'"]
DEBUG      [PD:4  MD:16]	................FunctionSegment                   	Ref.match OUT       	+   	[match=<MatchResult 1/10: 'b.val'>, seg="'b.val / -2 AS a_calc...'"]
INFO       [PD:4  MD:15]	...............FunctionSegment                    	AnyNu.match OUT     	+   	[match=<MatchResult 1/10: 'b.val'>, seg="'b.val / -2 AS a_calc...'"]
INFO       [PD:4  MD:15]	...............FunctionSegment                    	Brack.match OUT     	    	[match=<MatchResult 0/8: ''>, seg="'/ -2 AS a_calculatio...'"]
INFO       [PD:4  MD:14]	..............FunctionSegment                     	Seque.match OUT     	    	[match=<MatchResult 0/12: ''>, seg="'b.val / -2 AS a_calc...'"]
INFO       [PD:4  MD:13]	.............FunctionSegment                      	Seque.match OUT     	    	[match=<MatchResult 0/12: ''>, seg="'b.val / -2 AS a_calc...'"]
INFO       [PD:4  MD:12]	............FunctionSegment                       	OneOf.match OUT     	    	[match=<MatchResult 0/12: ''>, seg="'b.val / -2 AS a_calc...'"]
DEBUG      [PD:4  MD:11]	...........FunctionSegment                        	Funct.match OUT     	    	[match=<MatchResult 0/12: ''>, seg="'b.val / -2 AS a_calc...'"]
DEBUG      [PD:4  MD:11]	...........Expression_D_Grammar                   	Ref.match OUT       	    	[match=<MatchResult 0/12: ''>, seg="'b.val / -2 AS a_calc...'"]
INFO       [PD:4  MD:11]	...........LiteralGrammar                         	OneOf.match PRN     	    	[ns=2, ps=4, ms=0, pruned=[<Ref: BooleanLiteralGrammar>, <Ref: QualifiedNumericLiteralSegment>, <Ref: NullLiteralSegment>, <Ref: DateTimeLiteralGrammar>], opts=[<Ref: QuotedLiteralSegment>, <Ref: NumericLiteralSegment>]]
DEBUG      [PD:4  MD:12]	............LiteralGrammar                        	Ref.match OUT       	    	[match=<MatchResult 0/12: ''>, seg="'b.val / -2 AS a_calc...'"]
DEBUG      [PD:4  MD:12]	............LiteralGrammar                        	Ref.match OUT       	    	[match=<MatchResult 0/12: ''>, seg="'b.val / -2 AS a_calc...'"]
INFO       [PD:4  MD:11]	...........LiteralGrammar                         	OneOf.match OUT     	    	[match=<MatchResult 0/12: ''>, seg="'b.val / -2 AS a_calc...'"]
DEBUG      [PD:4  MD:11]	...........Expression_D_Grammar                   	Ref.match OUT       	    	[match=<MatchResult 0/12: ''>, seg="'b.val / -2 AS a_calc...'"]
DEBUG      [PD:4  MD:13]	.............ColumnReferenceSegment               	Delim._look_ahead_match IN	    	[ls=12, seg='b.val / -2 AS a_calc...']
DEBUG      [PD:4  MD:13]	.............ColumnReferenceSegment               	Delim._look_ahead_match SI	    	[mq=[(<OneOf: [<Ref: DotSegment>, <Sequence: [<Ref: DotSegment>, <Ref: Dot...]>, 1, '.'), (<OneOf: [<Ref: DotSegment>, <Sequence: [<Ref: DotSegment>, <Ref: Dot...]>, 1, '.')], sb=['B', '.', 'VAL', '', '/', '', '-', '2', '', 'AS', '', 'A_CALCULATION']]
INFO       [PD:4  MD:13]	.............ColumnReferenceSegment               	OneOf.match PRN     	    	[ns=0, ps=0, ms=2, pruned=[], opts=[<Ref: DotSegment>, <Sequence: [<Ref: DotSegment>, <Ref: DotSegment>]>]]
DEBUG      [PD:4  MD:14]	..............ColumnReferenceSegment              	Ref.match OUT       	+   	[match=<MatchResult 1/11: '.'>, seg="'.val / -2 AS a_calcu...'"]
DEBUG      [PD:4  MD:15]	...............ColumnReferenceSegment             	Ref.match OUT       	+   	[match=<MatchResult 1/11: '.'>, seg="'.val / -2 AS a_calcu...'"]
DEBUG      [PD:4  MD:15]	...............ColumnReferenceSegment             	Ref.match OUT       	    	[match=<MatchResult 0/10: ''>, seg="'val / -2 AS a_calcul...'"]
INFO       [PD:4  MD:14]	..............ColumnReferenceSegment              	Seque.match OUT     	    	[match=<MatchResult 0/11: ''>, seg="'.val / -2 AS a_calcu...'"]
INFO       [PD:4  MD:13]	.............ColumnReferenceSegment               	OneOf.match OUT     	+   	[match=<MatchResult 1/11: '.'>, seg="'.val / -2 AS a_calcu...'"]
INFO       [PD:4  MD:13]	.............ColumnReferenceSegment               	OneOf.match PRN     	    	[ns=0, ps=0, ms=2, pruned=[], opts=[<Ref: DotSegment>, <Sequence: [<Ref: DotSegment>, <Ref: DotSegment>]>]]
DEBUG      [PD:4  MD:14]	..............ColumnReferenceSegment              	Ref.match OUT       	+   	[match=<MatchResult 1/11: '.'>, seg="'.val / -2 AS a_calcu...'"]
DEBUG      [PD:4  MD:15]	...............ColumnReferenceSegment             	Ref.match OUT       	+   	[match=<MatchResult 1/11: '.'>, seg="'.val / -2 AS a_calcu...'"]
DEBUG      [PD:4  MD:15]	...............ColumnReferenceSegment             	Ref.match OUT       	    	[match=<MatchResult 0/10: ''>, seg="'val / -2 AS a_calcul...'"]
INFO       [PD:4  MD:14]	..............ColumnReferenceSegment              	Seque.match OUT     	    	[match=<MatchResult 0/11: ''>, seg="'.val / -2 AS a_calcu...'"]
INFO       [PD:4  MD:13]	.............ColumnReferenceSegment               	OneOf.match OUT     	+   	[match=<MatchResult 1/11: '.'>, seg="'.val / -2 AS a_calcu...'"]
INFO       [PD:4  MD:13]	.............ColumnReferenceSegment               	OneOf.match PRN     	    	[ns=1, ps=10, ms=0, pruned=[<Ref: OnKeywordSegment>, <Ref: AsKeywordSegment>, <Ref: UsingKeywordSegment>, <Ref: CommaSegment>, <Ref: CastOperatorSegment>, <Ref: StartSquareBracketSegment>, <Ref: StartBracketSegment>, <Ref: ColonSegment>, <Ref: DelimiterSegment>, <class 'sqlfluff.core.parser.segments.base.BracketedSegment'>], opts=[<Ref: BinaryOperatorGrammar>]]
INFO       [PD:4  MD:14]	..............BinaryOperatorGrammar               	OneOf.match PRN     	    	[ns=1, ps=3, ms=0, pruned=[<Ref: ArithmeticBinaryOperatorGrammar>, <Ref: StringBinaryOperatorGrammar>, <Ref: BooleanBinaryOperatorGrammar>], opts=[<Ref: ComparisonOperatorGrammar>]]
INFO       [PD:4  MD:15]	...............ComparisonOperatorGrammar          	OneOf.match PRN     	    	[ns=1, ps=7, ms=0, pruned=[<Ref: EqualsSegment>, <Ref: GreaterThanSegment>, <Ref: LessThanSegment>, <Ref: GreaterThanOrEqualToSegment>, <Ref: LessThanOrEqualToSegment>, <Ref: NotEqualToSegment_a>, <Ref: NotEqualToSegment_b>], opts=[<Ref: LikeOperatorSegment>]]
DEBUG      [PD:4  MD:16]	................ComparisonOperatorGrammar         	Ref.match OUT       	    	[match=<MatchResult 0/12: ''>, seg="'b.val / -2 AS a_calc...'"]
INFO       [PD:4  MD:15]	...............ComparisonOperatorGrammar          	OneOf.match OUT     	    	[match=<MatchResult 0/12: ''>, seg="'b.val / -2 AS a_calc...'"]
DEBUG      [PD:4  MD:15]	...............BinaryOperatorGrammar              	Ref.match OUT       	    	[match=<MatchResult 0/12: ''>, seg="'b.val / -2 AS a_calc...'"]
INFO       [PD:4  MD:14]	..............BinaryOperatorGrammar               	OneOf.match OUT     	    	[match=<MatchResult 0/12: ''>, seg="'b.val / -2 AS a_calc...'"]
DEBUG      [PD:4  MD:14]	..............ColumnReferenceSegment              	Ref.match OUT       	    	[match=<MatchResult 0/12: ''>, seg="'b.val / -2 AS a_calc...'"]
INFO       [PD:4  MD:13]	.............ColumnReferenceSegment               	OneOf.match OUT     	    	[match=<MatchResult 0/12: ''>, seg="'b.val / -2 AS a_calc...'"]
DEBUG      [PD:4  MD:13]	.............ColumnReferenceSegment               	NonCo.match OUT     	    	[match=<MatchResult 0/12: ''>, seg="'b.val / -2 AS a_calc...'"]
INFO       [PD:4  MD:13]	.............ColumnReferenceSegment               	OneOf.match PRN     	    	[ns=1, ps=10, ms=0, pruned=[<Ref: OnKeywordSegment>, <Ref: AsKeywordSegment>, <Ref: UsingKeywordSegment>, <Ref: CommaSegment>, <Ref: CastOperatorSegment>, <Ref: StartSquareBracketSegment>, <Ref: StartBracketSegment>, <Ref: ColonSegment>, <Ref: DelimiterSegment>, <class 'sqlfluff.core.parser.segments.base.BracketedSegment'>], opts=[<Ref: BinaryOperatorGrammar>]]
INFO       [PD:4  MD:14]	..............BinaryOperatorGrammar               	OneOf.match PRN     	    	[ns=1, ps=3, ms=0, pruned=[<Ref: ArithmeticBinaryOperatorGrammar>, <Ref: StringBinaryOperatorGrammar>, <Ref: BooleanBinaryOperatorGrammar>], opts=[<Ref: ComparisonOperatorGrammar>]]
INFO       [PD:4  MD:15]	...............ComparisonOperatorGrammar          	OneOf.match PRN     	    	[ns=1, ps=7, ms=0, pruned=[<Ref: EqualsSegment>, <Ref: GreaterThanSegment>, <Ref: LessThanSegment>, <Ref: GreaterThanOrEqualToSegment>, <Ref: LessThanOrEqualToSegment>, <Ref: NotEqualToSegment_a>, <Ref: NotEqualToSegment_b>], opts=[<Ref: LikeOperatorSegment>]]
DEBUG      [PD:4  MD:16]	................ComparisonOperatorGrammar         	Ref.match OUT       	    	[match=<MatchResult 0/11: ''>, seg="'.val / -2 AS a_calcu...'"]
INFO       [PD:4  MD:15]	...............ComparisonOperatorGrammar          	OneOf.match OUT     	    	[match=<MatchResult 0/11: ''>, seg="'.val / -2 AS a_calcu...'"]
DEBUG      [PD:4  MD:15]	...............BinaryOperatorGrammar              	Ref.match OUT       	    	[match=<MatchResult 0/11: ''>, seg="'.val / -2 AS a_calcu...'"]
INFO       [PD:4  MD:14]	..............BinaryOperatorGrammar               	OneOf.match OUT     	    	[match=<MatchResult 0/11: ''>, seg="'.val / -2 AS a_calcu...'"]
DEBUG      [PD:4  MD:14]	..............ColumnReferenceSegment              	Ref.match OUT       	    	[match=<MatchResult 0/11: ''>, seg="'.val / -2 AS a_calcu...'"]
INFO       [PD:4  MD:13]	.............ColumnReferenceSegment               	OneOf.match OUT     	    	[match=<MatchResult 0/11: ''>, seg="'.val / -2 AS a_calcu...'"]
DEBUG      [PD:4  MD:13]	.............ColumnReferenceSegment               	NonCo.match OUT     	    	[match=<MatchResult 0/11: ''>, seg="'.val / -2 AS a_calcu...'"]
INFO       [PD:4  MD:13]	.............SingleIdentifierGrammar              	OneOf.match PRN     	    	[ns=2, ps=0, ms=0, pruned=[], opts=[<Ref: NakedIdentifierSegment>, <Ref: QuotedIdentifierSegment>]]
DEBUG      [PD:4  MD:14]	..............SingleIdentifierGrammar             	Ref.match OUT       	++  	[match=<MatchResult 1/1: 'b'>, seg="'b'"]
INFO       [PD:4  MD:13]	.............SingleIdentifierGrammar              	OneOf.match OUT     	++  	[match=<MatchResult 1/1: 'b'>, seg="'b'"]
DEBUG      [PD:4  MD:13]	.............ColumnReferenceSegment               	Ref.match OUT       	++  	[match=<MatchResult 1/1: 'b'>, seg="'b'"]
DEBUG      [PD:4  MD:13]	.............ColumnReferenceSegment               	Delim._look_ahead_match IN	    	[ls=10, seg='val / -2 AS a_calcul...']
DEBUG      [PD:4  MD:13]	.............ColumnReferenceSegment               	Delim._look_ahead_match SI	    	[mq=[], sb=['VAL', '', '/', '', '-', '2', '', 'AS', '', 'A_CALCULATION']]
INFO       [PD:4  MD:13]	.............ColumnReferenceSegment               	OneOf.match PRN     	    	[ns=1, ps=10, ms=0, pruned=[<Ref: OnKeywordSegment>, <Ref: AsKeywordSegment>, <Ref: UsingKeywordSegment>, <Ref: CommaSegment>, <Ref: CastOperatorSegment>, <Ref: StartSquareBracketSegment>, <Ref: StartBracketSegment>, <Ref: ColonSegment>, <Ref: DelimiterSegment>, <class 'sqlfluff.core.parser.segments.base.BracketedSegment'>], opts=[<Ref: BinaryOperatorGrammar>]]
INFO       [PD:4  MD:14]	..............BinaryOperatorGrammar               	OneOf.match PRN     	    	[ns=1, ps=3, ms=0, pruned=[<Ref: ArithmeticBinaryOperatorGrammar>, <Ref: StringBinaryOperatorGrammar>, <Ref: BooleanBinaryOperatorGrammar>], opts=[<Ref: ComparisonOperatorGrammar>]]
INFO       [PD:4  MD:15]	...............ComparisonOperatorGrammar          	OneOf.match PRN     	    	[ns=1, ps=7, ms=0, pruned=[<Ref: EqualsSegment>, <Ref: GreaterThanSegment>, <Ref: LessThanSegment>, <Ref: GreaterThanOrEqualToSegment>, <Ref: LessThanOrEqualToSegment>, <Ref: NotEqualToSegment_a>, <Ref: NotEqualToSegment_b>], opts=[<Ref: LikeOperatorSegment>]]
DEBUG      [PD:4  MD:16]	................ComparisonOperatorGrammar         	Ref.match OUT       	    	[match=<MatchResult 0/10: ''>, seg="'val / -2 AS a_calcul...'"]
INFO       [PD:4  MD:15]	...............ComparisonOperatorGrammar          	OneOf.match OUT     	    	[match=<MatchResult 0/10: ''>, seg="'val / -2 AS a_calcul...'"]
DEBUG      [PD:4  MD:15]	...............BinaryOperatorGrammar              	Ref.match OUT       	    	[match=<MatchResult 0/10: ''>, seg="'val / -2 AS a_calcul...'"]
INFO       [PD:4  MD:14]	..............BinaryOperatorGrammar               	OneOf.match OUT     	    	[match=<MatchResult 0/10: ''>, seg="'val / -2 AS a_calcul...'"]
DEBUG      [PD:4  MD:14]	..............ColumnReferenceSegment              	Ref.match OUT       	    	[match=<MatchResult 0/10: ''>, seg="'val / -2 AS a_calcul...'"]
INFO       [PD:4  MD:13]	.............ColumnReferenceSegment               	OneOf.match OUT     	    	[match=<MatchResult 0/10: ''>, seg="'val / -2 AS a_calcul...'"]
DEBUG      [PD:4  MD:13]	.............ColumnReferenceSegment               	NonCo.match OUT     	    	[match=<MatchResult 0/10: ''>, seg="'val / -2 AS a_calcul...'"]
INFO       [PD:4  MD:13]	.............ColumnReferenceSegment               	OneOf.match PRN     	    	[ns=1, ps=10, ms=0, pruned=[<Ref: OnKeywordSegment>, <Ref: AsKeywordSegment>, <Ref: UsingKeywordSegment>, <Ref: CommaSegment>, <Ref: CastOperatorSegment>, <Ref: StartSquareBracketSegment>, <Ref: StartBracketSegment>, <Ref: ColonSegment>, <Ref: DelimiterSegment>, <class 'sqlfluff.core.parser.segments.base.BracketedSegment'>], opts=[<Ref: BinaryOperatorGrammar>]]
INFO       [PD:4  MD:14]	..............BinaryOperatorGrammar               	OneOf.match PRN     	    	[ns=1, ps=2, ms=1, pruned=[<Ref: StringBinaryOperatorGrammar>, <Ref: BooleanBinaryOperatorGrammar>], opts=[<Ref: ArithmeticBinaryOperatorGrammar>, <Ref: ComparisonOperatorGrammar>]]
INFO       [PD:4  MD:15]	...............ArithmeticBinaryOperatorGrammar    	OneOf.match PRN     	    	[ns=0, ps=9, ms=1, pruned=[<Ref: PlusSegment>, <Ref: MinusSegment>, <Ref: MultiplySegment>, <Ref: ModuloSegment>, <Ref: BitwiseAndSegment>, <Ref: BitwiseOrSegment>, <Ref: BitwiseXorSegment>, <Ref: BitwiseLShiftSegment>, <Ref: BitwiseRShiftSegment>], opts=[<Ref: DivideSegment>]]
DEBUG      [PD:4  MD:16]	................ArithmeticBinaryOperatorGrammar   	Ref.match OUT       	    	[match=<MatchResult 0/9: ''>, seg="' / -2 AS a_calculati...'"]
INFO       [PD:4  MD:15]	...............ArithmeticBinaryOperatorGrammar    	OneOf.match OUT     	    	[match=<MatchResult 0/9: ''>, seg="' / -2 AS a_calculati...'"]
DEBUG      [PD:4  MD:15]	...............BinaryOperatorGrammar              	Ref.match OUT       	    	[match=<MatchResult 0/9: ''>, seg="' / -2 AS a_calculati...'"]
INFO       [PD:4  MD:15]	...............ComparisonOperatorGrammar          	OneOf.match PRN     	    	[ns=1, ps=7, ms=0, pruned=[<Ref: EqualsSegment>, <Ref: GreaterThanSegment>, <Ref: LessThanSegment>, <Ref: GreaterThanOrEqualToSegment>, <Ref: LessThanOrEqualToSegment>, <Ref: NotEqualToSegment_a>, <Ref: NotEqualToSegment_b>], opts=[<Ref: LikeOperatorSegment>]]
DEBUG      [PD:4  MD:16]	................ComparisonOperatorGrammar         	Ref.match OUT       	    	[match=<MatchResult 0/9: ''>, seg="' / -2 AS a_calculati...'"]
INFO       [PD:4  MD:15]	...............ComparisonOperatorGrammar          	OneOf.match OUT     	    	[match=<MatchResult 0/9: ''>, seg="' / -2 AS a_calculati...'"]
DEBUG      [PD:4  MD:15]	...............BinaryOperatorGrammar              	Ref.match OUT       	    	[match=<MatchResult 0/9: ''>, seg="' / -2 AS a_calculati...'"]
INFO       [PD:4  MD:14]	..............BinaryOperatorGrammar               	OneOf.match OUT     	    	[match=<MatchResult 0/9: ''>, seg="' / -2 AS a_calculati...'"]
DEBUG      [PD:4  MD:14]	..............ColumnReferenceSegment              	Ref.match OUT       	    	[match=<MatchResult 0/9: ''>, seg="' / -2 AS a_calculati...'"]
INFO       [PD:4  MD:13]	.............ColumnReferenceSegment               	OneOf.match OUT     	    	[match=<MatchResult 0/9: ''>, seg="' / -2 AS a_calculati...'"]
DEBUG      [PD:4  MD:13]	.............ColumnReferenceSegment               	NonCo.match OUT     	+   	[match=<MatchResult 1/9: ' '>, seg="' / -2 AS a_calculati...'"]
INFO       [PD:4  MD:13]	.............SingleIdentifierGrammar              	OneOf.match PRN     	    	[ns=2, ps=0, ms=0, pruned=[], opts=[<Ref: NakedIdentifierSegment>, <Ref: QuotedIdentifierSegment>]]
DEBUG      [PD:4  MD:14]	..............SingleIdentifierGrammar             	Ref.match OUT       	++  	[match=<MatchResult 1/1: 'val'>, seg="'val'"]
INFO       [PD:4  MD:13]	.............SingleIdentifierGrammar              	OneOf.match OUT     	++  	[match=<MatchResult 1/1: 'val'>, seg="'val'"]
DEBUG      [PD:4  MD:13]	.............ColumnReferenceSegment               	Ref.match OUT       	++  	[match=<MatchResult 1/1: 'val'>, seg="'val'"]
INFO       [PD:4  MD:12]	............ColumnReferenceSegment                	Delim.match OUT     	+   	[match=<MatchResult 3/12: 'b.val'>, seg="'b.val / -2 AS a_calc...'"]
DEBUG      [PD:4  MD:11]	...........ColumnReferenceSegment                 	Colum.match OUT     	+   	[match=<MatchResult 1/10: 'b.val'>, seg="'b.val / -2 AS a_calc...'"]
DEBUG      [PD:4  MD:11]	...........Expression_D_Grammar                   	Ref.match OUT       	+   	[match=<MatchResult 1/10: 'b.val'>, seg="'b.val / -2 AS a_calc...'"]
DEBUG      [PD:4  MD:12]	............Expression_D_Grammar                  	Ref.match OUT       	    	[match=<MatchResult 0/12: ''>, seg="'b.val / -2 AS a_calc...'"]
INFO       [PD:4  MD:13]	.............ArrayLiteralSegment                  	Brack.match OUT     	    	[match=<MatchResult 0/12: ''>, seg="'b.val / -2 AS a_calc...'"]
DEBUG      [PD:4  MD:12]	............ArrayLiteralSegment                   	Array.match OUT     	    	[match=<MatchResult 0/12: ''>, seg="'b.val / -2 AS a_calc...'"]
DEBUG      [PD:4  MD:12]	............Expression_D_Grammar                  	Ref.match OUT       	    	[match=<MatchResult 0/12: ''>, seg="'b.val / -2 AS a_calc...'"]
INFO       [PD:4  MD:11]	...........Expression_D_Grammar                   	Seque.match OUT     	    	[match=<MatchResult 0/12: ''>, seg="'b.val / -2 AS a_calc...'"]
INFO       [PD:4  MD:13]	.............DatatypeSegment                      	OneOf.match PRN     	    	[ns=1, ps=2, ms=0, pruned=[<Sequence: [<OneOf: [<Ref: TimeKeywordSegment>, <Ref..., <Bracketed: [<Ref: NumericLiteralSegment..., <Sequence:...]>, <Sequence: [<Ref: DoubleKeywordSegment>, <Ref: PrecisionKeywordSegment>]>], opts=[<Sequence: [<OneOf: [<Sequence: [<OneOf: [<Ref: Char..., <Bracketed: [<OneOf: [<Delimited: [<Ref:..., <Ref: Char...]>]]
INFO       [PD:4  MD:15]	...............DatatypeSegment                    	OneOf.match PRN     	    	[ns=1, ps=1, ms=0, pruned=[<Sequence: [<OneOf: [<Ref: CharacterKeywordSegment>,..., <OneOf: [<Ref: VaryingKeywordSegment>, <...]>], opts=[<Sequence: [<Sequence: [<Ref: SingleIdentifierGramma..., <Ref: DatatypeIdentifierSegment>]>]]
INFO       [PD:4  MD:18]	..................SingleIdentifierGrammar         	OneOf.match PRN     	    	[ns=2, ps=0, ms=0, pruned=[], opts=[<Ref: NakedIdentifierSegment>, <Ref: QuotedIdentifierSegment>]]
DEBUG      [PD:4  MD:19]	...................SingleIdentifierGrammar        	Ref.match OUT       	+   	[match=<MatchResult 1/12: 'b'>, seg="'b.val / -2 AS a_calc...'"]
DEBUG      [PD:4  MD:19]	...................SingleIdentifierGrammar        	Ref.match OUT       	    	[match=<MatchResult 0/12: ''>, seg="'b.val / -2 AS a_calc...'"]
INFO       [PD:4  MD:18]	..................SingleIdentifierGrammar         	OneOf.match OUT     	+   	[match=<MatchResult 1/12: 'b'>, seg="'b.val / -2 AS a_calc...'"]
DEBUG      [PD:4  MD:18]	..................DatatypeSegment                 	Ref.match OUT       	+   	[match=<MatchResult 1/12: 'b'>, seg="'b.val / -2 AS a_calc...'"]
DEBUG      [PD:4  MD:18]	..................DatatypeSegment                 	Ref.match OUT       	+   	[match=<MatchResult 1/11: '.'>, seg="'.val / -2 AS a_calcu...'"]
INFO       [PD:4  MD:17]	.................DatatypeSegment                  	Seque.match OUT     	+   	[match=<MatchResult 2/12: 'b.'>, seg="'b.val / -2 AS a_calc...'"]
DEBUG      [PD:4  MD:17]	.................DatatypeSegment                  	Ref.match OUT       	+   	[match=<MatchResult 1/10: 'val'>, seg="'val / -2 AS a_calcul...'"]
INFO       [PD:4  MD:16]	................DatatypeSegment                   	Seque.match OUT     	+   	[match=<MatchResult 3/12: 'b.val'>, seg="'b.val / -2 AS a_calc...'"]
INFO       [PD:4  MD:15]	...............DatatypeSegment                    	OneOf.match OUT     	+   	[match=<MatchResult 3/12: 'b.val'>, seg="'b.val / -2 AS a_calc...'"]
INFO       [PD:4  MD:15]	...............DatatypeSegment                    	Brack.match OUT     	    	[match=<MatchResult 0/8: ''>, seg="'/ -2 AS a_calculatio...'"]
DEBUG      [PD:4  MD:15]	...............DatatypeSegment                    	Ref.match OUT       	    	[match=<MatchResult 0/8: ''>, seg="'/ -2 AS a_calculatio...'"]
INFO       [PD:4  MD:14]	..............DatatypeSegment                     	Seque.match OUT     	+   	[match=<MatchResult 3/12: 'b.val'>, seg="'b.val / -2 AS a_calc...'"]
INFO       [PD:4  MD:13]	.............DatatypeSegment                      	OneOf.match OUT     	+   	[match=<MatchResult 3/12: 'b.val'>, seg="'b.val / -2 AS a_calc...'"]
DEBUG      [PD:4  MD:12]	............DatatypeSegment                       	Datat.match OUT     	+   	[match=<MatchResult 1/10: 'b.val'>, seg="'b.val / -2 AS a_calc...'"]
DEBUG      [PD:4  MD:12]	............Expression_D_Grammar                  	Ref.match OUT       	+   	[match=<MatchResult 1/10: 'b.val'>, seg="'b.val / -2 AS a_calc...'"]
INFO       [PD:4  MD:12]	............Expression_D_Grammar                  	OneOf.match PRN     	    	[ns=2, ps=3, ms=0, pruned=[<Ref: BooleanLiteralGrammar>, <Ref: NullLiteralSegment>, <Ref: DateTimeLiteralGrammar>], opts=[<Ref: QuotedLiteralSegment>, <Ref: NumericLiteralSegment>]]
DEBUG      [PD:4  MD:13]	.............Expression_D_Grammar                 	Ref.match OUT       	    	[match=<MatchResult 0/8: ''>, seg="'/ -2 AS a_calculatio...'"]
DEBUG      [PD:4  MD:13]	.............Expression_D_Grammar                 	Ref.match OUT       	    	[match=<MatchResult 0/8: ''>, seg="'/ -2 AS a_calculatio...'"]
INFO       [PD:4  MD:12]	............Expression_D_Grammar                  	OneOf.match OUT     	    	[match=<MatchResult 0/8: ''>, seg="'/ -2 AS a_calculatio...'"]
INFO       [PD:4  MD:11]	...........Expression_D_Grammar                   	Seque.match OUT     	    	[match=<MatchResult 0/12: ''>, seg="'b.val / -2 AS a_calc...'"]
INFO       [PD:4  MD:10]	..........Expression_D_Grammar                    	OneOf.match OUT     	+   	[match=<MatchResult 1/10: 'b.val'>, seg="'b.val / -2 AS a_calc...'"]
INFO       [PD:4  MD:10]	..........Accessor_Grammar                        	AnyNu.match PRN     	    	[ns=0, ps=1, ms=0, pruned=[<Ref: ArrayAccessorSegment>], opts='ALL']
INFO       [PD:4  MD:10]	..........Accessor_Grammar                        	AnyNu.match OUT     	    	[match=<MatchResult 0/8: ''>, seg="'/ -2 AS a_calculatio...'"]
DEBUG      [PD:4  MD:10]	..........Expression_D_Grammar                    	Ref.match OUT       	    	[match=<MatchResult 0/8: ''>, seg="'/ -2 AS a_calculatio...'"]
INFO       [PD:4  MD:10]	..........Expression_D_Grammar                    	AnyNu.match PRN     	    	[ns=0, ps=1, ms=0, pruned=[<Ref: ShorthandCastSegment>], opts='ALL']
INFO       [PD:4  MD:10]	..........Expression_D_Grammar                    	AnyNu.match OUT     	    	[match=<MatchResult 0/8: ''>, seg="'/ -2 AS a_calculatio...'"]
INFO       [PD:4  MD:9 ]	.........Expression_D_Grammar                     	Seque.match OUT     	+   	[match=<MatchResult 1/10: 'b.val'>, seg="'b.val / -2 AS a_calc...'"]
DEBUG      [PD:4  MD:9 ]	.........Expression_C_Grammar                     	Ref.match OUT       	+   	[match=<MatchResult 1/10: 'b.val'>, seg="'b.val / -2 AS a_calc...'"]
INFO       [PD:4  MD:8 ]	........Expression_C_Grammar                      	OneOf.match OUT     	+   	[match=<MatchResult 1/10: 'b.val'>, seg="'b.val / -2 AS a_calc...'"]
DEBUG      [PD:4  MD:8 ]	........Expression_A_Grammar                      	Ref.match OUT       	+   	[match=<MatchResult 1/10: 'b.val'>, seg="'b.val / -2 AS a_calc...'"]
DEBUG      [PD:4  MD:9 ]	.........Expression_A_Grammar                     	Ref.match OUT       	    	[match=<MatchResult 0/8: ''>, seg="'/ -2 AS a_calculatio...'"]
INFO       [PD:4  MD:8 ]	........Expression_A_Grammar                      	Seque.match OUT     	    	[match=<MatchResult 0/8: ''>, seg="'/ -2 AS a_calculatio...'"]
INFO       [PD:4  MD:7 ]	.......Expression_A_Grammar                       	Seque.match OUT     	+   	[match=<MatchResult 3/12: '+ b.val'>, seg="'+ b.val / -2 AS a_ca...'"]
DEBUG      [PD:4  MD:7 ]	.......Expression_A_Grammar                       	Ref.match OUT       	    	[match=<MatchResult 0/14: ''>, seg="'+ b.val / -2 AS a_ca...'"]
DEBUG      [PD:4  MD:7 ]	.......Expression_A_Grammar                       	Ref.match OUT       	    	[match=<MatchResult 0/14: ''>, seg="'+ b.val / -2 AS a_ca...'"]
INFO       [PD:4  MD:6 ]	......Expression_A_Grammar                        	OneOf.match OUT     	+   	[match=<MatchResult 3/12: '+ b.val'>, seg="'+ b.val / -2 AS a_ca...'"]
INFO       [PD:4  MD:5 ]	.....Expression_A_Grammar                         	AnyNu.match PRN     	    	[ns=1, ps=0, ms=0, pruned=[], opts=[<OneOf: [<Sequence: [<OneOf: [<Sequence: [<Ref: N..., <Sequence: [<Ref: NotKeywordSegment [opt..., <Sequence:...]>]]
INFO       [PD:4  MD:6 ]	......Expression_A_Grammar                        	OneOf.match PRN     	    	[ns=3, ps=5, ms=0, pruned=[<Sequence: [<Ref: NotKeywordSegment [opt]>, <Ref: InKeywordSegment>, <Bracketed: [<OneOf: [<Delimited: [<Ref:...]>, <Sequence: [<Ref: NotKeywordSegment [opt]>, <Ref: InKeywordSegment>, <Ref: FunctionSegment>]>, <Sequence: [<Ref: IsKeywordSegment>, <Ref: NotKeywordSegment [opt]>, <Ref: IsClauseGrammar>]>, <Sequence: [<Ref: NotKeywordSegment>, <Ref: Expression_C_Grammar>]>, <Sequence: [<Ref: NotKeywordSegment [opt]>, <Ref: BetweenKeywordSegment>, <Ref: Expression_C_Grammar>, <AnyNumbe...]>], opts=[<Sequence: [<OneOf: [<Sequence: [<Ref: NotKeywordSeg..., <Ref: Expression_C_Grammar>, <Sequence: [<Ref: EscapeKe...]>, <Ref: IsNullGrammar>, <Ref: NotNullGrammar>]]
INFO       [PD:4  MD:8 ]	........Expression_A_Grammar                      	OneOf.match PRN     	    	[ns=1, ps=1, ms=0, pruned=[<Sequence: [<Ref: NotKeywordSegment [opt]>, <Ref: LikeGrammar>]>], opts=[<Sequence: [<Ref: BinaryOperatorGrammar>, <Ref: NotKeywordSegment [opt]>]>]]
INFO       [PD:4  MD:10]	..........BinaryOperatorGrammar                   	OneOf.match PRN     	    	[ns=1, ps=2, ms=1, pruned=[<Ref: StringBinaryOperatorGrammar>, <Ref: BooleanBinaryOperatorGrammar>], opts=[<Ref: ArithmeticBinaryOperatorGrammar>, <Ref: ComparisonOperatorGrammar>]]
INFO       [PD:4  MD:11]	...........ArithmeticBinaryOperatorGrammar        	OneOf.match PRN     	    	[ns=0, ps=9, ms=1, pruned=[<Ref: PlusSegment>, <Ref: MinusSegment>, <Ref: MultiplySegment>, <Ref: ModuloSegment>, <Ref: BitwiseAndSegment>, <Ref: BitwiseOrSegment>, <Ref: BitwiseXorSegment>, <Ref: BitwiseLShiftSegment>, <Ref: BitwiseRShiftSegment>], opts=[<Ref: DivideSegment>]]
DEBUG      [PD:4  MD:12]	............ArithmeticBinaryOperatorGrammar       	Ref.match OUT       	+   	[match=<MatchResult 1/8: '/'>, seg="'/ -2 AS a_calculatio...'"]
INFO       [PD:4  MD:11]	...........ArithmeticBinaryOperatorGrammar        	OneOf.match OUT     	+   	[match=<MatchResult 1/8: '/'>, seg="'/ -2 AS a_calculatio...'"]
DEBUG      [PD:4  MD:11]	...........BinaryOperatorGrammar                  	Ref.match OUT       	+   	[match=<MatchResult 1/8: '/'>, seg="'/ -2 AS a_calculatio...'"]
INFO       [PD:4  MD:11]	...........ComparisonOperatorGrammar              	OneOf.match PRN     	    	[ns=1, ps=7, ms=0, pruned=[<Ref: EqualsSegment>, <Ref: GreaterThanSegment>, <Ref: LessThanSegment>, <Ref: GreaterThanOrEqualToSegment>, <Ref: LessThanOrEqualToSegment>, <Ref: NotEqualToSegment_a>, <Ref: NotEqualToSegment_b>], opts=[<Ref: LikeOperatorSegment>]]
DEBUG      [PD:4  MD:12]	............ComparisonOperatorGrammar             	Ref.match OUT       	    	[match=<MatchResult 0/8: ''>, seg="'/ -2 AS a_calculatio...'"]
INFO       [PD:4  MD:11]	...........ComparisonOperatorGrammar              	OneOf.match OUT     	    	[match=<MatchResult 0/8: ''>, seg="'/ -2 AS a_calculatio...'"]
DEBUG      [PD:4  MD:11]	...........BinaryOperatorGrammar                  	Ref.match OUT       	    	[match=<MatchResult 0/8: ''>, seg="'/ -2 AS a_calculatio...'"]
INFO       [PD:4  MD:10]	..........BinaryOperatorGrammar                   	OneOf.match OUT     	+   	[match=<MatchResult 1/8: '/'>, seg="'/ -2 AS a_calculatio...'"]
DEBUG      [PD:4  MD:10]	..........Expression_A_Grammar                    	Ref.match OUT       	+   	[match=<MatchResult 1/8: '/'>, seg="'/ -2 AS a_calculatio...'"]
DEBUG      [PD:4  MD:10]	..........Expression_A_Grammar                    	Ref.match OUT       	    	[match=<MatchResult 0/6: ''>, seg="'-2 AS a_calculation'"]
INFO       [PD:4  MD:9 ]	.........Expression_A_Grammar                     	Seque.match OUT     	+   	[match=<MatchResult 1/8: '/'>, seg="'/ -2 AS a_calculatio...'"]
INFO       [PD:4  MD:8 ]	........Expression_A_Grammar                      	OneOf.match OUT     	+   	[match=<MatchResult 1/8: '/'>, seg="'/ -2 AS a_calculatio...'"]
INFO       [PD:4  MD:8 ]	........Expression_C_Grammar                      	OneOf.match PRN     	    	[ns=1, ps=2, ms=0, pruned=[<Sequence: [<Ref: ExistsKeywordSegment>, <Bracketed: [<Ref: SelectStatementSegmen...]>, <Ref: CaseExpressionSegment>], opts=[<Ref: Expression_D_Grammar>]]
INFO       [PD:4  MD:10]	..........Expression_D_Grammar                    	OneOf.match PRN     	    	[ns=6, ps=3, ms=0, pruned=[<Bracketed: [<OneOf: [<Ref: ExpressionSegment>, <Ref:...]>, <Ref: SelectStatementSegment>, <Ref: IntervalExpressionSegment>], opts=[<Ref: BareFunctionSegment>, <Ref: FunctionSegment>, <Ref: LiteralGrammar>, <Ref: ColumnReferenceSegment>, <Sequence: [<Ref: SimpleArrayTypeGrammar [opt]>, <Ref: ArrayLiteralSegment>]>, <Sequence: [<Ref: DatatypeSegment>, <OneOf: [<Ref: QuotedLiteralSegment>, <R...]>]]
DEBUG      [PD:4  MD:11]	...........Expression_D_Grammar                   	Ref.match OUT       	    	[match=<MatchResult 0/6: ''>, seg="'-2 AS a_calculation'"]
INFO       [PD:4  MD:12]	............FunctionSegment                       	OneOf.match PRN     	    	[ns=1, ps=1, ms=0, pruned=[<Sequence: [<Sequence: [<Ref: DateAddFunctionNameSeg...]>], opts=[<Sequence: [<Sequence: [<AnyNumberOf: [<Ref: Functio..., <Ref: PostFunctionGrammar [opt]>]>]]
DEBUG      [PD:4  MD:18]	..................DateAddFunctionNameSegment      	Ref.match OUT       	    	[match=<MatchResult 0/6: ''>, seg="'-2 AS a_calculation'"]
INFO       [PD:4  MD:17]	.................DateAddFunctionNameSegment       	Seque.match OUT     	    	[match=<MatchResult 0/6: ''>, seg="'-2 AS a_calculation'"]
DEBUG      [PD:4  MD:16]	................DateAddFunctionNameSegment        	DateA.match OUT     	    	[match=<MatchResult 0/6: ''>, seg="'-2 AS a_calculation'"]
DEBUG      [PD:4  MD:16]	................FunctionSegment                   	Ref.match OUT       	    	[match=<MatchResult 0/6: ''>, seg="'-2 AS a_calculation'"]
INFO       [PD:4  MD:15]	...............FunctionSegment                    	AnyNu.match PRN     	    	[ns=1, ps=0, ms=0, pruned=[], opts=[<Ref: FunctionNameSegment>]]
INFO       [PD:4  MD:18]	..................FunctionNameSegment             	AnyNu.match PRN     	    	[ns=1, ps=0, ms=0, pruned=[], opts=[<Sequence: [<Ref: SingleIdentifierGrammar>, <Ref: DotSegment>]>]]
INFO       [PD:4  MD:20]	....................SingleIdentifierGrammar       	OneOf.match PRN     	    	[ns=2, ps=0, ms=0, pruned=[], opts=[<Ref: NakedIdentifierSegment>, <Ref: QuotedIdentifierSegment>]]
DEBUG      [PD:4  MD:21]	.....................SingleIdentifierGrammar      	Ref.match OUT       	    	[match=<MatchResult 0/6: ''>, seg="'-2 AS a_calculation'"]
DEBUG      [PD:4  MD:21]	.....................SingleIdentifierGrammar      	Ref.match OUT       	    	[match=<MatchResult 0/6: ''>, seg="'-2 AS a_calculation'"]
INFO       [PD:4  MD:20]	....................SingleIdentifierGrammar       	OneOf.match OUT     	    	[match=<MatchResult 0/6: ''>, seg="'-2 AS a_calculation'"]
DEBUG      [PD:4  MD:20]	....................FunctionNameSegment           	Ref.match OUT       	    	[match=<MatchResult 0/6: ''>, seg="'-2 AS a_calculation'"]
INFO       [PD:4  MD:19]	...................FunctionNameSegment            	Seque.match OUT     	    	[match=<MatchResult 0/6: ''>, seg="'-2 AS a_calculation'"]
INFO       [PD:4  MD:18]	..................FunctionNameSegment             	AnyNu.match OUT     	    	[match=<MatchResult 0/6: ''>, seg="'-2 AS a_calculation'"]
INFO       [PD:4  MD:18]	..................FunctionNameSegment             	OneOf.match PRN     	    	[ns=2, ps=0, ms=0, pruned=[], opts=[<Ref: FunctionNameIdentifierSegment>, <Ref: QuotedIdentifierSegment>]]
DEBUG      [PD:4  MD:19]	...................FunctionNameSegment            	Ref.match OUT       	    	[match=<MatchResult 0/6: ''>, seg="'-2 AS a_calculation'"]
DEBUG      [PD:4  MD:19]	...................FunctionNameSegment            	Ref.match OUT       	    	[match=<MatchResult 0/6: ''>, seg="'-2 AS a_calculation'"]
INFO       [PD:4  MD:18]	..................FunctionNameSegment             	OneOf.match OUT     	    	[match=<MatchResult 0/6: ''>, seg="'-2 AS a_calculation'"]
INFO       [PD:4  MD:17]	.................FunctionNameSegment              	Seque.match OUT     	    	[match=<MatchResult 0/6: ''>, seg="'-2 AS a_calculation'"]
DEBUG      [PD:4  MD:16]	................FunctionNameSegment               	Funct.match OUT     	    	[match=<MatchResult 0/6: ''>, seg="'-2 AS a_calculation'"]
DEBUG      [PD:4  MD:16]	................FunctionSegment                   	Ref.match OUT       	    	[match=<MatchResult 0/6: ''>, seg="'-2 AS a_calculation'"]
INFO       [PD:4  MD:15]	...............FunctionSegment                    	AnyNu.match OUT     	    	[match=<MatchResult 0/6: ''>, seg="'-2 AS a_calculation'"]
INFO       [PD:4  MD:14]	..............FunctionSegment                     	Seque.match OUT     	    	[match=<MatchResult 0/6: ''>, seg="'-2 AS a_calculation'"]
INFO       [PD:4  MD:13]	.............FunctionSegment                      	Seque.match OUT     	    	[match=<MatchResult 0/6: ''>, seg="'-2 AS a_calculation'"]
INFO       [PD:4  MD:12]	............FunctionSegment                       	OneOf.match OUT     	    	[match=<MatchResult 0/6: ''>, seg="'-2 AS a_calculation'"]
DEBUG      [PD:4  MD:11]	...........FunctionSegment                        	Funct.match OUT     	    	[match=<MatchResult 0/6: ''>, seg="'-2 AS a_calculation'"]
DEBUG      [PD:4  MD:11]	...........Expression_D_Grammar                   	Ref.match OUT       	    	[match=<MatchResult 0/6: ''>, seg="'-2 AS a_calculation'"]
INFO       [PD:4  MD:11]	...........LiteralGrammar                         	OneOf.match PRN     	    	[ns=2, ps=3, ms=1, pruned=[<Ref: BooleanLiteralGrammar>, <Ref: NullLiteralSegment>, <Ref: DateTimeLiteralGrammar>], opts=[<Ref: QuotedLiteralSegment>, <Ref: NumericLiteralSegment>, <Ref: QualifiedNumericLiteralSegment>]]
DEBUG      [PD:4  MD:12]	............LiteralGrammar                        	Ref.match OUT       	    	[match=<MatchResult 0/6: ''>, seg="'-2 AS a_calculation'"]
DEBUG      [PD:4  MD:12]	............LiteralGrammar                        	Ref.match OUT       	    	[match=<MatchResult 0/6: ''>, seg="'-2 AS a_calculation'"]
INFO       [PD:4  MD:14]	..............QualifiedNumericLiteralSegment      	OneOf.match PRN     	    	[ns=0, ps=1, ms=1, pruned=[<Ref: PlusSegment>], opts=[<Ref: MinusSegment>]]
DEBUG      [PD:4  MD:15]	...............QualifiedNumericLiteralSegment     	Ref.match OUT       	+   	[match=<MatchResult 1/6: '-'>, seg="'-2 AS a_calculation'"]
INFO       [PD:4  MD:14]	..............QualifiedNumericLiteralSegment      	OneOf.match OUT     	+   	[match=<MatchResult 1/6: '-'>, seg="'-2 AS a_calculation'"]
DEBUG      [PD:4  MD:14]	..............QualifiedNumericLiteralSegment      	Ref.match OUT       	+   	[match=<MatchResult 1/5: '2'>, seg="'2 AS a_calculation'"]
INFO       [PD:4  MD:13]	.............QualifiedNumericLiteralSegment       	Seque.match OUT     	+   	[match=<MatchResult 2/6: '-2'>, seg="'-2 AS a_calculation'"]
DEBUG      [PD:4  MD:12]	............QualifiedNumericLiteralSegment        	Quali.match OUT     	+   	[match=<MatchResult 1/5: '-2'>, seg="'-2 AS a_calculation'"]
DEBUG      [PD:4  MD:12]	............LiteralGrammar                        	Ref.match OUT       	+   	[match=<MatchResult 1/5: '-2'>, seg="'-2 AS a_calculation'"]
INFO       [PD:4  MD:11]	...........LiteralGrammar                         	OneOf.match OUT     	+   	[match=<MatchResult 1/5: '-2'>, seg="'-2 AS a_calculation'"]
DEBUG      [PD:4  MD:11]	...........Expression_D_Grammar                   	Ref.match OUT       	+   	[match=<MatchResult 1/5: '-2'>, seg="'-2 AS a_calculation'"]
DEBUG      [PD:4  MD:13]	.............ColumnReferenceSegment               	Delim._look_ahead_match IN	    	[ls=6, seg='-2 AS a_calculation']
DEBUG      [PD:4  MD:13]	.............ColumnReferenceSegment               	Delim._look_ahead_match SI	    	[mq=[], sb=['-', '2', '', 'AS', '', 'A_CALCULATION']]
INFO       [PD:4  MD:13]	.............ColumnReferenceSegment               	OneOf.match PRN     	    	[ns=1, ps=10, ms=0, pruned=[<Ref: OnKeywordSegment>, <Ref: AsKeywordSegment>, <Ref: UsingKeywordSegment>, <Ref: CommaSegment>, <Ref: CastOperatorSegment>, <Ref: StartSquareBracketSegment>, <Ref: StartBracketSegment>, <Ref: ColonSegment>, <Ref: DelimiterSegment>, <class 'sqlfluff.core.parser.segments.base.BracketedSegment'>], opts=[<Ref: BinaryOperatorGrammar>]]
INFO       [PD:4  MD:14]	..............BinaryOperatorGrammar               	OneOf.match PRN     	    	[ns=1, ps=2, ms=1, pruned=[<Ref: StringBinaryOperatorGrammar>, <Ref: BooleanBinaryOperatorGrammar>], opts=[<Ref: ArithmeticBinaryOperatorGrammar>, <Ref: ComparisonOperatorGrammar>]]
INFO       [PD:4  MD:15]	...............ArithmeticBinaryOperatorGrammar    	OneOf.match PRN     	    	[ns=0, ps=9, ms=1, pruned=[<Ref: PlusSegment>, <Ref: DivideSegment>, <Ref: MultiplySegment>, <Ref: ModuloSegment>, <Ref: BitwiseAndSegment>, <Ref: BitwiseOrSegment>, <Ref: BitwiseXorSegment>, <Ref: BitwiseLShiftSegment>, <Ref: BitwiseRShiftSegment>], opts=[<Ref: MinusSegment>]]
DEBUG      [PD:4  MD:16]	................ArithmeticBinaryOperatorGrammar   	Ref.match OUT       	+   	[match=<MatchResult 1/6: '-'>, seg="'-2 AS a_calculation'"]
INFO       [PD:4  MD:15]	...............ArithmeticBinaryOperatorGrammar    	OneOf.match OUT     	+   	[match=<MatchResult 1/6: '-'>, seg="'-2 AS a_calculation'"]
DEBUG      [PD:4  MD:15]	...............BinaryOperatorGrammar              	Ref.match OUT       	+   	[match=<MatchResult 1/6: '-'>, seg="'-2 AS a_calculation'"]
INFO       [PD:4  MD:15]	...............ComparisonOperatorGrammar          	OneOf.match PRN     	    	[ns=1, ps=7, ms=0, pruned=[<Ref: EqualsSegment>, <Ref: GreaterThanSegment>, <Ref: LessThanSegment>, <Ref: GreaterThanOrEqualToSegment>, <Ref: LessThanOrEqualToSegment>, <Ref: NotEqualToSegment_a>, <Ref: NotEqualToSegment_b>], opts=[<Ref: LikeOperatorSegment>]]
DEBUG      [PD:4  MD:16]	................ComparisonOperatorGrammar         	Ref.match OUT       	    	[match=<MatchResult 0/6: ''>, seg="'-2 AS a_calculation'"]
INFO       [PD:4  MD:15]	...............ComparisonOperatorGrammar          	OneOf.match OUT     	    	[match=<MatchResult 0/6: ''>, seg="'-2 AS a_calculation'"]
DEBUG      [PD:4  MD:15]	...............BinaryOperatorGrammar              	Ref.match OUT       	    	[match=<MatchResult 0/6: ''>, seg="'-2 AS a_calculation'"]
INFO       [PD:4  MD:14]	..............BinaryOperatorGrammar               	OneOf.match OUT     	+   	[match=<MatchResult 1/6: '-'>, seg="'-2 AS a_calculation'"]
DEBUG      [PD:4  MD:14]	..............ColumnReferenceSegment              	Ref.match OUT       	+   	[match=<MatchResult 1/6: '-'>, seg="'-2 AS a_calculation'"]
INFO       [PD:4  MD:13]	.............ColumnReferenceSegment               	OneOf.match OUT     	+   	[match=<MatchResult 1/6: '-'>, seg="'-2 AS a_calculation'"]
DEBUG      [PD:4  MD:13]	.............ColumnReferenceSegment               	NonCo.match OUT     	    	[match=<MatchResult 0/6: ''>, seg="'-2 AS a_calculation'"]
INFO       [PD:4  MD:12]	............ColumnReferenceSegment                	Delim.match OUT     	    	[match=<MatchResult 0/6: ''>, seg="'-2 AS a_calculation'"]
DEBUG      [PD:4  MD:11]	...........ColumnReferenceSegment                 	Colum.match OUT     	    	[match=<MatchResult 0/6: ''>, seg="'-2 AS a_calculation'"]
DEBUG      [PD:4  MD:11]	...........Expression_D_Grammar                   	Ref.match OUT       	    	[match=<MatchResult 0/6: ''>, seg="'-2 AS a_calculation'"]
DEBUG      [PD:4  MD:12]	............Expression_D_Grammar                  	Ref.match OUT       	    	[match=<MatchResult 0/6: ''>, seg="'-2 AS a_calculation'"]
INFO       [PD:4  MD:13]	.............ArrayLiteralSegment                  	Brack.match OUT     	    	[match=<MatchResult 0/6: ''>, seg="'-2 AS a_calculation'"]
DEBUG      [PD:4  MD:12]	............ArrayLiteralSegment                   	Array.match OUT     	    	[match=<MatchResult 0/6: ''>, seg="'-2 AS a_calculation'"]
DEBUG      [PD:4  MD:12]	............Expression_D_Grammar                  	Ref.match OUT       	    	[match=<MatchResult 0/6: ''>, seg="'-2 AS a_calculation'"]
INFO       [PD:4  MD:11]	...........Expression_D_Grammar                   	Seque.match OUT     	    	[match=<MatchResult 0/6: ''>, seg="'-2 AS a_calculation'"]
INFO       [PD:4  MD:13]	.............DatatypeSegment                      	OneOf.match PRN     	    	[ns=1, ps=2, ms=0, pruned=[<Sequence: [<OneOf: [<Ref: TimeKeywordSegment>, <Ref..., <Bracketed: [<Ref: NumericLiteralSegment..., <Sequence:...]>, <Sequence: [<Ref: DoubleKeywordSegment>, <Ref: PrecisionKeywordSegment>]>], opts=[<Sequence: [<OneOf: [<Sequence: [<OneOf: [<Ref: Char..., <Bracketed: [<OneOf: [<Delimited: [<Ref:..., <Ref: Char...]>]]
INFO       [PD:4  MD:15]	...............DatatypeSegment                    	OneOf.match PRN     	    	[ns=1, ps=1, ms=0, pruned=[<Sequence: [<OneOf: [<Ref: CharacterKeywordSegment>,..., <OneOf: [<Ref: VaryingKeywordSegment>, <...]>], opts=[<Sequence: [<Sequence: [<Ref: SingleIdentifierGramma..., <Ref: DatatypeIdentifierSegment>]>]]
INFO       [PD:4  MD:18]	..................SingleIdentifierGrammar         	OneOf.match PRN     	    	[ns=2, ps=0, ms=0, pruned=[], opts=[<Ref: NakedIdentifierSegment>, <Ref: QuotedIdentifierSegment>]]
DEBUG      [PD:4  MD:19]	...................SingleIdentifierGrammar        	Ref.match OUT       	    	[match=<MatchResult 0/6: ''>, seg="'-2 AS a_calculation'"]
DEBUG      [PD:4  MD:19]	...................SingleIdentifierGrammar        	Ref.match OUT       	    	[match=<MatchResult 0/6: ''>, seg="'-2 AS a_calculation'"]
INFO       [PD:4  MD:18]	..................SingleIdentifierGrammar         	OneOf.match OUT     	    	[match=<MatchResult 0/6: ''>, seg="'-2 AS a_calculation'"]
DEBUG      [PD:4  MD:18]	..................DatatypeSegment                 	Ref.match OUT       	    	[match=<MatchResult 0/6: ''>, seg="'-2 AS a_calculation'"]
INFO       [PD:4  MD:17]	.................DatatypeSegment                  	Seque.match OUT     	    	[match=<MatchResult 0/6: ''>, seg="'-2 AS a_calculation'"]
DEBUG      [PD:4  MD:17]	.................DatatypeSegment                  	Ref.match OUT       	    	[match=<MatchResult 0/6: ''>, seg="'-2 AS a_calculation'"]
INFO       [PD:4  MD:16]	................DatatypeSegment                   	Seque.match OUT     	    	[match=<MatchResult 0/6: ''>, seg="'-2 AS a_calculation'"]
INFO       [PD:4  MD:15]	...............DatatypeSegment                    	OneOf.match OUT     	    	[match=<MatchResult 0/6: ''>, seg="'-2 AS a_calculation'"]
INFO       [PD:4  MD:14]	..............DatatypeSegment                     	Seque.match OUT     	    	[match=<MatchResult 0/6: ''>, seg="'-2 AS a_calculation'"]
INFO       [PD:4  MD:13]	.............DatatypeSegment                      	OneOf.match OUT     	    	[match=<MatchResult 0/6: ''>, seg="'-2 AS a_calculation'"]
DEBUG      [PD:4  MD:12]	............DatatypeSegment                       	Datat.match OUT     	    	[match=<MatchResult 0/6: ''>, seg="'-2 AS a_calculation'"]
DEBUG      [PD:4  MD:12]	............Expression_D_Grammar                  	Ref.match OUT       	    	[match=<MatchResult 0/6: ''>, seg="'-2 AS a_calculation'"]
INFO       [PD:4  MD:11]	...........Expression_D_Grammar                   	Seque.match OUT     	    	[match=<MatchResult 0/6: ''>, seg="'-2 AS a_calculation'"]
INFO       [PD:4  MD:10]	..........Expression_D_Grammar                    	OneOf.match OUT     	+   	[match=<MatchResult 1/5: '-2'>, seg="'-2 AS a_calculation'"]
INFO       [PD:4  MD:10]	..........Accessor_Grammar                        	AnyNu.match PRN     	    	[ns=0, ps=1, ms=0, pruned=[<Ref: ArrayAccessorSegment>], opts='ALL']
INFO       [PD:4  MD:10]	..........Accessor_Grammar                        	AnyNu.match OUT     	    	[match=<MatchResult 0/3: ''>, seg="'AS a_calculation'"]
DEBUG      [PD:4  MD:10]	..........Expression_D_Grammar                    	Ref.match OUT       	    	[match=<MatchResult 0/3: ''>, seg="'AS a_calculation'"]
INFO       [PD:4  MD:10]	..........Expression_D_Grammar                    	AnyNu.match PRN     	    	[ns=0, ps=1, ms=0, pruned=[<Ref: ShorthandCastSegment>], opts='ALL']
INFO       [PD:4  MD:10]	..........Expression_D_Grammar                    	AnyNu.match OUT     	    	[match=<MatchResult 0/3: ''>, seg="'AS a_calculation'"]
INFO       [PD:4  MD:9 ]	.........Expression_D_Grammar                     	Seque.match OUT     	+   	[match=<MatchResult 1/5: '-2'>, seg="'-2 AS a_calculation'"]
DEBUG      [PD:4  MD:9 ]	.........Expression_C_Grammar                     	Ref.match OUT       	+   	[match=<MatchResult 1/5: '-2'>, seg="'-2 AS a_calculation'"]
INFO       [PD:4  MD:8 ]	........Expression_C_Grammar                      	OneOf.match OUT     	+   	[match=<MatchResult 1/5: '-2'>, seg="'-2 AS a_calculation'"]
DEBUG      [PD:4  MD:8 ]	........Expression_A_Grammar                      	Ref.match OUT       	+   	[match=<MatchResult 1/5: '-2'>, seg="'-2 AS a_calculation'"]
DEBUG      [PD:4  MD:9 ]	.........Expression_A_Grammar                     	Ref.match OUT       	    	[match=<MatchResult 0/3: ''>, seg="'AS a_calculation'"]
INFO       [PD:4  MD:8 ]	........Expression_A_Grammar                      	Seque.match OUT     	    	[match=<MatchResult 0/3: ''>, seg="'AS a_calculation'"]
INFO       [PD:4  MD:7 ]	.......Expression_A_Grammar                       	Seque.match OUT     	+   	[match=<MatchResult 3/7: '/ -2'>, seg="'/ -2 AS a_calculatio...'"]
DEBUG      [PD:4  MD:7 ]	.......Expression_A_Grammar                       	Ref.match OUT       	    	[match=<MatchResult 0/8: ''>, seg="'/ -2 AS a_calculatio...'"]
DEBUG      [PD:4  MD:7 ]	.......Expression_A_Grammar                       	Ref.match OUT       	    	[match=<MatchResult 0/8: ''>, seg="'/ -2 AS a_calculatio...'"]
INFO       [PD:4  MD:6 ]	......Expression_A_Grammar                        	OneOf.match OUT     	+   	[match=<MatchResult 3/7: '/ -2'>, seg="'/ -2 AS a_calculatio...'"]
INFO       [PD:4  MD:5 ]	.....Expression_A_Grammar                         	AnyNu.match PRN     	    	[ns=1, ps=0, ms=0, pruned=[], opts=[<OneOf: [<Sequence: [<OneOf: [<Sequence: [<Ref: N..., <Sequence: [<Ref: NotKeywordSegment [opt..., <Sequence:...]>]]
INFO       [PD:4  MD:6 ]	......Expression_A_Grammar                        	OneOf.match PRN     	    	[ns=3, ps=5, ms=0, pruned=[<Sequence: [<Ref: NotKeywordSegment [opt]>, <Ref: InKeywordSegment>, <Bracketed: [<OneOf: [<Delimited: [<Ref:...]>, <Sequence: [<Ref: NotKeywordSegment [opt]>, <Ref: InKeywordSegment>, <Ref: FunctionSegment>]>, <Sequence: [<Ref: IsKeywordSegment>, <Ref: NotKeywordSegment [opt]>, <Ref: IsClauseGrammar>]>, <Sequence: [<Ref: NotKeywordSegment>, <Ref: Expression_C_Grammar>]>, <Sequence: [<Ref: NotKeywordSegment [opt]>, <Ref: BetweenKeywordSegment>, <Ref: Expression_C_Grammar>, <AnyNumbe...]>], opts=[<Sequence: [<OneOf: [<Sequence: [<Ref: NotKeywordSeg..., <Ref: Expression_C_Grammar>, <Sequence: [<Ref: EscapeKe...]>, <Ref: IsNullGrammar>, <Ref: NotNullGrammar>]]
INFO       [PD:4  MD:8 ]	........Expression_A_Grammar                      	OneOf.match PRN     	    	[ns=1, ps=1, ms=0, pruned=[<Sequence: [<Ref: NotKeywordSegment [opt]>, <Ref: LikeGrammar>]>], opts=[<Sequence: [<Ref: BinaryOperatorGrammar>, <Ref: NotKeywordSegment [opt]>]>]]
INFO       [PD:4  MD:10]	..........BinaryOperatorGrammar                   	OneOf.match PRN     	    	[ns=1, ps=3, ms=0, pruned=[<Ref: ArithmeticBinaryOperatorGrammar>, <Ref: StringBinaryOperatorGrammar>, <Ref: BooleanBinaryOperatorGrammar>], opts=[<Ref: ComparisonOperatorGrammar>]]
INFO       [PD:4  MD:11]	...........ComparisonOperatorGrammar              	OneOf.match PRN     	    	[ns=1, ps=7, ms=0, pruned=[<Ref: EqualsSegment>, <Ref: GreaterThanSegment>, <Ref: LessThanSegment>, <Ref: GreaterThanOrEqualToSegment>, <Ref: LessThanOrEqualToSegment>, <Ref: NotEqualToSegment_a>, <Ref: NotEqualToSegment_b>], opts=[<Ref: LikeOperatorSegment>]]
DEBUG      [PD:4  MD:12]	............ComparisonOperatorGrammar             	Ref.match OUT       	    	[match=<MatchResult 0/3: ''>, seg="'AS a_calculation'"]
INFO       [PD:4  MD:11]	...........ComparisonOperatorGrammar              	OneOf.match OUT     	    	[match=<MatchResult 0/3: ''>, seg="'AS a_calculation'"]
DEBUG      [PD:4  MD:11]	...........BinaryOperatorGrammar                  	Ref.match OUT       	    	[match=<MatchResult 0/3: ''>, seg="'AS a_calculation'"]
INFO       [PD:4  MD:10]	..........BinaryOperatorGrammar                   	OneOf.match OUT     	    	[match=<MatchResult 0/3: ''>, seg="'AS a_calculation'"]
DEBUG      [PD:4  MD:10]	..........Expression_A_Grammar                    	Ref.match OUT       	    	[match=<MatchResult 0/3: ''>, seg="'AS a_calculation'"]
INFO       [PD:4  MD:9 ]	.........Expression_A_Grammar                     	Seque.match OUT     	    	[match=<MatchResult 0/3: ''>, seg="'AS a_calculation'"]
INFO       [PD:4  MD:8 ]	........Expression_A_Grammar                      	OneOf.match OUT     	    	[match=<MatchResult 0/3: ''>, seg="'AS a_calculation'"]
INFO       [PD:4  MD:7 ]	.......Expression_A_Grammar                       	Seque.match OUT     	    	[match=<MatchResult 0/3: ''>, seg="'AS a_calculation'"]
DEBUG      [PD:4  MD:7 ]	.......Expression_A_Grammar                       	Ref.match OUT       	    	[match=<MatchResult 0/3: ''>, seg="'AS a_calculation'"]
DEBUG      [PD:4  MD:7 ]	.......Expression_A_Grammar                       	Ref.match OUT       	    	[match=<MatchResult 0/3: ''>, seg="'AS a_calculation'"]
INFO       [PD:4  MD:6 ]	......Expression_A_Grammar                        	OneOf.match OUT     	    	[match=<MatchResult 0/3: ''>, seg="'AS a_calculation'"]
INFO       [PD:4  MD:5 ]	.....Expression_A_Grammar                         	AnyNu.match OUT     	+   	[match=<MatchResult 7/11: '+ b.val / -2'>, seg="'+ b.val / -2 AS a_ca...'"]
INFO       [PD:4  MD:4 ]	....Expression_A_Grammar                          	Seque.match OUT     	+   	[match=<MatchResult 9/13: 'c.val + b.val / -2'>, seg="'c.val + b.val / -2 A...'"]
DEBUG      [PD:4  MD:4 ]	....ExpressionSegment                             	Ref.match OUT       	+   	[match=<MatchResult 9/13: 'c.val + b.val / -2'>, seg="'c.val + b.val / -2 A...'"]
DEBUG      [PD:4  MD:3 ]	...ExpressionSegment                              	Expre.match OUT     	+   	[match=<MatchResult 1/5: 'c.val + b.val / -2'>, seg="'c.val + b.val / -2 A...'"]
DEBUG      [PD:4  MD:3 ]	...BaseExpressionElementGrammar                   	Ref.match OUT       	+   	[match=<MatchResult 1/5: 'c.val + b.val / -2'>, seg="'c.val + b.val / -2 A...'"]
INFO       [PD:4  MD:2 ]	..BaseExpressionElementGrammar                    	OneOf.match OUT     	+   	[match=<MatchResult 1/5: 'c.val + b.val / -2'>, seg="'c.val + b.val / -2 A...'"]
DEBUG      [PD:4  MD:2 ]	..SelectClauseElementSegment                      	Ref.match OUT       	+   	[match=<MatchResult 1/5: 'c.val + b.val / -2'>, seg="'c.val + b.val / -2 A...'"]
DEBUG      [PD:4  MD:4 ]	....AliasExpressionSegment                        	Ref.match OUT       	+   	[match=<MatchResult 1/3: 'AS'>, seg="'AS a_calculation'"]
INFO       [PD:4  MD:4 ]	....AliasExpressionSegment                        	OneOf.match PRN     	    	[ns=2, ps=0, ms=0, pruned=[], opts=[<Sequence: [<Ref: SingleIdentifierGrammar>, <Bracketed: [<Ref: SingleIdentifierListS...]>, <Ref: QuotedLiteralSegment>]]
INFO       [PD:4  MD:6 ]	......SingleIdentifierGrammar                     	OneOf.match PRN     	    	[ns=2, ps=0, ms=0, pruned=[], opts=[<Ref: NakedIdentifierSegment>, <Ref: QuotedIdentifierSegment>]]
DEBUG      [PD:4  MD:7 ]	.......SingleIdentifierGrammar                    	Ref.match OUT       	++  	[match=<MatchResult 1/1: 'a_calculation'>, seg="'a_calculation'"]
INFO       [PD:4  MD:6 ]	......SingleIdentifierGrammar                     	OneOf.match OUT     	++  	[match=<MatchResult 1/1: 'a_calculation'>, seg="'a_calculation'"]
DEBUG      [PD:4  MD:6 ]	......AliasExpressionSegment                      	Ref.match OUT       	++  	[match=<MatchResult 1/1: 'a_calculation'>, seg="'a_calculation'"]
INFO       [PD:4  MD:5 ]	.....AliasExpressionSegment                       	Seque.match OUT     	++  	[match=<MatchResult 1/1: 'a_calculation'>, seg="'a_calculation'"]
INFO       [PD:4  MD:4 ]	....AliasExpressionSegment                        	OneOf.match OUT     	++  	[match=<MatchResult 1/1: 'a_calculation'>, seg="'a_calculation'"]
INFO       [PD:4  MD:3 ]	...AliasExpressionSegment                         	Seque.match OUT     	++  	[match=<MatchResult 3/3: 'AS a_calculation'>, seg="'AS a_calculation'"]
DEBUG      [PD:4  MD:2 ]	..AliasExpressionSegment                          	Alias.match OUT     	++  	[match=<MatchResult 1/1: 'AS a_calculation'>, seg="'AS a_calculation'"]
DEBUG      [PD:4  MD:2 ]	..SelectClauseElementSegment                      	Ref.match OUT       	++  	[match=<MatchResult 1/1: 'AS a_calculation'>, seg="'AS a_calculation'"]
INFO       [PD:4  MD:1 ]	.SelectClauseElementSegment                       	Seque.match OUT     	++  	[match=<MatchResult 3/3: 'c.val + b.val /...S a_calculation'>, seg="'c.val + b.val / -2 A...'"]
INFO       [PD:4  MD:0 ]	SelectClauseElementSegment                        	OneOf.match OUT     	++  	[match=<MatchResult 3/3: 'c.val + b.val /...S a_calculation'>, seg="'c.val + b.val / -2 A...'"]
DEBUG      SelectClauseElementSegment.parse: Done Parse. Plotting Recursion. Recurse=True
DEBUG      ###
#
# Beginning Parse Depth 5: SelectClauseElementSegment
#
###
Initial Structure:
[L:  9, P:  5]      |select_clause_element:
[L:  9, P:  5]      |    expression:
[L:  9, P:  5]      |        column_reference:
[L:  9, P:  5]      |            identifier:                                       'c'
[L:  9, P:  6]      |            dot:                                              '.'
[L:  9, P:  7]      |            identifier:                                       'val'
[L:  9, P: 10]      |        whitespace:                                           ' '
[L:  9, P: 11]      |        binary_operator:                                      '+'
[L:  9, P: 12]      |        whitespace:                                           ' '
[L:  9, P: 13]      |        column_reference:
[L:  9, P: 13]      |            identifier:                                       'b'
[L:  9, P: 14]      |            dot:                                              '.'
[L:  9, P: 15]      |            identifier:                                       'val'
[L:  9, P: 18]      |        whitespace:                                           ' '
[L:  9, P: 19]      |        binary_operator:                                      '/'
[L:  9, P: 20]      |        whitespace:                                           ' '
[L:  9, P: 21]      |        numeric_literal:
[L:  9, P: 21]      |            binary_operator:                                  '-'
[L:  9, P: 22]      |            literal:                                          '2'
[L:  9, P: 23]      |    whitespace:                                               ' '
[L:  9, P: 24]      |    alias_expression:
[L:  9, P: 24]      |        keyword:                                              'AS'
[L:  9, P: 26]      |        whitespace:                                           ' '
[L:  9, P: 27]      |        identifier:                                           'a_calculation'

INFO       [PD:5] Skipping expansion of <ExpressionSegment: ([L:  9, P:  5])>...
INFO       [PD:5] Skipping expansion of <WhitespaceSegment: ([L:  9, P: 23]) ' '>...
INFO       [PD:5] Skipping expansion of <AliasExpressionSegment: ([L:  9, P: 24])>...
INFO       [PD:3] Skipping expansion of <NewlineSegment: ([L:  9, P: 40]) '\n'>...
INFO       [PD:3] Skipping expansion of <Dedent: ([L: 10, P:  1]) ''>...
INFO       
###
#
# Parse Depth 3. Expanding: FromClauseSegment: 'FROM tbl\nINNER JOIN b ON (tbl.common_id ...'
#
###
DEBUG      [PD:3  MD:1 ]	.FromClauseSegment                                	Ref.match OUT       	+   	[match=<MatchResult 1/31: 'FROM'>, seg="'FROM tbl\\nINNER JOIN ...'"]
DEBUG      [PD:3  MD:2 ]	..FromClauseSegment                               	Delim._look_ahead_match IN	    	[ls=29, seg='tbl\nINNER JOIN b ON ...']
DEBUG      [PD:3  MD:2 ]	..FromClauseSegment                               	Delim._look_ahead_match SI	    	[mq=[], sb=['TBL', '', 'INNER', '', 'JOIN', '', 'B', '', 'ON', '', '(TBL.COMMON_ID', '', 'JOIN', '', 'C', '', 'ON', '', '(TBL.ID', '', 'LEFT', '', 'JOIN', '', 'D', '', 'ON', '', '(TBL.ID']]
DEBUG      [PD:3  MD:2 ]	..FromClauseSegment                               	Delim._look_ahead_match SC	    	[bsm=None]
INFO       [PD:3  MD:4 ]	....FromExpressionSegment                         	OneOf.match PRN     	    	[ns=1, ps=1, ms=0, pruned=[<Ref: MLTableExpressionSegment>], opts=[<Ref: FromExpressionElementSegment>]]
DEBUG      [PD:3  MD:7 ]	.......FromExpressionElementSegment               	Ref.match OUT       	    	[match=<MatchResult 0/29: ''>, seg="'tbl\\nINNER JOIN b ON ...'"]
INFO       [PD:3  MD:7 ]	.......FromExpressionElementSegment               	Optio.match PRN     	    	[ns=1, ps=1, ms=0, pruned=[<Bracketed: [<Ref: TableExpressionSegment>]>], opts=[<Ref: TableExpressionSegment>]]
INFO       [PD:3  MD:9 ]	.........TableExpressionSegment                   	OneOf.match PRN     	    	[ns=3, ps=1, ms=0, pruned=[<Bracketed: [<Ref: SelectableGrammar>]>], opts=[<Ref: BareFunctionSegment>, <Ref: FunctionSegment>, <Ref: TableReferenceSegment>]]
DEBUG      [PD:3  MD:10]	..........TableExpressionSegment                  	Ref.match OUT       	    	[match=<MatchResult 0/29: ''>, seg="'tbl\\nINNER JOIN b ON ...'"]
INFO       [PD:3  MD:11]	...........FunctionSegment                        	OneOf.match PRN     	    	[ns=1, ps=1, ms=0, pruned=[<Sequence: [<Sequence: [<Ref: DateAddFunctionNameSeg...]>], opts=[<Sequence: [<Sequence: [<AnyNumberOf: [<Ref: Functio..., <Ref: PostFunctionGrammar [opt]>]>]]
DEBUG      [PD:3  MD:17]	.................DateAddFunctionNameSegment       	Ref.match OUT       	    	[match=<MatchResult 0/29: ''>, seg="'tbl\\nINNER JOIN b ON ...'"]
INFO       [PD:3  MD:16]	................DateAddFunctionNameSegment        	Seque.match OUT     	    	[match=<MatchResult 0/29: ''>, seg="'tbl\\nINNER JOIN b ON ...'"]
DEBUG      [PD:3  MD:15]	...............DateAddFunctionNameSegment         	DateA.match OUT     	    	[match=<MatchResult 0/29: ''>, seg="'tbl\\nINNER JOIN b ON ...'"]
DEBUG      [PD:3  MD:15]	...............FunctionSegment                    	Ref.match OUT       	    	[match=<MatchResult 0/29: ''>, seg="'tbl\\nINNER JOIN b ON ...'"]
INFO       [PD:3  MD:14]	..............FunctionSegment                     	AnyNu.match PRN     	    	[ns=1, ps=0, ms=0, pruned=[], opts=[<Ref: FunctionNameSegment>]]
INFO       [PD:3  MD:17]	.................FunctionNameSegment              	AnyNu.match PRN     	    	[ns=1, ps=0, ms=0, pruned=[], opts=[<Sequence: [<Ref: SingleIdentifierGrammar>, <Ref: DotSegment>]>]]
INFO       [PD:3  MD:19]	...................SingleIdentifierGrammar        	OneOf.match PRN     	    	[ns=2, ps=0, ms=0, pruned=[], opts=[<Ref: NakedIdentifierSegment>, <Ref: QuotedIdentifierSegment>]]
DEBUG      [PD:3  MD:20]	....................SingleIdentifierGrammar       	Ref.match OUT       	+   	[match=<MatchResult 1/29: 'tbl'>, seg="'tbl\\nINNER JOIN b ON ...'"]
DEBUG      [PD:3  MD:20]	....................SingleIdentifierGrammar       	Ref.match OUT       	    	[match=<MatchResult 0/29: ''>, seg="'tbl\\nINNER JOIN b ON ...'"]
INFO       [PD:3  MD:19]	...................SingleIdentifierGrammar        	OneOf.match OUT     	+   	[match=<MatchResult 1/29: 'tbl'>, seg="'tbl\\nINNER JOIN b ON ...'"]
DEBUG      [PD:3  MD:19]	...................FunctionNameSegment            	Ref.match OUT       	+   	[match=<MatchResult 1/29: 'tbl'>, seg="'tbl\\nINNER JOIN b ON ...'"]
DEBUG      [PD:3  MD:19]	...................FunctionNameSegment            	Ref.match OUT       	    	[match=<MatchResult 0/27: ''>, seg="'INNER JOIN b ON (tbl...'"]
INFO       [PD:3  MD:18]	..................FunctionNameSegment             	Seque.match OUT     	    	[match=<MatchResult 0/29: ''>, seg="'tbl\\nINNER JOIN b ON ...'"]
INFO       [PD:3  MD:17]	.................FunctionNameSegment              	AnyNu.match OUT     	    	[match=<MatchResult 0/29: ''>, seg="'tbl\\nINNER JOIN b ON ...'"]
INFO       [PD:3  MD:17]	.................FunctionNameSegment              	OneOf.match PRN     	    	[ns=2, ps=0, ms=0, pruned=[], opts=[<Ref: FunctionNameIdentifierSegment>, <Ref: QuotedIdentifierSegment>]]
DEBUG      [PD:3  MD:18]	..................FunctionNameSegment             	Ref.match OUT       	+   	[match=<MatchResult 1/29: 'tbl'>, seg="'tbl\\nINNER JOIN b ON ...'"]
DEBUG      [PD:3  MD:18]	..................FunctionNameSegment             	Ref.match OUT       	    	[match=<MatchResult 0/29: ''>, seg="'tbl\\nINNER JOIN b ON ...'"]
INFO       [PD:3  MD:17]	.................FunctionNameSegment              	OneOf.match OUT     	+   	[match=<MatchResult 1/29: 'tbl'>, seg="'tbl\\nINNER JOIN b ON ...'"]
INFO       [PD:3  MD:16]	................FunctionNameSegment               	Seque.match OUT     	+   	[match=<MatchResult 1/29: 'tbl'>, seg="'tbl\\nINNER JOIN b ON ...'"]
DEBUG      [PD:3  MD:15]	...............FunctionNameSegment                	Funct.match OUT     	+   	[match=<MatchResult 1/29: 'tbl'>, seg="'tbl\\nINNER JOIN b ON ...'"]
DEBUG      [PD:3  MD:15]	...............FunctionSegment                    	Ref.match OUT       	+   	[match=<MatchResult 1/29: 'tbl'>, seg="'tbl\\nINNER JOIN b ON ...'"]
INFO       [PD:3  MD:14]	..............FunctionSegment                     	AnyNu.match OUT     	+   	[match=<MatchResult 1/29: 'tbl'>, seg="'tbl\\nINNER JOIN b ON ...'"]
INFO       [PD:3  MD:14]	..............FunctionSegment                     	Brack.match OUT     	    	[match=<MatchResult 0/27: ''>, seg="'INNER JOIN b ON (tbl...'"]
INFO       [PD:3  MD:13]	.............FunctionSegment                      	Seque.match OUT     	    	[match=<MatchResult 0/29: ''>, seg="'tbl\\nINNER JOIN b ON ...'"]
INFO       [PD:3  MD:12]	............FunctionSegment                       	Seque.match OUT     	    	[match=<MatchResult 0/29: ''>, seg="'tbl\\nINNER JOIN b ON ...'"]
INFO       [PD:3  MD:11]	...........FunctionSegment                        	OneOf.match OUT     	    	[match=<MatchResult 0/29: ''>, seg="'tbl\\nINNER JOIN b ON ...'"]
DEBUG      [PD:3  MD:10]	..........FunctionSegment                         	Funct.match OUT     	    	[match=<MatchResult 0/29: ''>, seg="'tbl\\nINNER JOIN b ON ...'"]
DEBUG      [PD:3  MD:10]	..........TableExpressionSegment                  	Ref.match OUT       	    	[match=<MatchResult 0/29: ''>, seg="'tbl\\nINNER JOIN b ON ...'"]
DEBUG      [PD:3  MD:12]	............TableReferenceSegment                 	Delim._look_ahead_match IN	    	[ls=29, seg='tbl\nINNER JOIN b ON ...']
DEBUG      [PD:3  MD:12]	............TableReferenceSegment                 	Delim._look_ahead_match SI	    	[mq=[], sb=['TBL', '', 'INNER', '', 'JOIN', '', 'B', '', 'ON', '', '(TBL.COMMON_ID', '', 'JOIN', '', 'C', '', 'ON', '', '(TBL.ID', '', 'LEFT', '', 'JOIN', '', 'D', '', 'ON', '', '(TBL.ID']]
INFO       [PD:3  MD:12]	............TableReferenceSegment                 	OneOf.match PRN     	    	[ns=1, ps=10, ms=0, pruned=[<Ref: OnKeywordSegment>, <Ref: AsKeywordSegment>, <Ref: UsingKeywordSegment>, <Ref: CommaSegment>, <Ref: CastOperatorSegment>, <Ref: StartSquareBracketSegment>, <Ref: StartBracketSegment>, <Ref: ColonSegment>, <Ref: DelimiterSegment>, <class 'sqlfluff.core.parser.segments.base.BracketedSegment'>], opts=[<Ref: BinaryOperatorGrammar>]]
INFO       [PD:3  MD:13]	.............BinaryOperatorGrammar                	OneOf.match PRN     	    	[ns=1, ps=3, ms=0, pruned=[<Ref: ArithmeticBinaryOperatorGrammar>, <Ref: StringBinaryOperatorGrammar>, <Ref: BooleanBinaryOperatorGrammar>], opts=[<Ref: ComparisonOperatorGrammar>]]
INFO       [PD:3  MD:14]	..............ComparisonOperatorGrammar           	OneOf.match PRN     	    	[ns=1, ps=7, ms=0, pruned=[<Ref: EqualsSegment>, <Ref: GreaterThanSegment>, <Ref: LessThanSegment>, <Ref: GreaterThanOrEqualToSegment>, <Ref: LessThanOrEqualToSegment>, <Ref: NotEqualToSegment_a>, <Ref: NotEqualToSegment_b>], opts=[<Ref: LikeOperatorSegment>]]
DEBUG      [PD:3  MD:15]	...............ComparisonOperatorGrammar          	Ref.match OUT       	    	[match=<MatchResult 0/29: ''>, seg="'tbl\\nINNER JOIN b ON ...'"]
INFO       [PD:3  MD:14]	..............ComparisonOperatorGrammar           	OneOf.match OUT     	    	[match=<MatchResult 0/29: ''>, seg="'tbl\\nINNER JOIN b ON ...'"]
DEBUG      [PD:3  MD:14]	..............BinaryOperatorGrammar               	Ref.match OUT       	    	[match=<MatchResult 0/29: ''>, seg="'tbl\\nINNER JOIN b ON ...'"]
INFO       [PD:3  MD:13]	.............BinaryOperatorGrammar                	OneOf.match OUT     	    	[match=<MatchResult 0/29: ''>, seg="'tbl\\nINNER JOIN b ON ...'"]
DEBUG      [PD:3  MD:13]	.............TableReferenceSegment                	Ref.match OUT       	    	[match=<MatchResult 0/29: ''>, seg="'tbl\\nINNER JOIN b ON ...'"]
INFO       [PD:3  MD:12]	............TableReferenceSegment                 	OneOf.match OUT     	    	[match=<MatchResult 0/29: ''>, seg="'tbl\\nINNER JOIN b ON ...'"]
DEBUG      [PD:3  MD:12]	............TableReferenceSegment                 	NonCo.match OUT     	    	[match=<MatchResult 0/29: ''>, seg="'tbl\\nINNER JOIN b ON ...'"]
INFO       [PD:3  MD:12]	............TableReferenceSegment                 	OneOf.match PRN     	    	[ns=1, ps=10, ms=0, pruned=[<Ref: OnKeywordSegment>, <Ref: AsKeywordSegment>, <Ref: UsingKeywordSegment>, <Ref: CommaSegment>, <Ref: CastOperatorSegment>, <Ref: StartSquareBracketSegment>, <Ref: StartBracketSegment>, <Ref: ColonSegment>, <Ref: DelimiterSegment>, <class 'sqlfluff.core.parser.segments.base.BracketedSegment'>], opts=[<Ref: BinaryOperatorGrammar>]]
INFO       [PD:3  MD:13]	.............BinaryOperatorGrammar                	OneOf.match PRN     	    	[ns=1, ps=3, ms=0, pruned=[<Ref: ArithmeticBinaryOperatorGrammar>, <Ref: StringBinaryOperatorGrammar>, <Ref: BooleanBinaryOperatorGrammar>], opts=[<Ref: ComparisonOperatorGrammar>]]
INFO       [PD:3  MD:14]	..............ComparisonOperatorGrammar           	OneOf.match PRN     	    	[ns=1, ps=7, ms=0, pruned=[<Ref: EqualsSegment>, <Ref: GreaterThanSegment>, <Ref: LessThanSegment>, <Ref: GreaterThanOrEqualToSegment>, <Ref: LessThanOrEqualToSegment>, <Ref: NotEqualToSegment_a>, <Ref: NotEqualToSegment_b>], opts=[<Ref: LikeOperatorSegment>]]
DEBUG      [PD:3  MD:15]	...............ComparisonOperatorGrammar          	Ref.match OUT       	    	[match=<MatchResult 0/28: ''>, seg="'\\nINNER JOIN b ON (tb...'"]
INFO       [PD:3  MD:14]	..............ComparisonOperatorGrammar           	OneOf.match OUT     	    	[match=<MatchResult 0/28: ''>, seg="'\\nINNER JOIN b ON (tb...'"]
DEBUG      [PD:3  MD:14]	..............BinaryOperatorGrammar               	Ref.match OUT       	    	[match=<MatchResult 0/28: ''>, seg="'\\nINNER JOIN b ON (tb...'"]
INFO       [PD:3  MD:13]	.............BinaryOperatorGrammar                	OneOf.match OUT     	    	[match=<MatchResult 0/28: ''>, seg="'\\nINNER JOIN b ON (tb...'"]
DEBUG      [PD:3  MD:13]	.............TableReferenceSegment                	Ref.match OUT       	    	[match=<MatchResult 0/28: ''>, seg="'\\nINNER JOIN b ON (tb...'"]
INFO       [PD:3  MD:12]	............TableReferenceSegment                 	OneOf.match OUT     	    	[match=<MatchResult 0/28: ''>, seg="'\\nINNER JOIN b ON (tb...'"]
DEBUG      [PD:3  MD:12]	............TableReferenceSegment                 	NonCo.match OUT     	+   	[match=<MatchResult 1/28: '\n'>, seg="'\\nINNER JOIN b ON (tb...'"]
INFO       [PD:3  MD:12]	............SingleIdentifierGrammar               	OneOf.match PRN     	    	[ns=2, ps=0, ms=0, pruned=[], opts=[<Ref: NakedIdentifierSegment>, <Ref: QuotedIdentifierSegment>]]
DEBUG      [PD:3  MD:13]	.............SingleIdentifierGrammar              	Ref.match OUT       	++  	[match=<MatchResult 1/1: 'tbl'>, seg="'tbl'"]
INFO       [PD:3  MD:12]	............SingleIdentifierGrammar               	OneOf.match OUT     	++  	[match=<MatchResult 1/1: 'tbl'>, seg="'tbl'"]
DEBUG      [PD:3  MD:12]	............TableReferenceSegment                 	Ref.match OUT       	++  	[match=<MatchResult 1/1: 'tbl'>, seg="'tbl'"]
INFO       [PD:3  MD:11]	...........TableReferenceSegment                  	Delim.match OUT     	+   	[match=<MatchResult 1/29: 'tbl'>, seg="'tbl\\nINNER JOIN b ON ...'"]
DEBUG      [PD:3  MD:10]	..........TableReferenceSegment                   	Table.match OUT     	+   	[match=<MatchResult 1/29: 'tbl'>, seg="'tbl\\nINNER JOIN b ON ...'"]
DEBUG      [PD:3  MD:10]	..........TableExpressionSegment                  	Ref.match OUT       	+   	[match=<MatchResult 1/29: 'tbl'>, seg="'tbl\\nINNER JOIN b ON ...'"]
INFO       [PD:3  MD:9 ]	.........TableExpressionSegment                   	OneOf.match OUT     	+   	[match=<MatchResult 1/29: 'tbl'>, seg="'tbl\\nINNER JOIN b ON ...'"]
DEBUG      [PD:3  MD:8 ]	........TableExpressionSegment                    	Table.match OUT     	+   	[match=<MatchResult 1/29: 'tbl'>, seg="'tbl\\nINNER JOIN b ON ...'"]
DEBUG      [PD:3  MD:8 ]	........FromExpressionElementSegment              	Ref.match OUT       	+   	[match=<MatchResult 1/29: 'tbl'>, seg="'tbl\\nINNER JOIN b ON ...'"]
INFO       [PD:3  MD:7 ]	.......FromExpressionElementSegment               	Optio.match OUT     	+   	[match=<MatchResult 1/29: 'tbl'>, seg="'tbl\\nINNER JOIN b ON ...'"]
DEBUG      [PD:3  MD:8 ]	........FromExpressionElementSegment              	Ref.match OUT       	    	[match=<MatchResult 0/27: ''>, seg="'INNER JOIN b ON (tbl...'"]
INFO       [PD:3  MD:7 ]	.......FromExpressionElementSegment               	Seque.match OUT     	    	[match=<MatchResult 0/27: ''>, seg="'INNER JOIN b ON (tbl...'"]
DEBUG      [PD:3  MD:9 ]	.........AliasExpressionSegment                   	Ref.match OUT       	    	[match=<MatchResult 0/27: ''>, seg="'INNER JOIN b ON (tbl...'"]
INFO       [PD:3  MD:9 ]	.........AliasExpressionSegment                   	OneOf.match PRN     	    	[ns=2, ps=0, ms=0, pruned=[], opts=[<Sequence: [<Ref: SingleIdentifierGrammar>, <Bracketed: [<Ref: SingleIdentifierListS...]>, <Ref: QuotedLiteralSegment>]]
INFO       [PD:3  MD:11]	...........SingleIdentifierGrammar                	OneOf.match PRN     	    	[ns=2, ps=0, ms=0, pruned=[], opts=[<Ref: NakedIdentifierSegment>, <Ref: QuotedIdentifierSegment>]]
DEBUG      [PD:3  MD:12]	............SingleIdentifierGrammar               	Ref.match OUT       	    	[match=<MatchResult 0/27: ''>, seg="'INNER JOIN b ON (tbl...'"]
DEBUG      [PD:3  MD:12]	............SingleIdentifierGrammar               	Ref.match OUT       	    	[match=<MatchResult 0/27: ''>, seg="'INNER JOIN b ON (tbl...'"]
INFO       [PD:3  MD:11]	...........SingleIdentifierGrammar                	OneOf.match OUT     	    	[match=<MatchResult 0/27: ''>, seg="'INNER JOIN b ON (tbl...'"]
DEBUG      [PD:3  MD:11]	...........AliasExpressionSegment                 	Ref.match OUT       	    	[match=<MatchResult 0/27: ''>, seg="'INNER JOIN b ON (tbl...'"]
INFO       [PD:3  MD:10]	..........AliasExpressionSegment                  	Seque.match OUT     	    	[match=<MatchResult 0/27: ''>, seg="'INNER JOIN b ON (tbl...'"]
DEBUG      [PD:3  MD:10]	..........AliasExpressionSegment                  	Ref.match OUT       	    	[match=<MatchResult 0/27: ''>, seg="'INNER JOIN b ON (tbl...'"]
INFO       [PD:3  MD:9 ]	.........AliasExpressionSegment                   	OneOf.match OUT     	    	[match=<MatchResult 0/27: ''>, seg="'INNER JOIN b ON (tbl...'"]
INFO       [PD:3  MD:8 ]	........AliasExpressionSegment                    	Seque.match OUT     	    	[match=<MatchResult 0/27: ''>, seg="'INNER JOIN b ON (tbl...'"]
DEBUG      [PD:3  MD:7 ]	.......AliasExpressionSegment                     	Alias.match OUT     	    	[match=<MatchResult 0/27: ''>, seg="'INNER JOIN b ON (tbl...'"]
DEBUG      [PD:3  MD:7 ]	.......FromExpressionElementSegment               	Ref.match OUT       	    	[match=<MatchResult 0/27: ''>, seg="'INNER JOIN b ON (tbl...'"]
DEBUG      [PD:3  MD:7 ]	.......FromExpressionElementSegment               	Ref.match OUT       	    	[match=<MatchResult 0/27: ''>, seg="'INNER JOIN b ON (tbl...'"]
INFO       [PD:3  MD:6 ]	......FromExpressionElementSegment                	Seque.match OUT     	+   	[match=<MatchResult 1/29: 'tbl'>, seg="'tbl\\nINNER JOIN b ON ...'"]
DEBUG      [PD:3  MD:5 ]	.....FromExpressionElementSegment                 	FromE.match OUT     	+   	[match=<MatchResult 1/29: 'tbl'>, seg="'tbl\\nINNER JOIN b ON ...'"]
DEBUG      [PD:3  MD:5 ]	.....FromExpressionSegment                        	Ref.match OUT       	+   	[match=<MatchResult 1/29: 'tbl'>, seg="'tbl\\nINNER JOIN b ON ...'"]
INFO       [PD:3  MD:4 ]	....FromExpressionSegment                         	OneOf.match OUT     	+   	[match=<MatchResult 1/29: 'tbl'>, seg="'tbl\\nINNER JOIN b ON ...'"]
INFO       [PD:3  MD:4 ]	....FromExpressionSegment                         	Condi.match OUT     	+   	[match=<MatchResult 1/28: ''>, seg="'INNER JOIN b ON (tbl...'"]
INFO       [PD:3  MD:4 ]	....FromExpressionSegment                         	AnyNu.match PRN     	    	[ns=1, ps=0, ms=1, pruned=[], opts=[<Ref: JoinClauseSegment>, <Ref: JoinLikeClauseGrammar>]]
INFO       [PD:3  MD:7 ]	.......JoinClauseSegment                          	OneOf.match PRN     	    	[ns=0, ps=2, ms=1, pruned=[<Ref: CrossKeywordSegment>, <Sequence: [<OneOf: [<Ref: FullKeywordSegment>, <Ref..., <Ref: OuterKeywordSegment [opt]>]>], opts=[<Ref: InnerKeywordSegment>]]
DEBUG      [PD:3  MD:8 ]	........JoinClauseSegment                         	Ref.match OUT       	+   	[match=<MatchResult 1/27: 'INNER'>, seg="'INNER JOIN b ON (tbl...'"]
INFO       [PD:3  MD:7 ]	.......JoinClauseSegment                          	OneOf.match OUT     	+   	[match=<MatchResult 1/27: 'INNER'>, seg="'INNER JOIN b ON (tbl...'"]
DEBUG      [PD:3  MD:8 ]	........JoinKeywords                              	Ref.match OUT       	+   	[match=<MatchResult 1/25: 'JOIN'>, seg="'JOIN b ON (tbl.commo...'"]
INFO       [PD:3  MD:7 ]	.......JoinKeywords                               	Seque.match OUT     	+   	[match=<MatchResult 1/25: 'JOIN'>, seg="'JOIN b ON (tbl.commo...'"]
DEBUG      [PD:3  MD:7 ]	.......JoinClauseSegment                          	Ref.match OUT       	+   	[match=<MatchResult 1/25: 'JOIN'>, seg="'JOIN b ON (tbl.commo...'"]
DEBUG      [PD:3  MD:10]	..........FromExpressionElementSegment            	Ref.match OUT       	    	[match=<MatchResult 0/23: ''>, seg="'b ON (tbl.common_id ...'"]
INFO       [PD:3  MD:10]	..........FromExpressionElementSegment            	Optio.match PRN     	    	[ns=1, ps=1, ms=0, pruned=[<Bracketed: [<Ref: TableExpressionSegment>]>], opts=[<Ref: TableExpressionSegment>]]
INFO       [PD:3  MD:12]	............TableExpressionSegment                	OneOf.match PRN     	    	[ns=3, ps=1, ms=0, pruned=[<Bracketed: [<Ref: SelectableGrammar>]>], opts=[<Ref: BareFunctionSegment>, <Ref: FunctionSegment>, <Ref: TableReferenceSegment>]]
DEBUG      [PD:3  MD:13]	.............TableExpressionSegment               	Ref.match OUT       	    	[match=<MatchResult 0/23: ''>, seg="'b ON (tbl.common_id ...'"]
INFO       [PD:3  MD:14]	..............FunctionSegment                     	OneOf.match PRN     	    	[ns=1, ps=1, ms=0, pruned=[<Sequence: [<Sequence: [<Ref: DateAddFunctionNameSeg...]>], opts=[<Sequence: [<Sequence: [<AnyNumberOf: [<Ref: Functio..., <Ref: PostFunctionGrammar [opt]>]>]]
DEBUG      [PD:3  MD:20]	....................DateAddFunctionNameSegment    	Ref.match OUT       	    	[match=<MatchResult 0/23: ''>, seg="'b ON (tbl.common_id ...'"]
INFO       [PD:3  MD:19]	...................DateAddFunctionNameSegment     	Seque.match OUT     	    	[match=<MatchResult 0/23: ''>, seg="'b ON (tbl.common_id ...'"]
DEBUG      [PD:3  MD:18]	..................DateAddFunctionNameSegment      	DateA.match OUT     	    	[match=<MatchResult 0/23: ''>, seg="'b ON (tbl.common_id ...'"]
DEBUG      [PD:3  MD:18]	..................FunctionSegment                 	Ref.match OUT       	    	[match=<MatchResult 0/23: ''>, seg="'b ON (tbl.common_id ...'"]
INFO       [PD:3  MD:17]	.................FunctionSegment                  	AnyNu.match PRN     	    	[ns=1, ps=0, ms=0, pruned=[], opts=[<Ref: FunctionNameSegment>]]
INFO       [PD:3  MD:20]	....................FunctionNameSegment           	AnyNu.match PRN     	    	[ns=1, ps=0, ms=0, pruned=[], opts=[<Sequence: [<Ref: SingleIdentifierGrammar>, <Ref: DotSegment>]>]]
INFO       [PD:3  MD:22]	......................SingleIdentifierGrammar     	OneOf.match PRN     	    	[ns=2, ps=0, ms=0, pruned=[], opts=[<Ref: NakedIdentifierSegment>, <Ref: QuotedIdentifierSegment>]]
DEBUG      [PD:3  MD:23]	.......................SingleIdentifierGrammar    	Ref.match OUT       	+   	[match=<MatchResult 1/23: 'b'>, seg="'b ON (tbl.common_id ...'"]
DEBUG      [PD:3  MD:23]	.......................SingleIdentifierGrammar    	Ref.match OUT       	    	[match=<MatchResult 0/23: ''>, seg="'b ON (tbl.common_id ...'"]
INFO       [PD:3  MD:22]	......................SingleIdentifierGrammar     	OneOf.match OUT     	+   	[match=<MatchResult 1/23: 'b'>, seg="'b ON (tbl.common_id ...'"]
DEBUG      [PD:3  MD:22]	......................FunctionNameSegment         	Ref.match OUT       	+   	[match=<MatchResult 1/23: 'b'>, seg="'b ON (tbl.common_id ...'"]
DEBUG      [PD:3  MD:22]	......................FunctionNameSegment         	Ref.match OUT       	    	[match=<MatchResult 0/21: ''>, seg="'ON (tbl.common_id = ...'"]
INFO       [PD:3  MD:21]	.....................FunctionNameSegment          	Seque.match OUT     	    	[match=<MatchResult 0/23: ''>, seg="'b ON (tbl.common_id ...'"]
INFO       [PD:3  MD:20]	....................FunctionNameSegment           	AnyNu.match OUT     	    	[match=<MatchResult 0/23: ''>, seg="'b ON (tbl.common_id ...'"]
INFO       [PD:3  MD:20]	....................FunctionNameSegment           	OneOf.match PRN     	    	[ns=2, ps=0, ms=0, pruned=[], opts=[<Ref: FunctionNameIdentifierSegment>, <Ref: QuotedIdentifierSegment>]]
DEBUG      [PD:3  MD:21]	.....................FunctionNameSegment          	Ref.match OUT       	+   	[match=<MatchResult 1/23: 'b'>, seg="'b ON (tbl.common_id ...'"]
DEBUG      [PD:3  MD:21]	.....................FunctionNameSegment          	Ref.match OUT       	    	[match=<MatchResult 0/23: ''>, seg="'b ON (tbl.common_id ...'"]
INFO       [PD:3  MD:20]	....................FunctionNameSegment           	OneOf.match OUT     	+   	[match=<MatchResult 1/23: 'b'>, seg="'b ON (tbl.common_id ...'"]
INFO       [PD:3  MD:19]	...................FunctionNameSegment            	Seque.match OUT     	+   	[match=<MatchResult 1/23: 'b'>, seg="'b ON (tbl.common_id ...'"]
DEBUG      [PD:3  MD:18]	..................FunctionNameSegment             	Funct.match OUT     	+   	[match=<MatchResult 1/23: 'b'>, seg="'b ON (tbl.common_id ...'"]
DEBUG      [PD:3  MD:18]	..................FunctionSegment                 	Ref.match OUT       	+   	[match=<MatchResult 1/23: 'b'>, seg="'b ON (tbl.common_id ...'"]
INFO       [PD:3  MD:17]	.................FunctionSegment                  	AnyNu.match OUT     	+   	[match=<MatchResult 1/23: 'b'>, seg="'b ON (tbl.common_id ...'"]
INFO       [PD:3  MD:17]	.................FunctionSegment                  	Brack.match OUT     	    	[match=<MatchResult 0/21: ''>, seg="'ON (tbl.common_id = ...'"]
INFO       [PD:3  MD:16]	................FunctionSegment                   	Seque.match OUT     	    	[match=<MatchResult 0/23: ''>, seg="'b ON (tbl.common_id ...'"]
INFO       [PD:3  MD:15]	...............FunctionSegment                    	Seque.match OUT     	    	[match=<MatchResult 0/23: ''>, seg="'b ON (tbl.common_id ...'"]
INFO       [PD:3  MD:14]	..............FunctionSegment                     	OneOf.match OUT     	    	[match=<MatchResult 0/23: ''>, seg="'b ON (tbl.common_id ...'"]
DEBUG      [PD:3  MD:13]	.............FunctionSegment                      	Funct.match OUT     	    	[match=<MatchResult 0/23: ''>, seg="'b ON (tbl.common_id ...'"]
DEBUG      [PD:3  MD:13]	.............TableExpressionSegment               	Ref.match OUT       	    	[match=<MatchResult 0/23: ''>, seg="'b ON (tbl.common_id ...'"]
DEBUG      [PD:3  MD:15]	...............TableReferenceSegment              	Delim._look_ahead_match IN	    	[ls=23, seg='b ON (tbl.common_id ...']
DEBUG      [PD:3  MD:15]	...............TableReferenceSegment              	Delim._look_ahead_match SI	    	[mq=[], sb=['B', '', 'ON', '', '(TBL.COMMON_ID', '', 'JOIN', '', 'C', '', 'ON', '', '(TBL.ID', '', 'LEFT', '', 'JOIN', '', 'D', '', 'ON', '', '(TBL.ID']]
INFO       [PD:3  MD:15]	...............TableReferenceSegment              	OneOf.match PRN     	    	[ns=1, ps=10, ms=0, pruned=[<Ref: OnKeywordSegment>, <Ref: AsKeywordSegment>, <Ref: UsingKeywordSegment>, <Ref: CommaSegment>, <Ref: CastOperatorSegment>, <Ref: StartSquareBracketSegment>, <Ref: StartBracketSegment>, <Ref: ColonSegment>, <Ref: DelimiterSegment>, <class 'sqlfluff.core.parser.segments.base.BracketedSegment'>], opts=[<Ref: BinaryOperatorGrammar>]]
INFO       [PD:3  MD:16]	................BinaryOperatorGrammar             	OneOf.match PRN     	    	[ns=1, ps=3, ms=0, pruned=[<Ref: ArithmeticBinaryOperatorGrammar>, <Ref: StringBinaryOperatorGrammar>, <Ref: BooleanBinaryOperatorGrammar>], opts=[<Ref: ComparisonOperatorGrammar>]]
INFO       [PD:3  MD:17]	.................ComparisonOperatorGrammar        	OneOf.match PRN     	    	[ns=1, ps=7, ms=0, pruned=[<Ref: EqualsSegment>, <Ref: GreaterThanSegment>, <Ref: LessThanSegment>, <Ref: GreaterThanOrEqualToSegment>, <Ref: LessThanOrEqualToSegment>, <Ref: NotEqualToSegment_a>, <Ref: NotEqualToSegment_b>], opts=[<Ref: LikeOperatorSegment>]]
DEBUG      [PD:3  MD:18]	..................ComparisonOperatorGrammar       	Ref.match OUT       	    	[match=<MatchResult 0/23: ''>, seg="'b ON (tbl.common_id ...'"]
INFO       [PD:3  MD:17]	.................ComparisonOperatorGrammar        	OneOf.match OUT     	    	[match=<MatchResult 0/23: ''>, seg="'b ON (tbl.common_id ...'"]
DEBUG      [PD:3  MD:17]	.................BinaryOperatorGrammar            	Ref.match OUT       	    	[match=<MatchResult 0/23: ''>, seg="'b ON (tbl.common_id ...'"]
INFO       [PD:3  MD:16]	................BinaryOperatorGrammar             	OneOf.match OUT     	    	[match=<MatchResult 0/23: ''>, seg="'b ON (tbl.common_id ...'"]
DEBUG      [PD:3  MD:16]	................TableReferenceSegment             	Ref.match OUT       	    	[match=<MatchResult 0/23: ''>, seg="'b ON (tbl.common_id ...'"]
INFO       [PD:3  MD:15]	...............TableReferenceSegment              	OneOf.match OUT     	    	[match=<MatchResult 0/23: ''>, seg="'b ON (tbl.common_id ...'"]
DEBUG      [PD:3  MD:15]	...............TableReferenceSegment              	NonCo.match OUT     	    	[match=<MatchResult 0/23: ''>, seg="'b ON (tbl.common_id ...'"]
INFO       [PD:3  MD:15]	...............TableReferenceSegment              	OneOf.match PRN     	    	[ns=1, ps=9, ms=1, pruned=[<Ref: AsKeywordSegment>, <Ref: UsingKeywordSegment>, <Ref: CommaSegment>, <Ref: CastOperatorSegment>, <Ref: StartSquareBracketSegment>, <Ref: StartBracketSegment>, <Ref: ColonSegment>, <Ref: DelimiterSegment>, <class 'sqlfluff.core.parser.segments.base.BracketedSegment'>], opts=[<Ref: OnKeywordSegment>, <Ref: BinaryOperatorGrammar>]]
DEBUG      [PD:3  MD:16]	................TableReferenceSegment             	Ref.match OUT       	    	[match=<MatchResult 0/22: ''>, seg="' ON (tbl.common_id =...'"]
INFO       [PD:3  MD:16]	................BinaryOperatorGrammar             	OneOf.match PRN     	    	[ns=1, ps=3, ms=0, pruned=[<Ref: ArithmeticBinaryOperatorGrammar>, <Ref: StringBinaryOperatorGrammar>, <Ref: BooleanBinaryOperatorGrammar>], opts=[<Ref: ComparisonOperatorGrammar>]]
INFO       [PD:3  MD:17]	.................ComparisonOperatorGrammar        	OneOf.match PRN     	    	[ns=1, ps=7, ms=0, pruned=[<Ref: EqualsSegment>, <Ref: GreaterThanSegment>, <Ref: LessThanSegment>, <Ref: GreaterThanOrEqualToSegment>, <Ref: LessThanOrEqualToSegment>, <Ref: NotEqualToSegment_a>, <Ref: NotEqualToSegment_b>], opts=[<Ref: LikeOperatorSegment>]]
DEBUG      [PD:3  MD:18]	..................ComparisonOperatorGrammar       	Ref.match OUT       	    	[match=<MatchResult 0/22: ''>, seg="' ON (tbl.common_id =...'"]
INFO       [PD:3  MD:17]	.................ComparisonOperatorGrammar        	OneOf.match OUT     	    	[match=<MatchResult 0/22: ''>, seg="' ON (tbl.common_id =...'"]
DEBUG      [PD:3  MD:17]	.................BinaryOperatorGrammar            	Ref.match OUT       	    	[match=<MatchResult 0/22: ''>, seg="' ON (tbl.common_id =...'"]
INFO       [PD:3  MD:16]	................BinaryOperatorGrammar             	OneOf.match OUT     	    	[match=<MatchResult 0/22: ''>, seg="' ON (tbl.common_id =...'"]
DEBUG      [PD:3  MD:16]	................TableReferenceSegment             	Ref.match OUT       	    	[match=<MatchResult 0/22: ''>, seg="' ON (tbl.common_id =...'"]
INFO       [PD:3  MD:15]	...............TableReferenceSegment              	OneOf.match OUT     	    	[match=<MatchResult 0/22: ''>, seg="' ON (tbl.common_id =...'"]
DEBUG      [PD:3  MD:15]	...............TableReferenceSegment              	NonCo.match OUT     	+   	[match=<MatchResult 1/22: ' '>, seg="' ON (tbl.common_id =...'"]
INFO       [PD:3  MD:15]	...............SingleIdentifierGrammar            	OneOf.match PRN     	    	[ns=2, ps=0, ms=0, pruned=[], opts=[<Ref: NakedIdentifierSegment>, <Ref: QuotedIdentifierSegment>]]
DEBUG      [PD:3  MD:16]	................SingleIdentifierGrammar           	Ref.match OUT       	++  	[match=<MatchResult 1/1: 'b'>, seg="'b'"]
INFO       [PD:3  MD:15]	...............SingleIdentifierGrammar            	OneOf.match OUT     	++  	[match=<MatchResult 1/1: 'b'>, seg="'b'"]
DEBUG      [PD:3  MD:15]	...............TableReferenceSegment              	Ref.match OUT       	++  	[match=<MatchResult 1/1: 'b'>, seg="'b'"]
INFO       [PD:3  MD:14]	..............TableReferenceSegment               	Delim.match OUT     	+   	[match=<MatchResult 1/23: 'b'>, seg="'b ON (tbl.common_id ...'"]
DEBUG      [PD:3  MD:13]	.............TableReferenceSegment                	Table.match OUT     	+   	[match=<MatchResult 1/23: 'b'>, seg="'b ON (tbl.common_id ...'"]
DEBUG      [PD:3  MD:13]	.............TableExpressionSegment               	Ref.match OUT       	+   	[match=<MatchResult 1/23: 'b'>, seg="'b ON (tbl.common_id ...'"]
INFO       [PD:3  MD:12]	............TableExpressionSegment                	OneOf.match OUT     	+   	[match=<MatchResult 1/23: 'b'>, seg="'b ON (tbl.common_id ...'"]
DEBUG      [PD:3  MD:11]	...........TableExpressionSegment                 	Table.match OUT     	+   	[match=<MatchResult 1/23: 'b'>, seg="'b ON (tbl.common_id ...'"]
DEBUG      [PD:3  MD:11]	...........FromExpressionElementSegment           	Ref.match OUT       	+   	[match=<MatchResult 1/23: 'b'>, seg="'b ON (tbl.common_id ...'"]
INFO       [PD:3  MD:10]	..........FromExpressionElementSegment            	Optio.match OUT     	+   	[match=<MatchResult 1/23: 'b'>, seg="'b ON (tbl.common_id ...'"]
DEBUG      [PD:3  MD:11]	...........FromExpressionElementSegment           	Ref.match OUT       	    	[match=<MatchResult 0/21: ''>, seg="'ON (tbl.common_id = ...'"]
INFO       [PD:3  MD:10]	..........FromExpressionElementSegment            	Seque.match OUT     	    	[match=<MatchResult 0/21: ''>, seg="'ON (tbl.common_id = ...'"]
DEBUG      [PD:3  MD:12]	............AliasExpressionSegment                	Ref.match OUT       	    	[match=<MatchResult 0/21: ''>, seg="'ON (tbl.common_id = ...'"]
INFO       [PD:3  MD:12]	............AliasExpressionSegment                	OneOf.match PRN     	    	[ns=2, ps=0, ms=0, pruned=[], opts=[<Sequence: [<Ref: SingleIdentifierGrammar>, <Bracketed: [<Ref: SingleIdentifierListS...]>, <Ref: QuotedLiteralSegment>]]
INFO       [PD:3  MD:14]	..............SingleIdentifierGrammar             	OneOf.match PRN     	    	[ns=2, ps=0, ms=0, pruned=[], opts=[<Ref: NakedIdentifierSegment>, <Ref: QuotedIdentifierSegment>]]
DEBUG      [PD:3  MD:15]	...............SingleIdentifierGrammar            	Ref.match OUT       	    	[match=<MatchResult 0/21: ''>, seg="'ON (tbl.common_id = ...'"]
DEBUG      [PD:3  MD:15]	...............SingleIdentifierGrammar            	Ref.match OUT       	    	[match=<MatchResult 0/21: ''>, seg="'ON (tbl.common_id = ...'"]
INFO       [PD:3  MD:14]	..............SingleIdentifierGrammar             	OneOf.match OUT     	    	[match=<MatchResult 0/21: ''>, seg="'ON (tbl.common_id = ...'"]
DEBUG      [PD:3  MD:14]	..............AliasExpressionSegment              	Ref.match OUT       	    	[match=<MatchResult 0/21: ''>, seg="'ON (tbl.common_id = ...'"]
INFO       [PD:3  MD:13]	.............AliasExpressionSegment               	Seque.match OUT     	    	[match=<MatchResult 0/21: ''>, seg="'ON (tbl.common_id = ...'"]
DEBUG      [PD:3  MD:13]	.............AliasExpressionSegment               	Ref.match OUT       	    	[match=<MatchResult 0/21: ''>, seg="'ON (tbl.common_id = ...'"]
INFO       [PD:3  MD:12]	............AliasExpressionSegment                	OneOf.match OUT     	    	[match=<MatchResult 0/21: ''>, seg="'ON (tbl.common_id = ...'"]
INFO       [PD:3  MD:11]	...........AliasExpressionSegment                 	Seque.match OUT     	    	[match=<MatchResult 0/21: ''>, seg="'ON (tbl.common_id = ...'"]
DEBUG      [PD:3  MD:10]	..........AliasExpressionSegment                  	Alias.match OUT     	    	[match=<MatchResult 0/21: ''>, seg="'ON (tbl.common_id = ...'"]
DEBUG      [PD:3  MD:10]	..........FromExpressionElementSegment            	Ref.match OUT       	    	[match=<MatchResult 0/21: ''>, seg="'ON (tbl.common_id = ...'"]
DEBUG      [PD:3  MD:10]	..........FromExpressionElementSegment            	Ref.match OUT       	    	[match=<MatchResult 0/21: ''>, seg="'ON (tbl.common_id = ...'"]
INFO       [PD:3  MD:9 ]	.........FromExpressionElementSegment             	Seque.match OUT     	+   	[match=<MatchResult 1/23: 'b'>, seg="'b ON (tbl.common_id ...'"]
DEBUG      [PD:3  MD:8 ]	........FromExpressionElementSegment              	FromE.match OUT     	+   	[match=<MatchResult 1/23: 'b'>, seg="'b ON (tbl.common_id ...'"]
DEBUG      [PD:3  MD:8 ]	........JoinClauseSegment                         	Ref.match OUT       	+   	[match=<MatchResult 1/23: 'b'>, seg="'b ON (tbl.common_id ...'"]
INFO       [PD:3  MD:8 ]	........JoinClauseSegment                         	OneOf.match PRN     	    	[ns=0, ps=1, ms=1, pruned=[<Sequence: [<Ref: UsingKeywordSegment>, <class 'sqlfluff.core.parser.segments.me..., <Bracketed: [<Delimited: [<...]>], opts=[<Ref: JoinOnConditionSegment>]]
DEBUG      [PD:3  MD:11]	...........JoinOnConditionSegment                 	Ref.match OUT       	+   	[match=<MatchResult 1/21: 'ON'>, seg="'ON (tbl.common_id = ...'"]
INFO       [PD:3  MD:11]	...........JoinOnConditionSegment                 	Optio.match PRN     	    	[ns=1, ps=0, ms=1, pruned=[], opts=[<Bracketed: [<Ref: ExpressionSegment>]>, <Ref: ExpressionSegment>]]
INFO       [PD:3  MD:16]	................Expression_A_Grammar              	OneOf.match PRN     	    	[ns=1, ps=1, ms=0, pruned=[<Sequence: [<OneOf: [<Ref: PositiveSegment>, <Ref: N..., <Ref: Expression_C_Grammar>]>], opts=[<Ref: Expression_C_Grammar>]]
INFO       [PD:3  MD:17]	.................Expression_C_Grammar             	OneOf.match PRN     	    	[ns=1, ps=2, ms=0, pruned=[<Sequence: [<Ref: ExistsKeywordSegment>, <Bracketed: [<Ref: SelectStatementSegmen...]>, <Ref: CaseExpressionSegment>], opts=[<Ref: Expression_D_Grammar>]]
INFO       [PD:3  MD:19]	...................Expression_D_Grammar           	OneOf.match PRN     	    	[ns=6, ps=3, ms=0, pruned=[<Bracketed: [<OneOf: [<Ref: ExpressionSegment>, <Ref:...]>, <Ref: SelectStatementSegment>, <Ref: IntervalExpressionSegment>], opts=[<Ref: BareFunctionSegment>, <Ref: FunctionSegment>, <Ref: LiteralGrammar>, <Ref: ColumnReferenceSegment>, <Sequence: [<Ref: SimpleArrayTypeGrammar [opt]>, <Ref: ArrayLiteralSegment>]>, <Sequence: [<Ref: DatatypeSegment>, <OneOf: [<Ref: QuotedLiteralSegment>, <R...]>]]
DEBUG      [PD:3  MD:20]	....................Expression_D_Grammar          	Ref.match OUT       	    	[match=<MatchResult 0/9: ''>, seg="'tbl.common_id = b.co...'"]
INFO       [PD:3  MD:21]	.....................FunctionSegment              	OneOf.match PRN     	    	[ns=1, ps=1, ms=0, pruned=[<Sequence: [<Sequence: [<Ref: DateAddFunctionNameSeg...]>], opts=[<Sequence: [<Sequence: [<AnyNumberOf: [<Ref: Functio..., <Ref: PostFunctionGrammar [opt]>]>]]
DEBUG      [PD:3  MD:27]	...........................DateAddFunctionNameSegment	Ref.match OUT       	    	[match=<MatchResult 0/9: ''>, seg="'tbl.common_id = b.co...'"]
INFO       [PD:3  MD:26]	..........................DateAddFunctionNameSegment	Seque.match OUT     	    	[match=<MatchResult 0/9: ''>, seg="'tbl.common_id = b.co...'"]
DEBUG      [PD:3  MD:25]	.........................DateAddFunctionNameSegment	DateA.match OUT     	    	[match=<MatchResult 0/9: ''>, seg="'tbl.common_id = b.co...'"]
DEBUG      [PD:3  MD:25]	.........................FunctionSegment          	Ref.match OUT       	    	[match=<MatchResult 0/9: ''>, seg="'tbl.common_id = b.co...'"]
INFO       [PD:3  MD:24]	........................FunctionSegment           	AnyNu.match PRN     	    	[ns=1, ps=0, ms=0, pruned=[], opts=[<Ref: FunctionNameSegment>]]
INFO       [PD:3  MD:27]	...........................FunctionNameSegment    	AnyNu.match PRN     	    	[ns=1, ps=0, ms=0, pruned=[], opts=[<Sequence: [<Ref: SingleIdentifierGrammar>, <Ref: DotSegment>]>]]
INFO       [PD:3  MD:29]	.............................SingleIdentifierGrammar	OneOf.match PRN     	    	[ns=2, ps=0, ms=0, pruned=[], opts=[<Ref: NakedIdentifierSegment>, <Ref: QuotedIdentifierSegment>]]
DEBUG      [PD:3  MD:30]	..............................SingleIdentifierGrammar	Ref.match OUT       	+   	[match=<MatchResult 1/9: 'tbl'>, seg="'tbl.common_id = b.co...'"]
DEBUG      [PD:3  MD:30]	..............................SingleIdentifierGrammar	Ref.match OUT       	    	[match=<MatchResult 0/9: ''>, seg="'tbl.common_id = b.co...'"]
INFO       [PD:3  MD:29]	.............................SingleIdentifierGrammar	OneOf.match OUT     	+   	[match=<MatchResult 1/9: 'tbl'>, seg="'tbl.common_id = b.co...'"]
DEBUG      [PD:3  MD:29]	.............................FunctionNameSegment  	Ref.match OUT       	+   	[match=<MatchResult 1/9: 'tbl'>, seg="'tbl.common_id = b.co...'"]
DEBUG      [PD:3  MD:29]	.............................FunctionNameSegment  	Ref.match OUT       	+   	[match=<MatchResult 1/8: '.'>, seg="'.common_id = b.commo...'"]
INFO       [PD:3  MD:28]	............................FunctionNameSegment   	Seque.match OUT     	+   	[match=<MatchResult 2/9: 'tbl.'>, seg="'tbl.common_id = b.co...'"]
INFO       [PD:3  MD:27]	...........................FunctionNameSegment    	AnyNu.match PRN     	    	[ns=1, ps=0, ms=0, pruned=[], opts=[<Sequence: [<Ref: SingleIdentifierGrammar>, <Ref: DotSegment>]>]]
INFO       [PD:3  MD:29]	.............................SingleIdentifierGrammar	OneOf.match PRN     	    	[ns=2, ps=0, ms=0, pruned=[], opts=[<Ref: NakedIdentifierSegment>, <Ref: QuotedIdentifierSegment>]]
DEBUG      [PD:3  MD:30]	..............................SingleIdentifierGrammar	Ref.match OUT       	+   	[match=<MatchResult 1/7: 'common_id'>, seg="'common_id = b.common...'"]
DEBUG      [PD:3  MD:30]	..............................SingleIdentifierGrammar	Ref.match OUT       	    	[match=<MatchResult 0/7: ''>, seg="'common_id = b.common...'"]
INFO       [PD:3  MD:29]	.............................SingleIdentifierGrammar	OneOf.match OUT     	+   	[match=<MatchResult 1/7: 'common_id'>, seg="'common_id = b.common...'"]
DEBUG      [PD:3  MD:29]	.............................FunctionNameSegment  	Ref.match OUT       	+   	[match=<MatchResult 1/7: 'common_id'>, seg="'common_id = b.common...'"]
DEBUG      [PD:3  MD:29]	.............................FunctionNameSegment  	Ref.match OUT       	    	[match=<MatchResult 0/5: ''>, seg="'= b.common_id'"]
INFO       [PD:3  MD:28]	............................FunctionNameSegment   	Seque.match OUT     	    	[match=<MatchResult 0/7: ''>, seg="'common_id = b.common...'"]
INFO       [PD:3  MD:27]	...........................FunctionNameSegment    	AnyNu.match OUT     	+   	[match=<MatchResult 2/9: 'tbl.'>, seg="'tbl.common_id = b.co...'"]
INFO       [PD:3  MD:27]	...........................FunctionNameSegment    	OneOf.match PRN     	    	[ns=2, ps=0, ms=0, pruned=[], opts=[<Ref: FunctionNameIdentifierSegment>, <Ref: QuotedIdentifierSegment>]]
DEBUG      [PD:3  MD:28]	............................FunctionNameSegment   	Ref.match OUT       	+   	[match=<MatchResult 1/7: 'common_id'>, seg="'common_id = b.common...'"]
DEBUG      [PD:3  MD:28]	............................FunctionNameSegment   	Ref.match OUT       	    	[match=<MatchResult 0/7: ''>, seg="'common_id = b.common...'"]
INFO       [PD:3  MD:27]	...........................FunctionNameSegment    	OneOf.match OUT     	+   	[match=<MatchResult 1/7: 'common_id'>, seg="'common_id = b.common...'"]
INFO       [PD:3  MD:26]	..........................FunctionNameSegment     	Seque.match OUT     	+   	[match=<MatchResult 3/9: 'tbl.common_id'>, seg="'tbl.common_id = b.co...'"]
DEBUG      [PD:3  MD:25]	.........................FunctionNameSegment      	Funct.match OUT     	+   	[match=<MatchResult 1/7: 'tbl.common_id'>, seg="'tbl.common_id = b.co...'"]
DEBUG      [PD:3  MD:25]	.........................FunctionSegment          	Ref.match OUT       	+   	[match=<MatchResult 1/7: 'tbl.common_id'>, seg="'tbl.common_id = b.co...'"]
INFO       [PD:3  MD:24]	........................FunctionSegment           	AnyNu.match OUT     	+   	[match=<MatchResult 1/7: 'tbl.common_id'>, seg="'tbl.common_id = b.co...'"]
INFO       [PD:3  MD:24]	........................FunctionSegment           	Brack.match OUT     	    	[match=<MatchResult 0/5: ''>, seg="'= b.common_id'"]
INFO       [PD:3  MD:23]	.......................FunctionSegment            	Seque.match OUT     	    	[match=<MatchResult 0/9: ''>, seg="'tbl.common_id = b.co...'"]
INFO       [PD:3  MD:22]	......................FunctionSegment             	Seque.match OUT     	    	[match=<MatchResult 0/9: ''>, seg="'tbl.common_id = b.co...'"]
INFO       [PD:3  MD:21]	.....................FunctionSegment              	OneOf.match OUT     	    	[match=<MatchResult 0/9: ''>, seg="'tbl.common_id = b.co...'"]
DEBUG      [PD:3  MD:20]	....................FunctionSegment               	Funct.match OUT     	    	[match=<MatchResult 0/9: ''>, seg="'tbl.common_id = b.co...'"]
DEBUG      [PD:3  MD:20]	....................Expression_D_Grammar          	Ref.match OUT       	    	[match=<MatchResult 0/9: ''>, seg="'tbl.common_id = b.co...'"]
INFO       [PD:3  MD:20]	....................LiteralGrammar                	OneOf.match PRN     	    	[ns=2, ps=4, ms=0, pruned=[<Ref: BooleanLiteralGrammar>, <Ref: QualifiedNumericLiteralSegment>, <Ref: NullLiteralSegment>, <Ref: DateTimeLiteralGrammar>], opts=[<Ref: QuotedLiteralSegment>, <Ref: NumericLiteralSegment>]]
DEBUG      [PD:3  MD:21]	.....................LiteralGrammar               	Ref.match OUT       	    	[match=<MatchResult 0/9: ''>, seg="'tbl.common_id = b.co...'"]
DEBUG      [PD:3  MD:21]	.....................LiteralGrammar               	Ref.match OUT       	    	[match=<MatchResult 0/9: ''>, seg="'tbl.common_id = b.co...'"]
INFO       [PD:3  MD:20]	....................LiteralGrammar                	OneOf.match OUT     	    	[match=<MatchResult 0/9: ''>, seg="'tbl.common_id = b.co...'"]
DEBUG      [PD:3  MD:20]	....................Expression_D_Grammar          	Ref.match OUT       	    	[match=<MatchResult 0/9: ''>, seg="'tbl.common_id = b.co...'"]
DEBUG      [PD:3  MD:22]	......................ColumnReferenceSegment      	Delim._look_ahead_match IN	    	[ls=9, seg='tbl.common_id = b.co...']
DEBUG      [PD:3  MD:22]	......................ColumnReferenceSegment      	Delim._look_ahead_match SI	    	[mq=[(<OneOf: [<Ref: DotSegment>, <Sequence: [<Ref: DotSegment>, <Ref: Dot...]>, 1, '.'), (<OneOf: [<Ref: DotSegment>, <Sequence: [<Ref: DotSegment>, <Ref: Dot...]>, 1, '.'), (<OneOf: [<Ref: DotSegment>, <Sequence: [<Ref: DotSegment>, <Ref: Dot...]>, 7, '.'), (<OneOf: [<Ref: DotSegment>, <Sequence: [<Ref: DotSegment>, <Ref: Dot...]>, 7, '.')], sb=['TBL', '.', 'COMMON_ID', '', '=', '', 'B', '.', 'COMMON_ID']]
INFO       [PD:3  MD:22]	......................ColumnReferenceSegment      	OneOf.match PRN     	    	[ns=0, ps=0, ms=2, pruned=[], opts=[<Ref: DotSegment>, <Sequence: [<Ref: DotSegment>, <Ref: DotSegment>]>]]
DEBUG      [PD:3  MD:23]	.......................ColumnReferenceSegment     	Ref.match OUT       	+   	[match=<MatchResult 1/2: '.'>, seg="'.common_id'"]
DEBUG      [PD:3  MD:24]	........................ColumnReferenceSegment    	Ref.match OUT       	+   	[match=<MatchResult 1/2: '.'>, seg="'.common_id'"]
DEBUG      [PD:3  MD:24]	........................ColumnReferenceSegment    	Ref.match OUT       	    	[match=<MatchResult 0/1: ''>, seg="'common_id'"]
INFO       [PD:3  MD:23]	.......................ColumnReferenceSegment     	Seque.match OUT     	    	[match=<MatchResult 0/2: ''>, seg="'.common_id'"]
INFO       [PD:3  MD:22]	......................ColumnReferenceSegment      	OneOf.match OUT     	+   	[match=<MatchResult 1/2: '.'>, seg="'.common_id'"]
INFO       [PD:3  MD:22]	......................ColumnReferenceSegment      	OneOf.match PRN     	    	[ns=0, ps=0, ms=2, pruned=[], opts=[<Ref: DotSegment>, <Sequence: [<Ref: DotSegment>, <Ref: DotSegment>]>]]
DEBUG      [PD:3  MD:23]	.......................ColumnReferenceSegment     	Ref.match OUT       	+   	[match=<MatchResult 1/2: '.'>, seg="'.common_id'"]
DEBUG      [PD:3  MD:24]	........................ColumnReferenceSegment    	Ref.match OUT       	+   	[match=<MatchResult 1/2: '.'>, seg="'.common_id'"]
DEBUG      [PD:3  MD:24]	........................ColumnReferenceSegment    	Ref.match OUT       	    	[match=<MatchResult 0/1: ''>, seg="'common_id'"]
INFO       [PD:3  MD:23]	.......................ColumnReferenceSegment     	Seque.match OUT     	    	[match=<MatchResult 0/2: ''>, seg="'.common_id'"]
INFO       [PD:3  MD:22]	......................ColumnReferenceSegment      	OneOf.match OUT     	+   	[match=<MatchResult 1/2: '.'>, seg="'.common_id'"]
INFO       [PD:3  MD:22]	......................ColumnReferenceSegment      	OneOf.match PRN     	    	[ns=0, ps=0, ms=2, pruned=[], opts=[<Ref: DotSegment>, <Sequence: [<Ref: DotSegment>, <Ref: DotSegment>]>]]
DEBUG      [PD:3  MD:23]	.......................ColumnReferenceSegment     	Ref.match OUT       	+   	[match=<MatchResult 1/8: '.'>, seg="'.common_id = b.commo...'"]
DEBUG      [PD:3  MD:24]	........................ColumnReferenceSegment    	Ref.match OUT       	+   	[match=<MatchResult 1/8: '.'>, seg="'.common_id = b.commo...'"]
DEBUG      [PD:3  MD:24]	........................ColumnReferenceSegment    	Ref.match OUT       	    	[match=<MatchResult 0/7: ''>, seg="'common_id = b.common...'"]
INFO       [PD:3  MD:23]	.......................ColumnReferenceSegment     	Seque.match OUT     	    	[match=<MatchResult 0/8: ''>, seg="'.common_id = b.commo...'"]
INFO       [PD:3  MD:22]	......................ColumnReferenceSegment      	OneOf.match OUT     	+   	[match=<MatchResult 1/8: '.'>, seg="'.common_id = b.commo...'"]
INFO       [PD:3  MD:22]	......................ColumnReferenceSegment      	OneOf.match PRN     	    	[ns=0, ps=0, ms=2, pruned=[], opts=[<Ref: DotSegment>, <Sequence: [<Ref: DotSegment>, <Ref: DotSegment>]>]]
DEBUG      [PD:3  MD:23]	.......................ColumnReferenceSegment     	Ref.match OUT       	+   	[match=<MatchResult 1/8: '.'>, seg="'.common_id = b.commo...'"]
DEBUG      [PD:3  MD:24]	........................ColumnReferenceSegment    	Ref.match OUT       	+   	[match=<MatchResult 1/8: '.'>, seg="'.common_id = b.commo...'"]
DEBUG      [PD:3  MD:24]	........................ColumnReferenceSegment    	Ref.match OUT       	    	[match=<MatchResult 0/7: ''>, seg="'common_id = b.common...'"]
INFO       [PD:3  MD:23]	.......................ColumnReferenceSegment     	Seque.match OUT     	    	[match=<MatchResult 0/8: ''>, seg="'.common_id = b.commo...'"]
INFO       [PD:3  MD:22]	......................ColumnReferenceSegment      	OneOf.match OUT     	+   	[match=<MatchResult 1/8: '.'>, seg="'.common_id = b.commo...'"]
INFO       [PD:3  MD:22]	......................ColumnReferenceSegment      	OneOf.match PRN     	    	[ns=1, ps=10, ms=0, pruned=[<Ref: OnKeywordSegment>, <Ref: AsKeywordSegment>, <Ref: UsingKeywordSegment>, <Ref: CommaSegment>, <Ref: CastOperatorSegment>, <Ref: StartSquareBracketSegment>, <Ref: StartBracketSegment>, <Ref: ColonSegment>, <Ref: DelimiterSegment>, <class 'sqlfluff.core.parser.segments.base.BracketedSegment'>], opts=[<Ref: BinaryOperatorGrammar>]]
INFO       [PD:3  MD:23]	.......................BinaryOperatorGrammar      	OneOf.match PRN     	    	[ns=1, ps=3, ms=0, pruned=[<Ref: ArithmeticBinaryOperatorGrammar>, <Ref: StringBinaryOperatorGrammar>, <Ref: BooleanBinaryOperatorGrammar>], opts=[<Ref: ComparisonOperatorGrammar>]]
INFO       [PD:3  MD:24]	........................ComparisonOperatorGrammar 	OneOf.match PRN     	    	[ns=1, ps=7, ms=0, pruned=[<Ref: EqualsSegment>, <Ref: GreaterThanSegment>, <Ref: LessThanSegment>, <Ref: GreaterThanOrEqualToSegment>, <Ref: LessThanOrEqualToSegment>, <Ref: NotEqualToSegment_a>, <Ref: NotEqualToSegment_b>], opts=[<Ref: LikeOperatorSegment>]]
DEBUG      [PD:3  MD:25]	.........................ComparisonOperatorGrammar	Ref.match OUT       	    	[match=<MatchResult 0/9: ''>, seg="'tbl.common_id = b.co...'"]
INFO       [PD:3  MD:24]	........................ComparisonOperatorGrammar 	OneOf.match OUT     	    	[match=<MatchResult 0/9: ''>, seg="'tbl.common_id = b.co...'"]
DEBUG      [PD:3  MD:24]	........................BinaryOperatorGrammar     	Ref.match OUT       	    	[match=<MatchResult 0/9: ''>, seg="'tbl.common_id = b.co...'"]
INFO       [PD:3  MD:23]	.......................BinaryOperatorGrammar      	OneOf.match OUT     	    	[match=<MatchResult 0/9: ''>, seg="'tbl.common_id = b.co...'"]
DEBUG      [PD:3  MD:23]	.......................ColumnReferenceSegment     	Ref.match OUT       	    	[match=<MatchResult 0/9: ''>, seg="'tbl.common_id = b.co...'"]
INFO       [PD:3  MD:22]	......................ColumnReferenceSegment      	OneOf.match OUT     	    	[match=<MatchResult 0/9: ''>, seg="'tbl.common_id = b.co...'"]
DEBUG      [PD:3  MD:22]	......................ColumnReferenceSegment      	NonCo.match OUT     	    	[match=<MatchResult 0/9: ''>, seg="'tbl.common_id = b.co...'"]
INFO       [PD:3  MD:22]	......................ColumnReferenceSegment      	OneOf.match PRN     	    	[ns=1, ps=10, ms=0, pruned=[<Ref: OnKeywordSegment>, <Ref: AsKeywordSegment>, <Ref: UsingKeywordSegment>, <Ref: CommaSegment>, <Ref: CastOperatorSegment>, <Ref: StartSquareBracketSegment>, <Ref: StartBracketSegment>, <Ref: ColonSegment>, <Ref: DelimiterSegment>, <class 'sqlfluff.core.parser.segments.base.BracketedSegment'>], opts=[<Ref: BinaryOperatorGrammar>]]
INFO       [PD:3  MD:23]	.......................BinaryOperatorGrammar      	OneOf.match PRN     	    	[ns=1, ps=3, ms=0, pruned=[<Ref: ArithmeticBinaryOperatorGrammar>, <Ref: StringBinaryOperatorGrammar>, <Ref: BooleanBinaryOperatorGrammar>], opts=[<Ref: ComparisonOperatorGrammar>]]
INFO       [PD:3  MD:24]	........................ComparisonOperatorGrammar 	OneOf.match PRN     	    	[ns=1, ps=7, ms=0, pruned=[<Ref: EqualsSegment>, <Ref: GreaterThanSegment>, <Ref: LessThanSegment>, <Ref: GreaterThanOrEqualToSegment>, <Ref: LessThanOrEqualToSegment>, <Ref: NotEqualToSegment_a>, <Ref: NotEqualToSegment_b>], opts=[<Ref: LikeOperatorSegment>]]
DEBUG      [PD:3  MD:25]	.........................ComparisonOperatorGrammar	Ref.match OUT       	    	[match=<MatchResult 0/8: ''>, seg="'.common_id = b.commo...'"]
INFO       [PD:3  MD:24]	........................ComparisonOperatorGrammar 	OneOf.match OUT     	    	[match=<MatchResult 0/8: ''>, seg="'.common_id = b.commo...'"]
DEBUG      [PD:3  MD:24]	........................BinaryOperatorGrammar     	Ref.match OUT       	    	[match=<MatchResult 0/8: ''>, seg="'.common_id = b.commo...'"]
INFO       [PD:3  MD:23]	.......................BinaryOperatorGrammar      	OneOf.match OUT     	    	[match=<MatchResult 0/8: ''>, seg="'.common_id = b.commo...'"]
DEBUG      [PD:3  MD:23]	.......................ColumnReferenceSegment     	Ref.match OUT       	    	[match=<MatchResult 0/8: ''>, seg="'.common_id = b.commo...'"]
INFO       [PD:3  MD:22]	......................ColumnReferenceSegment      	OneOf.match OUT     	    	[match=<MatchResult 0/8: ''>, seg="'.common_id = b.commo...'"]
DEBUG      [PD:3  MD:22]	......................ColumnReferenceSegment      	NonCo.match OUT     	    	[match=<MatchResult 0/8: ''>, seg="'.common_id = b.commo...'"]
INFO       [PD:3  MD:22]	......................SingleIdentifierGrammar     	OneOf.match PRN     	    	[ns=2, ps=0, ms=0, pruned=[], opts=[<Ref: NakedIdentifierSegment>, <Ref: QuotedIdentifierSegment>]]
DEBUG      [PD:3  MD:23]	.......................SingleIdentifierGrammar    	Ref.match OUT       	++  	[match=<MatchResult 1/1: 'tbl'>, seg="'tbl'"]
INFO       [PD:3  MD:22]	......................SingleIdentifierGrammar     	OneOf.match OUT     	++  	[match=<MatchResult 1/1: 'tbl'>, seg="'tbl'"]
DEBUG      [PD:3  MD:22]	......................ColumnReferenceSegment      	Ref.match OUT       	++  	[match=<MatchResult 1/1: 'tbl'>, seg="'tbl'"]
DEBUG      [PD:3  MD:22]	......................ColumnReferenceSegment      	Delim._look_ahead_match IN	    	[ls=7, seg='common_id = b.common...']
DEBUG      [PD:3  MD:22]	......................ColumnReferenceSegment      	Delim._look_ahead_match SI	    	[mq=[(<OneOf: [<Ref: DotSegment>, <Sequence: [<Ref: DotSegment>, <Ref: Dot...]>, 5, '.'), (<OneOf: [<Ref: DotSegment>, <Sequence: [<Ref: DotSegment>, <Ref: Dot...]>, 5, '.')], sb=['COMMON_ID', '', '=', '', 'B', '.', 'COMMON_ID']]
INFO       [PD:3  MD:22]	......................ColumnReferenceSegment      	OneOf.match PRN     	    	[ns=0, ps=0, ms=2, pruned=[], opts=[<Ref: DotSegment>, <Sequence: [<Ref: DotSegment>, <Ref: DotSegment>]>]]
DEBUG      [PD:3  MD:23]	.......................ColumnReferenceSegment     	Ref.match OUT       	+   	[match=<MatchResult 1/2: '.'>, seg="'.common_id'"]
DEBUG      [PD:3  MD:24]	........................ColumnReferenceSegment    	Ref.match OUT       	+   	[match=<MatchResult 1/2: '.'>, seg="'.common_id'"]
DEBUG      [PD:3  MD:24]	........................ColumnReferenceSegment    	Ref.match OUT       	    	[match=<MatchResult 0/1: ''>, seg="'common_id'"]
INFO       [PD:3  MD:23]	.......................ColumnReferenceSegment     	Seque.match OUT     	    	[match=<MatchResult 0/2: ''>, seg="'.common_id'"]
INFO       [PD:3  MD:22]	......................ColumnReferenceSegment      	OneOf.match OUT     	+   	[match=<MatchResult 1/2: '.'>, seg="'.common_id'"]
INFO       [PD:3  MD:22]	......................ColumnReferenceSegment      	OneOf.match PRN     	    	[ns=0, ps=0, ms=2, pruned=[], opts=[<Ref: DotSegment>, <Sequence: [<Ref: DotSegment>, <Ref: DotSegment>]>]]
DEBUG      [PD:3  MD:23]	.......................ColumnReferenceSegment     	Ref.match OUT       	+   	[match=<MatchResult 1/2: '.'>, seg="'.common_id'"]
DEBUG      [PD:3  MD:24]	........................ColumnReferenceSegment    	Ref.match OUT       	+   	[match=<MatchResult 1/2: '.'>, seg="'.common_id'"]
DEBUG      [PD:3  MD:24]	........................ColumnReferenceSegment    	Ref.match OUT       	    	[match=<MatchResult 0/1: ''>, seg="'common_id'"]
INFO       [PD:3  MD:23]	.......................ColumnReferenceSegment     	Seque.match OUT     	    	[match=<MatchResult 0/2: ''>, seg="'.common_id'"]
INFO       [PD:3  MD:22]	......................ColumnReferenceSegment      	OneOf.match OUT     	+   	[match=<MatchResult 1/2: '.'>, seg="'.common_id'"]
INFO       [PD:3  MD:22]	......................ColumnReferenceSegment      	OneOf.match PRN     	    	[ns=1, ps=10, ms=0, pruned=[<Ref: OnKeywordSegment>, <Ref: AsKeywordSegment>, <Ref: UsingKeywordSegment>, <Ref: CommaSegment>, <Ref: CastOperatorSegment>, <Ref: StartSquareBracketSegment>, <Ref: StartBracketSegment>, <Ref: ColonSegment>, <Ref: DelimiterSegment>, <class 'sqlfluff.core.parser.segments.base.BracketedSegment'>], opts=[<Ref: BinaryOperatorGrammar>]]
INFO       [PD:3  MD:23]	.......................BinaryOperatorGrammar      	OneOf.match PRN     	    	[ns=1, ps=3, ms=0, pruned=[<Ref: ArithmeticBinaryOperatorGrammar>, <Ref: StringBinaryOperatorGrammar>, <Ref: BooleanBinaryOperatorGrammar>], opts=[<Ref: ComparisonOperatorGrammar>]]
INFO       [PD:3  MD:24]	........................ComparisonOperatorGrammar 	OneOf.match PRN     	    	[ns=1, ps=7, ms=0, pruned=[<Ref: EqualsSegment>, <Ref: GreaterThanSegment>, <Ref: LessThanSegment>, <Ref: GreaterThanOrEqualToSegment>, <Ref: LessThanOrEqualToSegment>, <Ref: NotEqualToSegment_a>, <Ref: NotEqualToSegment_b>], opts=[<Ref: LikeOperatorSegment>]]
DEBUG      [PD:3  MD:25]	.........................ComparisonOperatorGrammar	Ref.match OUT       	    	[match=<MatchResult 0/7: ''>, seg="'common_id = b.common...'"]
INFO       [PD:3  MD:24]	........................ComparisonOperatorGrammar 	OneOf.match OUT     	    	[match=<MatchResult 0/7: ''>, seg="'common_id = b.common...'"]
DEBUG      [PD:3  MD:24]	........................BinaryOperatorGrammar     	Ref.match OUT       	    	[match=<MatchResult 0/7: ''>, seg="'common_id = b.common...'"]
INFO       [PD:3  MD:23]	.......................BinaryOperatorGrammar      	OneOf.match OUT     	    	[match=<MatchResult 0/7: ''>, seg="'common_id = b.common...'"]
DEBUG      [PD:3  MD:23]	.......................ColumnReferenceSegment     	Ref.match OUT       	    	[match=<MatchResult 0/7: ''>, seg="'common_id = b.common...'"]
INFO       [PD:3  MD:22]	......................ColumnReferenceSegment      	OneOf.match OUT     	    	[match=<MatchResult 0/7: ''>, seg="'common_id = b.common...'"]
DEBUG      [PD:3  MD:22]	......................ColumnReferenceSegment      	NonCo.match OUT     	    	[match=<MatchResult 0/7: ''>, seg="'common_id = b.common...'"]
INFO       [PD:3  MD:22]	......................ColumnReferenceSegment      	OneOf.match PRN     	    	[ns=1, ps=10, ms=0, pruned=[<Ref: OnKeywordSegment>, <Ref: AsKeywordSegment>, <Ref: UsingKeywordSegment>, <Ref: CommaSegment>, <Ref: CastOperatorSegment>, <Ref: StartSquareBracketSegment>, <Ref: StartBracketSegment>, <Ref: ColonSegment>, <Ref: DelimiterSegment>, <class 'sqlfluff.core.parser.segments.base.BracketedSegment'>], opts=[<Ref: BinaryOperatorGrammar>]]
INFO       [PD:3  MD:23]	.......................BinaryOperatorGrammar      	OneOf.match PRN     	    	[ns=1, ps=3, ms=0, pruned=[<Ref: ArithmeticBinaryOperatorGrammar>, <Ref: StringBinaryOperatorGrammar>, <Ref: BooleanBinaryOperatorGrammar>], opts=[<Ref: ComparisonOperatorGrammar>]]
INFO       [PD:3  MD:24]	........................ComparisonOperatorGrammar 	OneOf.match PRN     	    	[ns=1, ps=6, ms=1, pruned=[<Ref: GreaterThanSegment>, <Ref: LessThanSegment>, <Ref: GreaterThanOrEqualToSegment>, <Ref: LessThanOrEqualToSegment>, <Ref: NotEqualToSegment_a>, <Ref: NotEqualToSegment_b>], opts=[<Ref: EqualsSegment>, <Ref: LikeOperatorSegment>]]
DEBUG      [PD:3  MD:25]	.........................ComparisonOperatorGrammar	Ref.match OUT       	    	[match=<MatchResult 0/6: ''>, seg="' = b.common_id'"]
DEBUG      [PD:3  MD:25]	.........................ComparisonOperatorGrammar	Ref.match OUT       	    	[match=<MatchResult 0/6: ''>, seg="' = b.common_id'"]
INFO       [PD:3  MD:24]	........................ComparisonOperatorGrammar 	OneOf.match OUT     	    	[match=<MatchResult 0/6: ''>, seg="' = b.common_id'"]
DEBUG      [PD:3  MD:24]	........................BinaryOperatorGrammar     	Ref.match OUT       	    	[match=<MatchResult 0/6: ''>, seg="' = b.common_id'"]
INFO       [PD:3  MD:23]	.......................BinaryOperatorGrammar      	OneOf.match OUT     	    	[match=<MatchResult 0/6: ''>, seg="' = b.common_id'"]
DEBUG      [PD:3  MD:23]	.......................ColumnReferenceSegment     	Ref.match OUT       	    	[match=<MatchResult 0/6: ''>, seg="' = b.common_id'"]
INFO       [PD:3  MD:22]	......................ColumnReferenceSegment      	OneOf.match OUT     	    	[match=<MatchResult 0/6: ''>, seg="' = b.common_id'"]
DEBUG      [PD:3  MD:22]	......................ColumnReferenceSegment      	NonCo.match OUT     	+   	[match=<MatchResult 1/6: ' '>, seg="' = b.common_id'"]
INFO       [PD:3  MD:22]	......................SingleIdentifierGrammar     	OneOf.match PRN     	    	[ns=2, ps=0, ms=0, pruned=[], opts=[<Ref: NakedIdentifierSegment>, <Ref: QuotedIdentifierSegment>]]
DEBUG      [PD:3  MD:23]	.......................SingleIdentifierGrammar    	Ref.match OUT       	++  	[match=<MatchResult 1/1: 'common_id'>, seg="'common_id'"]
INFO       [PD:3  MD:22]	......................SingleIdentifierGrammar     	OneOf.match OUT     	++  	[match=<MatchResult 1/1: 'common_id'>, seg="'common_id'"]
DEBUG      [PD:3  MD:22]	......................ColumnReferenceSegment      	Ref.match OUT       	++  	[match=<MatchResult 1/1: 'common_id'>, seg="'common_id'"]
INFO       [PD:3  MD:21]	.....................ColumnReferenceSegment       	Delim.match OUT     	+   	[match=<MatchResult 3/9: 'tbl.common_id'>, seg="'tbl.common_id = b.co...'"]
DEBUG      [PD:3  MD:20]	....................ColumnReferenceSegment        	Colum.match OUT     	+   	[match=<MatchResult 1/7: 'tbl.common_id'>, seg="'tbl.common_id = b.co...'"]
DEBUG      [PD:3  MD:20]	....................Expression_D_Grammar          	Ref.match OUT       	+   	[match=<MatchResult 1/7: 'tbl.common_id'>, seg="'tbl.common_id = b.co...'"]
DEBUG      [PD:3  MD:21]	.....................Expression_D_Grammar         	Ref.match OUT       	    	[match=<MatchResult 0/9: ''>, seg="'tbl.common_id = b.co...'"]
INFO       [PD:3  MD:22]	......................ArrayLiteralSegment         	Brack.match OUT     	    	[match=<MatchResult 0/9: ''>, seg="'tbl.common_id = b.co...'"]
DEBUG      [PD:3  MD:21]	.....................ArrayLiteralSegment          	Array.match OUT     	    	[match=<MatchResult 0/9: ''>, seg="'tbl.common_id = b.co...'"]
DEBUG      [PD:3  MD:21]	.....................Expression_D_Grammar         	Ref.match OUT       	    	[match=<MatchResult 0/9: ''>, seg="'tbl.common_id = b.co...'"]
INFO       [PD:3  MD:20]	....................Expression_D_Grammar          	Seque.match OUT     	    	[match=<MatchResult 0/9: ''>, seg="'tbl.common_id = b.co...'"]
INFO       [PD:3  MD:22]	......................DatatypeSegment             	OneOf.match PRN     	    	[ns=1, ps=2, ms=0, pruned=[<Sequence: [<OneOf: [<Ref: TimeKeywordSegment>, <Ref..., <Bracketed: [<Ref: NumericLiteralSegment..., <Sequence:...]>, <Sequence: [<Ref: DoubleKeywordSegment>, <Ref: PrecisionKeywordSegment>]>], opts=[<Sequence: [<OneOf: [<Sequence: [<OneOf: [<Ref: Char..., <Bracketed: [<OneOf: [<Delimited: [<Ref:..., <Ref: Char...]>]]
INFO       [PD:3  MD:24]	........................DatatypeSegment           	OneOf.match PRN     	    	[ns=1, ps=1, ms=0, pruned=[<Sequence: [<OneOf: [<Ref: CharacterKeywordSegment>,..., <OneOf: [<Ref: VaryingKeywordSegment>, <...]>], opts=[<Sequence: [<Sequence: [<Ref: SingleIdentifierGramma..., <Ref: DatatypeIdentifierSegment>]>]]
INFO       [PD:3  MD:27]	...........................SingleIdentifierGrammar	OneOf.match PRN     	    	[ns=2, ps=0, ms=0, pruned=[], opts=[<Ref: NakedIdentifierSegment>, <Ref: QuotedIdentifierSegment>]]
DEBUG      [PD:3  MD:28]	............................SingleIdentifierGrammar	Ref.match OUT       	+   	[match=<MatchResult 1/9: 'tbl'>, seg="'tbl.common_id = b.co...'"]
DEBUG      [PD:3  MD:28]	............................SingleIdentifierGrammar	Ref.match OUT       	    	[match=<MatchResult 0/9: ''>, seg="'tbl.common_id = b.co...'"]
INFO       [PD:3  MD:27]	...........................SingleIdentifierGrammar	OneOf.match OUT     	+   	[match=<MatchResult 1/9: 'tbl'>, seg="'tbl.common_id = b.co...'"]
DEBUG      [PD:3  MD:27]	...........................DatatypeSegment        	Ref.match OUT       	+   	[match=<MatchResult 1/9: 'tbl'>, seg="'tbl.common_id = b.co...'"]
DEBUG      [PD:3  MD:27]	...........................DatatypeSegment        	Ref.match OUT       	+   	[match=<MatchResult 1/8: '.'>, seg="'.common_id = b.commo...'"]
INFO       [PD:3  MD:26]	..........................DatatypeSegment         	Seque.match OUT     	+   	[match=<MatchResult 2/9: 'tbl.'>, seg="'tbl.common_id = b.co...'"]
DEBUG      [PD:3  MD:26]	..........................DatatypeSegment         	Ref.match OUT       	+   	[match=<MatchResult 1/7: 'common_id'>, seg="'common_id = b.common...'"]
INFO       [PD:3  MD:25]	.........................DatatypeSegment          	Seque.match OUT     	+   	[match=<MatchResult 3/9: 'tbl.common_id'>, seg="'tbl.common_id = b.co...'"]
INFO       [PD:3  MD:24]	........................DatatypeSegment           	OneOf.match OUT     	+   	[match=<MatchResult 3/9: 'tbl.common_id'>, seg="'tbl.common_id = b.co...'"]
INFO       [PD:3  MD:24]	........................DatatypeSegment           	Brack.match OUT     	    	[match=<MatchResult 0/5: ''>, seg="'= b.common_id'"]
DEBUG      [PD:3  MD:24]	........................DatatypeSegment           	Ref.match OUT       	    	[match=<MatchResult 0/5: ''>, seg="'= b.common_id'"]
INFO       [PD:3  MD:23]	.......................DatatypeSegment            	Seque.match OUT     	+   	[match=<MatchResult 3/9: 'tbl.common_id'>, seg="'tbl.common_id = b.co...'"]
INFO       [PD:3  MD:22]	......................DatatypeSegment             	OneOf.match OUT     	+   	[match=<MatchResult 3/9: 'tbl.common_id'>, seg="'tbl.common_id = b.co...'"]
DEBUG      [PD:3  MD:21]	.....................DatatypeSegment              	Datat.match OUT     	+   	[match=<MatchResult 1/7: 'tbl.common_id'>, seg="'tbl.common_id = b.co...'"]
DEBUG      [PD:3  MD:21]	.....................Expression_D_Grammar         	Ref.match OUT       	+   	[match=<MatchResult 1/7: 'tbl.common_id'>, seg="'tbl.common_id = b.co...'"]
INFO       [PD:3  MD:21]	.....................Expression_D_Grammar         	OneOf.match PRN     	    	[ns=2, ps=3, ms=0, pruned=[<Ref: BooleanLiteralGrammar>, <Ref: NullLiteralSegment>, <Ref: DateTimeLiteralGrammar>], opts=[<Ref: QuotedLiteralSegment>, <Ref: NumericLiteralSegment>]]
DEBUG      [PD:3  MD:22]	......................Expression_D_Grammar        	Ref.match OUT       	    	[match=<MatchResult 0/5: ''>, seg="'= b.common_id'"]
DEBUG      [PD:3  MD:22]	......................Expression_D_Grammar        	Ref.match OUT       	    	[match=<MatchResult 0/5: ''>, seg="'= b.common_id'"]
INFO       [PD:3  MD:21]	.....................Expression_D_Grammar         	OneOf.match OUT     	    	[match=<MatchResult 0/5: ''>, seg="'= b.common_id'"]
INFO       [PD:3  MD:20]	....................Expression_D_Grammar          	Seque.match OUT     	    	[match=<MatchResult 0/9: ''>, seg="'tbl.common_id = b.co...'"]
INFO       [PD:3  MD:19]	...................Expression_D_Grammar           	OneOf.match OUT     	+   	[match=<MatchResult 1/7: 'tbl.common_id'>, seg="'tbl.common_id = b.co...'"]
INFO       [PD:3  MD:19]	...................Accessor_Grammar               	AnyNu.match PRN     	    	[ns=0, ps=1, ms=0, pruned=[<Ref: ArrayAccessorSegment>], opts='ALL']
INFO       [PD:3  MD:19]	...................Accessor_Grammar               	AnyNu.match OUT     	    	[match=<MatchResult 0/5: ''>, seg="'= b.common_id'"]
DEBUG      [PD:3  MD:19]	...................Expression_D_Grammar           	Ref.match OUT       	    	[match=<MatchResult 0/5: ''>, seg="'= b.common_id'"]
INFO       [PD:3  MD:19]	...................Expression_D_Grammar           	AnyNu.match PRN     	    	[ns=0, ps=1, ms=0, pruned=[<Ref: ShorthandCastSegment>], opts='ALL']
INFO       [PD:3  MD:19]	...................Expression_D_Grammar           	AnyNu.match OUT     	    	[match=<MatchResult 0/5: ''>, seg="'= b.common_id'"]
INFO       [PD:3  MD:18]	..................Expression_D_Grammar            	Seque.match OUT     	+   	[match=<MatchResult 1/7: 'tbl.common_id'>, seg="'tbl.common_id = b.co...'"]
DEBUG      [PD:3  MD:18]	..................Expression_C_Grammar            	Ref.match OUT       	+   	[match=<MatchResult 1/7: 'tbl.common_id'>, seg="'tbl.common_id = b.co...'"]
INFO       [PD:3  MD:17]	.................Expression_C_Grammar             	OneOf.match OUT     	+   	[match=<MatchResult 1/7: 'tbl.common_id'>, seg="'tbl.common_id = b.co...'"]
DEBUG      [PD:3  MD:17]	.................Expression_A_Grammar             	Ref.match OUT       	+   	[match=<MatchResult 1/7: 'tbl.common_id'>, seg="'tbl.common_id = b.co...'"]
INFO       [PD:3  MD:16]	................Expression_A_Grammar              	OneOf.match OUT     	+   	[match=<MatchResult 1/7: 'tbl.common_id'>, seg="'tbl.common_id = b.co...'"]
INFO       [PD:3  MD:16]	................Expression_A_Grammar              	AnyNu.match PRN     	    	[ns=1, ps=0, ms=0, pruned=[], opts=[<OneOf: [<Sequence: [<OneOf: [<Sequence: [<Ref: N..., <Sequence: [<Ref: NotKeywordSegment [opt..., <Sequence:...]>]]
INFO       [PD:3  MD:17]	.................Expression_A_Grammar             	OneOf.match PRN     	    	[ns=3, ps=5, ms=0, pruned=[<Sequence: [<Ref: NotKeywordSegment [opt]>, <Ref: InKeywordSegment>, <Bracketed: [<OneOf: [<Delimited: [<Ref:...]>, <Sequence: [<Ref: NotKeywordSegment [opt]>, <Ref: InKeywordSegment>, <Ref: FunctionSegment>]>, <Sequence: [<Ref: IsKeywordSegment>, <Ref: NotKeywordSegment [opt]>, <Ref: IsClauseGrammar>]>, <Sequence: [<Ref: NotKeywordSegment>, <Ref: Expression_C_Grammar>]>, <Sequence: [<Ref: NotKeywordSegment [opt]>, <Ref: BetweenKeywordSegment>, <Ref: Expression_C_Grammar>, <AnyNumbe...]>], opts=[<Sequence: [<OneOf: [<Sequence: [<Ref: NotKeywordSeg..., <Ref: Expression_C_Grammar>, <Sequence: [<Ref: EscapeKe...]>, <Ref: IsNullGrammar>, <Ref: NotNullGrammar>]]
INFO       [PD:3  MD:19]	...................Expression_A_Grammar           	OneOf.match PRN     	    	[ns=1, ps=1, ms=0, pruned=[<Sequence: [<Ref: NotKeywordSegment [opt]>, <Ref: LikeGrammar>]>], opts=[<Sequence: [<Ref: BinaryOperatorGrammar>, <Ref: NotKeywordSegment [opt]>]>]]
INFO       [PD:3  MD:21]	.....................BinaryOperatorGrammar        	OneOf.match PRN     	    	[ns=1, ps=3, ms=0, pruned=[<Ref: ArithmeticBinaryOperatorGrammar>, <Ref: StringBinaryOperatorGrammar>, <Ref: BooleanBinaryOperatorGrammar>], opts=[<Ref: ComparisonOperatorGrammar>]]
INFO       [PD:3  MD:22]	......................ComparisonOperatorGrammar   	OneOf.match PRN     	    	[ns=1, ps=6, ms=1, pruned=[<Ref: GreaterThanSegment>, <Ref: LessThanSegment>, <Ref: GreaterThanOrEqualToSegment>, <Ref: LessThanOrEqualToSegment>, <Ref: NotEqualToSegment_a>, <Ref: NotEqualToSegment_b>], opts=[<Ref: EqualsSegment>, <Ref: LikeOperatorSegment>]]
DEBUG      [PD:3  MD:23]	.......................ComparisonOperatorGrammar  	Ref.match OUT       	+   	[match=<MatchResult 1/5: '='>, seg="'= b.common_id'"]
DEBUG      [PD:3  MD:23]	.......................ComparisonOperatorGrammar  	Ref.match OUT       	    	[match=<MatchResult 0/5: ''>, seg="'= b.common_id'"]
INFO       [PD:3  MD:22]	......................ComparisonOperatorGrammar   	OneOf.match OUT     	+   	[match=<MatchResult 1/5: '='>, seg="'= b.common_id'"]
DEBUG      [PD:3  MD:22]	......................BinaryOperatorGrammar       	Ref.match OUT       	+   	[match=<MatchResult 1/5: '='>, seg="'= b.common_id'"]
INFO       [PD:3  MD:21]	.....................BinaryOperatorGrammar        	OneOf.match OUT     	+   	[match=<MatchResult 1/5: '='>, seg="'= b.common_id'"]
DEBUG      [PD:3  MD:21]	.....................Expression_A_Grammar         	Ref.match OUT       	+   	[match=<MatchResult 1/5: '='>, seg="'= b.common_id'"]
DEBUG      [PD:3  MD:21]	.....................Expression_A_Grammar         	Ref.match OUT       	    	[match=<MatchResult 0/3: ''>, seg="'b.common_id'"]
INFO       [PD:3  MD:20]	....................Expression_A_Grammar          	Seque.match OUT     	+   	[match=<MatchResult 1/5: '='>, seg="'= b.common_id'"]
INFO       [PD:3  MD:19]	...................Expression_A_Grammar           	OneOf.match OUT     	+   	[match=<MatchResult 1/5: '='>, seg="'= b.common_id'"]
INFO       [PD:3  MD:19]	...................Expression_C_Grammar           	OneOf.match PRN     	    	[ns=1, ps=2, ms=0, pruned=[<Sequence: [<Ref: ExistsKeywordSegment>, <Bracketed: [<Ref: SelectStatementSegmen...]>, <Ref: CaseExpressionSegment>], opts=[<Ref: Expression_D_Grammar>]]
INFO       [PD:3  MD:21]	.....................Expression_D_Grammar         	OneOf.match PRN     	    	[ns=6, ps=3, ms=0, pruned=[<Bracketed: [<OneOf: [<Ref: ExpressionSegment>, <Ref:...]>, <Ref: SelectStatementSegment>, <Ref: IntervalExpressionSegment>], opts=[<Ref: BareFunctionSegment>, <Ref: FunctionSegment>, <Ref: LiteralGrammar>, <Ref: ColumnReferenceSegment>, <Sequence: [<Ref: SimpleArrayTypeGrammar [opt]>, <Ref: ArrayLiteralSegment>]>, <Sequence: [<Ref: DatatypeSegment>, <OneOf: [<Ref: QuotedLiteralSegment>, <R...]>]]
DEBUG      [PD:3  MD:22]	......................Expression_D_Grammar        	Ref.match OUT       	    	[match=<MatchResult 0/3: ''>, seg="'b.common_id'"]
INFO       [PD:3  MD:23]	.......................FunctionSegment            	OneOf.match PRN     	    	[ns=1, ps=1, ms=0, pruned=[<Sequence: [<Sequence: [<Ref: DateAddFunctionNameSeg...]>], opts=[<Sequence: [<Sequence: [<AnyNumberOf: [<Ref: Functio..., <Ref: PostFunctionGrammar [opt]>]>]]
DEBUG      [PD:3  MD:29]	.............................DateAddFunctionNameSegment	Ref.match OUT       	    	[match=<MatchResult 0/3: ''>, seg="'b.common_id'"]
INFO       [PD:3  MD:28]	............................DateAddFunctionNameSegment	Seque.match OUT     	    	[match=<MatchResult 0/3: ''>, seg="'b.common_id'"]
DEBUG      [PD:3  MD:27]	...........................DateAddFunctionNameSegment	DateA.match OUT     	    	[match=<MatchResult 0/3: ''>, seg="'b.common_id'"]
DEBUG      [PD:3  MD:27]	...........................FunctionSegment        	Ref.match OUT       	    	[match=<MatchResult 0/3: ''>, seg="'b.common_id'"]
INFO       [PD:3  MD:26]	..........................FunctionSegment         	AnyNu.match PRN     	    	[ns=1, ps=0, ms=0, pruned=[], opts=[<Ref: FunctionNameSegment>]]
INFO       [PD:3  MD:29]	.............................FunctionNameSegment  	AnyNu.match PRN     	    	[ns=1, ps=0, ms=0, pruned=[], opts=[<Sequence: [<Ref: SingleIdentifierGrammar>, <Ref: DotSegment>]>]]
INFO       [PD:3  MD:31]	...............................SingleIdentifierGrammar	OneOf.match PRN     	    	[ns=2, ps=0, ms=0, pruned=[], opts=[<Ref: NakedIdentifierSegment>, <Ref: QuotedIdentifierSegment>]]
DEBUG      [PD:3  MD:32]	................................SingleIdentifierGrammar	Ref.match OUT       	+   	[match=<MatchResult 1/3: 'b'>, seg="'b.common_id'"]
DEBUG      [PD:3  MD:32]	................................SingleIdentifierGrammar	Ref.match OUT       	    	[match=<MatchResult 0/3: ''>, seg="'b.common_id'"]
INFO       [PD:3  MD:31]	...............................SingleIdentifierGrammar	OneOf.match OUT     	+   	[match=<MatchResult 1/3: 'b'>, seg="'b.common_id'"]
DEBUG      [PD:3  MD:31]	...............................FunctionNameSegment	Ref.match OUT       	+   	[match=<MatchResult 1/3: 'b'>, seg="'b.common_id'"]
DEBUG      [PD:3  MD:31]	...............................FunctionNameSegment	Ref.match OUT       	+   	[match=<MatchResult 1/2: '.'>, seg="'.common_id'"]
INFO       [PD:3  MD:30]	..............................FunctionNameSegment 	Seque.match OUT     	+   	[match=<MatchResult 2/3: 'b.'>, seg="'b.common_id'"]
INFO       [PD:3  MD:29]	.............................FunctionNameSegment  	AnyNu.match PRN     	    	[ns=1, ps=0, ms=0, pruned=[], opts=[<Sequence: [<Ref: SingleIdentifierGrammar>, <Ref: DotSegment>]>]]
INFO       [PD:3  MD:31]	...............................SingleIdentifierGrammar	OneOf.match PRN     	    	[ns=2, ps=0, ms=0, pruned=[], opts=[<Ref: NakedIdentifierSegment>, <Ref: QuotedIdentifierSegment>]]
DEBUG      [PD:3  MD:32]	................................SingleIdentifierGrammar	Ref.match OUT       	++  	[match=<MatchResult 1/1: 'common_id'>, seg="'common_id'"]
INFO       [PD:3  MD:31]	...............................SingleIdentifierGrammar	OneOf.match OUT     	++  	[match=<MatchResult 1/1: 'common_id'>, seg="'common_id'"]
DEBUG      [PD:3  MD:31]	...............................FunctionNameSegment	Ref.match OUT       	++  	[match=<MatchResult 1/1: 'common_id'>, seg="'common_id'"]
INFO       [PD:3  MD:30]	..............................FunctionNameSegment 	Seque.match OUT     	    	[match=<MatchResult 0/1: ''>, seg="'common_id'"]
INFO       [PD:3  MD:29]	.............................FunctionNameSegment  	AnyNu.match OUT     	+   	[match=<MatchResult 2/3: 'b.'>, seg="'b.common_id'"]
INFO       [PD:3  MD:29]	.............................FunctionNameSegment  	OneOf.match PRN     	    	[ns=2, ps=0, ms=0, pruned=[], opts=[<Ref: FunctionNameIdentifierSegment>, <Ref: QuotedIdentifierSegment>]]
DEBUG      [PD:3  MD:30]	..............................FunctionNameSegment 	Ref.match OUT       	++  	[match=<MatchResult 1/1: 'common_id'>, seg="'common_id'"]
INFO       [PD:3  MD:29]	.............................FunctionNameSegment  	OneOf.match OUT     	++  	[match=<MatchResult 1/1: 'common_id'>, seg="'common_id'"]
INFO       [PD:3  MD:28]	............................FunctionNameSegment   	Seque.match OUT     	++  	[match=<MatchResult 3/3: 'b.common_id'>, seg="'b.common_id'"]
DEBUG      [PD:3  MD:27]	...........................FunctionNameSegment    	Funct.match OUT     	++  	[match=<MatchResult 1/1: 'b.common_id'>, seg="'b.common_id'"]
DEBUG      [PD:3  MD:27]	...........................FunctionSegment        	Ref.match OUT       	++  	[match=<MatchResult 1/1: 'b.common_id'>, seg="'b.common_id'"]
INFO       [PD:3  MD:26]	..........................FunctionSegment         	AnyNu.match OUT     	++  	[match=<MatchResult 1/1: 'b.common_id'>, seg="'b.common_id'"]
INFO       [PD:3  MD:25]	.........................FunctionSegment          	Seque.match OUT     	    	[match=<MatchResult 0/3: ''>, seg="'b.common_id'"]
INFO       [PD:3  MD:24]	........................FunctionSegment           	Seque.match OUT     	    	[match=<MatchResult 0/3: ''>, seg="'b.common_id'"]
INFO       [PD:3  MD:23]	.......................FunctionSegment            	OneOf.match OUT     	    	[match=<MatchResult 0/3: ''>, seg="'b.common_id'"]
DEBUG      [PD:3  MD:22]	......................FunctionSegment             	Funct.match OUT     	    	[match=<MatchResult 0/3: ''>, seg="'b.common_id'"]
DEBUG      [PD:3  MD:22]	......................Expression_D_Grammar        	Ref.match OUT       	    	[match=<MatchResult 0/3: ''>, seg="'b.common_id'"]
INFO       [PD:3  MD:22]	......................LiteralGrammar              	OneOf.match PRN     	    	[ns=2, ps=4, ms=0, pruned=[<Ref: BooleanLiteralGrammar>, <Ref: QualifiedNumericLiteralSegment>, <Ref: NullLiteralSegment>, <Ref: DateTimeLiteralGrammar>], opts=[<Ref: QuotedLiteralSegment>, <Ref: NumericLiteralSegment>]]
DEBUG      [PD:3  MD:23]	.......................LiteralGrammar             	Ref.match OUT       	    	[match=<MatchResult 0/3: ''>, seg="'b.common_id'"]
DEBUG      [PD:3  MD:23]	.......................LiteralGrammar             	Ref.match OUT       	    	[match=<MatchResult 0/3: ''>, seg="'b.common_id'"]
INFO       [PD:3  MD:22]	......................LiteralGrammar              	OneOf.match OUT     	    	[match=<MatchResult 0/3: ''>, seg="'b.common_id'"]
DEBUG      [PD:3  MD:22]	......................Expression_D_Grammar        	Ref.match OUT       	    	[match=<MatchResult 0/3: ''>, seg="'b.common_id'"]
DEBUG      [PD:3  MD:24]	........................ColumnReferenceSegment    	Delim._look_ahead_match IN	    	[ls=3, seg='b.common_id']
DEBUG      [PD:3  MD:24]	........................ColumnReferenceSegment    	Delim._look_ahead_match SI	    	[mq=[(<OneOf: [<Ref: DotSegment>, <Sequence: [<Ref: DotSegment>, <Ref: Dot...]>, 1, '.'), (<OneOf: [<Ref: DotSegment>, <Sequence: [<Ref: DotSegment>, <Ref: Dot...]>, 1, '.')], sb=['B', '.', 'COMMON_ID']]
INFO       [PD:3  MD:24]	........................ColumnReferenceSegment    	OneOf.match PRN     	    	[ns=0, ps=0, ms=2, pruned=[], opts=[<Ref: DotSegment>, <Sequence: [<Ref: DotSegment>, <Ref: DotSegment>]>]]
DEBUG      [PD:3  MD:25]	.........................ColumnReferenceSegment   	Ref.match OUT       	+   	[match=<MatchResult 1/2: '.'>, seg="'.common_id'"]
DEBUG      [PD:3  MD:26]	..........................ColumnReferenceSegment  	Ref.match OUT       	+   	[match=<MatchResult 1/2: '.'>, seg="'.common_id'"]
DEBUG      [PD:3  MD:26]	..........................ColumnReferenceSegment  	Ref.match OUT       	    	[match=<MatchResult 0/1: ''>, seg="'common_id'"]
INFO       [PD:3  MD:25]	.........................ColumnReferenceSegment   	Seque.match OUT     	    	[match=<MatchResult 0/2: ''>, seg="'.common_id'"]
INFO       [PD:3  MD:24]	........................ColumnReferenceSegment    	OneOf.match OUT     	+   	[match=<MatchResult 1/2: '.'>, seg="'.common_id'"]
INFO       [PD:3  MD:24]	........................ColumnReferenceSegment    	OneOf.match PRN     	    	[ns=0, ps=0, ms=2, pruned=[], opts=[<Ref: DotSegment>, <Sequence: [<Ref: DotSegment>, <Ref: DotSegment>]>]]
DEBUG      [PD:3  MD:25]	.........................ColumnReferenceSegment   	Ref.match OUT       	+   	[match=<MatchResult 1/2: '.'>, seg="'.common_id'"]
DEBUG      [PD:3  MD:26]	..........................ColumnReferenceSegment  	Ref.match OUT       	+   	[match=<MatchResult 1/2: '.'>, seg="'.common_id'"]
DEBUG      [PD:3  MD:26]	..........................ColumnReferenceSegment  	Ref.match OUT       	    	[match=<MatchResult 0/1: ''>, seg="'common_id'"]
INFO       [PD:3  MD:25]	.........................ColumnReferenceSegment   	Seque.match OUT     	    	[match=<MatchResult 0/2: ''>, seg="'.common_id'"]
INFO       [PD:3  MD:24]	........................ColumnReferenceSegment    	OneOf.match OUT     	+   	[match=<MatchResult 1/2: '.'>, seg="'.common_id'"]
INFO       [PD:3  MD:24]	........................ColumnReferenceSegment    	OneOf.match PRN     	    	[ns=1, ps=10, ms=0, pruned=[<Ref: OnKeywordSegment>, <Ref: AsKeywordSegment>, <Ref: UsingKeywordSegment>, <Ref: CommaSegment>, <Ref: CastOperatorSegment>, <Ref: StartSquareBracketSegment>, <Ref: StartBracketSegment>, <Ref: ColonSegment>, <Ref: DelimiterSegment>, <class 'sqlfluff.core.parser.segments.base.BracketedSegment'>], opts=[<Ref: BinaryOperatorGrammar>]]
INFO       [PD:3  MD:25]	.........................BinaryOperatorGrammar    	OneOf.match PRN     	    	[ns=1, ps=3, ms=0, pruned=[<Ref: ArithmeticBinaryOperatorGrammar>, <Ref: StringBinaryOperatorGrammar>, <Ref: BooleanBinaryOperatorGrammar>], opts=[<Ref: ComparisonOperatorGrammar>]]
INFO       [PD:3  MD:26]	..........................ComparisonOperatorGrammar	OneOf.match PRN     	    	[ns=1, ps=7, ms=0, pruned=[<Ref: EqualsSegment>, <Ref: GreaterThanSegment>, <Ref: LessThanSegment>, <Ref: GreaterThanOrEqualToSegment>, <Ref: LessThanOrEqualToSegment>, <Ref: NotEqualToSegment_a>, <Ref: NotEqualToSegment_b>], opts=[<Ref: LikeOperatorSegment>]]
DEBUG      [PD:3  MD:27]	...........................ComparisonOperatorGrammar	Ref.match OUT       	    	[match=<MatchResult 0/3: ''>, seg="'b.common_id'"]
INFO       [PD:3  MD:26]	..........................ComparisonOperatorGrammar	OneOf.match OUT     	    	[match=<MatchResult 0/3: ''>, seg="'b.common_id'"]
DEBUG      [PD:3  MD:26]	..........................BinaryOperatorGrammar   	Ref.match OUT       	    	[match=<MatchResult 0/3: ''>, seg="'b.common_id'"]
INFO       [PD:3  MD:25]	.........................BinaryOperatorGrammar    	OneOf.match OUT     	    	[match=<MatchResult 0/3: ''>, seg="'b.common_id'"]
DEBUG      [PD:3  MD:25]	.........................ColumnReferenceSegment   	Ref.match OUT       	    	[match=<MatchResult 0/3: ''>, seg="'b.common_id'"]
INFO       [PD:3  MD:24]	........................ColumnReferenceSegment    	OneOf.match OUT     	    	[match=<MatchResult 0/3: ''>, seg="'b.common_id'"]
DEBUG      [PD:3  MD:24]	........................ColumnReferenceSegment    	NonCo.match OUT     	    	[match=<MatchResult 0/3: ''>, seg="'b.common_id'"]
INFO       [PD:3  MD:24]	........................ColumnReferenceSegment    	OneOf.match PRN     	    	[ns=1, ps=10, ms=0, pruned=[<Ref: OnKeywordSegment>, <Ref: AsKeywordSegment>, <Ref: UsingKeywordSegment>, <Ref: CommaSegment>, <Ref: CastOperatorSegment>, <Ref: StartSquareBracketSegment>, <Ref: StartBracketSegment>, <Ref: ColonSegment>, <Ref: DelimiterSegment>, <class 'sqlfluff.core.parser.segments.base.BracketedSegment'>], opts=[<Ref: BinaryOperatorGrammar>]]
INFO       [PD:3  MD:25]	.........................BinaryOperatorGrammar    	OneOf.match PRN     	    	[ns=1, ps=3, ms=0, pruned=[<Ref: ArithmeticBinaryOperatorGrammar>, <Ref: StringBinaryOperatorGrammar>, <Ref: BooleanBinaryOperatorGrammar>], opts=[<Ref: ComparisonOperatorGrammar>]]
INFO       [PD:3  MD:26]	..........................ComparisonOperatorGrammar	OneOf.match PRN     	    	[ns=1, ps=7, ms=0, pruned=[<Ref: EqualsSegment>, <Ref: GreaterThanSegment>, <Ref: LessThanSegment>, <Ref: GreaterThanOrEqualToSegment>, <Ref: LessThanOrEqualToSegment>, <Ref: NotEqualToSegment_a>, <Ref: NotEqualToSegment_b>], opts=[<Ref: LikeOperatorSegment>]]
DEBUG      [PD:3  MD:27]	...........................ComparisonOperatorGrammar	Ref.match OUT       	    	[match=<MatchResult 0/2: ''>, seg="'.common_id'"]
INFO       [PD:3  MD:26]	..........................ComparisonOperatorGrammar	OneOf.match OUT     	    	[match=<MatchResult 0/2: ''>, seg="'.common_id'"]
DEBUG      [PD:3  MD:26]	..........................BinaryOperatorGrammar   	Ref.match OUT       	    	[match=<MatchResult 0/2: ''>, seg="'.common_id'"]
INFO       [PD:3  MD:25]	.........................BinaryOperatorGrammar    	OneOf.match OUT     	    	[match=<MatchResult 0/2: ''>, seg="'.common_id'"]
DEBUG      [PD:3  MD:25]	.........................ColumnReferenceSegment   	Ref.match OUT       	    	[match=<MatchResult 0/2: ''>, seg="'.common_id'"]
INFO       [PD:3  MD:24]	........................ColumnReferenceSegment    	OneOf.match OUT     	    	[match=<MatchResult 0/2: ''>, seg="'.common_id'"]
DEBUG      [PD:3  MD:24]	........................ColumnReferenceSegment    	NonCo.match OUT     	    	[match=<MatchResult 0/2: ''>, seg="'.common_id'"]
INFO       [PD:3  MD:24]	........................SingleIdentifierGrammar   	OneOf.match PRN     	    	[ns=2, ps=0, ms=0, pruned=[], opts=[<Ref: NakedIdentifierSegment>, <Ref: QuotedIdentifierSegment>]]
DEBUG      [PD:3  MD:25]	.........................SingleIdentifierGrammar  	Ref.match OUT       	++  	[match=<MatchResult 1/1: 'b'>, seg="'b'"]
INFO       [PD:3  MD:24]	........................SingleIdentifierGrammar   	OneOf.match OUT     	++  	[match=<MatchResult 1/1: 'b'>, seg="'b'"]
DEBUG      [PD:3  MD:24]	........................ColumnReferenceSegment    	Ref.match OUT       	++  	[match=<MatchResult 1/1: 'b'>, seg="'b'"]
DEBUG      [PD:3  MD:24]	........................ColumnReferenceSegment    	Delim._look_ahead_match IN	    	[ls=1, seg='common_id']
DEBUG      [PD:3  MD:24]	........................ColumnReferenceSegment    	Delim._look_ahead_match SI	    	[mq=[], sb=['COMMON_ID']]
INFO       [PD:3  MD:24]	........................ColumnReferenceSegment    	OneOf.match PRN     	    	[ns=1, ps=10, ms=0, pruned=[<Ref: OnKeywordSegment>, <Ref: AsKeywordSegment>, <Ref: UsingKeywordSegment>, <Ref: CommaSegment>, <Ref: CastOperatorSegment>, <Ref: StartSquareBracketSegment>, <Ref: StartBracketSegment>, <Ref: ColonSegment>, <Ref: DelimiterSegment>, <class 'sqlfluff.core.parser.segments.base.BracketedSegment'>], opts=[<Ref: BinaryOperatorGrammar>]]
INFO       [PD:3  MD:25]	.........................BinaryOperatorGrammar    	OneOf.match PRN     	    	[ns=1, ps=3, ms=0, pruned=[<Ref: ArithmeticBinaryOperatorGrammar>, <Ref: StringBinaryOperatorGrammar>, <Ref: BooleanBinaryOperatorGrammar>], opts=[<Ref: ComparisonOperatorGrammar>]]
INFO       [PD:3  MD:26]	..........................ComparisonOperatorGrammar	OneOf.match PRN     	    	[ns=1, ps=7, ms=0, pruned=[<Ref: EqualsSegment>, <Ref: GreaterThanSegment>, <Ref: LessThanSegment>, <Ref: GreaterThanOrEqualToSegment>, <Ref: LessThanOrEqualToSegment>, <Ref: NotEqualToSegment_a>, <Ref: NotEqualToSegment_b>], opts=[<Ref: LikeOperatorSegment>]]
DEBUG      [PD:3  MD:27]	...........................ComparisonOperatorGrammar	Ref.match OUT       	    	[match=<MatchResult 0/1: ''>, seg="'common_id'"]
INFO       [PD:3  MD:26]	..........................ComparisonOperatorGrammar	OneOf.match OUT     	    	[match=<MatchResult 0/1: ''>, seg="'common_id'"]
DEBUG      [PD:3  MD:26]	..........................BinaryOperatorGrammar   	Ref.match OUT       	    	[match=<MatchResult 0/1: ''>, seg="'common_id'"]
INFO       [PD:3  MD:25]	.........................BinaryOperatorGrammar    	OneOf.match OUT     	    	[match=<MatchResult 0/1: ''>, seg="'common_id'"]
DEBUG      [PD:3  MD:25]	.........................ColumnReferenceSegment   	Ref.match OUT       	    	[match=<MatchResult 0/1: ''>, seg="'common_id'"]
INFO       [PD:3  MD:24]	........................ColumnReferenceSegment    	OneOf.match OUT     	    	[match=<MatchResult 0/1: ''>, seg="'common_id'"]
DEBUG      [PD:3  MD:24]	........................ColumnReferenceSegment    	NonCo.match OUT     	    	[match=<MatchResult 0/1: ''>, seg="'common_id'"]
INFO       [PD:3  MD:24]	........................SingleIdentifierGrammar   	OneOf.match PRN     	    	[ns=2, ps=0, ms=0, pruned=[], opts=[<Ref: NakedIdentifierSegment>, <Ref: QuotedIdentifierSegment>]]
DEBUG      [PD:3  MD:25]	.........................SingleIdentifierGrammar  	Ref.match OUT       	++  	[match=<MatchResult 1/1: 'common_id'>, seg="'common_id'"]
INFO       [PD:3  MD:24]	........................SingleIdentifierGrammar   	OneOf.match OUT     	++  	[match=<MatchResult 1/1: 'common_id'>, seg="'common_id'"]
DEBUG      [PD:3  MD:24]	........................ColumnReferenceSegment    	Ref.match OUT       	++  	[match=<MatchResult 1/1: 'common_id'>, seg="'common_id'"]
INFO       [PD:3  MD:23]	.......................ColumnReferenceSegment     	Delim.match OUT     	++  	[match=<MatchResult 3/3: 'b.common_id'>, seg="'b.common_id'"]
DEBUG      [PD:3  MD:22]	......................ColumnReferenceSegment      	Colum.match OUT     	++  	[match=<MatchResult 1/1: 'b.common_id'>, seg="'b.common_id'"]
DEBUG      [PD:3  MD:22]	......................Expression_D_Grammar        	Ref.match OUT       	++  	[match=<MatchResult 1/1: 'b.common_id'>, seg="'b.common_id'"]
INFO       [PD:3  MD:21]	.....................Expression_D_Grammar         	OneOf.match OUT     	++  	[match=<MatchResult 1/1: 'b.common_id'>, seg="'b.common_id'"]
INFO       [PD:3  MD:20]	....................Expression_D_Grammar          	Seque.match OUT     	++  	[match=<MatchResult 1/1: 'b.common_id'>, seg="'b.common_id'"]
DEBUG      [PD:3  MD:20]	....................Expression_C_Grammar          	Ref.match OUT       	++  	[match=<MatchResult 1/1: 'b.common_id'>, seg="'b.common_id'"]
INFO       [PD:3  MD:19]	...................Expression_C_Grammar           	OneOf.match OUT     	++  	[match=<MatchResult 1/1: 'b.common_id'>, seg="'b.common_id'"]
DEBUG      [PD:3  MD:19]	...................Expression_A_Grammar           	Ref.match OUT       	++  	[match=<MatchResult 1/1: 'b.common_id'>, seg="'b.common_id'"]
INFO       [PD:3  MD:18]	..................Expression_A_Grammar            	Seque.match OUT     	++  	[match=<MatchResult 3/3: '= b.common_id'>, seg="'= b.common_id'"]
INFO       [PD:3  MD:17]	.................Expression_A_Grammar             	OneOf.match OUT     	++  	[match=<MatchResult 3/3: '= b.common_id'>, seg="'= b.common_id'"]
INFO       [PD:3  MD:16]	................Expression_A_Grammar              	AnyNu.match OUT     	++  	[match=<MatchResult 3/3: '= b.common_id'>, seg="'= b.common_id'"]
INFO       [PD:3  MD:15]	...............Expression_A_Grammar               	Seque.match OUT     	++  	[match=<MatchResult 5/5: 'tbl.common_id = b.common_id'>, seg="'tbl.common_id = b.co...'"]
DEBUG      [PD:3  MD:15]	...............ExpressionSegment                  	Ref.match OUT       	++  	[match=<MatchResult 5/5: 'tbl.common_id = b.common_id'>, seg="'tbl.common_id = b.co...'"]
DEBUG      [PD:3  MD:14]	..............ExpressionSegment                   	Expre.match OUT     	++  	[match=<MatchResult 1/1: 'tbl.common_id = b.common_id'>, seg="'tbl.common_id = b.co...'"]
DEBUG      [PD:3  MD:14]	..............JoinOnConditionSegment              	Ref.match OUT       	++  	[match=<MatchResult 1/1: 'tbl.common_id = b.common_id'>, seg="'tbl.common_id = b.co...'"]
INFO       [PD:3  MD:13]	.............JoinOnConditionSegment               	Brack.match OUT     	++  	[match=<MatchResult 1/1: 'tbl.common_id = b.common_id'>, seg="'tbl.common_id = b.co...'"]
INFO       [PD:3  MD:12]	............JoinOnConditionSegment                	Brack.match OUT     	+   	[match=<MatchResult 1/19: '(tbl.common_id = b.common_id)'>, seg="'(tbl.common_id = b.c...'"]
INFO       [PD:3  MD:14]	..............Expression_A_Grammar                	OneOf.match PRN     	    	[ns=1, ps=1, ms=0, pruned=[<Sequence: [<OneOf: [<Ref: PositiveSegment>, <Ref: N..., <Ref: Expression_C_Grammar>]>], opts=[<Ref: Expression_C_Grammar>]]
INFO       [PD:3  MD:15]	...............Expression_C_Grammar               	OneOf.match PRN     	    	[ns=1, ps=2, ms=0, pruned=[<Sequence: [<Ref: ExistsKeywordSegment>, <Bracketed: [<Ref: SelectStatementSegmen...]>, <Ref: CaseExpressionSegment>], opts=[<Ref: Expression_D_Grammar>]]
INFO       [PD:3  MD:17]	.................Expression_D_Grammar             	OneOf.match PRN     	    	[ns=6, ps=2, ms=1, pruned=[<Ref: SelectStatementSegment>, <Ref: IntervalExpressionSegment>], opts=[<Ref: BareFunctionSegment>, <Ref: FunctionSegment>, <Bracketed: [<OneOf: [<Ref: ExpressionSegment>, <Ref:...]>, <Ref: LiteralGrammar>, <Ref: ColumnReferenceSegment>, <Sequence: [<Ref: SimpleArrayTypeGrammar [opt]>, <Ref: ArrayLiteralSegment>]>, <Sequence: [<Ref: DatatypeSegment>, <OneOf: [<Ref: QuotedLiteralSegment>, <R...]>]]
DEBUG      [PD:3  MD:18]	..................Expression_D_Grammar            	Ref.match OUT       	    	[match=<MatchResult 0/19: ''>, seg="'(tbl.common_id = b.c...'"]
INFO       [PD:3  MD:19]	...................FunctionSegment                	OneOf.match PRN     	    	[ns=1, ps=1, ms=0, pruned=[<Sequence: [<Sequence: [<Ref: DateAddFunctionNameSeg...]>], opts=[<Sequence: [<Sequence: [<AnyNumberOf: [<Ref: Functio..., <Ref: PostFunctionGrammar [opt]>]>]]
DEBUG      [PD:3  MD:25]	.........................DateAddFunctionNameSegment	Ref.match OUT       	    	[match=<MatchResult 0/19: ''>, seg="'(tbl.common_id = b.c...'"]
INFO       [PD:3  MD:24]	........................DateAddFunctionNameSegment	Seque.match OUT     	    	[match=<MatchResult 0/19: ''>, seg="'(tbl.common_id = b.c...'"]
DEBUG      [PD:3  MD:23]	.......................DateAddFunctionNameSegment 	DateA.match OUT     	    	[match=<MatchResult 0/19: ''>, seg="'(tbl.common_id = b.c...'"]
DEBUG      [PD:3  MD:23]	.......................FunctionSegment            	Ref.match OUT       	    	[match=<MatchResult 0/19: ''>, seg="'(tbl.common_id = b.c...'"]
INFO       [PD:3  MD:22]	......................FunctionSegment             	AnyNu.match PRN     	    	[ns=1, ps=0, ms=0, pruned=[], opts=[<Ref: FunctionNameSegment>]]
INFO       [PD:3  MD:25]	.........................FunctionNameSegment      	AnyNu.match PRN     	    	[ns=1, ps=0, ms=0, pruned=[], opts=[<Sequence: [<Ref: SingleIdentifierGrammar>, <Ref: DotSegment>]>]]
INFO       [PD:3  MD:27]	...........................SingleIdentifierGrammar	OneOf.match PRN     	    	[ns=2, ps=0, ms=0, pruned=[], opts=[<Ref: NakedIdentifierSegment>, <Ref: QuotedIdentifierSegment>]]
DEBUG      [PD:3  MD:28]	............................SingleIdentifierGrammar	Ref.match OUT       	    	[match=<MatchResult 0/19: ''>, seg="'(tbl.common_id = b.c...'"]
DEBUG      [PD:3  MD:28]	............................SingleIdentifierGrammar	Ref.match OUT       	    	[match=<MatchResult 0/19: ''>, seg="'(tbl.common_id = b.c...'"]
INFO       [PD:3  MD:27]	...........................SingleIdentifierGrammar	OneOf.match OUT     	    	[match=<MatchResult 0/19: ''>, seg="'(tbl.common_id = b.c...'"]
DEBUG      [PD:3  MD:27]	...........................FunctionNameSegment    	Ref.match OUT       	    	[match=<MatchResult 0/19: ''>, seg="'(tbl.common_id = b.c...'"]
INFO       [PD:3  MD:26]	..........................FunctionNameSegment     	Seque.match OUT     	    	[match=<MatchResult 0/19: ''>, seg="'(tbl.common_id = b.c...'"]
INFO       [PD:3  MD:25]	.........................FunctionNameSegment      	AnyNu.match OUT     	    	[match=<MatchResult 0/19: ''>, seg="'(tbl.common_id = b.c...'"]
INFO       [PD:3  MD:25]	.........................FunctionNameSegment      	OneOf.match PRN     	    	[ns=2, ps=0, ms=0, pruned=[], opts=[<Ref: FunctionNameIdentifierSegment>, <Ref: QuotedIdentifierSegment>]]
DEBUG      [PD:3  MD:26]	..........................FunctionNameSegment     	Ref.match OUT       	    	[match=<MatchResult 0/19: ''>, seg="'(tbl.common_id = b.c...'"]
DEBUG      [PD:3  MD:26]	..........................FunctionNameSegment     	Ref.match OUT       	    	[match=<MatchResult 0/19: ''>, seg="'(tbl.common_id = b.c...'"]
INFO       [PD:3  MD:25]	.........................FunctionNameSegment      	OneOf.match OUT     	    	[match=<MatchResult 0/19: ''>, seg="'(tbl.common_id = b.c...'"]
INFO       [PD:3  MD:24]	........................FunctionNameSegment       	Seque.match OUT     	    	[match=<MatchResult 0/19: ''>, seg="'(tbl.common_id = b.c...'"]
DEBUG      [PD:3  MD:23]	.......................FunctionNameSegment        	Funct.match OUT     	    	[match=<MatchResult 0/19: ''>, seg="'(tbl.common_id = b.c...'"]
DEBUG      [PD:3  MD:23]	.......................FunctionSegment            	Ref.match OUT       	    	[match=<MatchResult 0/19: ''>, seg="'(tbl.common_id = b.c...'"]
INFO       [PD:3  MD:22]	......................FunctionSegment             	AnyNu.match OUT     	    	[match=<MatchResult 0/19: ''>, seg="'(tbl.common_id = b.c...'"]
INFO       [PD:3  MD:21]	.....................FunctionSegment              	Seque.match OUT     	    	[match=<MatchResult 0/19: ''>, seg="'(tbl.common_id = b.c...'"]
INFO       [PD:3  MD:20]	....................FunctionSegment               	Seque.match OUT     	    	[match=<MatchResult 0/19: ''>, seg="'(tbl.common_id = b.c...'"]
INFO       [PD:3  MD:19]	...................FunctionSegment                	OneOf.match OUT     	    	[match=<MatchResult 0/19: ''>, seg="'(tbl.common_id = b.c...'"]
DEBUG      [PD:3  MD:18]	..................FunctionSegment                 	Funct.match OUT     	    	[match=<MatchResult 0/19: ''>, seg="'(tbl.common_id = b.c...'"]
DEBUG      [PD:3  MD:18]	..................Expression_D_Grammar            	Ref.match OUT       	    	[match=<MatchResult 0/19: ''>, seg="'(tbl.common_id = b.c...'"]
INFO       [PD:3  MD:20]	....................Expression_D_Grammar          	OneOf.match OUT     	++  	[match=<MatchResult 1/1: 'tbl.common_id = b.common_id'>, seg="'tbl.common_id = b.co...'"]
INFO       [PD:3  MD:19]	...................Expression_D_Grammar           	Brack.match OUT     	++  	[match=<MatchResult 1/1: 'tbl.common_id = b.common_id'>, seg="'tbl.common_id = b.co...'"]
INFO       [PD:3  MD:18]	..................Expression_D_Grammar            	Brack.match OUT     	+   	[match=<MatchResult 1/19: '(tbl.common_id = b.common_id)'>, seg="'(tbl.common_id = b.c...'"]
INFO       [PD:3  MD:18]	..................LiteralGrammar                  	OneOf.match PRN     	    	[ns=2, ps=4, ms=0, pruned=[<Ref: BooleanLiteralGrammar>, <Ref: QualifiedNumericLiteralSegment>, <Ref: NullLiteralSegment>, <Ref: DateTimeLiteralGrammar>], opts=[<Ref: QuotedLiteralSegment>, <Ref: NumericLiteralSegment>]]
DEBUG      [PD:3  MD:19]	...................LiteralGrammar                 	Ref.match OUT       	    	[match=<MatchResult 0/19: ''>, seg="'(tbl.common_id = b.c...'"]
DEBUG      [PD:3  MD:19]	...................LiteralGrammar                 	Ref.match OUT       	    	[match=<MatchResult 0/19: ''>, seg="'(tbl.common_id = b.c...'"]
INFO       [PD:3  MD:18]	..................LiteralGrammar                  	OneOf.match OUT     	    	[match=<MatchResult 0/19: ''>, seg="'(tbl.common_id = b.c...'"]
DEBUG      [PD:3  MD:18]	..................Expression_D_Grammar            	Ref.match OUT       	    	[match=<MatchResult 0/19: ''>, seg="'(tbl.common_id = b.c...'"]
DEBUG      [PD:3  MD:20]	....................ColumnReferenceSegment        	Delim._look_ahead_match IN	    	[ls=19, seg='(tbl.common_id = b.c...']
DEBUG      [PD:3  MD:20]	....................ColumnReferenceSegment        	Delim._look_ahead_match SI	    	[mq=[], sb=['(TBL.COMMON_ID', '', 'JOIN', '', 'C', '', 'ON', '', '(TBL.ID', '', 'LEFT', '', 'JOIN', '', 'D', '', 'ON', '', '(TBL.ID']]
INFO       [PD:3  MD:20]	....................ColumnReferenceSegment        	OneOf.match PRN     	    	[ns=1, ps=8, ms=2, pruned=[<Ref: OnKeywordSegment>, <Ref: AsKeywordSegment>, <Ref: UsingKeywordSegment>, <Ref: CommaSegment>, <Ref: CastOperatorSegment>, <Ref: StartSquareBracketSegment>, <Ref: ColonSegment>, <Ref: DelimiterSegment>], opts=[<Ref: StartBracketSegment>, <Ref: BinaryOperatorGrammar>, <class 'sqlfluff.core.parser.segments.base.BracketedSegment'>]]
DEBUG      [PD:3  MD:21]	.....................ColumnReferenceSegment       	Ref.match OUT       	    	[match=<MatchResult 0/19: ''>, seg="'(tbl.common_id = b.c...'"]
INFO       [PD:3  MD:21]	.....................BinaryOperatorGrammar        	OneOf.match PRN     	    	[ns=1, ps=3, ms=0, pruned=[<Ref: ArithmeticBinaryOperatorGrammar>, <Ref: StringBinaryOperatorGrammar>, <Ref: BooleanBinaryOperatorGrammar>], opts=[<Ref: ComparisonOperatorGrammar>]]
INFO       [PD:3  MD:22]	......................ComparisonOperatorGrammar   	OneOf.match PRN     	    	[ns=1, ps=7, ms=0, pruned=[<Ref: EqualsSegment>, <Ref: GreaterThanSegment>, <Ref: LessThanSegment>, <Ref: GreaterThanOrEqualToSegment>, <Ref: LessThanOrEqualToSegment>, <Ref: NotEqualToSegment_a>, <Ref: NotEqualToSegment_b>], opts=[<Ref: LikeOperatorSegment>]]
DEBUG      [PD:3  MD:23]	.......................ComparisonOperatorGrammar  	Ref.match OUT       	    	[match=<MatchResult 0/19: ''>, seg="'(tbl.common_id = b.c...'"]
INFO       [PD:3  MD:22]	......................ComparisonOperatorGrammar   	OneOf.match OUT     	    	[match=<MatchResult 0/19: ''>, seg="'(tbl.common_id = b.c...'"]
DEBUG      [PD:3  MD:22]	......................BinaryOperatorGrammar       	Ref.match OUT       	    	[match=<MatchResult 0/19: ''>, seg="'(tbl.common_id = b.c...'"]
INFO       [PD:3  MD:21]	.....................BinaryOperatorGrammar        	OneOf.match OUT     	    	[match=<MatchResult 0/19: ''>, seg="'(tbl.common_id = b.c...'"]
DEBUG      [PD:3  MD:21]	.....................ColumnReferenceSegment       	Ref.match OUT       	    	[match=<MatchResult 0/19: ''>, seg="'(tbl.common_id = b.c...'"]
INFO       [PD:3  MD:20]	....................ColumnReferenceSegment        	OneOf.match OUT     	+   	[match=<MatchResult 1/19: '(tbl.common_id = b.common_id)'>, seg="'(tbl.common_id = b.c...'"]
DEBUG      [PD:3  MD:20]	....................ColumnReferenceSegment        	NonCo.match OUT     	    	[match=<MatchResult 0/19: ''>, seg="'(tbl.common_id = b.c...'"]
INFO       [PD:3  MD:19]	...................ColumnReferenceSegment         	Delim.match OUT     	    	[match=<MatchResult 0/19: ''>, seg="'(tbl.common_id = b.c...'"]
DEBUG      [PD:3  MD:18]	..................ColumnReferenceSegment          	Colum.match OUT     	    	[match=<MatchResult 0/19: ''>, seg="'(tbl.common_id = b.c...'"]
DEBUG      [PD:3  MD:18]	..................Expression_D_Grammar            	Ref.match OUT       	    	[match=<MatchResult 0/19: ''>, seg="'(tbl.common_id = b.c...'"]
DEBUG      [PD:3  MD:19]	...................Expression_D_Grammar           	Ref.match OUT       	    	[match=<MatchResult 0/19: ''>, seg="'(tbl.common_id = b.c...'"]
DEBUG      [PD:3  MD:23]	.......................ArrayLiteralSegment        	Delim._look_ahead_match IN	    	[ls=1, seg='tbl.common_id = b.co...']
DEBUG      [PD:3  MD:23]	.......................ArrayLiteralSegment        	Delim._look_ahead_match SI	    	[mq=[], sb=['TBL.COMMON_ID']]
DEBUG      [PD:3  MD:23]	.......................ArrayLiteralSegment        	Delim._look_ahead_match SC	    	[bsm=None]
INFO       [PD:3  MD:25]	.........................Expression_A_Grammar     	OneOf.match PRN     	    	[ns=1, ps=1, ms=0, pruned=[<Sequence: [<OneOf: [<Ref: PositiveSegment>, <Ref: N..., <Ref: Expression_C_Grammar>]>], opts=[<Ref: Expression_C_Grammar>]]
INFO       [PD:3  MD:26]	..........................Expression_C_Grammar    	OneOf.match PRN     	    	[ns=1, ps=2, ms=0, pruned=[<Sequence: [<Ref: ExistsKeywordSegment>, <Bracketed: [<Ref: SelectStatementSegmen...]>, <Ref: CaseExpressionSegment>], opts=[<Ref: Expression_D_Grammar>]]
INFO       [PD:3  MD:28]	............................Expression_D_Grammar  	OneOf.match PRN     	    	[ns=6, ps=3, ms=0, pruned=[<Bracketed: [<OneOf: [<Ref: ExpressionSegment>, <Ref:...]>, <Ref: SelectStatementSegment>, <Ref: IntervalExpressionSegment>], opts=[<Ref: BareFunctionSegment>, <Ref: FunctionSegment>, <Ref: LiteralGrammar>, <Ref: ColumnReferenceSegment>, <Sequence: [<Ref: SimpleArrayTypeGrammar [opt]>, <Ref: ArrayLiteralSegment>]>, <Sequence: [<Ref: DatatypeSegment>, <OneOf: [<Ref: QuotedLiteralSegment>, <R...]>]]
DEBUG      [PD:3  MD:29]	.............................Expression_D_Grammar 	Ref.match OUT       	    	[match=<MatchResult 0/1: ''>, seg="'tbl.common_id = b.co...'"]
INFO       [PD:3  MD:30]	..............................FunctionSegment     	OneOf.match PRN     	    	[ns=1, ps=1, ms=0, pruned=[<Sequence: [<Sequence: [<Ref: DateAddFunctionNameSeg...]>], opts=[<Sequence: [<Sequence: [<AnyNumberOf: [<Ref: Functio..., <Ref: PostFunctionGrammar [opt]>]>]]
DEBUG      [PD:3  MD:36]	....................................DateAddFunctionNameSegment	Ref.match OUT       	    	[match=<MatchResult 0/1: ''>, seg="'tbl.common_id = b.co...'"]
INFO       [PD:3  MD:35]	...................................DateAddFunctionNameSegment	Seque.match OUT     	    	[match=<MatchResult 0/1: ''>, seg="'tbl.common_id = b.co...'"]
DEBUG      [PD:3  MD:34]	..................................DateAddFunctionNameSegment	DateA.match OUT     	    	[match=<MatchResult 0/1: ''>, seg="'tbl.common_id = b.co...'"]
DEBUG      [PD:3  MD:34]	..................................FunctionSegment 	Ref.match OUT       	    	[match=<MatchResult 0/1: ''>, seg="'tbl.common_id = b.co...'"]
INFO       [PD:3  MD:33]	.................................FunctionSegment  	AnyNu.match PRN     	    	[ns=1, ps=0, ms=0, pruned=[], opts=[<Ref: FunctionNameSegment>]]
INFO       [PD:3  MD:36]	....................................FunctionNameSegment	AnyNu.match PRN     	    	[ns=1, ps=0, ms=0, pruned=[], opts=[<Sequence: [<Ref: SingleIdentifierGrammar>, <Ref: DotSegment>]>]]
INFO       [PD:3  MD:38]	......................................SingleIdentifierGrammar	OneOf.match PRN     	    	[ns=2, ps=0, ms=0, pruned=[], opts=[<Ref: NakedIdentifierSegment>, <Ref: QuotedIdentifierSegment>]]
DEBUG      [PD:3  MD:39]	.......................................SingleIdentifierGrammar	Ref.match OUT       	    	[match=<MatchResult 0/1: ''>, seg="'tbl.common_id = b.co...'"]
DEBUG      [PD:3  MD:39]	.......................................SingleIdentifierGrammar	Ref.match OUT       	    	[match=<MatchResult 0/1: ''>, seg="'tbl.common_id = b.co...'"]
INFO       [PD:3  MD:38]	......................................SingleIdentifierGrammar	OneOf.match OUT     	    	[match=<MatchResult 0/1: ''>, seg="'tbl.common_id = b.co...'"]
DEBUG      [PD:3  MD:38]	......................................FunctionNameSegment	Ref.match OUT       	    	[match=<MatchResult 0/1: ''>, seg="'tbl.common_id = b.co...'"]
INFO       [PD:3  MD:37]	.....................................FunctionNameSegment	Seque.match OUT     	    	[match=<MatchResult 0/1: ''>, seg="'tbl.common_id = b.co...'"]
INFO       [PD:3  MD:36]	....................................FunctionNameSegment	AnyNu.match OUT     	    	[match=<MatchResult 0/1: ''>, seg="'tbl.common_id = b.co...'"]
INFO       [PD:3  MD:36]	....................................FunctionNameSegment	OneOf.match PRN     	    	[ns=2, ps=0, ms=0, pruned=[], opts=[<Ref: FunctionNameIdentifierSegment>, <Ref: QuotedIdentifierSegment>]]
DEBUG      [PD:3  MD:37]	.....................................FunctionNameSegment	Ref.match OUT       	    	[match=<MatchResult 0/1: ''>, seg="'tbl.common_id = b.co...'"]
DEBUG      [PD:3  MD:37]	.....................................FunctionNameSegment	Ref.match OUT       	    	[match=<MatchResult 0/1: ''>, seg="'tbl.common_id = b.co...'"]
INFO       [PD:3  MD:36]	....................................FunctionNameSegment	OneOf.match OUT     	    	[match=<MatchResult 0/1: ''>, seg="'tbl.common_id = b.co...'"]
INFO       [PD:3  MD:35]	...................................FunctionNameSegment	Seque.match OUT     	    	[match=<MatchResult 0/1: ''>, seg="'tbl.common_id = b.co...'"]
DEBUG      [PD:3  MD:34]	..................................FunctionNameSegment	Funct.match OUT     	    	[match=<MatchResult 0/1: ''>, seg="'tbl.common_id = b.co...'"]
DEBUG      [PD:3  MD:34]	..................................FunctionSegment 	Ref.match OUT       	    	[match=<MatchResult 0/1: ''>, seg="'tbl.common_id = b.co...'"]
INFO       [PD:3  MD:33]	.................................FunctionSegment  	AnyNu.match OUT     	    	[match=<MatchResult 0/1: ''>, seg="'tbl.common_id = b.co...'"]
INFO       [PD:3  MD:32]	................................FunctionSegment   	Seque.match OUT     	    	[match=<MatchResult 0/1: ''>, seg="'tbl.common_id = b.co...'"]
INFO       [PD:3  MD:31]	...............................FunctionSegment    	Seque.match OUT     	    	[match=<MatchResult 0/1: ''>, seg="'tbl.common_id = b.co...'"]
INFO       [PD:3  MD:30]	..............................FunctionSegment     	OneOf.match OUT     	    	[match=<MatchResult 0/1: ''>, seg="'tbl.common_id = b.co...'"]
DEBUG      [PD:3  MD:29]	.............................FunctionSegment      	Funct.match OUT     	    	[match=<MatchResult 0/1: ''>, seg="'tbl.common_id = b.co...'"]
DEBUG      [PD:3  MD:29]	.............................Expression_D_Grammar 	Ref.match OUT       	    	[match=<MatchResult 0/1: ''>, seg="'tbl.common_id = b.co...'"]
INFO       [PD:3  MD:29]	.............................LiteralGrammar       	OneOf.match PRN     	    	[ns=2, ps=4, ms=0, pruned=[<Ref: BooleanLiteralGrammar>, <Ref: QualifiedNumericLiteralSegment>, <Ref: NullLiteralSegment>, <Ref: DateTimeLiteralGrammar>], opts=[<Ref: QuotedLiteralSegment>, <Ref: NumericLiteralSegment>]]
DEBUG      [PD:3  MD:30]	..............................LiteralGrammar      	Ref.match OUT       	    	[match=<MatchResult 0/1: ''>, seg="'tbl.common_id = b.co...'"]
DEBUG      [PD:3  MD:30]	..............................LiteralGrammar      	Ref.match OUT       	    	[match=<MatchResult 0/1: ''>, seg="'tbl.common_id = b.co...'"]
INFO       [PD:3  MD:29]	.............................LiteralGrammar       	OneOf.match OUT     	    	[match=<MatchResult 0/1: ''>, seg="'tbl.common_id = b.co...'"]
DEBUG      [PD:3  MD:29]	.............................Expression_D_Grammar 	Ref.match OUT       	    	[match=<MatchResult 0/1: ''>, seg="'tbl.common_id = b.co...'"]
DEBUG      [PD:3  MD:31]	...............................ColumnReferenceSegment	Delim._look_ahead_match IN	    	[ls=1, seg='tbl.common_id = b.co...']
DEBUG      [PD:3  MD:31]	...............................ColumnReferenceSegment	Delim._look_ahead_match SI	    	[mq=[], sb=['TBL.COMMON_ID']]
INFO       [PD:3  MD:31]	...............................ColumnReferenceSegment	OneOf.match PRN     	    	[ns=1, ps=10, ms=0, pruned=[<Ref: OnKeywordSegment>, <Ref: AsKeywordSegment>, <Ref: UsingKeywordSegment>, <Ref: CommaSegment>, <Ref: CastOperatorSegment>, <Ref: StartSquareBracketSegment>, <Ref: StartBracketSegment>, <Ref: ColonSegment>, <Ref: DelimiterSegment>, <class 'sqlfluff.core.parser.segments.base.BracketedSegment'>], opts=[<Ref: BinaryOperatorGrammar>]]
INFO       [PD:3  MD:32]	................................BinaryOperatorGrammar	OneOf.match PRN     	    	[ns=1, ps=3, ms=0, pruned=[<Ref: ArithmeticBinaryOperatorGrammar>, <Ref: StringBinaryOperatorGrammar>, <Ref: BooleanBinaryOperatorGrammar>], opts=[<Ref: ComparisonOperatorGrammar>]]
INFO       [PD:3  MD:33]	.................................ComparisonOperatorGrammar	OneOf.match PRN     	    	[ns=1, ps=7, ms=0, pruned=[<Ref: EqualsSegment>, <Ref: GreaterThanSegment>, <Ref: LessThanSegment>, <Ref: GreaterThanOrEqualToSegment>, <Ref: LessThanOrEqualToSegment>, <Ref: NotEqualToSegment_a>, <Ref: NotEqualToSegment_b>], opts=[<Ref: LikeOperatorSegment>]]
DEBUG      [PD:3  MD:34]	..................................ComparisonOperatorGrammar	Ref.match OUT       	    	[match=<MatchResult 0/1: ''>, seg="'tbl.common_id = b.co...'"]
INFO       [PD:3  MD:33]	.................................ComparisonOperatorGrammar	OneOf.match OUT     	    	[match=<MatchResult 0/1: ''>, seg="'tbl.common_id = b.co...'"]
DEBUG      [PD:3  MD:33]	.................................BinaryOperatorGrammar	Ref.match OUT       	    	[match=<MatchResult 0/1: ''>, seg="'tbl.common_id = b.co...'"]
INFO       [PD:3  MD:32]	................................BinaryOperatorGrammar	OneOf.match OUT     	    	[match=<MatchResult 0/1: ''>, seg="'tbl.common_id = b.co...'"]
DEBUG      [PD:3  MD:32]	................................ColumnReferenceSegment	Ref.match OUT       	    	[match=<MatchResult 0/1: ''>, seg="'tbl.common_id = b.co...'"]
INFO       [PD:3  MD:31]	...............................ColumnReferenceSegment	OneOf.match OUT     	    	[match=<MatchResult 0/1: ''>, seg="'tbl.common_id = b.co...'"]
DEBUG      [PD:3  MD:31]	...............................ColumnReferenceSegment	NonCo.match OUT     	    	[match=<MatchResult 0/1: ''>, seg="'tbl.common_id = b.co...'"]
INFO       [PD:3  MD:31]	...............................SingleIdentifierGrammar	OneOf.match PRN     	    	[ns=2, ps=0, ms=0, pruned=[], opts=[<Ref: NakedIdentifierSegment>, <Ref: QuotedIdentifierSegment>]]
DEBUG      [PD:3  MD:32]	................................SingleIdentifierGrammar	Ref.match OUT       	    	[match=<MatchResult 0/1: ''>, seg="'tbl.common_id = b.co...'"]
DEBUG      [PD:3  MD:32]	................................SingleIdentifierGrammar	Ref.match OUT       	    	[match=<MatchResult 0/1: ''>, seg="'tbl.common_id = b.co...'"]
INFO       [PD:3  MD:31]	...............................SingleIdentifierGrammar	OneOf.match OUT     	    	[match=<MatchResult 0/1: ''>, seg="'tbl.common_id = b.co...'"]
DEBUG      [PD:3  MD:31]	...............................ColumnReferenceSegment	Ref.match OUT       	    	[match=<MatchResult 0/1: ''>, seg="'tbl.common_id = b.co...'"]
INFO       [PD:3  MD:30]	..............................ColumnReferenceSegment	Delim.match OUT     	    	[match=<MatchResult 0/1: ''>, seg="'tbl.common_id = b.co...'"]
DEBUG      [PD:3  MD:29]	.............................ColumnReferenceSegment	Colum.match OUT     	    	[match=<MatchResult 0/1: ''>, seg="'tbl.common_id = b.co...'"]
DEBUG      [PD:3  MD:29]	.............................Expression_D_Grammar 	Ref.match OUT       	    	[match=<MatchResult 0/1: ''>, seg="'tbl.common_id = b.co...'"]
DEBUG      [PD:3  MD:30]	..............................Expression_D_Grammar	Ref.match OUT       	    	[match=<MatchResult 0/1: ''>, seg="'tbl.common_id = b.co...'"]
INFO       [PD:3  MD:31]	...............................ArrayLiteralSegment	Brack.match OUT     	    	[match=<MatchResult 0/1: ''>, seg="'tbl.common_id = b.co...'"]
DEBUG      [PD:3  MD:30]	..............................ArrayLiteralSegment 	Array.match OUT     	    	[match=<MatchResult 0/1: ''>, seg="'tbl.common_id = b.co...'"]
DEBUG      [PD:3  MD:30]	..............................Expression_D_Grammar	Ref.match OUT       	    	[match=<MatchResult 0/1: ''>, seg="'tbl.common_id = b.co...'"]
INFO       [PD:3  MD:29]	.............................Expression_D_Grammar 	Seque.match OUT     	    	[match=<MatchResult 0/1: ''>, seg="'tbl.common_id = b.co...'"]
INFO       [PD:3  MD:31]	...............................DatatypeSegment    	OneOf.match PRN     	    	[ns=1, ps=2, ms=0, pruned=[<Sequence: [<OneOf: [<Ref: TimeKeywordSegment>, <Ref..., <Bracketed: [<Ref: NumericLiteralSegment..., <Sequence:...]>, <Sequence: [<Ref: DoubleKeywordSegment>, <Ref: PrecisionKeywordSegment>]>], opts=[<Sequence: [<OneOf: [<Sequence: [<OneOf: [<Ref: Char..., <Bracketed: [<OneOf: [<Delimited: [<Ref:..., <Ref: Char...]>]]
INFO       [PD:3  MD:33]	.................................DatatypeSegment  	OneOf.match PRN     	    	[ns=1, ps=1, ms=0, pruned=[<Sequence: [<OneOf: [<Ref: CharacterKeywordSegment>,..., <OneOf: [<Ref: VaryingKeywordSegment>, <...]>], opts=[<Sequence: [<Sequence: [<Ref: SingleIdentifierGramma..., <Ref: DatatypeIdentifierSegment>]>]]
INFO       [PD:3  MD:36]	....................................SingleIdentifierGrammar	OneOf.match PRN     	    	[ns=2, ps=0, ms=0, pruned=[], opts=[<Ref: NakedIdentifierSegment>, <Ref: QuotedIdentifierSegment>]]
DEBUG      [PD:3  MD:37]	.....................................SingleIdentifierGrammar	Ref.match OUT       	    	[match=<MatchResult 0/1: ''>, seg="'tbl.common_id = b.co...'"]
DEBUG      [PD:3  MD:37]	.....................................SingleIdentifierGrammar	Ref.match OUT       	    	[match=<MatchResult 0/1: ''>, seg="'tbl.common_id = b.co...'"]
INFO       [PD:3  MD:36]	....................................SingleIdentifierGrammar	OneOf.match OUT     	    	[match=<MatchResult 0/1: ''>, seg="'tbl.common_id = b.co...'"]
DEBUG      [PD:3  MD:36]	....................................DatatypeSegment	Ref.match OUT       	    	[match=<MatchResult 0/1: ''>, seg="'tbl.common_id = b.co...'"]
INFO       [PD:3  MD:35]	...................................DatatypeSegment	Seque.match OUT     	    	[match=<MatchResult 0/1: ''>, seg="'tbl.common_id = b.co...'"]
DEBUG      [PD:3  MD:35]	...................................DatatypeSegment	Ref.match OUT       	    	[match=<MatchResult 0/1: ''>, seg="'tbl.common_id = b.co...'"]
INFO       [PD:3  MD:34]	..................................DatatypeSegment 	Seque.match OUT     	    	[match=<MatchResult 0/1: ''>, seg="'tbl.common_id = b.co...'"]
INFO       [PD:3  MD:33]	.................................DatatypeSegment  	OneOf.match OUT     	    	[match=<MatchResult 0/1: ''>, seg="'tbl.common_id = b.co...'"]
INFO       [PD:3  MD:32]	................................DatatypeSegment   	Seque.match OUT     	    	[match=<MatchResult 0/1: ''>, seg="'tbl.common_id = b.co...'"]
INFO       [PD:3  MD:31]	...............................DatatypeSegment    	OneOf.match OUT     	    	[match=<MatchResult 0/1: ''>, seg="'tbl.common_id = b.co...'"]
DEBUG      [PD:3  MD:30]	..............................DatatypeSegment     	Datat.match OUT     	    	[match=<MatchResult 0/1: ''>, seg="'tbl.common_id = b.co...'"]
DEBUG      [PD:3  MD:30]	..............................Expression_D_Grammar	Ref.match OUT       	    	[match=<MatchResult 0/1: ''>, seg="'tbl.common_id = b.co...'"]
INFO       [PD:3  MD:29]	.............................Expression_D_Grammar 	Seque.match OUT     	    	[match=<MatchResult 0/1: ''>, seg="'tbl.common_id = b.co...'"]
INFO       [PD:3  MD:28]	............................Expression_D_Grammar  	OneOf.match OUT     	    	[match=<MatchResult 0/1: ''>, seg="'tbl.common_id = b.co...'"]
INFO       [PD:3  MD:27]	...........................Expression_D_Grammar   	Seque.match OUT     	    	[match=<MatchResult 0/1: ''>, seg="'tbl.common_id = b.co...'"]
DEBUG      [PD:3  MD:27]	...........................Expression_C_Grammar   	Ref.match OUT       	    	[match=<MatchResult 0/1: ''>, seg="'tbl.common_id = b.co...'"]
INFO       [PD:3  MD:26]	..........................Expression_C_Grammar    	OneOf.match OUT     	    	[match=<MatchResult 0/1: ''>, seg="'tbl.common_id = b.co...'"]
DEBUG      [PD:3  MD:26]	..........................Expression_A_Grammar    	Ref.match OUT       	    	[match=<MatchResult 0/1: ''>, seg="'tbl.common_id = b.co...'"]
INFO       [PD:3  MD:25]	.........................Expression_A_Grammar     	OneOf.match OUT     	    	[match=<MatchResult 0/1: ''>, seg="'tbl.common_id = b.co...'"]
INFO       [PD:3  MD:24]	........................Expression_A_Grammar      	Seque.match OUT     	    	[match=<MatchResult 0/1: ''>, seg="'tbl.common_id = b.co...'"]
DEBUG      [PD:3  MD:24]	........................ExpressionSegment         	Ref.match OUT       	    	[match=<MatchResult 0/1: ''>, seg="'tbl.common_id = b.co...'"]
DEBUG      [PD:3  MD:23]	.......................ExpressionSegment          	Expre.match OUT     	    	[match=<MatchResult 0/1: ''>, seg="'tbl.common_id = b.co...'"]
DEBUG      [PD:3  MD:23]	.......................ArrayLiteralSegment        	Ref.match OUT       	    	[match=<MatchResult 0/1: ''>, seg="'tbl.common_id = b.co...'"]
INFO       [PD:3  MD:22]	......................ArrayLiteralSegment         	Delim.match OUT     	    	[match=<MatchResult 0/1: ''>, seg="'tbl.common_id = b.co...'"]
INFO       [PD:3  MD:21]	.....................ArrayLiteralSegment          	Brack.match OUT     	    	[match=<MatchResult 0/1: ''>, seg="'tbl.common_id = b.co...'"]
INFO       [PD:3  MD:20]	....................ArrayLiteralSegment           	Brack.match OUT     	    	[match=<MatchResult 0/19: ''>, seg="'(tbl.common_id = b.c...'"]
DEBUG      [PD:3  MD:19]	...................ArrayLiteralSegment            	Array.match OUT     	    	[match=<MatchResult 0/19: ''>, seg="'(tbl.common_id = b.c...'"]
DEBUG      [PD:3  MD:19]	...................Expression_D_Grammar           	Ref.match OUT       	    	[match=<MatchResult 0/19: ''>, seg="'(tbl.common_id = b.c...'"]
INFO       [PD:3  MD:18]	..................Expression_D_Grammar            	Seque.match OUT     	    	[match=<MatchResult 0/19: ''>, seg="'(tbl.common_id = b.c...'"]
INFO       [PD:3  MD:20]	....................DatatypeSegment               	OneOf.match PRN     	    	[ns=1, ps=2, ms=0, pruned=[<Sequence: [<OneOf: [<Ref: TimeKeywordSegment>, <Ref..., <Bracketed: [<Ref: NumericLiteralSegment..., <Sequence:...]>, <Sequence: [<Ref: DoubleKeywordSegment>, <Ref: PrecisionKeywordSegment>]>], opts=[<Sequence: [<OneOf: [<Sequence: [<OneOf: [<Ref: Char..., <Bracketed: [<OneOf: [<Delimited: [<Ref:..., <Ref: Char...]>]]
INFO       [PD:3  MD:22]	......................DatatypeSegment             	OneOf.match PRN     	    	[ns=1, ps=1, ms=0, pruned=[<Sequence: [<OneOf: [<Ref: CharacterKeywordSegment>,..., <OneOf: [<Ref: VaryingKeywordSegment>, <...]>], opts=[<Sequence: [<Sequence: [<Ref: SingleIdentifierGramma..., <Ref: DatatypeIdentifierSegment>]>]]
INFO       [PD:3  MD:25]	.........................SingleIdentifierGrammar  	OneOf.match PRN     	    	[ns=2, ps=0, ms=0, pruned=[], opts=[<Ref: NakedIdentifierSegment>, <Ref: QuotedIdentifierSegment>]]
DEBUG      [PD:3  MD:26]	..........................SingleIdentifierGrammar 	Ref.match OUT       	    	[match=<MatchResult 0/19: ''>, seg="'(tbl.common_id = b.c...'"]
DEBUG      [PD:3  MD:26]	..........................SingleIdentifierGrammar 	Ref.match OUT       	    	[match=<MatchResult 0/19: ''>, seg="'(tbl.common_id = b.c...'"]
INFO       [PD:3  MD:25]	.........................SingleIdentifierGrammar  	OneOf.match OUT     	    	[match=<MatchResult 0/19: ''>, seg="'(tbl.common_id = b.c...'"]
DEBUG      [PD:3  MD:25]	.........................DatatypeSegment          	Ref.match OUT       	    	[match=<MatchResult 0/19: ''>, seg="'(tbl.common_id = b.c...'"]
INFO       [PD:3  MD:24]	........................DatatypeSegment           	Seque.match OUT     	    	[match=<MatchResult 0/19: ''>, seg="'(tbl.common_id = b.c...'"]
DEBUG      [PD:3  MD:24]	........................DatatypeSegment           	Ref.match OUT       	    	[match=<MatchResult 0/19: ''>, seg="'(tbl.common_id = b.c...'"]
INFO       [PD:3  MD:23]	.......................DatatypeSegment            	Seque.match OUT     	    	[match=<MatchResult 0/19: ''>, seg="'(tbl.common_id = b.c...'"]
INFO       [PD:3  MD:22]	......................DatatypeSegment             	OneOf.match OUT     	    	[match=<MatchResult 0/19: ''>, seg="'(tbl.common_id = b.c...'"]
INFO       [PD:3  MD:21]	.....................DatatypeSegment              	Seque.match OUT     	    	[match=<MatchResult 0/19: ''>, seg="'(tbl.common_id = b.c...'"]
INFO       [PD:3  MD:20]	....................DatatypeSegment               	OneOf.match OUT     	    	[match=<MatchResult 0/19: ''>, seg="'(tbl.common_id = b.c...'"]
DEBUG      [PD:3  MD:19]	...................DatatypeSegment                	Datat.match OUT     	    	[match=<MatchResult 0/19: ''>, seg="'(tbl.common_id = b.c...'"]
DEBUG      [PD:3  MD:19]	...................Expression_D_Grammar           	Ref.match OUT       	    	[match=<MatchResult 0/19: ''>, seg="'(tbl.common_id = b.c...'"]
INFO       [PD:3  MD:18]	..................Expression_D_Grammar            	Seque.match OUT     	    	[match=<MatchResult 0/19: ''>, seg="'(tbl.common_id = b.c...'"]
INFO       [PD:3  MD:17]	.................Expression_D_Grammar             	OneOf.match OUT     	+   	[match=<MatchResult 1/19: '(tbl.common_id = b.common_id)'>, seg="'(tbl.common_id = b.c...'"]
INFO       [PD:3  MD:17]	.................Accessor_Grammar                 	AnyNu.match PRN     	    	[ns=0, ps=1, ms=0, pruned=[<Ref: ArrayAccessorSegment>], opts='ALL']
INFO       [PD:3  MD:17]	.................Accessor_Grammar                 	AnyNu.match OUT     	    	[match=<MatchResult 0/17: ''>, seg="'JOIN c ON (tbl.id = ...'"]
DEBUG      [PD:3  MD:17]	.................Expression_D_Grammar             	Ref.match OUT       	    	[match=<MatchResult 0/17: ''>, seg="'JOIN c ON (tbl.id = ...'"]
INFO       [PD:3  MD:17]	.................Expression_D_Grammar             	AnyNu.match PRN     	    	[ns=0, ps=1, ms=0, pruned=[<Ref: ShorthandCastSegment>], opts='ALL']
INFO       [PD:3  MD:17]	.................Expression_D_Grammar             	AnyNu.match OUT     	    	[match=<MatchResult 0/17: ''>, seg="'JOIN c ON (tbl.id = ...'"]
INFO       [PD:3  MD:16]	................Expression_D_Grammar              	Seque.match OUT     	+   	[match=<MatchResult 1/19: '(tbl.common_id = b.common_id)'>, seg="'(tbl.common_id = b.c...'"]
DEBUG      [PD:3  MD:16]	................Expression_C_Grammar              	Ref.match OUT       	+   	[match=<MatchResult 1/19: '(tbl.common_id = b.common_id)'>, seg="'(tbl.common_id = b.c...'"]
INFO       [PD:3  MD:15]	...............Expression_C_Grammar               	OneOf.match OUT     	+   	[match=<MatchResult 1/19: '(tbl.common_id = b.common_id)'>, seg="'(tbl.common_id = b.c...'"]
DEBUG      [PD:3  MD:15]	...............Expression_A_Grammar               	Ref.match OUT       	+   	[match=<MatchResult 1/19: '(tbl.common_id = b.common_id)'>, seg="'(tbl.common_id = b.c...'"]
INFO       [PD:3  MD:14]	..............Expression_A_Grammar                	OneOf.match OUT     	+   	[match=<MatchResult 1/19: '(tbl.common_id = b.common_id)'>, seg="'(tbl.common_id = b.c...'"]
INFO       [PD:3  MD:14]	..............Expression_A_Grammar                	AnyNu.match PRN     	    	[ns=1, ps=0, ms=0, pruned=[], opts=[<OneOf: [<Sequence: [<OneOf: [<Sequence: [<Ref: N..., <Sequence: [<Ref: NotKeywordSegment [opt..., <Sequence:...]>]]
INFO       [PD:3  MD:15]	...............Expression_A_Grammar               	OneOf.match PRN     	    	[ns=3, ps=5, ms=0, pruned=[<Sequence: [<Ref: NotKeywordSegment [opt]>, <Ref: InKeywordSegment>, <Bracketed: [<OneOf: [<Delimited: [<Ref:...]>, <Sequence: [<Ref: NotKeywordSegment [opt]>, <Ref: InKeywordSegment>, <Ref: FunctionSegment>]>, <Sequence: [<Ref: IsKeywordSegment>, <Ref: NotKeywordSegment [opt]>, <Ref: IsClauseGrammar>]>, <Sequence: [<Ref: NotKeywordSegment>, <Ref: Expression_C_Grammar>]>, <Sequence: [<Ref: NotKeywordSegment [opt]>, <Ref: BetweenKeywordSegment>, <Ref: Expression_C_Grammar>, <AnyNumbe...]>], opts=[<Sequence: [<OneOf: [<Sequence: [<Ref: NotKeywordSeg..., <Ref: Expression_C_Grammar>, <Sequence: [<Ref: EscapeKe...]>, <Ref: IsNullGrammar>, <Ref: NotNullGrammar>]]
INFO       [PD:3  MD:17]	.................Expression_A_Grammar             	OneOf.match PRN     	    	[ns=1, ps=1, ms=0, pruned=[<Sequence: [<Ref: NotKeywordSegment [opt]>, <Ref: LikeGrammar>]>], opts=[<Sequence: [<Ref: BinaryOperatorGrammar>, <Ref: NotKeywordSegment [opt]>]>]]
INFO       [PD:3  MD:19]	...................BinaryOperatorGrammar          	OneOf.match PRN     	    	[ns=1, ps=3, ms=0, pruned=[<Ref: ArithmeticBinaryOperatorGrammar>, <Ref: StringBinaryOperatorGrammar>, <Ref: BooleanBinaryOperatorGrammar>], opts=[<Ref: ComparisonOperatorGrammar>]]
INFO       [PD:3  MD:20]	....................ComparisonOperatorGrammar     	OneOf.match PRN     	    	[ns=1, ps=7, ms=0, pruned=[<Ref: EqualsSegment>, <Ref: GreaterThanSegment>, <Ref: LessThanSegment>, <Ref: GreaterThanOrEqualToSegment>, <Ref: LessThanOrEqualToSegment>, <Ref: NotEqualToSegment_a>, <Ref: NotEqualToSegment_b>], opts=[<Ref: LikeOperatorSegment>]]
DEBUG      [PD:3  MD:21]	.....................ComparisonOperatorGrammar    	Ref.match OUT       	    	[match=<MatchResult 0/17: ''>, seg="'JOIN c ON (tbl.id = ...'"]
INFO       [PD:3  MD:20]	....................ComparisonOperatorGrammar     	OneOf.match OUT     	    	[match=<MatchResult 0/17: ''>, seg="'JOIN c ON (tbl.id = ...'"]
DEBUG      [PD:3  MD:20]	....................BinaryOperatorGrammar         	Ref.match OUT       	    	[match=<MatchResult 0/17: ''>, seg="'JOIN c ON (tbl.id = ...'"]
INFO       [PD:3  MD:19]	...................BinaryOperatorGrammar          	OneOf.match OUT     	    	[match=<MatchResult 0/17: ''>, seg="'JOIN c ON (tbl.id = ...'"]
DEBUG      [PD:3  MD:19]	...................Expression_A_Grammar           	Ref.match OUT       	    	[match=<MatchResult 0/17: ''>, seg="'JOIN c ON (tbl.id = ...'"]
INFO       [PD:3  MD:18]	..................Expression_A_Grammar            	Seque.match OUT     	    	[match=<MatchResult 0/17: ''>, seg="'JOIN c ON (tbl.id = ...'"]
INFO       [PD:3  MD:17]	.................Expression_A_Grammar             	OneOf.match OUT     	    	[match=<MatchResult 0/17: ''>, seg="'JOIN c ON (tbl.id = ...'"]
INFO       [PD:3  MD:16]	................Expression_A_Grammar              	Seque.match OUT     	    	[match=<MatchResult 0/17: ''>, seg="'JOIN c ON (tbl.id = ...'"]
DEBUG      [PD:3  MD:16]	................Expression_A_Grammar              	Ref.match OUT       	    	[match=<MatchResult 0/17: ''>, seg="'JOIN c ON (tbl.id = ...'"]
DEBUG      [PD:3  MD:16]	................Expression_A_Grammar              	Ref.match OUT       	    	[match=<MatchResult 0/17: ''>, seg="'JOIN c ON (tbl.id = ...'"]
INFO       [PD:3  MD:15]	...............Expression_A_Grammar               	OneOf.match OUT     	    	[match=<MatchResult 0/17: ''>, seg="'JOIN c ON (tbl.id = ...'"]
INFO       [PD:3  MD:14]	..............Expression_A_Grammar                	AnyNu.match OUT     	    	[match=<MatchResult 0/17: ''>, seg="'JOIN c ON (tbl.id = ...'"]
INFO       [PD:3  MD:13]	.............Expression_A_Grammar                 	Seque.match OUT     	+   	[match=<MatchResult 1/19: '(tbl.common_id = b.common_id)'>, seg="'(tbl.common_id = b.c...'"]
DEBUG      [PD:3  MD:13]	.............ExpressionSegment                    	Ref.match OUT       	+   	[match=<MatchResult 1/19: '(tbl.common_id = b.common_id)'>, seg="'(tbl.common_id = b.c...'"]
DEBUG      [PD:3  MD:12]	............ExpressionSegment                     	Expre.match OUT     	+   	[match=<MatchResult 1/19: '(tbl.common_id = b.common_id)'>, seg="'(tbl.common_id = b.c...'"]
DEBUG      [PD:3  MD:12]	............JoinOnConditionSegment                	Ref.match OUT       	+   	[match=<MatchResult 1/19: '(tbl.common_id = b.common_id)'>, seg="'(tbl.common_id = b.c...'"]
INFO       [PD:3  MD:11]	...........JoinOnConditionSegment                 	Optio.match OUT     	+   	[match=<MatchResult 1/19: '(tbl.common_id = b.common_id)'>, seg="'(tbl.common_id = b.c...'"]
INFO       [PD:3  MD:10]	..........JoinOnConditionSegment                  	Seque.match OUT     	+   	[match=<MatchResult 5/23: 'ON (tbl.common_id = b.common_id)'>, seg="'ON (tbl.common_id = ...'"]
DEBUG      [PD:3  MD:9 ]	.........JoinOnConditionSegment                   	JoinO.match OUT     	+   	[match=<MatchResult 1/19: 'ON (tbl.common_id = b.common_id)'>, seg="'ON (tbl.common_id = ...'"]
DEBUG      [PD:3  MD:9 ]	.........JoinClauseSegment                        	Ref.match OUT       	+   	[match=<MatchResult 1/19: 'ON (tbl.common_id = b.common_id)'>, seg="'ON (tbl.common_id = ...'"]
INFO       [PD:3  MD:8 ]	........JoinClauseSegment                         	OneOf.match OUT     	+   	[match=<MatchResult 1/19: 'ON (tbl.common_id = b.common_id)'>, seg="'ON (tbl.common_id = ...'"]
INFO       [PD:3  MD:7 ]	.......JoinClauseSegment                          	Seque.match OUT     	+   	[match=<MatchResult 3/21: 'b ON (tbl.commo... = b.common_id)'>, seg="'b ON (tbl.common_id ...'"]
INFO       [PD:3  MD:6 ]	......JoinClauseSegment                           	Seque.match OUT     	+   	[match=<MatchResult 9/27: 'INNER JOIN b ON... = b.common_id)'>, seg="'INNER JOIN b ON (tbl...'"]
DEBUG      [PD:3  MD:5 ]	.....JoinClauseSegment                            	JoinC.match OUT     	+   	[match=<MatchResult 1/19: 'INNER JOIN b ON... = b.common_id)'>, seg="'INNER JOIN b ON (tbl...'"]
DEBUG      [PD:3  MD:5 ]	.....FromExpressionSegment                        	Ref.match OUT       	+   	[match=<MatchResult 1/19: 'INNER JOIN b ON... = b.common_id)'>, seg="'INNER JOIN b ON (tbl...'"]
DEBUG      [PD:3  MD:5 ]	.....FromExpressionSegment                        	Ref.match OUT       	    	[match=<MatchResult 0/27: ''>, seg="'INNER JOIN b ON (tbl...'"]
INFO       [PD:3  MD:4 ]	....FromExpressionSegment                         	AnyNu.match PRN     	    	[ns=1, ps=0, ms=1, pruned=[], opts=[<Ref: JoinClauseSegment>, <Ref: JoinLikeClauseGrammar>]]
INFO       [PD:3  MD:7 ]	.......JoinClauseSegment                          	OneOf.match PRN     	    	[ns=0, ps=3, ms=0, pruned=[<Ref: CrossKeywordSegment>, <Ref: InnerKeywordSegment>, <Sequence: [<OneOf: [<Ref: FullKeywordSegment>, <Ref..., <Ref: OuterKeywordSegment [opt]>]>], opts='ALL']
INFO       [PD:3  MD:7 ]	.......JoinClauseSegment                          	OneOf.match OUT     	    	[match=<MatchResult 0/17: ''>, seg="'JOIN c ON (tbl.id = ...'"]
DEBUG      [PD:3  MD:8 ]	........JoinKeywords                              	Ref.match OUT       	+   	[match=<MatchResult 1/17: 'JOIN'>, seg="'JOIN c ON (tbl.id = ...'"]
INFO       [PD:3  MD:7 ]	.......JoinKeywords                               	Seque.match OUT     	+   	[match=<MatchResult 1/17: 'JOIN'>, seg="'JOIN c ON (tbl.id = ...'"]
DEBUG      [PD:3  MD:7 ]	.......JoinClauseSegment                          	Ref.match OUT       	+   	[match=<MatchResult 1/17: 'JOIN'>, seg="'JOIN c ON (tbl.id = ...'"]
DEBUG      [PD:3  MD:10]	..........FromExpressionElementSegment            	Ref.match OUT       	    	[match=<MatchResult 0/15: ''>, seg="'c ON (tbl.id = c.id)...'"]
INFO       [PD:3  MD:10]	..........FromExpressionElementSegment            	Optio.match PRN     	    	[ns=1, ps=1, ms=0, pruned=[<Bracketed: [<Ref: TableExpressionSegment>]>], opts=[<Ref: TableExpressionSegment>]]
INFO       [PD:3  MD:12]	............TableExpressionSegment                	OneOf.match PRN     	    	[ns=3, ps=1, ms=0, pruned=[<Bracketed: [<Ref: SelectableGrammar>]>], opts=[<Ref: BareFunctionSegment>, <Ref: FunctionSegment>, <Ref: TableReferenceSegment>]]
DEBUG      [PD:3  MD:13]	.............TableExpressionSegment               	Ref.match OUT       	    	[match=<MatchResult 0/15: ''>, seg="'c ON (tbl.id = c.id)...'"]
INFO       [PD:3  MD:14]	..............FunctionSegment                     	OneOf.match PRN     	    	[ns=1, ps=1, ms=0, pruned=[<Sequence: [<Sequence: [<Ref: DateAddFunctionNameSeg...]>], opts=[<Sequence: [<Sequence: [<AnyNumberOf: [<Ref: Functio..., <Ref: PostFunctionGrammar [opt]>]>]]
DEBUG      [PD:3  MD:20]	....................DateAddFunctionNameSegment    	Ref.match OUT       	    	[match=<MatchResult 0/15: ''>, seg="'c ON (tbl.id = c.id)...'"]
INFO       [PD:3  MD:19]	...................DateAddFunctionNameSegment     	Seque.match OUT     	    	[match=<MatchResult 0/15: ''>, seg="'c ON (tbl.id = c.id)...'"]
DEBUG      [PD:3  MD:18]	..................DateAddFunctionNameSegment      	DateA.match OUT     	    	[match=<MatchResult 0/15: ''>, seg="'c ON (tbl.id = c.id)...'"]
DEBUG      [PD:3  MD:18]	..................FunctionSegment                 	Ref.match OUT       	    	[match=<MatchResult 0/15: ''>, seg="'c ON (tbl.id = c.id)...'"]
INFO       [PD:3  MD:17]	.................FunctionSegment                  	AnyNu.match PRN     	    	[ns=1, ps=0, ms=0, pruned=[], opts=[<Ref: FunctionNameSegment>]]
INFO       [PD:3  MD:20]	....................FunctionNameSegment           	AnyNu.match PRN     	    	[ns=1, ps=0, ms=0, pruned=[], opts=[<Sequence: [<Ref: SingleIdentifierGrammar>, <Ref: DotSegment>]>]]
INFO       [PD:3  MD:22]	......................SingleIdentifierGrammar     	OneOf.match PRN     	    	[ns=2, ps=0, ms=0, pruned=[], opts=[<Ref: NakedIdentifierSegment>, <Ref: QuotedIdentifierSegment>]]
DEBUG      [PD:3  MD:23]	.......................SingleIdentifierGrammar    	Ref.match OUT       	+   	[match=<MatchResult 1/15: 'c'>, seg="'c ON (tbl.id = c.id)...'"]
DEBUG      [PD:3  MD:23]	.......................SingleIdentifierGrammar    	Ref.match OUT       	    	[match=<MatchResult 0/15: ''>, seg="'c ON (tbl.id = c.id)...'"]
INFO       [PD:3  MD:22]	......................SingleIdentifierGrammar     	OneOf.match OUT     	+   	[match=<MatchResult 1/15: 'c'>, seg="'c ON (tbl.id = c.id)...'"]
DEBUG      [PD:3  MD:22]	......................FunctionNameSegment         	Ref.match OUT       	+   	[match=<MatchResult 1/15: 'c'>, seg="'c ON (tbl.id = c.id)...'"]
DEBUG      [PD:3  MD:22]	......................FunctionNameSegment         	Ref.match OUT       	    	[match=<MatchResult 0/13: ''>, seg="'ON (tbl.id = c.id)\\nL...'"]
INFO       [PD:3  MD:21]	.....................FunctionNameSegment          	Seque.match OUT     	    	[match=<MatchResult 0/15: ''>, seg="'c ON (tbl.id = c.id)...'"]
INFO       [PD:3  MD:20]	....................FunctionNameSegment           	AnyNu.match OUT     	    	[match=<MatchResult 0/15: ''>, seg="'c ON (tbl.id = c.id)...'"]
INFO       [PD:3  MD:20]	....................FunctionNameSegment           	OneOf.match PRN     	    	[ns=2, ps=0, ms=0, pruned=[], opts=[<Ref: FunctionNameIdentifierSegment>, <Ref: QuotedIdentifierSegment>]]
DEBUG      [PD:3  MD:21]	.....................FunctionNameSegment          	Ref.match OUT       	+   	[match=<MatchResult 1/15: 'c'>, seg="'c ON (tbl.id = c.id)...'"]
DEBUG      [PD:3  MD:21]	.....................FunctionNameSegment          	Ref.match OUT       	    	[match=<MatchResult 0/15: ''>, seg="'c ON (tbl.id = c.id)...'"]
INFO       [PD:3  MD:20]	....................FunctionNameSegment           	OneOf.match OUT     	+   	[match=<MatchResult 1/15: 'c'>, seg="'c ON (tbl.id = c.id)...'"]
INFO       [PD:3  MD:19]	...................FunctionNameSegment            	Seque.match OUT     	+   	[match=<MatchResult 1/15: 'c'>, seg="'c ON (tbl.id = c.id)...'"]
DEBUG      [PD:3  MD:18]	..................FunctionNameSegment             	Funct.match OUT     	+   	[match=<MatchResult 1/15: 'c'>, seg="'c ON (tbl.id = c.id)...'"]
DEBUG      [PD:3  MD:18]	..................FunctionSegment                 	Ref.match OUT       	+   	[match=<MatchResult 1/15: 'c'>, seg="'c ON (tbl.id = c.id)...'"]
INFO       [PD:3  MD:17]	.................FunctionSegment                  	AnyNu.match OUT     	+   	[match=<MatchResult 1/15: 'c'>, seg="'c ON (tbl.id = c.id)...'"]
INFO       [PD:3  MD:17]	.................FunctionSegment                  	Brack.match OUT     	    	[match=<MatchResult 0/13: ''>, seg="'ON (tbl.id = c.id)\\nL...'"]
INFO       [PD:3  MD:16]	................FunctionSegment                   	Seque.match OUT     	    	[match=<MatchResult 0/15: ''>, seg="'c ON (tbl.id = c.id)...'"]
INFO       [PD:3  MD:15]	...............FunctionSegment                    	Seque.match OUT     	    	[match=<MatchResult 0/15: ''>, seg="'c ON (tbl.id = c.id)...'"]
INFO       [PD:3  MD:14]	..............FunctionSegment                     	OneOf.match OUT     	    	[match=<MatchResult 0/15: ''>, seg="'c ON (tbl.id = c.id)...'"]
DEBUG      [PD:3  MD:13]	.............FunctionSegment                      	Funct.match OUT     	    	[match=<MatchResult 0/15: ''>, seg="'c ON (tbl.id = c.id)...'"]
DEBUG      [PD:3  MD:13]	.............TableExpressionSegment               	Ref.match OUT       	    	[match=<MatchResult 0/15: ''>, seg="'c ON (tbl.id = c.id)...'"]
DEBUG      [PD:3  MD:15]	...............TableReferenceSegment              	Delim._look_ahead_match IN	    	[ls=15, seg='c ON (tbl.id = c.id)...']
DEBUG      [PD:3  MD:15]	...............TableReferenceSegment              	Delim._look_ahead_match SI	    	[mq=[], sb=['C', '', 'ON', '', '(TBL.ID', '', 'LEFT', '', 'JOIN', '', 'D', '', 'ON', '', '(TBL.ID']]
INFO       [PD:3  MD:15]	...............TableReferenceSegment              	OneOf.match PRN     	    	[ns=1, ps=10, ms=0, pruned=[<Ref: OnKeywordSegment>, <Ref: AsKeywordSegment>, <Ref: UsingKeywordSegment>, <Ref: CommaSegment>, <Ref: CastOperatorSegment>, <Ref: StartSquareBracketSegment>, <Ref: StartBracketSegment>, <Ref: ColonSegment>, <Ref: DelimiterSegment>, <class 'sqlfluff.core.parser.segments.base.BracketedSegment'>], opts=[<Ref: BinaryOperatorGrammar>]]
INFO       [PD:3  MD:16]	................BinaryOperatorGrammar             	OneOf.match PRN     	    	[ns=1, ps=3, ms=0, pruned=[<Ref: ArithmeticBinaryOperatorGrammar>, <Ref: StringBinaryOperatorGrammar>, <Ref: BooleanBinaryOperatorGrammar>], opts=[<Ref: ComparisonOperatorGrammar>]]
INFO       [PD:3  MD:17]	.................ComparisonOperatorGrammar        	OneOf.match PRN     	    	[ns=1, ps=7, ms=0, pruned=[<Ref: EqualsSegment>, <Ref: GreaterThanSegment>, <Ref: LessThanSegment>, <Ref: GreaterThanOrEqualToSegment>, <Ref: LessThanOrEqualToSegment>, <Ref: NotEqualToSegment_a>, <Ref: NotEqualToSegment_b>], opts=[<Ref: LikeOperatorSegment>]]
DEBUG      [PD:3  MD:18]	..................ComparisonOperatorGrammar       	Ref.match OUT       	    	[match=<MatchResult 0/15: ''>, seg="'c ON (tbl.id = c.id)...'"]
INFO       [PD:3  MD:17]	.................ComparisonOperatorGrammar        	OneOf.match OUT     	    	[match=<MatchResult 0/15: ''>, seg="'c ON (tbl.id = c.id)...'"]
DEBUG      [PD:3  MD:17]	.................BinaryOperatorGrammar            	Ref.match OUT       	    	[match=<MatchResult 0/15: ''>, seg="'c ON (tbl.id = c.id)...'"]
INFO       [PD:3  MD:16]	................BinaryOperatorGrammar             	OneOf.match OUT     	    	[match=<MatchResult 0/15: ''>, seg="'c ON (tbl.id = c.id)...'"]
DEBUG      [PD:3  MD:16]	................TableReferenceSegment             	Ref.match OUT       	    	[match=<MatchResult 0/15: ''>, seg="'c ON (tbl.id = c.id)...'"]
INFO       [PD:3  MD:15]	...............TableReferenceSegment              	OneOf.match OUT     	    	[match=<MatchResult 0/15: ''>, seg="'c ON (tbl.id = c.id)...'"]
DEBUG      [PD:3  MD:15]	...............TableReferenceSegment              	NonCo.match OUT     	    	[match=<MatchResult 0/15: ''>, seg="'c ON (tbl.id = c.id)...'"]
INFO       [PD:3  MD:15]	...............TableReferenceSegment              	OneOf.match PRN     	    	[ns=1, ps=9, ms=1, pruned=[<Ref: AsKeywordSegment>, <Ref: UsingKeywordSegment>, <Ref: CommaSegment>, <Ref: CastOperatorSegment>, <Ref: StartSquareBracketSegment>, <Ref: StartBracketSegment>, <Ref: ColonSegment>, <Ref: DelimiterSegment>, <class 'sqlfluff.core.parser.segments.base.BracketedSegment'>], opts=[<Ref: OnKeywordSegment>, <Ref: BinaryOperatorGrammar>]]
DEBUG      [PD:3  MD:16]	................TableReferenceSegment             	Ref.match OUT       	    	[match=<MatchResult 0/14: ''>, seg="' ON (tbl.id = c.id)\\n...'"]
INFO       [PD:3  MD:16]	................BinaryOperatorGrammar             	OneOf.match PRN     	    	[ns=1, ps=3, ms=0, pruned=[<Ref: ArithmeticBinaryOperatorGrammar>, <Ref: StringBinaryOperatorGrammar>, <Ref: BooleanBinaryOperatorGrammar>], opts=[<Ref: ComparisonOperatorGrammar>]]
INFO       [PD:3  MD:17]	.................ComparisonOperatorGrammar        	OneOf.match PRN     	    	[ns=1, ps=7, ms=0, pruned=[<Ref: EqualsSegment>, <Ref: GreaterThanSegment>, <Ref: LessThanSegment>, <Ref: GreaterThanOrEqualToSegment>, <Ref: LessThanOrEqualToSegment>, <Ref: NotEqualToSegment_a>, <Ref: NotEqualToSegment_b>], opts=[<Ref: LikeOperatorSegment>]]
DEBUG      [PD:3  MD:18]	..................ComparisonOperatorGrammar       	Ref.match OUT       	    	[match=<MatchResult 0/14: ''>, seg="' ON (tbl.id = c.id)\\n...'"]
INFO       [PD:3  MD:17]	.................ComparisonOperatorGrammar        	OneOf.match OUT     	    	[match=<MatchResult 0/14: ''>, seg="' ON (tbl.id = c.id)\\n...'"]
DEBUG      [PD:3  MD:17]	.................BinaryOperatorGrammar            	Ref.match OUT       	    	[match=<MatchResult 0/14: ''>, seg="' ON (tbl.id = c.id)\\n...'"]
INFO       [PD:3  MD:16]	................BinaryOperatorGrammar             	OneOf.match OUT     	    	[match=<MatchResult 0/14: ''>, seg="' ON (tbl.id = c.id)\\n...'"]
DEBUG      [PD:3  MD:16]	................TableReferenceSegment             	Ref.match OUT       	    	[match=<MatchResult 0/14: ''>, seg="' ON (tbl.id = c.id)\\n...'"]
INFO       [PD:3  MD:15]	...............TableReferenceSegment              	OneOf.match OUT     	    	[match=<MatchResult 0/14: ''>, seg="' ON (tbl.id = c.id)\\n...'"]
DEBUG      [PD:3  MD:15]	...............TableReferenceSegment              	NonCo.match OUT     	+   	[match=<MatchResult 1/14: ' '>, seg="' ON (tbl.id = c.id)\\n...'"]
INFO       [PD:3  MD:15]	...............SingleIdentifierGrammar            	OneOf.match PRN     	    	[ns=2, ps=0, ms=0, pruned=[], opts=[<Ref: NakedIdentifierSegment>, <Ref: QuotedIdentifierSegment>]]
DEBUG      [PD:3  MD:16]	................SingleIdentifierGrammar           	Ref.match OUT       	++  	[match=<MatchResult 1/1: 'c'>, seg="'c'"]
INFO       [PD:3  MD:15]	...............SingleIdentifierGrammar            	OneOf.match OUT     	++  	[match=<MatchResult 1/1: 'c'>, seg="'c'"]
DEBUG      [PD:3  MD:15]	...............TableReferenceSegment              	Ref.match OUT       	++  	[match=<MatchResult 1/1: 'c'>, seg="'c'"]
INFO       [PD:3  MD:14]	..............TableReferenceSegment               	Delim.match OUT     	+   	[match=<MatchResult 1/15: 'c'>, seg="'c ON (tbl.id = c.id)...'"]
DEBUG      [PD:3  MD:13]	.............TableReferenceSegment                	Table.match OUT     	+   	[match=<MatchResult 1/15: 'c'>, seg="'c ON (tbl.id = c.id)...'"]
DEBUG      [PD:3  MD:13]	.............TableExpressionSegment               	Ref.match OUT       	+   	[match=<MatchResult 1/15: 'c'>, seg="'c ON (tbl.id = c.id)...'"]
INFO       [PD:3  MD:12]	............TableExpressionSegment                	OneOf.match OUT     	+   	[match=<MatchResult 1/15: 'c'>, seg="'c ON (tbl.id = c.id)...'"]
DEBUG      [PD:3  MD:11]	...........TableExpressionSegment                 	Table.match OUT     	+   	[match=<MatchResult 1/15: 'c'>, seg="'c ON (tbl.id = c.id)...'"]
DEBUG      [PD:3  MD:11]	...........FromExpressionElementSegment           	Ref.match OUT       	+   	[match=<MatchResult 1/15: 'c'>, seg="'c ON (tbl.id = c.id)...'"]
INFO       [PD:3  MD:10]	..........FromExpressionElementSegment            	Optio.match OUT     	+   	[match=<MatchResult 1/15: 'c'>, seg="'c ON (tbl.id = c.id)...'"]
DEBUG      [PD:3  MD:11]	...........FromExpressionElementSegment           	Ref.match OUT       	    	[match=<MatchResult 0/13: ''>, seg="'ON (tbl.id = c.id)\\nL...'"]
INFO       [PD:3  MD:10]	..........FromExpressionElementSegment            	Seque.match OUT     	    	[match=<MatchResult 0/13: ''>, seg="'ON (tbl.id = c.id)\\nL...'"]
DEBUG      [PD:3  MD:12]	............AliasExpressionSegment                	Ref.match OUT       	    	[match=<MatchResult 0/13: ''>, seg="'ON (tbl.id = c.id)\\nL...'"]
INFO       [PD:3  MD:12]	............AliasExpressionSegment                	OneOf.match PRN     	    	[ns=2, ps=0, ms=0, pruned=[], opts=[<Sequence: [<Ref: SingleIdentifierGrammar>, <Bracketed: [<Ref: SingleIdentifierListS...]>, <Ref: QuotedLiteralSegment>]]
INFO       [PD:3  MD:14]	..............SingleIdentifierGrammar             	OneOf.match PRN     	    	[ns=2, ps=0, ms=0, pruned=[], opts=[<Ref: NakedIdentifierSegment>, <Ref: QuotedIdentifierSegment>]]
DEBUG      [PD:3  MD:15]	...............SingleIdentifierGrammar            	Ref.match OUT       	    	[match=<MatchResult 0/13: ''>, seg="'ON (tbl.id = c.id)\\nL...'"]
DEBUG      [PD:3  MD:15]	...............SingleIdentifierGrammar            	Ref.match OUT       	    	[match=<MatchResult 0/13: ''>, seg="'ON (tbl.id = c.id)\\nL...'"]
INFO       [PD:3  MD:14]	..............SingleIdentifierGrammar             	OneOf.match OUT     	    	[match=<MatchResult 0/13: ''>, seg="'ON (tbl.id = c.id)\\nL...'"]
DEBUG      [PD:3  MD:14]	..............AliasExpressionSegment              	Ref.match OUT       	    	[match=<MatchResult 0/13: ''>, seg="'ON (tbl.id = c.id)\\nL...'"]
INFO       [PD:3  MD:13]	.............AliasExpressionSegment               	Seque.match OUT     	    	[match=<MatchResult 0/13: ''>, seg="'ON (tbl.id = c.id)\\nL...'"]
DEBUG      [PD:3  MD:13]	.............AliasExpressionSegment               	Ref.match OUT       	    	[match=<MatchResult 0/13: ''>, seg="'ON (tbl.id = c.id)\\nL...'"]
INFO       [PD:3  MD:12]	............AliasExpressionSegment                	OneOf.match OUT     	    	[match=<MatchResult 0/13: ''>, seg="'ON (tbl.id = c.id)\\nL...'"]
INFO       [PD:3  MD:11]	...........AliasExpressionSegment                 	Seque.match OUT     	    	[match=<MatchResult 0/13: ''>, seg="'ON (tbl.id = c.id)\\nL...'"]
DEBUG      [PD:3  MD:10]	..........AliasExpressionSegment                  	Alias.match OUT     	    	[match=<MatchResult 0/13: ''>, seg="'ON (tbl.id = c.id)\\nL...'"]
DEBUG      [PD:3  MD:10]	..........FromExpressionElementSegment            	Ref.match OUT       	    	[match=<MatchResult 0/13: ''>, seg="'ON (tbl.id = c.id)\\nL...'"]
DEBUG      [PD:3  MD:10]	..........FromExpressionElementSegment            	Ref.match OUT       	    	[match=<MatchResult 0/13: ''>, seg="'ON (tbl.id = c.id)\\nL...'"]
INFO       [PD:3  MD:9 ]	.........FromExpressionElementSegment             	Seque.match OUT     	+   	[match=<MatchResult 1/15: 'c'>, seg="'c ON (tbl.id = c.id)...'"]
DEBUG      [PD:3  MD:8 ]	........FromExpressionElementSegment              	FromE.match OUT     	+   	[match=<MatchResult 1/15: 'c'>, seg="'c ON (tbl.id = c.id)...'"]
DEBUG      [PD:3  MD:8 ]	........JoinClauseSegment                         	Ref.match OUT       	+   	[match=<MatchResult 1/15: 'c'>, seg="'c ON (tbl.id = c.id)...'"]
INFO       [PD:3  MD:8 ]	........JoinClauseSegment                         	OneOf.match PRN     	    	[ns=0, ps=1, ms=1, pruned=[<Sequence: [<Ref: UsingKeywordSegment>, <class 'sqlfluff.core.parser.segments.me..., <Bracketed: [<Delimited: [<...]>], opts=[<Ref: JoinOnConditionSegment>]]
DEBUG      [PD:3  MD:11]	...........JoinOnConditionSegment                 	Ref.match OUT       	+   	[match=<MatchResult 1/13: 'ON'>, seg="'ON (tbl.id = c.id)\\nL...'"]
INFO       [PD:3  MD:11]	...........JoinOnConditionSegment                 	Optio.match PRN     	    	[ns=1, ps=0, ms=1, pruned=[], opts=[<Bracketed: [<Ref: ExpressionSegment>]>, <Ref: ExpressionSegment>]]
INFO       [PD:3  MD:16]	................Expression_A_Grammar              	OneOf.match PRN     	    	[ns=1, ps=1, ms=0, pruned=[<Sequence: [<OneOf: [<Ref: PositiveSegment>, <Ref: N..., <Ref: Expression_C_Grammar>]>], opts=[<Ref: Expression_C_Grammar>]]
INFO       [PD:3  MD:17]	.................Expression_C_Grammar             	OneOf.match PRN     	    	[ns=1, ps=2, ms=0, pruned=[<Sequence: [<Ref: ExistsKeywordSegment>, <Bracketed: [<Ref: SelectStatementSegmen...]>, <Ref: CaseExpressionSegment>], opts=[<Ref: Expression_D_Grammar>]]
INFO       [PD:3  MD:19]	...................Expression_D_Grammar           	OneOf.match PRN     	    	[ns=6, ps=3, ms=0, pruned=[<Bracketed: [<OneOf: [<Ref: ExpressionSegment>, <Ref:...]>, <Ref: SelectStatementSegment>, <Ref: IntervalExpressionSegment>], opts=[<Ref: BareFunctionSegment>, <Ref: FunctionSegment>, <Ref: LiteralGrammar>, <Ref: ColumnReferenceSegment>, <Sequence: [<Ref: SimpleArrayTypeGrammar [opt]>, <Ref: ArrayLiteralSegment>]>, <Sequence: [<Ref: DatatypeSegment>, <OneOf: [<Ref: QuotedLiteralSegment>, <R...]>]]
DEBUG      [PD:3  MD:20]	....................Expression_D_Grammar          	Ref.match OUT       	    	[match=<MatchResult 0/9: ''>, seg="'tbl.id = c.id'"]
INFO       [PD:3  MD:21]	.....................FunctionSegment              	OneOf.match PRN     	    	[ns=1, ps=1, ms=0, pruned=[<Sequence: [<Sequence: [<Ref: DateAddFunctionNameSeg...]>], opts=[<Sequence: [<Sequence: [<AnyNumberOf: [<Ref: Functio..., <Ref: PostFunctionGrammar [opt]>]>]]
DEBUG      [PD:3  MD:27]	...........................DateAddFunctionNameSegment	Ref.match OUT       	    	[match=<MatchResult 0/9: ''>, seg="'tbl.id = c.id'"]
INFO       [PD:3  MD:26]	..........................DateAddFunctionNameSegment	Seque.match OUT     	    	[match=<MatchResult 0/9: ''>, seg="'tbl.id = c.id'"]
DEBUG      [PD:3  MD:25]	.........................DateAddFunctionNameSegment	DateA.match OUT     	    	[match=<MatchResult 0/9: ''>, seg="'tbl.id = c.id'"]
DEBUG      [PD:3  MD:25]	.........................FunctionSegment          	Ref.match OUT       	    	[match=<MatchResult 0/9: ''>, seg="'tbl.id = c.id'"]
INFO       [PD:3  MD:24]	........................FunctionSegment           	AnyNu.match PRN     	    	[ns=1, ps=0, ms=0, pruned=[], opts=[<Ref: FunctionNameSegment>]]
INFO       [PD:3  MD:27]	...........................FunctionNameSegment    	AnyNu.match PRN     	    	[ns=1, ps=0, ms=0, pruned=[], opts=[<Sequence: [<Ref: SingleIdentifierGrammar>, <Ref: DotSegment>]>]]
INFO       [PD:3  MD:29]	.............................SingleIdentifierGrammar	OneOf.match PRN     	    	[ns=2, ps=0, ms=0, pruned=[], opts=[<Ref: NakedIdentifierSegment>, <Ref: QuotedIdentifierSegment>]]
DEBUG      [PD:3  MD:30]	..............................SingleIdentifierGrammar	Ref.match OUT       	+   	[match=<MatchResult 1/9: 'tbl'>, seg="'tbl.id = c.id'"]
DEBUG      [PD:3  MD:30]	..............................SingleIdentifierGrammar	Ref.match OUT       	    	[match=<MatchResult 0/9: ''>, seg="'tbl.id = c.id'"]
INFO       [PD:3  MD:29]	.............................SingleIdentifierGrammar	OneOf.match OUT     	+   	[match=<MatchResult 1/9: 'tbl'>, seg="'tbl.id = c.id'"]
DEBUG      [PD:3  MD:29]	.............................FunctionNameSegment  	Ref.match OUT       	+   	[match=<MatchResult 1/9: 'tbl'>, seg="'tbl.id = c.id'"]
DEBUG      [PD:3  MD:29]	.............................FunctionNameSegment  	Ref.match OUT       	+   	[match=<MatchResult 1/8: '.'>, seg="'.id = c.id'"]
INFO       [PD:3  MD:28]	............................FunctionNameSegment   	Seque.match OUT     	+   	[match=<MatchResult 2/9: 'tbl.'>, seg="'tbl.id = c.id'"]
INFO       [PD:3  MD:27]	...........................FunctionNameSegment    	AnyNu.match PRN     	    	[ns=1, ps=0, ms=0, pruned=[], opts=[<Sequence: [<Ref: SingleIdentifierGrammar>, <Ref: DotSegment>]>]]
INFO       [PD:3  MD:29]	.............................SingleIdentifierGrammar	OneOf.match PRN     	    	[ns=2, ps=0, ms=0, pruned=[], opts=[<Ref: NakedIdentifierSegment>, <Ref: QuotedIdentifierSegment>]]
DEBUG      [PD:3  MD:30]	..............................SingleIdentifierGrammar	Ref.match OUT       	+   	[match=<MatchResult 1/7: 'id'>, seg="'id = c.id'"]
DEBUG      [PD:3  MD:30]	..............................SingleIdentifierGrammar	Ref.match OUT       	    	[match=<MatchResult 0/7: ''>, seg="'id = c.id'"]
INFO       [PD:3  MD:29]	.............................SingleIdentifierGrammar	OneOf.match OUT     	+   	[match=<MatchResult 1/7: 'id'>, seg="'id = c.id'"]
DEBUG      [PD:3  MD:29]	.............................FunctionNameSegment  	Ref.match OUT       	+   	[match=<MatchResult 1/7: 'id'>, seg="'id = c.id'"]
DEBUG      [PD:3  MD:29]	.............................FunctionNameSegment  	Ref.match OUT       	    	[match=<MatchResult 0/5: ''>, seg="'= c.id'"]
INFO       [PD:3  MD:28]	............................FunctionNameSegment   	Seque.match OUT     	    	[match=<MatchResult 0/7: ''>, seg="'id = c.id'"]
INFO       [PD:3  MD:27]	...........................FunctionNameSegment    	AnyNu.match OUT     	+   	[match=<MatchResult 2/9: 'tbl.'>, seg="'tbl.id = c.id'"]
INFO       [PD:3  MD:27]	...........................FunctionNameSegment    	OneOf.match PRN     	    	[ns=2, ps=0, ms=0, pruned=[], opts=[<Ref: FunctionNameIdentifierSegment>, <Ref: QuotedIdentifierSegment>]]
DEBUG      [PD:3  MD:28]	............................FunctionNameSegment   	Ref.match OUT       	+   	[match=<MatchResult 1/7: 'id'>, seg="'id = c.id'"]
DEBUG      [PD:3  MD:28]	............................FunctionNameSegment   	Ref.match OUT       	    	[match=<MatchResult 0/7: ''>, seg="'id = c.id'"]
INFO       [PD:3  MD:27]	...........................FunctionNameSegment    	OneOf.match OUT     	+   	[match=<MatchResult 1/7: 'id'>, seg="'id = c.id'"]
INFO       [PD:3  MD:26]	..........................FunctionNameSegment     	Seque.match OUT     	+   	[match=<MatchResult 3/9: 'tbl.id'>, seg="'tbl.id = c.id'"]
DEBUG      [PD:3  MD:25]	.........................FunctionNameSegment      	Funct.match OUT     	+   	[match=<MatchResult 1/7: 'tbl.id'>, seg="'tbl.id = c.id'"]
DEBUG      [PD:3  MD:25]	.........................FunctionSegment          	Ref.match OUT       	+   	[match=<MatchResult 1/7: 'tbl.id'>, seg="'tbl.id = c.id'"]
INFO       [PD:3  MD:24]	........................FunctionSegment           	AnyNu.match OUT     	+   	[match=<MatchResult 1/7: 'tbl.id'>, seg="'tbl.id = c.id'"]
INFO       [PD:3  MD:24]	........................FunctionSegment           	Brack.match OUT     	    	[match=<MatchResult 0/5: ''>, seg="'= c.id'"]
INFO       [PD:3  MD:23]	.......................FunctionSegment            	Seque.match OUT     	    	[match=<MatchResult 0/9: ''>, seg="'tbl.id = c.id'"]
INFO       [PD:3  MD:22]	......................FunctionSegment             	Seque.match OUT     	    	[match=<MatchResult 0/9: ''>, seg="'tbl.id = c.id'"]
INFO       [PD:3  MD:21]	.....................FunctionSegment              	OneOf.match OUT     	    	[match=<MatchResult 0/9: ''>, seg="'tbl.id = c.id'"]
DEBUG      [PD:3  MD:20]	....................FunctionSegment               	Funct.match OUT     	    	[match=<MatchResult 0/9: ''>, seg="'tbl.id = c.id'"]
DEBUG      [PD:3  MD:20]	....................Expression_D_Grammar          	Ref.match OUT       	    	[match=<MatchResult 0/9: ''>, seg="'tbl.id = c.id'"]
INFO       [PD:3  MD:20]	....................LiteralGrammar                	OneOf.match PRN     	    	[ns=2, ps=4, ms=0, pruned=[<Ref: BooleanLiteralGrammar>, <Ref: QualifiedNumericLiteralSegment>, <Ref: NullLiteralSegment>, <Ref: DateTimeLiteralGrammar>], opts=[<Ref: QuotedLiteralSegment>, <Ref: NumericLiteralSegment>]]
DEBUG      [PD:3  MD:21]	.....................LiteralGrammar               	Ref.match OUT       	    	[match=<MatchResult 0/9: ''>, seg="'tbl.id = c.id'"]
DEBUG      [PD:3  MD:21]	.....................LiteralGrammar               	Ref.match OUT       	    	[match=<MatchResult 0/9: ''>, seg="'tbl.id = c.id'"]
INFO       [PD:3  MD:20]	....................LiteralGrammar                	OneOf.match OUT     	    	[match=<MatchResult 0/9: ''>, seg="'tbl.id = c.id'"]
DEBUG      [PD:3  MD:20]	....................Expression_D_Grammar          	Ref.match OUT       	    	[match=<MatchResult 0/9: ''>, seg="'tbl.id = c.id'"]
DEBUG      [PD:3  MD:22]	......................ColumnReferenceSegment      	Delim._look_ahead_match IN	    	[ls=9, seg='tbl.id = c.id']
DEBUG      [PD:3  MD:22]	......................ColumnReferenceSegment      	Delim._look_ahead_match SI	    	[mq=[(<OneOf: [<Ref: DotSegment>, <Sequence: [<Ref: DotSegment>, <Ref: Dot...]>, 1, '.'), (<OneOf: [<Ref: DotSegment>, <Sequence: [<Ref: DotSegment>, <Ref: Dot...]>, 1, '.'), (<OneOf: [<Ref: DotSegment>, <Sequence: [<Ref: DotSegment>, <Ref: Dot...]>, 7, '.'), (<OneOf: [<Ref: DotSegment>, <Sequence: [<Ref: DotSegment>, <Ref: Dot...]>, 7, '.')], sb=['TBL', '.', 'ID', '', '=', '', 'C', '.', 'ID']]
INFO       [PD:3  MD:22]	......................ColumnReferenceSegment      	OneOf.match PRN     	    	[ns=0, ps=0, ms=2, pruned=[], opts=[<Ref: DotSegment>, <Sequence: [<Ref: DotSegment>, <Ref: DotSegment>]>]]
DEBUG      [PD:3  MD:23]	.......................ColumnReferenceSegment     	Ref.match OUT       	+   	[match=<MatchResult 1/2: '.'>, seg="'.id'"]
DEBUG      [PD:3  MD:24]	........................ColumnReferenceSegment    	Ref.match OUT       	+   	[match=<MatchResult 1/2: '.'>, seg="'.id'"]
DEBUG      [PD:3  MD:24]	........................ColumnReferenceSegment    	Ref.match OUT       	    	[match=<MatchResult 0/1: ''>, seg="'id'"]
INFO       [PD:3  MD:23]	.......................ColumnReferenceSegment     	Seque.match OUT     	    	[match=<MatchResult 0/2: ''>, seg="'.id'"]
INFO       [PD:3  MD:22]	......................ColumnReferenceSegment      	OneOf.match OUT     	+   	[match=<MatchResult 1/2: '.'>, seg="'.id'"]
INFO       [PD:3  MD:22]	......................ColumnReferenceSegment      	OneOf.match PRN     	    	[ns=0, ps=0, ms=2, pruned=[], opts=[<Ref: DotSegment>, <Sequence: [<Ref: DotSegment>, <Ref: DotSegment>]>]]
DEBUG      [PD:3  MD:23]	.......................ColumnReferenceSegment     	Ref.match OUT       	+   	[match=<MatchResult 1/2: '.'>, seg="'.id'"]
DEBUG      [PD:3  MD:24]	........................ColumnReferenceSegment    	Ref.match OUT       	+   	[match=<MatchResult 1/2: '.'>, seg="'.id'"]
DEBUG      [PD:3  MD:24]	........................ColumnReferenceSegment    	Ref.match OUT       	    	[match=<MatchResult 0/1: ''>, seg="'id'"]
INFO       [PD:3  MD:23]	.......................ColumnReferenceSegment     	Seque.match OUT     	    	[match=<MatchResult 0/2: ''>, seg="'.id'"]
INFO       [PD:3  MD:22]	......................ColumnReferenceSegment      	OneOf.match OUT     	+   	[match=<MatchResult 1/2: '.'>, seg="'.id'"]
INFO       [PD:3  MD:22]	......................ColumnReferenceSegment      	OneOf.match PRN     	    	[ns=0, ps=0, ms=2, pruned=[], opts=[<Ref: DotSegment>, <Sequence: [<Ref: DotSegment>, <Ref: DotSegment>]>]]
DEBUG      [PD:3  MD:23]	.......................ColumnReferenceSegment     	Ref.match OUT       	+   	[match=<MatchResult 1/8: '.'>, seg="'.id = c.id'"]
DEBUG      [PD:3  MD:24]	........................ColumnReferenceSegment    	Ref.match OUT       	+   	[match=<MatchResult 1/8: '.'>, seg="'.id = c.id'"]
DEBUG      [PD:3  MD:24]	........................ColumnReferenceSegment    	Ref.match OUT       	    	[match=<MatchResult 0/7: ''>, seg="'id = c.id'"]
INFO       [PD:3  MD:23]	.......................ColumnReferenceSegment     	Seque.match OUT     	    	[match=<MatchResult 0/8: ''>, seg="'.id = c.id'"]
INFO       [PD:3  MD:22]	......................ColumnReferenceSegment      	OneOf.match OUT     	+   	[match=<MatchResult 1/8: '.'>, seg="'.id = c.id'"]
INFO       [PD:3  MD:22]	......................ColumnReferenceSegment      	OneOf.match PRN     	    	[ns=0, ps=0, ms=2, pruned=[], opts=[<Ref: DotSegment>, <Sequence: [<Ref: DotSegment>, <Ref: DotSegment>]>]]
DEBUG      [PD:3  MD:23]	.......................ColumnReferenceSegment     	Ref.match OUT       	+   	[match=<MatchResult 1/8: '.'>, seg="'.id = c.id'"]
DEBUG      [PD:3  MD:24]	........................ColumnReferenceSegment    	Ref.match OUT       	+   	[match=<MatchResult 1/8: '.'>, seg="'.id = c.id'"]
DEBUG      [PD:3  MD:24]	........................ColumnReferenceSegment    	Ref.match OUT       	    	[match=<MatchResult 0/7: ''>, seg="'id = c.id'"]
INFO       [PD:3  MD:23]	.......................ColumnReferenceSegment     	Seque.match OUT     	    	[match=<MatchResult 0/8: ''>, seg="'.id = c.id'"]
INFO       [PD:3  MD:22]	......................ColumnReferenceSegment      	OneOf.match OUT     	+   	[match=<MatchResult 1/8: '.'>, seg="'.id = c.id'"]
INFO       [PD:3  MD:22]	......................ColumnReferenceSegment      	OneOf.match PRN     	    	[ns=1, ps=10, ms=0, pruned=[<Ref: OnKeywordSegment>, <Ref: AsKeywordSegment>, <Ref: UsingKeywordSegment>, <Ref: CommaSegment>, <Ref: CastOperatorSegment>, <Ref: StartSquareBracketSegment>, <Ref: StartBracketSegment>, <Ref: ColonSegment>, <Ref: DelimiterSegment>, <class 'sqlfluff.core.parser.segments.base.BracketedSegment'>], opts=[<Ref: BinaryOperatorGrammar>]]
INFO       [PD:3  MD:23]	.......................BinaryOperatorGrammar      	OneOf.match PRN     	    	[ns=1, ps=3, ms=0, pruned=[<Ref: ArithmeticBinaryOperatorGrammar>, <Ref: StringBinaryOperatorGrammar>, <Ref: BooleanBinaryOperatorGrammar>], opts=[<Ref: ComparisonOperatorGrammar>]]
INFO       [PD:3  MD:24]	........................ComparisonOperatorGrammar 	OneOf.match PRN     	    	[ns=1, ps=7, ms=0, pruned=[<Ref: EqualsSegment>, <Ref: GreaterThanSegment>, <Ref: LessThanSegment>, <Ref: GreaterThanOrEqualToSegment>, <Ref: LessThanOrEqualToSegment>, <Ref: NotEqualToSegment_a>, <Ref: NotEqualToSegment_b>], opts=[<Ref: LikeOperatorSegment>]]
DEBUG      [PD:3  MD:25]	.........................ComparisonOperatorGrammar	Ref.match OUT       	    	[match=<MatchResult 0/9: ''>, seg="'tbl.id = c.id'"]
INFO       [PD:3  MD:24]	........................ComparisonOperatorGrammar 	OneOf.match OUT     	    	[match=<MatchResult 0/9: ''>, seg="'tbl.id = c.id'"]
DEBUG      [PD:3  MD:24]	........................BinaryOperatorGrammar     	Ref.match OUT       	    	[match=<MatchResult 0/9: ''>, seg="'tbl.id = c.id'"]
INFO       [PD:3  MD:23]	.......................BinaryOperatorGrammar      	OneOf.match OUT     	    	[match=<MatchResult 0/9: ''>, seg="'tbl.id = c.id'"]
DEBUG      [PD:3  MD:23]	.......................ColumnReferenceSegment     	Ref.match OUT       	    	[match=<MatchResult 0/9: ''>, seg="'tbl.id = c.id'"]
INFO       [PD:3  MD:22]	......................ColumnReferenceSegment      	OneOf.match OUT     	    	[match=<MatchResult 0/9: ''>, seg="'tbl.id = c.id'"]
DEBUG      [PD:3  MD:22]	......................ColumnReferenceSegment      	NonCo.match OUT     	    	[match=<MatchResult 0/9: ''>, seg="'tbl.id = c.id'"]
INFO       [PD:3  MD:22]	......................ColumnReferenceSegment      	OneOf.match PRN     	    	[ns=1, ps=10, ms=0, pruned=[<Ref: OnKeywordSegment>, <Ref: AsKeywordSegment>, <Ref: UsingKeywordSegment>, <Ref: CommaSegment>, <Ref: CastOperatorSegment>, <Ref: StartSquareBracketSegment>, <Ref: StartBracketSegment>, <Ref: ColonSegment>, <Ref: DelimiterSegment>, <class 'sqlfluff.core.parser.segments.base.BracketedSegment'>], opts=[<Ref: BinaryOperatorGrammar>]]
INFO       [PD:3  MD:23]	.......................BinaryOperatorGrammar      	OneOf.match PRN     	    	[ns=1, ps=3, ms=0, pruned=[<Ref: ArithmeticBinaryOperatorGrammar>, <Ref: StringBinaryOperatorGrammar>, <Ref: BooleanBinaryOperatorGrammar>], opts=[<Ref: ComparisonOperatorGrammar>]]
INFO       [PD:3  MD:24]	........................ComparisonOperatorGrammar 	OneOf.match PRN     	    	[ns=1, ps=7, ms=0, pruned=[<Ref: EqualsSegment>, <Ref: GreaterThanSegment>, <Ref: LessThanSegment>, <Ref: GreaterThanOrEqualToSegment>, <Ref: LessThanOrEqualToSegment>, <Ref: NotEqualToSegment_a>, <Ref: NotEqualToSegment_b>], opts=[<Ref: LikeOperatorSegment>]]
DEBUG      [PD:3  MD:25]	.........................ComparisonOperatorGrammar	Ref.match OUT       	    	[match=<MatchResult 0/8: ''>, seg="'.id = c.id'"]
INFO       [PD:3  MD:24]	........................ComparisonOperatorGrammar 	OneOf.match OUT     	    	[match=<MatchResult 0/8: ''>, seg="'.id = c.id'"]
DEBUG      [PD:3  MD:24]	........................BinaryOperatorGrammar     	Ref.match OUT       	    	[match=<MatchResult 0/8: ''>, seg="'.id = c.id'"]
INFO       [PD:3  MD:23]	.......................BinaryOperatorGrammar      	OneOf.match OUT     	    	[match=<MatchResult 0/8: ''>, seg="'.id = c.id'"]
DEBUG      [PD:3  MD:23]	.......................ColumnReferenceSegment     	Ref.match OUT       	    	[match=<MatchResult 0/8: ''>, seg="'.id = c.id'"]
INFO       [PD:3  MD:22]	......................ColumnReferenceSegment      	OneOf.match OUT     	    	[match=<MatchResult 0/8: ''>, seg="'.id = c.id'"]
DEBUG      [PD:3  MD:22]	......................ColumnReferenceSegment      	NonCo.match OUT     	    	[match=<MatchResult 0/8: ''>, seg="'.id = c.id'"]
INFO       [PD:3  MD:22]	......................SingleIdentifierGrammar     	OneOf.match PRN     	    	[ns=2, ps=0, ms=0, pruned=[], opts=[<Ref: NakedIdentifierSegment>, <Ref: QuotedIdentifierSegment>]]
DEBUG      [PD:3  MD:23]	.......................SingleIdentifierGrammar    	Ref.match OUT       	++  	[match=<MatchResult 1/1: 'tbl'>, seg="'tbl'"]
INFO       [PD:3  MD:22]	......................SingleIdentifierGrammar     	OneOf.match OUT     	++  	[match=<MatchResult 1/1: 'tbl'>, seg="'tbl'"]
DEBUG      [PD:3  MD:22]	......................ColumnReferenceSegment      	Ref.match OUT       	++  	[match=<MatchResult 1/1: 'tbl'>, seg="'tbl'"]
DEBUG      [PD:3  MD:22]	......................ColumnReferenceSegment      	Delim._look_ahead_match IN	    	[ls=7, seg='id = c.id']
DEBUG      [PD:3  MD:22]	......................ColumnReferenceSegment      	Delim._look_ahead_match SI	    	[mq=[(<OneOf: [<Ref: DotSegment>, <Sequence: [<Ref: DotSegment>, <Ref: Dot...]>, 5, '.'), (<OneOf: [<Ref: DotSegment>, <Sequence: [<Ref: DotSegment>, <Ref: Dot...]>, 5, '.')], sb=['ID', '', '=', '', 'C', '.', 'ID']]
INFO       [PD:3  MD:22]	......................ColumnReferenceSegment      	OneOf.match PRN     	    	[ns=0, ps=0, ms=2, pruned=[], opts=[<Ref: DotSegment>, <Sequence: [<Ref: DotSegment>, <Ref: DotSegment>]>]]
DEBUG      [PD:3  MD:23]	.......................ColumnReferenceSegment     	Ref.match OUT       	+   	[match=<MatchResult 1/2: '.'>, seg="'.id'"]
DEBUG      [PD:3  MD:24]	........................ColumnReferenceSegment    	Ref.match OUT       	+   	[match=<MatchResult 1/2: '.'>, seg="'.id'"]
DEBUG      [PD:3  MD:24]	........................ColumnReferenceSegment    	Ref.match OUT       	    	[match=<MatchResult 0/1: ''>, seg="'id'"]
INFO       [PD:3  MD:23]	.......................ColumnReferenceSegment     	Seque.match OUT     	    	[match=<MatchResult 0/2: ''>, seg="'.id'"]
INFO       [PD:3  MD:22]	......................ColumnReferenceSegment      	OneOf.match OUT     	+   	[match=<MatchResult 1/2: '.'>, seg="'.id'"]
INFO       [PD:3  MD:22]	......................ColumnReferenceSegment      	OneOf.match PRN     	    	[ns=0, ps=0, ms=2, pruned=[], opts=[<Ref: DotSegment>, <Sequence: [<Ref: DotSegment>, <Ref: DotSegment>]>]]
DEBUG      [PD:3  MD:23]	.......................ColumnReferenceSegment     	Ref.match OUT       	+   	[match=<MatchResult 1/2: '.'>, seg="'.id'"]
DEBUG      [PD:3  MD:24]	........................ColumnReferenceSegment    	Ref.match OUT       	+   	[match=<MatchResult 1/2: '.'>, seg="'.id'"]
DEBUG      [PD:3  MD:24]	........................ColumnReferenceSegment    	Ref.match OUT       	    	[match=<MatchResult 0/1: ''>, seg="'id'"]
INFO       [PD:3  MD:23]	.......................ColumnReferenceSegment     	Seque.match OUT     	    	[match=<MatchResult 0/2: ''>, seg="'.id'"]
INFO       [PD:3  MD:22]	......................ColumnReferenceSegment      	OneOf.match OUT     	+   	[match=<MatchResult 1/2: '.'>, seg="'.id'"]
INFO       [PD:3  MD:22]	......................ColumnReferenceSegment      	OneOf.match PRN     	    	[ns=1, ps=10, ms=0, pruned=[<Ref: OnKeywordSegment>, <Ref: AsKeywordSegment>, <Ref: UsingKeywordSegment>, <Ref: CommaSegment>, <Ref: CastOperatorSegment>, <Ref: StartSquareBracketSegment>, <Ref: StartBracketSegment>, <Ref: ColonSegment>, <Ref: DelimiterSegment>, <class 'sqlfluff.core.parser.segments.base.BracketedSegment'>], opts=[<Ref: BinaryOperatorGrammar>]]
INFO       [PD:3  MD:23]	.......................BinaryOperatorGrammar      	OneOf.match PRN     	    	[ns=1, ps=3, ms=0, pruned=[<Ref: ArithmeticBinaryOperatorGrammar>, <Ref: StringBinaryOperatorGrammar>, <Ref: BooleanBinaryOperatorGrammar>], opts=[<Ref: ComparisonOperatorGrammar>]]
INFO       [PD:3  MD:24]	........................ComparisonOperatorGrammar 	OneOf.match PRN     	    	[ns=1, ps=7, ms=0, pruned=[<Ref: EqualsSegment>, <Ref: GreaterThanSegment>, <Ref: LessThanSegment>, <Ref: GreaterThanOrEqualToSegment>, <Ref: LessThanOrEqualToSegment>, <Ref: NotEqualToSegment_a>, <Ref: NotEqualToSegment_b>], opts=[<Ref: LikeOperatorSegment>]]
DEBUG      [PD:3  MD:25]	.........................ComparisonOperatorGrammar	Ref.match OUT       	    	[match=<MatchResult 0/7: ''>, seg="'id = c.id'"]
INFO       [PD:3  MD:24]	........................ComparisonOperatorGrammar 	OneOf.match OUT     	    	[match=<MatchResult 0/7: ''>, seg="'id = c.id'"]
DEBUG      [PD:3  MD:24]	........................BinaryOperatorGrammar     	Ref.match OUT       	    	[match=<MatchResult 0/7: ''>, seg="'id = c.id'"]
INFO       [PD:3  MD:23]	.......................BinaryOperatorGrammar      	OneOf.match OUT     	    	[match=<MatchResult 0/7: ''>, seg="'id = c.id'"]
DEBUG      [PD:3  MD:23]	.......................ColumnReferenceSegment     	Ref.match OUT       	    	[match=<MatchResult 0/7: ''>, seg="'id = c.id'"]
INFO       [PD:3  MD:22]	......................ColumnReferenceSegment      	OneOf.match OUT     	    	[match=<MatchResult 0/7: ''>, seg="'id = c.id'"]
DEBUG      [PD:3  MD:22]	......................ColumnReferenceSegment      	NonCo.match OUT     	    	[match=<MatchResult 0/7: ''>, seg="'id = c.id'"]
INFO       [PD:3  MD:22]	......................ColumnReferenceSegment      	OneOf.match PRN     	    	[ns=1, ps=10, ms=0, pruned=[<Ref: OnKeywordSegment>, <Ref: AsKeywordSegment>, <Ref: UsingKeywordSegment>, <Ref: CommaSegment>, <Ref: CastOperatorSegment>, <Ref: StartSquareBracketSegment>, <Ref: StartBracketSegment>, <Ref: ColonSegment>, <Ref: DelimiterSegment>, <class 'sqlfluff.core.parser.segments.base.BracketedSegment'>], opts=[<Ref: BinaryOperatorGrammar>]]
INFO       [PD:3  MD:23]	.......................BinaryOperatorGrammar      	OneOf.match PRN     	    	[ns=1, ps=3, ms=0, pruned=[<Ref: ArithmeticBinaryOperatorGrammar>, <Ref: StringBinaryOperatorGrammar>, <Ref: BooleanBinaryOperatorGrammar>], opts=[<Ref: ComparisonOperatorGrammar>]]
INFO       [PD:3  MD:24]	........................ComparisonOperatorGrammar 	OneOf.match PRN     	    	[ns=1, ps=6, ms=1, pruned=[<Ref: GreaterThanSegment>, <Ref: LessThanSegment>, <Ref: GreaterThanOrEqualToSegment>, <Ref: LessThanOrEqualToSegment>, <Ref: NotEqualToSegment_a>, <Ref: NotEqualToSegment_b>], opts=[<Ref: EqualsSegment>, <Ref: LikeOperatorSegment>]]
DEBUG      [PD:3  MD:25]	.........................ComparisonOperatorGrammar	Ref.match OUT       	    	[match=<MatchResult 0/6: ''>, seg="' = c.id'"]
DEBUG      [PD:3  MD:25]	.........................ComparisonOperatorGrammar	Ref.match OUT       	    	[match=<MatchResult 0/6: ''>, seg="' = c.id'"]
INFO       [PD:3  MD:24]	........................ComparisonOperatorGrammar 	OneOf.match OUT     	    	[match=<MatchResult 0/6: ''>, seg="' = c.id'"]
DEBUG      [PD:3  MD:24]	........................BinaryOperatorGrammar     	Ref.match OUT       	    	[match=<MatchResult 0/6: ''>, seg="' = c.id'"]
INFO       [PD:3  MD:23]	.......................BinaryOperatorGrammar      	OneOf.match OUT     	    	[match=<MatchResult 0/6: ''>, seg="' = c.id'"]
DEBUG      [PD:3  MD:23]	.......................ColumnReferenceSegment     	Ref.match OUT       	    	[match=<MatchResult 0/6: ''>, seg="' = c.id'"]
INFO       [PD:3  MD:22]	......................ColumnReferenceSegment      	OneOf.match OUT     	    	[match=<MatchResult 0/6: ''>, seg="' = c.id'"]
DEBUG      [PD:3  MD:22]	......................ColumnReferenceSegment      	NonCo.match OUT     	+   	[match=<MatchResult 1/6: ' '>, seg="' = c.id'"]
INFO       [PD:3  MD:22]	......................SingleIdentifierGrammar     	OneOf.match PRN     	    	[ns=2, ps=0, ms=0, pruned=[], opts=[<Ref: NakedIdentifierSegment>, <Ref: QuotedIdentifierSegment>]]
DEBUG      [PD:3  MD:23]	.......................SingleIdentifierGrammar    	Ref.match OUT       	++  	[match=<MatchResult 1/1: 'id'>, seg="'id'"]
INFO       [PD:3  MD:22]	......................SingleIdentifierGrammar     	OneOf.match OUT     	++  	[match=<MatchResult 1/1: 'id'>, seg="'id'"]
DEBUG      [PD:3  MD:22]	......................ColumnReferenceSegment      	Ref.match OUT       	++  	[match=<MatchResult 1/1: 'id'>, seg="'id'"]
INFO       [PD:3  MD:21]	.....................ColumnReferenceSegment       	Delim.match OUT     	+   	[match=<MatchResult 3/9: 'tbl.id'>, seg="'tbl.id = c.id'"]
DEBUG      [PD:3  MD:20]	....................ColumnReferenceSegment        	Colum.match OUT     	+   	[match=<MatchResult 1/7: 'tbl.id'>, seg="'tbl.id = c.id'"]
DEBUG      [PD:3  MD:20]	....................Expression_D_Grammar          	Ref.match OUT       	+   	[match=<MatchResult 1/7: 'tbl.id'>, seg="'tbl.id = c.id'"]
DEBUG      [PD:3  MD:21]	.....................Expression_D_Grammar         	Ref.match OUT       	    	[match=<MatchResult 0/9: ''>, seg="'tbl.id = c.id'"]
INFO       [PD:3  MD:22]	......................ArrayLiteralSegment         	Brack.match OUT     	    	[match=<MatchResult 0/9: ''>, seg="'tbl.id = c.id'"]
DEBUG      [PD:3  MD:21]	.....................ArrayLiteralSegment          	Array.match OUT     	    	[match=<MatchResult 0/9: ''>, seg="'tbl.id = c.id'"]
DEBUG      [PD:3  MD:21]	.....................Expression_D_Grammar         	Ref.match OUT       	    	[match=<MatchResult 0/9: ''>, seg="'tbl.id = c.id'"]
INFO       [PD:3  MD:20]	....................Expression_D_Grammar          	Seque.match OUT     	    	[match=<MatchResult 0/9: ''>, seg="'tbl.id = c.id'"]
INFO       [PD:3  MD:22]	......................DatatypeSegment             	OneOf.match PRN     	    	[ns=1, ps=2, ms=0, pruned=[<Sequence: [<OneOf: [<Ref: TimeKeywordSegment>, <Ref..., <Bracketed: [<Ref: NumericLiteralSegment..., <Sequence:...]>, <Sequence: [<Ref: DoubleKeywordSegment>, <Ref: PrecisionKeywordSegment>]>], opts=[<Sequence: [<OneOf: [<Sequence: [<OneOf: [<Ref: Char..., <Bracketed: [<OneOf: [<Delimited: [<Ref:..., <Ref: Char...]>]]
INFO       [PD:3  MD:24]	........................DatatypeSegment           	OneOf.match PRN     	    	[ns=1, ps=1, ms=0, pruned=[<Sequence: [<OneOf: [<Ref: CharacterKeywordSegment>,..., <OneOf: [<Ref: VaryingKeywordSegment>, <...]>], opts=[<Sequence: [<Sequence: [<Ref: SingleIdentifierGramma..., <Ref: DatatypeIdentifierSegment>]>]]
INFO       [PD:3  MD:27]	...........................SingleIdentifierGrammar	OneOf.match PRN     	    	[ns=2, ps=0, ms=0, pruned=[], opts=[<Ref: NakedIdentifierSegment>, <Ref: QuotedIdentifierSegment>]]
DEBUG      [PD:3  MD:28]	............................SingleIdentifierGrammar	Ref.match OUT       	+   	[match=<MatchResult 1/9: 'tbl'>, seg="'tbl.id = c.id'"]
DEBUG      [PD:3  MD:28]	............................SingleIdentifierGrammar	Ref.match OUT       	    	[match=<MatchResult 0/9: ''>, seg="'tbl.id = c.id'"]
INFO       [PD:3  MD:27]	...........................SingleIdentifierGrammar	OneOf.match OUT     	+   	[match=<MatchResult 1/9: 'tbl'>, seg="'tbl.id = c.id'"]
DEBUG      [PD:3  MD:27]	...........................DatatypeSegment        	Ref.match OUT       	+   	[match=<MatchResult 1/9: 'tbl'>, seg="'tbl.id = c.id'"]
DEBUG      [PD:3  MD:27]	...........................DatatypeSegment        	Ref.match OUT       	+   	[match=<MatchResult 1/8: '.'>, seg="'.id = c.id'"]
INFO       [PD:3  MD:26]	..........................DatatypeSegment         	Seque.match OUT     	+   	[match=<MatchResult 2/9: 'tbl.'>, seg="'tbl.id = c.id'"]
DEBUG      [PD:3  MD:26]	..........................DatatypeSegment         	Ref.match OUT       	+   	[match=<MatchResult 1/7: 'id'>, seg="'id = c.id'"]
INFO       [PD:3  MD:25]	.........................DatatypeSegment          	Seque.match OUT     	+   	[match=<MatchResult 3/9: 'tbl.id'>, seg="'tbl.id = c.id'"]
INFO       [PD:3  MD:24]	........................DatatypeSegment           	OneOf.match OUT     	+   	[match=<MatchResult 3/9: 'tbl.id'>, seg="'tbl.id = c.id'"]
INFO       [PD:3  MD:24]	........................DatatypeSegment           	Brack.match OUT     	    	[match=<MatchResult 0/5: ''>, seg="'= c.id'"]
DEBUG      [PD:3  MD:24]	........................DatatypeSegment           	Ref.match OUT       	    	[match=<MatchResult 0/5: ''>, seg="'= c.id'"]
INFO       [PD:3  MD:23]	.......................DatatypeSegment            	Seque.match OUT     	+   	[match=<MatchResult 3/9: 'tbl.id'>, seg="'tbl.id = c.id'"]
INFO       [PD:3  MD:22]	......................DatatypeSegment             	OneOf.match OUT     	+   	[match=<MatchResult 3/9: 'tbl.id'>, seg="'tbl.id = c.id'"]
DEBUG      [PD:3  MD:21]	.....................DatatypeSegment              	Datat.match OUT     	+   	[match=<MatchResult 1/7: 'tbl.id'>, seg="'tbl.id = c.id'"]
DEBUG      [PD:3  MD:21]	.....................Expression_D_Grammar         	Ref.match OUT       	+   	[match=<MatchResult 1/7: 'tbl.id'>, seg="'tbl.id = c.id'"]
INFO       [PD:3  MD:21]	.....................Expression_D_Grammar         	OneOf.match PRN     	    	[ns=2, ps=3, ms=0, pruned=[<Ref: BooleanLiteralGrammar>, <Ref: NullLiteralSegment>, <Ref: DateTimeLiteralGrammar>], opts=[<Ref: QuotedLiteralSegment>, <Ref: NumericLiteralSegment>]]
DEBUG      [PD:3  MD:22]	......................Expression_D_Grammar        	Ref.match OUT       	    	[match=<MatchResult 0/5: ''>, seg="'= c.id'"]
DEBUG      [PD:3  MD:22]	......................Expression_D_Grammar        	Ref.match OUT       	    	[match=<MatchResult 0/5: ''>, seg="'= c.id'"]
INFO       [PD:3  MD:21]	.....................Expression_D_Grammar         	OneOf.match OUT     	    	[match=<MatchResult 0/5: ''>, seg="'= c.id'"]
INFO       [PD:3  MD:20]	....................Expression_D_Grammar          	Seque.match OUT     	    	[match=<MatchResult 0/9: ''>, seg="'tbl.id = c.id'"]
INFO       [PD:3  MD:19]	...................Expression_D_Grammar           	OneOf.match OUT     	+   	[match=<MatchResult 1/7: 'tbl.id'>, seg="'tbl.id = c.id'"]
INFO       [PD:3  MD:19]	...................Accessor_Grammar               	AnyNu.match PRN     	    	[ns=0, ps=1, ms=0, pruned=[<Ref: ArrayAccessorSegment>], opts='ALL']
INFO       [PD:3  MD:19]	...................Accessor_Grammar               	AnyNu.match OUT     	    	[match=<MatchResult 0/5: ''>, seg="'= c.id'"]
DEBUG      [PD:3  MD:19]	...................Expression_D_Grammar           	Ref.match OUT       	    	[match=<MatchResult 0/5: ''>, seg="'= c.id'"]
INFO       [PD:3  MD:19]	...................Expression_D_Grammar           	AnyNu.match PRN     	    	[ns=0, ps=1, ms=0, pruned=[<Ref: ShorthandCastSegment>], opts='ALL']
INFO       [PD:3  MD:19]	...................Expression_D_Grammar           	AnyNu.match OUT     	    	[match=<MatchResult 0/5: ''>, seg="'= c.id'"]
INFO       [PD:3  MD:18]	..................Expression_D_Grammar            	Seque.match OUT     	+   	[match=<MatchResult 1/7: 'tbl.id'>, seg="'tbl.id = c.id'"]
DEBUG      [PD:3  MD:18]	..................Expression_C_Grammar            	Ref.match OUT       	+   	[match=<MatchResult 1/7: 'tbl.id'>, seg="'tbl.id = c.id'"]
INFO       [PD:3  MD:17]	.................Expression_C_Grammar             	OneOf.match OUT     	+   	[match=<MatchResult 1/7: 'tbl.id'>, seg="'tbl.id = c.id'"]
DEBUG      [PD:3  MD:17]	.................Expression_A_Grammar             	Ref.match OUT       	+   	[match=<MatchResult 1/7: 'tbl.id'>, seg="'tbl.id = c.id'"]
INFO       [PD:3  MD:16]	................Expression_A_Grammar              	OneOf.match OUT     	+   	[match=<MatchResult 1/7: 'tbl.id'>, seg="'tbl.id = c.id'"]
INFO       [PD:3  MD:16]	................Expression_A_Grammar              	AnyNu.match PRN     	    	[ns=1, ps=0, ms=0, pruned=[], opts=[<OneOf: [<Sequence: [<OneOf: [<Sequence: [<Ref: N..., <Sequence: [<Ref: NotKeywordSegment [opt..., <Sequence:...]>]]
INFO       [PD:3  MD:17]	.................Expression_A_Grammar             	OneOf.match PRN     	    	[ns=3, ps=5, ms=0, pruned=[<Sequence: [<Ref: NotKeywordSegment [opt]>, <Ref: InKeywordSegment>, <Bracketed: [<OneOf: [<Delimited: [<Ref:...]>, <Sequence: [<Ref: NotKeywordSegment [opt]>, <Ref: InKeywordSegment>, <Ref: FunctionSegment>]>, <Sequence: [<Ref: IsKeywordSegment>, <Ref: NotKeywordSegment [opt]>, <Ref: IsClauseGrammar>]>, <Sequence: [<Ref: NotKeywordSegment>, <Ref: Expression_C_Grammar>]>, <Sequence: [<Ref: NotKeywordSegment [opt]>, <Ref: BetweenKeywordSegment>, <Ref: Expression_C_Grammar>, <AnyNumbe...]>], opts=[<Sequence: [<OneOf: [<Sequence: [<Ref: NotKeywordSeg..., <Ref: Expression_C_Grammar>, <Sequence: [<Ref: EscapeKe...]>, <Ref: IsNullGrammar>, <Ref: NotNullGrammar>]]
INFO       [PD:3  MD:19]	...................Expression_A_Grammar           	OneOf.match PRN     	    	[ns=1, ps=1, ms=0, pruned=[<Sequence: [<Ref: NotKeywordSegment [opt]>, <Ref: LikeGrammar>]>], opts=[<Sequence: [<Ref: BinaryOperatorGrammar>, <Ref: NotKeywordSegment [opt]>]>]]
INFO       [PD:3  MD:21]	.....................BinaryOperatorGrammar        	OneOf.match PRN     	    	[ns=1, ps=3, ms=0, pruned=[<Ref: ArithmeticBinaryOperatorGrammar>, <Ref: StringBinaryOperatorGrammar>, <Ref: BooleanBinaryOperatorGrammar>], opts=[<Ref: ComparisonOperatorGrammar>]]
INFO       [PD:3  MD:22]	......................ComparisonOperatorGrammar   	OneOf.match PRN     	    	[ns=1, ps=6, ms=1, pruned=[<Ref: GreaterThanSegment>, <Ref: LessThanSegment>, <Ref: GreaterThanOrEqualToSegment>, <Ref: LessThanOrEqualToSegment>, <Ref: NotEqualToSegment_a>, <Ref: NotEqualToSegment_b>], opts=[<Ref: EqualsSegment>, <Ref: LikeOperatorSegment>]]
DEBUG      [PD:3  MD:23]	.......................ComparisonOperatorGrammar  	Ref.match OUT       	+   	[match=<MatchResult 1/5: '='>, seg="'= c.id'"]
DEBUG      [PD:3  MD:23]	.......................ComparisonOperatorGrammar  	Ref.match OUT       	    	[match=<MatchResult 0/5: ''>, seg="'= c.id'"]
INFO       [PD:3  MD:22]	......................ComparisonOperatorGrammar   	OneOf.match OUT     	+   	[match=<MatchResult 1/5: '='>, seg="'= c.id'"]
DEBUG      [PD:3  MD:22]	......................BinaryOperatorGrammar       	Ref.match OUT       	+   	[match=<MatchResult 1/5: '='>, seg="'= c.id'"]
INFO       [PD:3  MD:21]	.....................BinaryOperatorGrammar        	OneOf.match OUT     	+   	[match=<MatchResult 1/5: '='>, seg="'= c.id'"]
DEBUG      [PD:3  MD:21]	.....................Expression_A_Grammar         	Ref.match OUT       	+   	[match=<MatchResult 1/5: '='>, seg="'= c.id'"]
DEBUG      [PD:3  MD:21]	.....................Expression_A_Grammar         	Ref.match OUT       	    	[match=<MatchResult 0/3: ''>, seg="'c.id'"]
INFO       [PD:3  MD:20]	....................Expression_A_Grammar          	Seque.match OUT     	+   	[match=<MatchResult 1/5: '='>, seg="'= c.id'"]
INFO       [PD:3  MD:19]	...................Expression_A_Grammar           	OneOf.match OUT     	+   	[match=<MatchResult 1/5: '='>, seg="'= c.id'"]
INFO       [PD:3  MD:19]	...................Expression_C_Grammar           	OneOf.match PRN     	    	[ns=1, ps=2, ms=0, pruned=[<Sequence: [<Ref: ExistsKeywordSegment>, <Bracketed: [<Ref: SelectStatementSegmen...]>, <Ref: CaseExpressionSegment>], opts=[<Ref: Expression_D_Grammar>]]
INFO       [PD:3  MD:21]	.....................Expression_D_Grammar         	OneOf.match PRN     	    	[ns=6, ps=3, ms=0, pruned=[<Bracketed: [<OneOf: [<Ref: ExpressionSegment>, <Ref:...]>, <Ref: SelectStatementSegment>, <Ref: IntervalExpressionSegment>], opts=[<Ref: BareFunctionSegment>, <Ref: FunctionSegment>, <Ref: LiteralGrammar>, <Ref: ColumnReferenceSegment>, <Sequence: [<Ref: SimpleArrayTypeGrammar [opt]>, <Ref: ArrayLiteralSegment>]>, <Sequence: [<Ref: DatatypeSegment>, <OneOf: [<Ref: QuotedLiteralSegment>, <R...]>]]
DEBUG      [PD:3  MD:22]	......................Expression_D_Grammar        	Ref.match OUT       	    	[match=<MatchResult 0/3: ''>, seg="'c.id'"]
INFO       [PD:3  MD:23]	.......................FunctionSegment            	OneOf.match PRN     	    	[ns=1, ps=1, ms=0, pruned=[<Sequence: [<Sequence: [<Ref: DateAddFunctionNameSeg...]>], opts=[<Sequence: [<Sequence: [<AnyNumberOf: [<Ref: Functio..., <Ref: PostFunctionGrammar [opt]>]>]]
DEBUG      [PD:3  MD:29]	.............................DateAddFunctionNameSegment	Ref.match OUT       	    	[match=<MatchResult 0/3: ''>, seg="'c.id'"]
INFO       [PD:3  MD:28]	............................DateAddFunctionNameSegment	Seque.match OUT     	    	[match=<MatchResult 0/3: ''>, seg="'c.id'"]
DEBUG      [PD:3  MD:27]	...........................DateAddFunctionNameSegment	DateA.match OUT     	    	[match=<MatchResult 0/3: ''>, seg="'c.id'"]
DEBUG      [PD:3  MD:27]	...........................FunctionSegment        	Ref.match OUT       	    	[match=<MatchResult 0/3: ''>, seg="'c.id'"]
INFO       [PD:3  MD:26]	..........................FunctionSegment         	AnyNu.match PRN     	    	[ns=1, ps=0, ms=0, pruned=[], opts=[<Ref: FunctionNameSegment>]]
INFO       [PD:3  MD:29]	.............................FunctionNameSegment  	AnyNu.match PRN     	    	[ns=1, ps=0, ms=0, pruned=[], opts=[<Sequence: [<Ref: SingleIdentifierGrammar>, <Ref: DotSegment>]>]]
INFO       [PD:3  MD:31]	...............................SingleIdentifierGrammar	OneOf.match PRN     	    	[ns=2, ps=0, ms=0, pruned=[], opts=[<Ref: NakedIdentifierSegment>, <Ref: QuotedIdentifierSegment>]]
DEBUG      [PD:3  MD:32]	................................SingleIdentifierGrammar	Ref.match OUT       	+   	[match=<MatchResult 1/3: 'c'>, seg="'c.id'"]
DEBUG      [PD:3  MD:32]	................................SingleIdentifierGrammar	Ref.match OUT       	    	[match=<MatchResult 0/3: ''>, seg="'c.id'"]
INFO       [PD:3  MD:31]	...............................SingleIdentifierGrammar	OneOf.match OUT     	+   	[match=<MatchResult 1/3: 'c'>, seg="'c.id'"]
DEBUG      [PD:3  MD:31]	...............................FunctionNameSegment	Ref.match OUT       	+   	[match=<MatchResult 1/3: 'c'>, seg="'c.id'"]
DEBUG      [PD:3  MD:31]	...............................FunctionNameSegment	Ref.match OUT       	+   	[match=<MatchResult 1/2: '.'>, seg="'.id'"]
INFO       [PD:3  MD:30]	..............................FunctionNameSegment 	Seque.match OUT     	+   	[match=<MatchResult 2/3: 'c.'>, seg="'c.id'"]
INFO       [PD:3  MD:29]	.............................FunctionNameSegment  	AnyNu.match PRN     	    	[ns=1, ps=0, ms=0, pruned=[], opts=[<Sequence: [<Ref: SingleIdentifierGrammar>, <Ref: DotSegment>]>]]
INFO       [PD:3  MD:31]	...............................SingleIdentifierGrammar	OneOf.match PRN     	    	[ns=2, ps=0, ms=0, pruned=[], opts=[<Ref: NakedIdentifierSegment>, <Ref: QuotedIdentifierSegment>]]
DEBUG      [PD:3  MD:32]	................................SingleIdentifierGrammar	Ref.match OUT       	++  	[match=<MatchResult 1/1: 'id'>, seg="'id'"]
INFO       [PD:3  MD:31]	...............................SingleIdentifierGrammar	OneOf.match OUT     	++  	[match=<MatchResult 1/1: 'id'>, seg="'id'"]
DEBUG      [PD:3  MD:31]	...............................FunctionNameSegment	Ref.match OUT       	++  	[match=<MatchResult 1/1: 'id'>, seg="'id'"]
INFO       [PD:3  MD:30]	..............................FunctionNameSegment 	Seque.match OUT     	    	[match=<MatchResult 0/1: ''>, seg="'id'"]
INFO       [PD:3  MD:29]	.............................FunctionNameSegment  	AnyNu.match OUT     	+   	[match=<MatchResult 2/3: 'c.'>, seg="'c.id'"]
INFO       [PD:3  MD:29]	.............................FunctionNameSegment  	OneOf.match PRN     	    	[ns=2, ps=0, ms=0, pruned=[], opts=[<Ref: FunctionNameIdentifierSegment>, <Ref: QuotedIdentifierSegment>]]
DEBUG      [PD:3  MD:30]	..............................FunctionNameSegment 	Ref.match OUT       	++  	[match=<MatchResult 1/1: 'id'>, seg="'id'"]
INFO       [PD:3  MD:29]	.............................FunctionNameSegment  	OneOf.match OUT     	++  	[match=<MatchResult 1/1: 'id'>, seg="'id'"]
INFO       [PD:3  MD:28]	............................FunctionNameSegment   	Seque.match OUT     	++  	[match=<MatchResult 3/3: 'c.id'>, seg="'c.id'"]
DEBUG      [PD:3  MD:27]	...........................FunctionNameSegment    	Funct.match OUT     	++  	[match=<MatchResult 1/1: 'c.id'>, seg="'c.id'"]
DEBUG      [PD:3  MD:27]	...........................FunctionSegment        	Ref.match OUT       	++  	[match=<MatchResult 1/1: 'c.id'>, seg="'c.id'"]
INFO       [PD:3  MD:26]	..........................FunctionSegment         	AnyNu.match OUT     	++  	[match=<MatchResult 1/1: 'c.id'>, seg="'c.id'"]
INFO       [PD:3  MD:25]	.........................FunctionSegment          	Seque.match OUT     	    	[match=<MatchResult 0/3: ''>, seg="'c.id'"]
INFO       [PD:3  MD:24]	........................FunctionSegment           	Seque.match OUT     	    	[match=<MatchResult 0/3: ''>, seg="'c.id'"]
INFO       [PD:3  MD:23]	.......................FunctionSegment            	OneOf.match OUT     	    	[match=<MatchResult 0/3: ''>, seg="'c.id'"]
DEBUG      [PD:3  MD:22]	......................FunctionSegment             	Funct.match OUT     	    	[match=<MatchResult 0/3: ''>, seg="'c.id'"]
DEBUG      [PD:3  MD:22]	......................Expression_D_Grammar        	Ref.match OUT       	    	[match=<MatchResult 0/3: ''>, seg="'c.id'"]
INFO       [PD:3  MD:22]	......................LiteralGrammar              	OneOf.match PRN     	    	[ns=2, ps=4, ms=0, pruned=[<Ref: BooleanLiteralGrammar>, <Ref: QualifiedNumericLiteralSegment>, <Ref: NullLiteralSegment>, <Ref: DateTimeLiteralGrammar>], opts=[<Ref: QuotedLiteralSegment>, <Ref: NumericLiteralSegment>]]
DEBUG      [PD:3  MD:23]	.......................LiteralGrammar             	Ref.match OUT       	    	[match=<MatchResult 0/3: ''>, seg="'c.id'"]
DEBUG      [PD:3  MD:23]	.......................LiteralGrammar             	Ref.match OUT       	    	[match=<MatchResult 0/3: ''>, seg="'c.id'"]
INFO       [PD:3  MD:22]	......................LiteralGrammar              	OneOf.match OUT     	    	[match=<MatchResult 0/3: ''>, seg="'c.id'"]
DEBUG      [PD:3  MD:22]	......................Expression_D_Grammar        	Ref.match OUT       	    	[match=<MatchResult 0/3: ''>, seg="'c.id'"]
DEBUG      [PD:3  MD:24]	........................ColumnReferenceSegment    	Delim._look_ahead_match IN	    	[ls=3, seg='c.id']
DEBUG      [PD:3  MD:24]	........................ColumnReferenceSegment    	Delim._look_ahead_match SI	    	[mq=[(<OneOf: [<Ref: DotSegment>, <Sequence: [<Ref: DotSegment>, <Ref: Dot...]>, 1, '.'), (<OneOf: [<Ref: DotSegment>, <Sequence: [<Ref: DotSegment>, <Ref: Dot...]>, 1, '.')], sb=['C', '.', 'ID']]
INFO       [PD:3  MD:24]	........................ColumnReferenceSegment    	OneOf.match PRN     	    	[ns=0, ps=0, ms=2, pruned=[], opts=[<Ref: DotSegment>, <Sequence: [<Ref: DotSegment>, <Ref: DotSegment>]>]]
DEBUG      [PD:3  MD:25]	.........................ColumnReferenceSegment   	Ref.match OUT       	+   	[match=<MatchResult 1/2: '.'>, seg="'.id'"]
DEBUG      [PD:3  MD:26]	..........................ColumnReferenceSegment  	Ref.match OUT       	+   	[match=<MatchResult 1/2: '.'>, seg="'.id'"]
DEBUG      [PD:3  MD:26]	..........................ColumnReferenceSegment  	Ref.match OUT       	    	[match=<MatchResult 0/1: ''>, seg="'id'"]
INFO       [PD:3  MD:25]	.........................ColumnReferenceSegment   	Seque.match OUT     	    	[match=<MatchResult 0/2: ''>, seg="'.id'"]
INFO       [PD:3  MD:24]	........................ColumnReferenceSegment    	OneOf.match OUT     	+   	[match=<MatchResult 1/2: '.'>, seg="'.id'"]
INFO       [PD:3  MD:24]	........................ColumnReferenceSegment    	OneOf.match PRN     	    	[ns=0, ps=0, ms=2, pruned=[], opts=[<Ref: DotSegment>, <Sequence: [<Ref: DotSegment>, <Ref: DotSegment>]>]]
DEBUG      [PD:3  MD:25]	.........................ColumnReferenceSegment   	Ref.match OUT       	+   	[match=<MatchResult 1/2: '.'>, seg="'.id'"]
DEBUG      [PD:3  MD:26]	..........................ColumnReferenceSegment  	Ref.match OUT       	+   	[match=<MatchResult 1/2: '.'>, seg="'.id'"]
DEBUG      [PD:3  MD:26]	..........................ColumnReferenceSegment  	Ref.match OUT       	    	[match=<MatchResult 0/1: ''>, seg="'id'"]
INFO       [PD:3  MD:25]	.........................ColumnReferenceSegment   	Seque.match OUT     	    	[match=<MatchResult 0/2: ''>, seg="'.id'"]
INFO       [PD:3  MD:24]	........................ColumnReferenceSegment    	OneOf.match OUT     	+   	[match=<MatchResult 1/2: '.'>, seg="'.id'"]
INFO       [PD:3  MD:24]	........................ColumnReferenceSegment    	OneOf.match PRN     	    	[ns=1, ps=10, ms=0, pruned=[<Ref: OnKeywordSegment>, <Ref: AsKeywordSegment>, <Ref: UsingKeywordSegment>, <Ref: CommaSegment>, <Ref: CastOperatorSegment>, <Ref: StartSquareBracketSegment>, <Ref: StartBracketSegment>, <Ref: ColonSegment>, <Ref: DelimiterSegment>, <class 'sqlfluff.core.parser.segments.base.BracketedSegment'>], opts=[<Ref: BinaryOperatorGrammar>]]
INFO       [PD:3  MD:25]	.........................BinaryOperatorGrammar    	OneOf.match PRN     	    	[ns=1, ps=3, ms=0, pruned=[<Ref: ArithmeticBinaryOperatorGrammar>, <Ref: StringBinaryOperatorGrammar>, <Ref: BooleanBinaryOperatorGrammar>], opts=[<Ref: ComparisonOperatorGrammar>]]
INFO       [PD:3  MD:26]	..........................ComparisonOperatorGrammar	OneOf.match PRN     	    	[ns=1, ps=7, ms=0, pruned=[<Ref: EqualsSegment>, <Ref: GreaterThanSegment>, <Ref: LessThanSegment>, <Ref: GreaterThanOrEqualToSegment>, <Ref: LessThanOrEqualToSegment>, <Ref: NotEqualToSegment_a>, <Ref: NotEqualToSegment_b>], opts=[<Ref: LikeOperatorSegment>]]
DEBUG      [PD:3  MD:27]	...........................ComparisonOperatorGrammar	Ref.match OUT       	    	[match=<MatchResult 0/3: ''>, seg="'c.id'"]
INFO       [PD:3  MD:26]	..........................ComparisonOperatorGrammar	OneOf.match OUT     	    	[match=<MatchResult 0/3: ''>, seg="'c.id'"]
DEBUG      [PD:3  MD:26]	..........................BinaryOperatorGrammar   	Ref.match OUT       	    	[match=<MatchResult 0/3: ''>, seg="'c.id'"]
INFO       [PD:3  MD:25]	.........................BinaryOperatorGrammar    	OneOf.match OUT     	    	[match=<MatchResult 0/3: ''>, seg="'c.id'"]
DEBUG      [PD:3  MD:25]	.........................ColumnReferenceSegment   	Ref.match OUT       	    	[match=<MatchResult 0/3: ''>, seg="'c.id'"]
INFO       [PD:3  MD:24]	........................ColumnReferenceSegment    	OneOf.match OUT     	    	[match=<MatchResult 0/3: ''>, seg="'c.id'"]
DEBUG      [PD:3  MD:24]	........................ColumnReferenceSegment    	NonCo.match OUT     	    	[match=<MatchResult 0/3: ''>, seg="'c.id'"]
INFO       [PD:3  MD:24]	........................ColumnReferenceSegment    	OneOf.match PRN     	    	[ns=1, ps=10, ms=0, pruned=[<Ref: OnKeywordSegment>, <Ref: AsKeywordSegment>, <Ref: UsingKeywordSegment>, <Ref: CommaSegment>, <Ref: CastOperatorSegment>, <Ref: StartSquareBracketSegment>, <Ref: StartBracketSegment>, <Ref: ColonSegment>, <Ref: DelimiterSegment>, <class 'sqlfluff.core.parser.segments.base.BracketedSegment'>], opts=[<Ref: BinaryOperatorGrammar>]]
INFO       [PD:3  MD:25]	.........................BinaryOperatorGrammar    	OneOf.match PRN     	    	[ns=1, ps=3, ms=0, pruned=[<Ref: ArithmeticBinaryOperatorGrammar>, <Ref: StringBinaryOperatorGrammar>, <Ref: BooleanBinaryOperatorGrammar>], opts=[<Ref: ComparisonOperatorGrammar>]]
INFO       [PD:3  MD:26]	..........................ComparisonOperatorGrammar	OneOf.match PRN     	    	[ns=1, ps=7, ms=0, pruned=[<Ref: EqualsSegment>, <Ref: GreaterThanSegment>, <Ref: LessThanSegment>, <Ref: GreaterThanOrEqualToSegment>, <Ref: LessThanOrEqualToSegment>, <Ref: NotEqualToSegment_a>, <Ref: NotEqualToSegment_b>], opts=[<Ref: LikeOperatorSegment>]]
DEBUG      [PD:3  MD:27]	...........................ComparisonOperatorGrammar	Ref.match OUT       	    	[match=<MatchResult 0/2: ''>, seg="'.id'"]
INFO       [PD:3  MD:26]	..........................ComparisonOperatorGrammar	OneOf.match OUT     	    	[match=<MatchResult 0/2: ''>, seg="'.id'"]
DEBUG      [PD:3  MD:26]	..........................BinaryOperatorGrammar   	Ref.match OUT       	    	[match=<MatchResult 0/2: ''>, seg="'.id'"]
INFO       [PD:3  MD:25]	.........................BinaryOperatorGrammar    	OneOf.match OUT     	    	[match=<MatchResult 0/2: ''>, seg="'.id'"]
DEBUG      [PD:3  MD:25]	.........................ColumnReferenceSegment   	Ref.match OUT       	    	[match=<MatchResult 0/2: ''>, seg="'.id'"]
INFO       [PD:3  MD:24]	........................ColumnReferenceSegment    	OneOf.match OUT     	    	[match=<MatchResult 0/2: ''>, seg="'.id'"]
DEBUG      [PD:3  MD:24]	........................ColumnReferenceSegment    	NonCo.match OUT     	    	[match=<MatchResult 0/2: ''>, seg="'.id'"]
INFO       [PD:3  MD:24]	........................SingleIdentifierGrammar   	OneOf.match PRN     	    	[ns=2, ps=0, ms=0, pruned=[], opts=[<Ref: NakedIdentifierSegment>, <Ref: QuotedIdentifierSegment>]]
DEBUG      [PD:3  MD:25]	.........................SingleIdentifierGrammar  	Ref.match OUT       	++  	[match=<MatchResult 1/1: 'c'>, seg="'c'"]
INFO       [PD:3  MD:24]	........................SingleIdentifierGrammar   	OneOf.match OUT     	++  	[match=<MatchResult 1/1: 'c'>, seg="'c'"]
DEBUG      [PD:3  MD:24]	........................ColumnReferenceSegment    	Ref.match OUT       	++  	[match=<MatchResult 1/1: 'c'>, seg="'c'"]
DEBUG      [PD:3  MD:24]	........................ColumnReferenceSegment    	Delim._look_ahead_match IN	    	[ls=1, seg='id']
DEBUG      [PD:3  MD:24]	........................ColumnReferenceSegment    	Delim._look_ahead_match SI	    	[mq=[], sb=['ID']]
INFO       [PD:3  MD:24]	........................ColumnReferenceSegment    	OneOf.match PRN     	    	[ns=1, ps=10, ms=0, pruned=[<Ref: OnKeywordSegment>, <Ref: AsKeywordSegment>, <Ref: UsingKeywordSegment>, <Ref: CommaSegment>, <Ref: CastOperatorSegment>, <Ref: StartSquareBracketSegment>, <Ref: StartBracketSegment>, <Ref: ColonSegment>, <Ref: DelimiterSegment>, <class 'sqlfluff.core.parser.segments.base.BracketedSegment'>], opts=[<Ref: BinaryOperatorGrammar>]]
INFO       [PD:3  MD:25]	.........................BinaryOperatorGrammar    	OneOf.match PRN     	    	[ns=1, ps=3, ms=0, pruned=[<Ref: ArithmeticBinaryOperatorGrammar>, <Ref: StringBinaryOperatorGrammar>, <Ref: BooleanBinaryOperatorGrammar>], opts=[<Ref: ComparisonOperatorGrammar>]]
INFO       [PD:3  MD:26]	..........................ComparisonOperatorGrammar	OneOf.match PRN     	    	[ns=1, ps=7, ms=0, pruned=[<Ref: EqualsSegment>, <Ref: GreaterThanSegment>, <Ref: LessThanSegment>, <Ref: GreaterThanOrEqualToSegment>, <Ref: LessThanOrEqualToSegment>, <Ref: NotEqualToSegment_a>, <Ref: NotEqualToSegment_b>], opts=[<Ref: LikeOperatorSegment>]]
DEBUG      [PD:3  MD:27]	...........................ComparisonOperatorGrammar	Ref.match OUT       	    	[match=<MatchResult 0/1: ''>, seg="'id'"]
INFO       [PD:3  MD:26]	..........................ComparisonOperatorGrammar	OneOf.match OUT     	    	[match=<MatchResult 0/1: ''>, seg="'id'"]
DEBUG      [PD:3  MD:26]	..........................BinaryOperatorGrammar   	Ref.match OUT       	    	[match=<MatchResult 0/1: ''>, seg="'id'"]
INFO       [PD:3  MD:25]	.........................BinaryOperatorGrammar    	OneOf.match OUT     	    	[match=<MatchResult 0/1: ''>, seg="'id'"]
DEBUG      [PD:3  MD:25]	.........................ColumnReferenceSegment   	Ref.match OUT       	    	[match=<MatchResult 0/1: ''>, seg="'id'"]
INFO       [PD:3  MD:24]	........................ColumnReferenceSegment    	OneOf.match OUT     	    	[match=<MatchResult 0/1: ''>, seg="'id'"]
DEBUG      [PD:3  MD:24]	........................ColumnReferenceSegment    	NonCo.match OUT     	    	[match=<MatchResult 0/1: ''>, seg="'id'"]
INFO       [PD:3  MD:24]	........................SingleIdentifierGrammar   	OneOf.match PRN     	    	[ns=2, ps=0, ms=0, pruned=[], opts=[<Ref: NakedIdentifierSegment>, <Ref: QuotedIdentifierSegment>]]
DEBUG      [PD:3  MD:25]	.........................SingleIdentifierGrammar  	Ref.match OUT       	++  	[match=<MatchResult 1/1: 'id'>, seg="'id'"]
INFO       [PD:3  MD:24]	........................SingleIdentifierGrammar   	OneOf.match OUT     	++  	[match=<MatchResult 1/1: 'id'>, seg="'id'"]
DEBUG      [PD:3  MD:24]	........................ColumnReferenceSegment    	Ref.match OUT       	++  	[match=<MatchResult 1/1: 'id'>, seg="'id'"]
INFO       [PD:3  MD:23]	.......................ColumnReferenceSegment     	Delim.match OUT     	++  	[match=<MatchResult 3/3: 'c.id'>, seg="'c.id'"]
DEBUG      [PD:3  MD:22]	......................ColumnReferenceSegment      	Colum.match OUT     	++  	[match=<MatchResult 1/1: 'c.id'>, seg="'c.id'"]
DEBUG      [PD:3  MD:22]	......................Expression_D_Grammar        	Ref.match OUT       	++  	[match=<MatchResult 1/1: 'c.id'>, seg="'c.id'"]
INFO       [PD:3  MD:21]	.....................Expression_D_Grammar         	OneOf.match OUT     	++  	[match=<MatchResult 1/1: 'c.id'>, seg="'c.id'"]
INFO       [PD:3  MD:20]	....................Expression_D_Grammar          	Seque.match OUT     	++  	[match=<MatchResult 1/1: 'c.id'>, seg="'c.id'"]
DEBUG      [PD:3  MD:20]	....................Expression_C_Grammar          	Ref.match OUT       	++  	[match=<MatchResult 1/1: 'c.id'>, seg="'c.id'"]
INFO       [PD:3  MD:19]	...................Expression_C_Grammar           	OneOf.match OUT     	++  	[match=<MatchResult 1/1: 'c.id'>, seg="'c.id'"]
DEBUG      [PD:3  MD:19]	...................Expression_A_Grammar           	Ref.match OUT       	++  	[match=<MatchResult 1/1: 'c.id'>, seg="'c.id'"]
INFO       [PD:3  MD:18]	..................Expression_A_Grammar            	Seque.match OUT     	++  	[match=<MatchResult 3/3: '= c.id'>, seg="'= c.id'"]
INFO       [PD:3  MD:17]	.................Expression_A_Grammar             	OneOf.match OUT     	++  	[match=<MatchResult 3/3: '= c.id'>, seg="'= c.id'"]
INFO       [PD:3  MD:16]	................Expression_A_Grammar              	AnyNu.match OUT     	++  	[match=<MatchResult 3/3: '= c.id'>, seg="'= c.id'"]
INFO       [PD:3  MD:15]	...............Expression_A_Grammar               	Seque.match OUT     	++  	[match=<MatchResult 5/5: 'tbl.id = c.id'>, seg="'tbl.id = c.id'"]
DEBUG      [PD:3  MD:15]	...............ExpressionSegment                  	Ref.match OUT       	++  	[match=<MatchResult 5/5: 'tbl.id = c.id'>, seg="'tbl.id = c.id'"]
DEBUG      [PD:3  MD:14]	..............ExpressionSegment                   	Expre.match OUT     	++  	[match=<MatchResult 1/1: 'tbl.id = c.id'>, seg="'tbl.id = c.id'"]
DEBUG      [PD:3  MD:14]	..............JoinOnConditionSegment              	Ref.match OUT       	++  	[match=<MatchResult 1/1: 'tbl.id = c.id'>, seg="'tbl.id = c.id'"]
INFO       [PD:3  MD:13]	.............JoinOnConditionSegment               	Brack.match OUT     	++  	[match=<MatchResult 1/1: 'tbl.id = c.id'>, seg="'tbl.id = c.id'"]
INFO       [PD:3  MD:12]	............JoinOnConditionSegment                	Brack.match OUT     	+   	[match=<MatchResult 1/11: '(tbl.id = c.id)'>, seg="'(tbl.id = c.id)\\nLEFT...'"]
INFO       [PD:3  MD:14]	..............Expression_A_Grammar                	OneOf.match PRN     	    	[ns=1, ps=1, ms=0, pruned=[<Sequence: [<OneOf: [<Ref: PositiveSegment>, <Ref: N..., <Ref: Expression_C_Grammar>]>], opts=[<Ref: Expression_C_Grammar>]]
INFO       [PD:3  MD:15]	...............Expression_C_Grammar               	OneOf.match PRN     	    	[ns=1, ps=2, ms=0, pruned=[<Sequence: [<Ref: ExistsKeywordSegment>, <Bracketed: [<Ref: SelectStatementSegmen...]>, <Ref: CaseExpressionSegment>], opts=[<Ref: Expression_D_Grammar>]]
INFO       [PD:3  MD:17]	.................Expression_D_Grammar             	OneOf.match PRN     	    	[ns=6, ps=2, ms=1, pruned=[<Ref: SelectStatementSegment>, <Ref: IntervalExpressionSegment>], opts=[<Ref: BareFunctionSegment>, <Ref: FunctionSegment>, <Bracketed: [<OneOf: [<Ref: ExpressionSegment>, <Ref:...]>, <Ref: LiteralGrammar>, <Ref: ColumnReferenceSegment>, <Sequence: [<Ref: SimpleArrayTypeGrammar [opt]>, <Ref: ArrayLiteralSegment>]>, <Sequence: [<Ref: DatatypeSegment>, <OneOf: [<Ref: QuotedLiteralSegment>, <R...]>]]
DEBUG      [PD:3  MD:18]	..................Expression_D_Grammar            	Ref.match OUT       	    	[match=<MatchResult 0/11: ''>, seg="'(tbl.id = c.id)\\nLEFT...'"]
INFO       [PD:3  MD:19]	...................FunctionSegment                	OneOf.match PRN     	    	[ns=1, ps=1, ms=0, pruned=[<Sequence: [<Sequence: [<Ref: DateAddFunctionNameSeg...]>], opts=[<Sequence: [<Sequence: [<AnyNumberOf: [<Ref: Functio..., <Ref: PostFunctionGrammar [opt]>]>]]
DEBUG      [PD:3  MD:25]	.........................DateAddFunctionNameSegment	Ref.match OUT       	    	[match=<MatchResult 0/11: ''>, seg="'(tbl.id = c.id)\\nLEFT...'"]
INFO       [PD:3  MD:24]	........................DateAddFunctionNameSegment	Seque.match OUT     	    	[match=<MatchResult 0/11: ''>, seg="'(tbl.id = c.id)\\nLEFT...'"]
DEBUG      [PD:3  MD:23]	.......................DateAddFunctionNameSegment 	DateA.match OUT     	    	[match=<MatchResult 0/11: ''>, seg="'(tbl.id = c.id)\\nLEFT...'"]
DEBUG      [PD:3  MD:23]	.......................FunctionSegment            	Ref.match OUT       	    	[match=<MatchResult 0/11: ''>, seg="'(tbl.id = c.id)\\nLEFT...'"]
INFO       [PD:3  MD:22]	......................FunctionSegment             	AnyNu.match PRN     	    	[ns=1, ps=0, ms=0, pruned=[], opts=[<Ref: FunctionNameSegment>]]
INFO       [PD:3  MD:25]	.........................FunctionNameSegment      	AnyNu.match PRN     	    	[ns=1, ps=0, ms=0, pruned=[], opts=[<Sequence: [<Ref: SingleIdentifierGrammar>, <Ref: DotSegment>]>]]
INFO       [PD:3  MD:27]	...........................SingleIdentifierGrammar	OneOf.match PRN     	    	[ns=2, ps=0, ms=0, pruned=[], opts=[<Ref: NakedIdentifierSegment>, <Ref: QuotedIdentifierSegment>]]
DEBUG      [PD:3  MD:28]	............................SingleIdentifierGrammar	Ref.match OUT       	    	[match=<MatchResult 0/11: ''>, seg="'(tbl.id = c.id)\\nLEFT...'"]
DEBUG      [PD:3  MD:28]	............................SingleIdentifierGrammar	Ref.match OUT       	    	[match=<MatchResult 0/11: ''>, seg="'(tbl.id = c.id)\\nLEFT...'"]
INFO       [PD:3  MD:27]	...........................SingleIdentifierGrammar	OneOf.match OUT     	    	[match=<MatchResult 0/11: ''>, seg="'(tbl.id = c.id)\\nLEFT...'"]
DEBUG      [PD:3  MD:27]	...........................FunctionNameSegment    	Ref.match OUT       	    	[match=<MatchResult 0/11: ''>, seg="'(tbl.id = c.id)\\nLEFT...'"]
INFO       [PD:3  MD:26]	..........................FunctionNameSegment     	Seque.match OUT     	    	[match=<MatchResult 0/11: ''>, seg="'(tbl.id = c.id)\\nLEFT...'"]
INFO       [PD:3  MD:25]	.........................FunctionNameSegment      	AnyNu.match OUT     	    	[match=<MatchResult 0/11: ''>, seg="'(tbl.id = c.id)\\nLEFT...'"]
INFO       [PD:3  MD:25]	.........................FunctionNameSegment      	OneOf.match PRN     	    	[ns=2, ps=0, ms=0, pruned=[], opts=[<Ref: FunctionNameIdentifierSegment>, <Ref: QuotedIdentifierSegment>]]
DEBUG      [PD:3  MD:26]	..........................FunctionNameSegment     	Ref.match OUT       	    	[match=<MatchResult 0/11: ''>, seg="'(tbl.id = c.id)\\nLEFT...'"]
DEBUG      [PD:3  MD:26]	..........................FunctionNameSegment     	Ref.match OUT       	    	[match=<MatchResult 0/11: ''>, seg="'(tbl.id = c.id)\\nLEFT...'"]
INFO       [PD:3  MD:25]	.........................FunctionNameSegment      	OneOf.match OUT     	    	[match=<MatchResult 0/11: ''>, seg="'(tbl.id = c.id)\\nLEFT...'"]
INFO       [PD:3  MD:24]	........................FunctionNameSegment       	Seque.match OUT     	    	[match=<MatchResult 0/11: ''>, seg="'(tbl.id = c.id)\\nLEFT...'"]
DEBUG      [PD:3  MD:23]	.......................FunctionNameSegment        	Funct.match OUT     	    	[match=<MatchResult 0/11: ''>, seg="'(tbl.id = c.id)\\nLEFT...'"]
DEBUG      [PD:3  MD:23]	.......................FunctionSegment            	Ref.match OUT       	    	[match=<MatchResult 0/11: ''>, seg="'(tbl.id = c.id)\\nLEFT...'"]
INFO       [PD:3  MD:22]	......................FunctionSegment             	AnyNu.match OUT     	    	[match=<MatchResult 0/11: ''>, seg="'(tbl.id = c.id)\\nLEFT...'"]
INFO       [PD:3  MD:21]	.....................FunctionSegment              	Seque.match OUT     	    	[match=<MatchResult 0/11: ''>, seg="'(tbl.id = c.id)\\nLEFT...'"]
INFO       [PD:3  MD:20]	....................FunctionSegment               	Seque.match OUT     	    	[match=<MatchResult 0/11: ''>, seg="'(tbl.id = c.id)\\nLEFT...'"]
INFO       [PD:3  MD:19]	...................FunctionSegment                	OneOf.match OUT     	    	[match=<MatchResult 0/11: ''>, seg="'(tbl.id = c.id)\\nLEFT...'"]
DEBUG      [PD:3  MD:18]	..................FunctionSegment                 	Funct.match OUT     	    	[match=<MatchResult 0/11: ''>, seg="'(tbl.id = c.id)\\nLEFT...'"]
DEBUG      [PD:3  MD:18]	..................Expression_D_Grammar            	Ref.match OUT       	    	[match=<MatchResult 0/11: ''>, seg="'(tbl.id = c.id)\\nLEFT...'"]
INFO       [PD:3  MD:20]	....................Expression_D_Grammar          	OneOf.match OUT     	++  	[match=<MatchResult 1/1: 'tbl.id = c.id'>, seg="'tbl.id = c.id'"]
INFO       [PD:3  MD:19]	...................Expression_D_Grammar           	Brack.match OUT     	++  	[match=<MatchResult 1/1: 'tbl.id = c.id'>, seg="'tbl.id = c.id'"]
INFO       [PD:3  MD:18]	..................Expression_D_Grammar            	Brack.match OUT     	+   	[match=<MatchResult 1/11: '(tbl.id = c.id)'>, seg="'(tbl.id = c.id)\\nLEFT...'"]
INFO       [PD:3  MD:18]	..................LiteralGrammar                  	OneOf.match PRN     	    	[ns=2, ps=4, ms=0, pruned=[<Ref: BooleanLiteralGrammar>, <Ref: QualifiedNumericLiteralSegment>, <Ref: NullLiteralSegment>, <Ref: DateTimeLiteralGrammar>], opts=[<Ref: QuotedLiteralSegment>, <Ref: NumericLiteralSegment>]]
DEBUG      [PD:3  MD:19]	...................LiteralGrammar                 	Ref.match OUT       	    	[match=<MatchResult 0/11: ''>, seg="'(tbl.id = c.id)\\nLEFT...'"]
DEBUG      [PD:3  MD:19]	...................LiteralGrammar                 	Ref.match OUT       	    	[match=<MatchResult 0/11: ''>, seg="'(tbl.id = c.id)\\nLEFT...'"]
INFO       [PD:3  MD:18]	..................LiteralGrammar                  	OneOf.match OUT     	    	[match=<MatchResult 0/11: ''>, seg="'(tbl.id = c.id)\\nLEFT...'"]
DEBUG      [PD:3  MD:18]	..................Expression_D_Grammar            	Ref.match OUT       	    	[match=<MatchResult 0/11: ''>, seg="'(tbl.id = c.id)\\nLEFT...'"]
DEBUG      [PD:3  MD:20]	....................ColumnReferenceSegment        	Delim._look_ahead_match IN	    	[ls=11, seg='(tbl.id = c.id)\nLEFT...']
DEBUG      [PD:3  MD:20]	....................ColumnReferenceSegment        	Delim._look_ahead_match SI	    	[mq=[], sb=['(TBL.ID', '', 'LEFT', '', 'JOIN', '', 'D', '', 'ON', '', '(TBL.ID']]
INFO       [PD:3  MD:20]	....................ColumnReferenceSegment        	OneOf.match PRN     	    	[ns=1, ps=8, ms=2, pruned=[<Ref: OnKeywordSegment>, <Ref: AsKeywordSegment>, <Ref: UsingKeywordSegment>, <Ref: CommaSegment>, <Ref: CastOperatorSegment>, <Ref: StartSquareBracketSegment>, <Ref: ColonSegment>, <Ref: DelimiterSegment>], opts=[<Ref: StartBracketSegment>, <Ref: BinaryOperatorGrammar>, <class 'sqlfluff.core.parser.segments.base.BracketedSegment'>]]
DEBUG      [PD:3  MD:21]	.....................ColumnReferenceSegment       	Ref.match OUT       	    	[match=<MatchResult 0/11: ''>, seg="'(tbl.id = c.id)\\nLEFT...'"]
INFO       [PD:3  MD:21]	.....................BinaryOperatorGrammar        	OneOf.match PRN     	    	[ns=1, ps=3, ms=0, pruned=[<Ref: ArithmeticBinaryOperatorGrammar>, <Ref: StringBinaryOperatorGrammar>, <Ref: BooleanBinaryOperatorGrammar>], opts=[<Ref: ComparisonOperatorGrammar>]]
INFO       [PD:3  MD:22]	......................ComparisonOperatorGrammar   	OneOf.match PRN     	    	[ns=1, ps=7, ms=0, pruned=[<Ref: EqualsSegment>, <Ref: GreaterThanSegment>, <Ref: LessThanSegment>, <Ref: GreaterThanOrEqualToSegment>, <Ref: LessThanOrEqualToSegment>, <Ref: NotEqualToSegment_a>, <Ref: NotEqualToSegment_b>], opts=[<Ref: LikeOperatorSegment>]]
DEBUG      [PD:3  MD:23]	.......................ComparisonOperatorGrammar  	Ref.match OUT       	    	[match=<MatchResult 0/11: ''>, seg="'(tbl.id = c.id)\\nLEFT...'"]
INFO       [PD:3  MD:22]	......................ComparisonOperatorGrammar   	OneOf.match OUT     	    	[match=<MatchResult 0/11: ''>, seg="'(tbl.id = c.id)\\nLEFT...'"]
DEBUG      [PD:3  MD:22]	......................BinaryOperatorGrammar       	Ref.match OUT       	    	[match=<MatchResult 0/11: ''>, seg="'(tbl.id = c.id)\\nLEFT...'"]
INFO       [PD:3  MD:21]	.....................BinaryOperatorGrammar        	OneOf.match OUT     	    	[match=<MatchResult 0/11: ''>, seg="'(tbl.id = c.id)\\nLEFT...'"]
DEBUG      [PD:3  MD:21]	.....................ColumnReferenceSegment       	Ref.match OUT       	    	[match=<MatchResult 0/11: ''>, seg="'(tbl.id = c.id)\\nLEFT...'"]
INFO       [PD:3  MD:20]	....................ColumnReferenceSegment        	OneOf.match OUT     	+   	[match=<MatchResult 1/11: '(tbl.id = c.id)'>, seg="'(tbl.id = c.id)\\nLEFT...'"]
DEBUG      [PD:3  MD:20]	....................ColumnReferenceSegment        	NonCo.match OUT     	    	[match=<MatchResult 0/11: ''>, seg="'(tbl.id = c.id)\\nLEFT...'"]
INFO       [PD:3  MD:19]	...................ColumnReferenceSegment         	Delim.match OUT     	    	[match=<MatchResult 0/11: ''>, seg="'(tbl.id = c.id)\\nLEFT...'"]
DEBUG      [PD:3  MD:18]	..................ColumnReferenceSegment          	Colum.match OUT     	    	[match=<MatchResult 0/11: ''>, seg="'(tbl.id = c.id)\\nLEFT...'"]
DEBUG      [PD:3  MD:18]	..................Expression_D_Grammar            	Ref.match OUT       	    	[match=<MatchResult 0/11: ''>, seg="'(tbl.id = c.id)\\nLEFT...'"]
DEBUG      [PD:3  MD:19]	...................Expression_D_Grammar           	Ref.match OUT       	    	[match=<MatchResult 0/11: ''>, seg="'(tbl.id = c.id)\\nLEFT...'"]
DEBUG      [PD:3  MD:23]	.......................ArrayLiteralSegment        	Delim._look_ahead_match IN	    	[ls=1, seg='tbl.id = c.id']
DEBUG      [PD:3  MD:23]	.......................ArrayLiteralSegment        	Delim._look_ahead_match SI	    	[mq=[], sb=['TBL.ID']]
DEBUG      [PD:3  MD:23]	.......................ArrayLiteralSegment        	Delim._look_ahead_match SC	    	[bsm=None]
INFO       [PD:3  MD:25]	.........................Expression_A_Grammar     	OneOf.match PRN     	    	[ns=1, ps=1, ms=0, pruned=[<Sequence: [<OneOf: [<Ref: PositiveSegment>, <Ref: N..., <Ref: Expression_C_Grammar>]>], opts=[<Ref: Expression_C_Grammar>]]
INFO       [PD:3  MD:26]	..........................Expression_C_Grammar    	OneOf.match PRN     	    	[ns=1, ps=2, ms=0, pruned=[<Sequence: [<Ref: ExistsKeywordSegment>, <Bracketed: [<Ref: SelectStatementSegmen...]>, <Ref: CaseExpressionSegment>], opts=[<Ref: Expression_D_Grammar>]]
INFO       [PD:3  MD:28]	............................Expression_D_Grammar  	OneOf.match PRN     	    	[ns=6, ps=3, ms=0, pruned=[<Bracketed: [<OneOf: [<Ref: ExpressionSegment>, <Ref:...]>, <Ref: SelectStatementSegment>, <Ref: IntervalExpressionSegment>], opts=[<Ref: BareFunctionSegment>, <Ref: FunctionSegment>, <Ref: LiteralGrammar>, <Ref: ColumnReferenceSegment>, <Sequence: [<Ref: SimpleArrayTypeGrammar [opt]>, <Ref: ArrayLiteralSegment>]>, <Sequence: [<Ref: DatatypeSegment>, <OneOf: [<Ref: QuotedLiteralSegment>, <R...]>]]
DEBUG      [PD:3  MD:29]	.............................Expression_D_Grammar 	Ref.match OUT       	    	[match=<MatchResult 0/1: ''>, seg="'tbl.id = c.id'"]
INFO       [PD:3  MD:30]	..............................FunctionSegment     	OneOf.match PRN     	    	[ns=1, ps=1, ms=0, pruned=[<Sequence: [<Sequence: [<Ref: DateAddFunctionNameSeg...]>], opts=[<Sequence: [<Sequence: [<AnyNumberOf: [<Ref: Functio..., <Ref: PostFunctionGrammar [opt]>]>]]
DEBUG      [PD:3  MD:36]	....................................DateAddFunctionNameSegment	Ref.match OUT       	    	[match=<MatchResult 0/1: ''>, seg="'tbl.id = c.id'"]
INFO       [PD:3  MD:35]	...................................DateAddFunctionNameSegment	Seque.match OUT     	    	[match=<MatchResult 0/1: ''>, seg="'tbl.id = c.id'"]
DEBUG      [PD:3  MD:34]	..................................DateAddFunctionNameSegment	DateA.match OUT     	    	[match=<MatchResult 0/1: ''>, seg="'tbl.id = c.id'"]
DEBUG      [PD:3  MD:34]	..................................FunctionSegment 	Ref.match OUT       	    	[match=<MatchResult 0/1: ''>, seg="'tbl.id = c.id'"]
INFO       [PD:3  MD:33]	.................................FunctionSegment  	AnyNu.match PRN     	    	[ns=1, ps=0, ms=0, pruned=[], opts=[<Ref: FunctionNameSegment>]]
INFO       [PD:3  MD:36]	....................................FunctionNameSegment	AnyNu.match PRN     	    	[ns=1, ps=0, ms=0, pruned=[], opts=[<Sequence: [<Ref: SingleIdentifierGrammar>, <Ref: DotSegment>]>]]
INFO       [PD:3  MD:38]	......................................SingleIdentifierGrammar	OneOf.match PRN     	    	[ns=2, ps=0, ms=0, pruned=[], opts=[<Ref: NakedIdentifierSegment>, <Ref: QuotedIdentifierSegment>]]
DEBUG      [PD:3  MD:39]	.......................................SingleIdentifierGrammar	Ref.match OUT       	    	[match=<MatchResult 0/1: ''>, seg="'tbl.id = c.id'"]
DEBUG      [PD:3  MD:39]	.......................................SingleIdentifierGrammar	Ref.match OUT       	    	[match=<MatchResult 0/1: ''>, seg="'tbl.id = c.id'"]
INFO       [PD:3  MD:38]	......................................SingleIdentifierGrammar	OneOf.match OUT     	    	[match=<MatchResult 0/1: ''>, seg="'tbl.id = c.id'"]
DEBUG      [PD:3  MD:38]	......................................FunctionNameSegment	Ref.match OUT       	    	[match=<MatchResult 0/1: ''>, seg="'tbl.id = c.id'"]
INFO       [PD:3  MD:37]	.....................................FunctionNameSegment	Seque.match OUT     	    	[match=<MatchResult 0/1: ''>, seg="'tbl.id = c.id'"]
INFO       [PD:3  MD:36]	....................................FunctionNameSegment	AnyNu.match OUT     	    	[match=<MatchResult 0/1: ''>, seg="'tbl.id = c.id'"]
INFO       [PD:3  MD:36]	....................................FunctionNameSegment	OneOf.match PRN     	    	[ns=2, ps=0, ms=0, pruned=[], opts=[<Ref: FunctionNameIdentifierSegment>, <Ref: QuotedIdentifierSegment>]]
DEBUG      [PD:3  MD:37]	.....................................FunctionNameSegment	Ref.match OUT       	    	[match=<MatchResult 0/1: ''>, seg="'tbl.id = c.id'"]
DEBUG      [PD:3  MD:37]	.....................................FunctionNameSegment	Ref.match OUT       	    	[match=<MatchResult 0/1: ''>, seg="'tbl.id = c.id'"]
INFO       [PD:3  MD:36]	....................................FunctionNameSegment	OneOf.match OUT     	    	[match=<MatchResult 0/1: ''>, seg="'tbl.id = c.id'"]
INFO       [PD:3  MD:35]	...................................FunctionNameSegment	Seque.match OUT     	    	[match=<MatchResult 0/1: ''>, seg="'tbl.id = c.id'"]
DEBUG      [PD:3  MD:34]	..................................FunctionNameSegment	Funct.match OUT     	    	[match=<MatchResult 0/1: ''>, seg="'tbl.id = c.id'"]
DEBUG      [PD:3  MD:34]	..................................FunctionSegment 	Ref.match OUT       	    	[match=<MatchResult 0/1: ''>, seg="'tbl.id = c.id'"]
INFO       [PD:3  MD:33]	.................................FunctionSegment  	AnyNu.match OUT     	    	[match=<MatchResult 0/1: ''>, seg="'tbl.id = c.id'"]
INFO       [PD:3  MD:32]	................................FunctionSegment   	Seque.match OUT     	    	[match=<MatchResult 0/1: ''>, seg="'tbl.id = c.id'"]
INFO       [PD:3  MD:31]	...............................FunctionSegment    	Seque.match OUT     	    	[match=<MatchResult 0/1: ''>, seg="'tbl.id = c.id'"]
INFO       [PD:3  MD:30]	..............................FunctionSegment     	OneOf.match OUT     	    	[match=<MatchResult 0/1: ''>, seg="'tbl.id = c.id'"]
DEBUG      [PD:3  MD:29]	.............................FunctionSegment      	Funct.match OUT     	    	[match=<MatchResult 0/1: ''>, seg="'tbl.id = c.id'"]
DEBUG      [PD:3  MD:29]	.............................Expression_D_Grammar 	Ref.match OUT       	    	[match=<MatchResult 0/1: ''>, seg="'tbl.id = c.id'"]
INFO       [PD:3  MD:29]	.............................LiteralGrammar       	OneOf.match PRN     	    	[ns=2, ps=4, ms=0, pruned=[<Ref: BooleanLiteralGrammar>, <Ref: QualifiedNumericLiteralSegment>, <Ref: NullLiteralSegment>, <Ref: DateTimeLiteralGrammar>], opts=[<Ref: QuotedLiteralSegment>, <Ref: NumericLiteralSegment>]]
DEBUG      [PD:3  MD:30]	..............................LiteralGrammar      	Ref.match OUT       	    	[match=<MatchResult 0/1: ''>, seg="'tbl.id = c.id'"]
DEBUG      [PD:3  MD:30]	..............................LiteralGrammar      	Ref.match OUT       	    	[match=<MatchResult 0/1: ''>, seg="'tbl.id = c.id'"]
INFO       [PD:3  MD:29]	.............................LiteralGrammar       	OneOf.match OUT     	    	[match=<MatchResult 0/1: ''>, seg="'tbl.id = c.id'"]
DEBUG      [PD:3  MD:29]	.............................Expression_D_Grammar 	Ref.match OUT       	    	[match=<MatchResult 0/1: ''>, seg="'tbl.id = c.id'"]
DEBUG      [PD:3  MD:31]	...............................ColumnReferenceSegment	Delim._look_ahead_match IN	    	[ls=1, seg='tbl.id = c.id']
DEBUG      [PD:3  MD:31]	...............................ColumnReferenceSegment	Delim._look_ahead_match SI	    	[mq=[], sb=['TBL.ID']]
INFO       [PD:3  MD:31]	...............................ColumnReferenceSegment	OneOf.match PRN     	    	[ns=1, ps=10, ms=0, pruned=[<Ref: OnKeywordSegment>, <Ref: AsKeywordSegment>, <Ref: UsingKeywordSegment>, <Ref: CommaSegment>, <Ref: CastOperatorSegment>, <Ref: StartSquareBracketSegment>, <Ref: StartBracketSegment>, <Ref: ColonSegment>, <Ref: DelimiterSegment>, <class 'sqlfluff.core.parser.segments.base.BracketedSegment'>], opts=[<Ref: BinaryOperatorGrammar>]]
INFO       [PD:3  MD:32]	................................BinaryOperatorGrammar	OneOf.match PRN     	    	[ns=1, ps=3, ms=0, pruned=[<Ref: ArithmeticBinaryOperatorGrammar>, <Ref: StringBinaryOperatorGrammar>, <Ref: BooleanBinaryOperatorGrammar>], opts=[<Ref: ComparisonOperatorGrammar>]]
INFO       [PD:3  MD:33]	.................................ComparisonOperatorGrammar	OneOf.match PRN     	    	[ns=1, ps=7, ms=0, pruned=[<Ref: EqualsSegment>, <Ref: GreaterThanSegment>, <Ref: LessThanSegment>, <Ref: GreaterThanOrEqualToSegment>, <Ref: LessThanOrEqualToSegment>, <Ref: NotEqualToSegment_a>, <Ref: NotEqualToSegment_b>], opts=[<Ref: LikeOperatorSegment>]]
DEBUG      [PD:3  MD:34]	..................................ComparisonOperatorGrammar	Ref.match OUT       	    	[match=<MatchResult 0/1: ''>, seg="'tbl.id = c.id'"]
INFO       [PD:3  MD:33]	.................................ComparisonOperatorGrammar	OneOf.match OUT     	    	[match=<MatchResult 0/1: ''>, seg="'tbl.id = c.id'"]
DEBUG      [PD:3  MD:33]	.................................BinaryOperatorGrammar	Ref.match OUT       	    	[match=<MatchResult 0/1: ''>, seg="'tbl.id = c.id'"]
INFO       [PD:3  MD:32]	................................BinaryOperatorGrammar	OneOf.match OUT     	    	[match=<MatchResult 0/1: ''>, seg="'tbl.id = c.id'"]
DEBUG      [PD:3  MD:32]	................................ColumnReferenceSegment	Ref.match OUT       	    	[match=<MatchResult 0/1: ''>, seg="'tbl.id = c.id'"]
INFO       [PD:3  MD:31]	...............................ColumnReferenceSegment	OneOf.match OUT     	    	[match=<MatchResult 0/1: ''>, seg="'tbl.id = c.id'"]
DEBUG      [PD:3  MD:31]	...............................ColumnReferenceSegment	NonCo.match OUT     	    	[match=<MatchResult 0/1: ''>, seg="'tbl.id = c.id'"]
INFO       [PD:3  MD:31]	...............................SingleIdentifierGrammar	OneOf.match PRN     	    	[ns=2, ps=0, ms=0, pruned=[], opts=[<Ref: NakedIdentifierSegment>, <Ref: QuotedIdentifierSegment>]]
DEBUG      [PD:3  MD:32]	................................SingleIdentifierGrammar	Ref.match OUT       	    	[match=<MatchResult 0/1: ''>, seg="'tbl.id = c.id'"]
DEBUG      [PD:3  MD:32]	................................SingleIdentifierGrammar	Ref.match OUT       	    	[match=<MatchResult 0/1: ''>, seg="'tbl.id = c.id'"]
INFO       [PD:3  MD:31]	...............................SingleIdentifierGrammar	OneOf.match OUT     	    	[match=<MatchResult 0/1: ''>, seg="'tbl.id = c.id'"]
DEBUG      [PD:3  MD:31]	...............................ColumnReferenceSegment	Ref.match OUT       	    	[match=<MatchResult 0/1: ''>, seg="'tbl.id = c.id'"]
INFO       [PD:3  MD:30]	..............................ColumnReferenceSegment	Delim.match OUT     	    	[match=<MatchResult 0/1: ''>, seg="'tbl.id = c.id'"]
DEBUG      [PD:3  MD:29]	.............................ColumnReferenceSegment	Colum.match OUT     	    	[match=<MatchResult 0/1: ''>, seg="'tbl.id = c.id'"]
DEBUG      [PD:3  MD:29]	.............................Expression_D_Grammar 	Ref.match OUT       	    	[match=<MatchResult 0/1: ''>, seg="'tbl.id = c.id'"]
DEBUG      [PD:3  MD:30]	..............................Expression_D_Grammar	Ref.match OUT       	    	[match=<MatchResult 0/1: ''>, seg="'tbl.id = c.id'"]
INFO       [PD:3  MD:31]	...............................ArrayLiteralSegment	Brack.match OUT     	    	[match=<MatchResult 0/1: ''>, seg="'tbl.id = c.id'"]
DEBUG      [PD:3  MD:30]	..............................ArrayLiteralSegment 	Array.match OUT     	    	[match=<MatchResult 0/1: ''>, seg="'tbl.id = c.id'"]
DEBUG      [PD:3  MD:30]	..............................Expression_D_Grammar	Ref.match OUT       	    	[match=<MatchResult 0/1: ''>, seg="'tbl.id = c.id'"]
INFO       [PD:3  MD:29]	.............................Expression_D_Grammar 	Seque.match OUT     	    	[match=<MatchResult 0/1: ''>, seg="'tbl.id = c.id'"]
INFO       [PD:3  MD:31]	...............................DatatypeSegment    	OneOf.match PRN     	    	[ns=1, ps=2, ms=0, pruned=[<Sequence: [<OneOf: [<Ref: TimeKeywordSegment>, <Ref..., <Bracketed: [<Ref: NumericLiteralSegment..., <Sequence:...]>, <Sequence: [<Ref: DoubleKeywordSegment>, <Ref: PrecisionKeywordSegment>]>], opts=[<Sequence: [<OneOf: [<Sequence: [<OneOf: [<Ref: Char..., <Bracketed: [<OneOf: [<Delimited: [<Ref:..., <Ref: Char...]>]]
INFO       [PD:3  MD:33]	.................................DatatypeSegment  	OneOf.match PRN     	    	[ns=1, ps=1, ms=0, pruned=[<Sequence: [<OneOf: [<Ref: CharacterKeywordSegment>,..., <OneOf: [<Ref: VaryingKeywordSegment>, <...]>], opts=[<Sequence: [<Sequence: [<Ref: SingleIdentifierGramma..., <Ref: DatatypeIdentifierSegment>]>]]
INFO       [PD:3  MD:36]	....................................SingleIdentifierGrammar	OneOf.match PRN     	    	[ns=2, ps=0, ms=0, pruned=[], opts=[<Ref: NakedIdentifierSegment>, <Ref: QuotedIdentifierSegment>]]
DEBUG      [PD:3  MD:37]	.....................................SingleIdentifierGrammar	Ref.match OUT       	    	[match=<MatchResult 0/1: ''>, seg="'tbl.id = c.id'"]
DEBUG      [PD:3  MD:37]	.....................................SingleIdentifierGrammar	Ref.match OUT       	    	[match=<MatchResult 0/1: ''>, seg="'tbl.id = c.id'"]
INFO       [PD:3  MD:36]	....................................SingleIdentifierGrammar	OneOf.match OUT     	    	[match=<MatchResult 0/1: ''>, seg="'tbl.id = c.id'"]
DEBUG      [PD:3  MD:36]	....................................DatatypeSegment	Ref.match OUT       	    	[match=<MatchResult 0/1: ''>, seg="'tbl.id = c.id'"]
INFO       [PD:3  MD:35]	...................................DatatypeSegment	Seque.match OUT     	    	[match=<MatchResult 0/1: ''>, seg="'tbl.id = c.id'"]
DEBUG      [PD:3  MD:35]	...................................DatatypeSegment	Ref.match OUT       	    	[match=<MatchResult 0/1: ''>, seg="'tbl.id = c.id'"]
INFO       [PD:3  MD:34]	..................................DatatypeSegment 	Seque.match OUT     	    	[match=<MatchResult 0/1: ''>, seg="'tbl.id = c.id'"]
INFO       [PD:3  MD:33]	.................................DatatypeSegment  	OneOf.match OUT     	    	[match=<MatchResult 0/1: ''>, seg="'tbl.id = c.id'"]
INFO       [PD:3  MD:32]	................................DatatypeSegment   	Seque.match OUT     	    	[match=<MatchResult 0/1: ''>, seg="'tbl.id = c.id'"]
INFO       [PD:3  MD:31]	...............................DatatypeSegment    	OneOf.match OUT     	    	[match=<MatchResult 0/1: ''>, seg="'tbl.id = c.id'"]
DEBUG      [PD:3  MD:30]	..............................DatatypeSegment     	Datat.match OUT     	    	[match=<MatchResult 0/1: ''>, seg="'tbl.id = c.id'"]
DEBUG      [PD:3  MD:30]	..............................Expression_D_Grammar	Ref.match OUT       	    	[match=<MatchResult 0/1: ''>, seg="'tbl.id = c.id'"]
INFO       [PD:3  MD:29]	.............................Expression_D_Grammar 	Seque.match OUT     	    	[match=<MatchResult 0/1: ''>, seg="'tbl.id = c.id'"]
INFO       [PD:3  MD:28]	............................Expression_D_Grammar  	OneOf.match OUT     	    	[match=<MatchResult 0/1: ''>, seg="'tbl.id = c.id'"]
INFO       [PD:3  MD:27]	...........................Expression_D_Grammar   	Seque.match OUT     	    	[match=<MatchResult 0/1: ''>, seg="'tbl.id = c.id'"]
DEBUG      [PD:3  MD:27]	...........................Expression_C_Grammar   	Ref.match OUT       	    	[match=<MatchResult 0/1: ''>, seg="'tbl.id = c.id'"]
INFO       [PD:3  MD:26]	..........................Expression_C_Grammar    	OneOf.match OUT     	    	[match=<MatchResult 0/1: ''>, seg="'tbl.id = c.id'"]
DEBUG      [PD:3  MD:26]	..........................Expression_A_Grammar    	Ref.match OUT       	    	[match=<MatchResult 0/1: ''>, seg="'tbl.id = c.id'"]
INFO       [PD:3  MD:25]	.........................Expression_A_Grammar     	OneOf.match OUT     	    	[match=<MatchResult 0/1: ''>, seg="'tbl.id = c.id'"]
INFO       [PD:3  MD:24]	........................Expression_A_Grammar      	Seque.match OUT     	    	[match=<MatchResult 0/1: ''>, seg="'tbl.id = c.id'"]
DEBUG      [PD:3  MD:24]	........................ExpressionSegment         	Ref.match OUT       	    	[match=<MatchResult 0/1: ''>, seg="'tbl.id = c.id'"]
DEBUG      [PD:3  MD:23]	.......................ExpressionSegment          	Expre.match OUT     	    	[match=<MatchResult 0/1: ''>, seg="'tbl.id = c.id'"]
DEBUG      [PD:3  MD:23]	.......................ArrayLiteralSegment        	Ref.match OUT       	    	[match=<MatchResult 0/1: ''>, seg="'tbl.id = c.id'"]
INFO       [PD:3  MD:22]	......................ArrayLiteralSegment         	Delim.match OUT     	    	[match=<MatchResult 0/1: ''>, seg="'tbl.id = c.id'"]
INFO       [PD:3  MD:21]	.....................ArrayLiteralSegment          	Brack.match OUT     	    	[match=<MatchResult 0/1: ''>, seg="'tbl.id = c.id'"]
INFO       [PD:3  MD:20]	....................ArrayLiteralSegment           	Brack.match OUT     	    	[match=<MatchResult 0/11: ''>, seg="'(tbl.id = c.id)\\nLEFT...'"]
DEBUG      [PD:3  MD:19]	...................ArrayLiteralSegment            	Array.match OUT     	    	[match=<MatchResult 0/11: ''>, seg="'(tbl.id = c.id)\\nLEFT...'"]
DEBUG      [PD:3  MD:19]	...................Expression_D_Grammar           	Ref.match OUT       	    	[match=<MatchResult 0/11: ''>, seg="'(tbl.id = c.id)\\nLEFT...'"]
INFO       [PD:3  MD:18]	..................Expression_D_Grammar            	Seque.match OUT     	    	[match=<MatchResult 0/11: ''>, seg="'(tbl.id = c.id)\\nLEFT...'"]
INFO       [PD:3  MD:20]	....................DatatypeSegment               	OneOf.match PRN     	    	[ns=1, ps=2, ms=0, pruned=[<Sequence: [<OneOf: [<Ref: TimeKeywordSegment>, <Ref..., <Bracketed: [<Ref: NumericLiteralSegment..., <Sequence:...]>, <Sequence: [<Ref: DoubleKeywordSegment>, <Ref: PrecisionKeywordSegment>]>], opts=[<Sequence: [<OneOf: [<Sequence: [<OneOf: [<Ref: Char..., <Bracketed: [<OneOf: [<Delimited: [<Ref:..., <Ref: Char...]>]]
INFO       [PD:3  MD:22]	......................DatatypeSegment             	OneOf.match PRN     	    	[ns=1, ps=1, ms=0, pruned=[<Sequence: [<OneOf: [<Ref: CharacterKeywordSegment>,..., <OneOf: [<Ref: VaryingKeywordSegment>, <...]>], opts=[<Sequence: [<Sequence: [<Ref: SingleIdentifierGramma..., <Ref: DatatypeIdentifierSegment>]>]]
INFO       [PD:3  MD:25]	.........................SingleIdentifierGrammar  	OneOf.match PRN     	    	[ns=2, ps=0, ms=0, pruned=[], opts=[<Ref: NakedIdentifierSegment>, <Ref: QuotedIdentifierSegment>]]
DEBUG      [PD:3  MD:26]	..........................SingleIdentifierGrammar 	Ref.match OUT       	    	[match=<MatchResult 0/11: ''>, seg="'(tbl.id = c.id)\\nLEFT...'"]
DEBUG      [PD:3  MD:26]	..........................SingleIdentifierGrammar 	Ref.match OUT       	    	[match=<MatchResult 0/11: ''>, seg="'(tbl.id = c.id)\\nLEFT...'"]
INFO       [PD:3  MD:25]	.........................SingleIdentifierGrammar  	OneOf.match OUT     	    	[match=<MatchResult 0/11: ''>, seg="'(tbl.id = c.id)\\nLEFT...'"]
DEBUG      [PD:3  MD:25]	.........................DatatypeSegment          	Ref.match OUT       	    	[match=<MatchResult 0/11: ''>, seg="'(tbl.id = c.id)\\nLEFT...'"]
INFO       [PD:3  MD:24]	........................DatatypeSegment           	Seque.match OUT     	    	[match=<MatchResult 0/11: ''>, seg="'(tbl.id = c.id)\\nLEFT...'"]
DEBUG      [PD:3  MD:24]	........................DatatypeSegment           	Ref.match OUT       	    	[match=<MatchResult 0/11: ''>, seg="'(tbl.id = c.id)\\nLEFT...'"]
INFO       [PD:3  MD:23]	.......................DatatypeSegment            	Seque.match OUT     	    	[match=<MatchResult 0/11: ''>, seg="'(tbl.id = c.id)\\nLEFT...'"]
INFO       [PD:3  MD:22]	......................DatatypeSegment             	OneOf.match OUT     	    	[match=<MatchResult 0/11: ''>, seg="'(tbl.id = c.id)\\nLEFT...'"]
INFO       [PD:3  MD:21]	.....................DatatypeSegment              	Seque.match OUT     	    	[match=<MatchResult 0/11: ''>, seg="'(tbl.id = c.id)\\nLEFT...'"]
INFO       [PD:3  MD:20]	....................DatatypeSegment               	OneOf.match OUT     	    	[match=<MatchResult 0/11: ''>, seg="'(tbl.id = c.id)\\nLEFT...'"]
DEBUG      [PD:3  MD:19]	...................DatatypeSegment                	Datat.match OUT     	    	[match=<MatchResult 0/11: ''>, seg="'(tbl.id = c.id)\\nLEFT...'"]
DEBUG      [PD:3  MD:19]	...................Expression_D_Grammar           	Ref.match OUT       	    	[match=<MatchResult 0/11: ''>, seg="'(tbl.id = c.id)\\nLEFT...'"]
INFO       [PD:3  MD:18]	..................Expression_D_Grammar            	Seque.match OUT     	    	[match=<MatchResult 0/11: ''>, seg="'(tbl.id = c.id)\\nLEFT...'"]
INFO       [PD:3  MD:17]	.................Expression_D_Grammar             	OneOf.match OUT     	+   	[match=<MatchResult 1/11: '(tbl.id = c.id)'>, seg="'(tbl.id = c.id)\\nLEFT...'"]
INFO       [PD:3  MD:17]	.................Accessor_Grammar                 	AnyNu.match PRN     	    	[ns=0, ps=1, ms=0, pruned=[<Ref: ArrayAccessorSegment>], opts='ALL']
INFO       [PD:3  MD:17]	.................Accessor_Grammar                 	AnyNu.match OUT     	    	[match=<MatchResult 0/9: ''>, seg="'LEFT JOIN d ON (tbl....'"]
DEBUG      [PD:3  MD:17]	.................Expression_D_Grammar             	Ref.match OUT       	    	[match=<MatchResult 0/9: ''>, seg="'LEFT JOIN d ON (tbl....'"]
INFO       [PD:3  MD:17]	.................Expression_D_Grammar             	AnyNu.match PRN     	    	[ns=0, ps=1, ms=0, pruned=[<Ref: ShorthandCastSegment>], opts='ALL']
INFO       [PD:3  MD:17]	.................Expression_D_Grammar             	AnyNu.match OUT     	    	[match=<MatchResult 0/9: ''>, seg="'LEFT JOIN d ON (tbl....'"]
INFO       [PD:3  MD:16]	................Expression_D_Grammar              	Seque.match OUT     	+   	[match=<MatchResult 1/11: '(tbl.id = c.id)'>, seg="'(tbl.id = c.id)\\nLEFT...'"]
DEBUG      [PD:3  MD:16]	................Expression_C_Grammar              	Ref.match OUT       	+   	[match=<MatchResult 1/11: '(tbl.id = c.id)'>, seg="'(tbl.id = c.id)\\nLEFT...'"]
INFO       [PD:3  MD:15]	...............Expression_C_Grammar               	OneOf.match OUT     	+   	[match=<MatchResult 1/11: '(tbl.id = c.id)'>, seg="'(tbl.id = c.id)\\nLEFT...'"]
DEBUG      [PD:3  MD:15]	...............Expression_A_Grammar               	Ref.match OUT       	+   	[match=<MatchResult 1/11: '(tbl.id = c.id)'>, seg="'(tbl.id = c.id)\\nLEFT...'"]
INFO       [PD:3  MD:14]	..............Expression_A_Grammar                	OneOf.match OUT     	+   	[match=<MatchResult 1/11: '(tbl.id = c.id)'>, seg="'(tbl.id = c.id)\\nLEFT...'"]
INFO       [PD:3  MD:14]	..............Expression_A_Grammar                	AnyNu.match PRN     	    	[ns=1, ps=0, ms=0, pruned=[], opts=[<OneOf: [<Sequence: [<OneOf: [<Sequence: [<Ref: N..., <Sequence: [<Ref: NotKeywordSegment [opt..., <Sequence:...]>]]
INFO       [PD:3  MD:15]	...............Expression_A_Grammar               	OneOf.match PRN     	    	[ns=3, ps=5, ms=0, pruned=[<Sequence: [<Ref: NotKeywordSegment [opt]>, <Ref: InKeywordSegment>, <Bracketed: [<OneOf: [<Delimited: [<Ref:...]>, <Sequence: [<Ref: NotKeywordSegment [opt]>, <Ref: InKeywordSegment>, <Ref: FunctionSegment>]>, <Sequence: [<Ref: IsKeywordSegment>, <Ref: NotKeywordSegment [opt]>, <Ref: IsClauseGrammar>]>, <Sequence: [<Ref: NotKeywordSegment>, <Ref: Expression_C_Grammar>]>, <Sequence: [<Ref: NotKeywordSegment [opt]>, <Ref: BetweenKeywordSegment>, <Ref: Expression_C_Grammar>, <AnyNumbe...]>], opts=[<Sequence: [<OneOf: [<Sequence: [<Ref: NotKeywordSeg..., <Ref: Expression_C_Grammar>, <Sequence: [<Ref: EscapeKe...]>, <Ref: IsNullGrammar>, <Ref: NotNullGrammar>]]
INFO       [PD:3  MD:17]	.................Expression_A_Grammar             	OneOf.match PRN     	    	[ns=1, ps=1, ms=0, pruned=[<Sequence: [<Ref: NotKeywordSegment [opt]>, <Ref: LikeGrammar>]>], opts=[<Sequence: [<Ref: BinaryOperatorGrammar>, <Ref: NotKeywordSegment [opt]>]>]]
INFO       [PD:3  MD:19]	...................BinaryOperatorGrammar          	OneOf.match PRN     	    	[ns=1, ps=3, ms=0, pruned=[<Ref: ArithmeticBinaryOperatorGrammar>, <Ref: StringBinaryOperatorGrammar>, <Ref: BooleanBinaryOperatorGrammar>], opts=[<Ref: ComparisonOperatorGrammar>]]
INFO       [PD:3  MD:20]	....................ComparisonOperatorGrammar     	OneOf.match PRN     	    	[ns=1, ps=7, ms=0, pruned=[<Ref: EqualsSegment>, <Ref: GreaterThanSegment>, <Ref: LessThanSegment>, <Ref: GreaterThanOrEqualToSegment>, <Ref: LessThanOrEqualToSegment>, <Ref: NotEqualToSegment_a>, <Ref: NotEqualToSegment_b>], opts=[<Ref: LikeOperatorSegment>]]
DEBUG      [PD:3  MD:21]	.....................ComparisonOperatorGrammar    	Ref.match OUT       	    	[match=<MatchResult 0/9: ''>, seg="'LEFT JOIN d ON (tbl....'"]
INFO       [PD:3  MD:20]	....................ComparisonOperatorGrammar     	OneOf.match OUT     	    	[match=<MatchResult 0/9: ''>, seg="'LEFT JOIN d ON (tbl....'"]
DEBUG      [PD:3  MD:20]	....................BinaryOperatorGrammar         	Ref.match OUT       	    	[match=<MatchResult 0/9: ''>, seg="'LEFT JOIN d ON (tbl....'"]
INFO       [PD:3  MD:19]	...................BinaryOperatorGrammar          	OneOf.match OUT     	    	[match=<MatchResult 0/9: ''>, seg="'LEFT JOIN d ON (tbl....'"]
DEBUG      [PD:3  MD:19]	...................Expression_A_Grammar           	Ref.match OUT       	    	[match=<MatchResult 0/9: ''>, seg="'LEFT JOIN d ON (tbl....'"]
INFO       [PD:3  MD:18]	..................Expression_A_Grammar            	Seque.match OUT     	    	[match=<MatchResult 0/9: ''>, seg="'LEFT JOIN d ON (tbl....'"]
INFO       [PD:3  MD:17]	.................Expression_A_Grammar             	OneOf.match OUT     	    	[match=<MatchResult 0/9: ''>, seg="'LEFT JOIN d ON (tbl....'"]
INFO       [PD:3  MD:16]	................Expression_A_Grammar              	Seque.match OUT     	    	[match=<MatchResult 0/9: ''>, seg="'LEFT JOIN d ON (tbl....'"]
DEBUG      [PD:3  MD:16]	................Expression_A_Grammar              	Ref.match OUT       	    	[match=<MatchResult 0/9: ''>, seg="'LEFT JOIN d ON (tbl....'"]
DEBUG      [PD:3  MD:16]	................Expression_A_Grammar              	Ref.match OUT       	    	[match=<MatchResult 0/9: ''>, seg="'LEFT JOIN d ON (tbl....'"]
INFO       [PD:3  MD:15]	...............Expression_A_Grammar               	OneOf.match OUT     	    	[match=<MatchResult 0/9: ''>, seg="'LEFT JOIN d ON (tbl....'"]
INFO       [PD:3  MD:14]	..............Expression_A_Grammar                	AnyNu.match OUT     	    	[match=<MatchResult 0/9: ''>, seg="'LEFT JOIN d ON (tbl....'"]
INFO       [PD:3  MD:13]	.............Expression_A_Grammar                 	Seque.match OUT     	+   	[match=<MatchResult 1/11: '(tbl.id = c.id)'>, seg="'(tbl.id = c.id)\\nLEFT...'"]
DEBUG      [PD:3  MD:13]	.............ExpressionSegment                    	Ref.match OUT       	+   	[match=<MatchResult 1/11: '(tbl.id = c.id)'>, seg="'(tbl.id = c.id)\\nLEFT...'"]
DEBUG      [PD:3  MD:12]	............ExpressionSegment                     	Expre.match OUT     	+   	[match=<MatchResult 1/11: '(tbl.id = c.id)'>, seg="'(tbl.id = c.id)\\nLEFT...'"]
DEBUG      [PD:3  MD:12]	............JoinOnConditionSegment                	Ref.match OUT       	+   	[match=<MatchResult 1/11: '(tbl.id = c.id)'>, seg="'(tbl.id = c.id)\\nLEFT...'"]
INFO       [PD:3  MD:11]	...........JoinOnConditionSegment                 	Optio.match OUT     	+   	[match=<MatchResult 1/11: '(tbl.id = c.id)'>, seg="'(tbl.id = c.id)\\nLEFT...'"]
INFO       [PD:3  MD:10]	..........JoinOnConditionSegment                  	Seque.match OUT     	+   	[match=<MatchResult 5/15: 'ON (tbl.id = c.id)'>, seg="'ON (tbl.id = c.id)\\nL...'"]
DEBUG      [PD:3  MD:9 ]	.........JoinOnConditionSegment                   	JoinO.match OUT     	+   	[match=<MatchResult 1/11: 'ON (tbl.id = c.id)'>, seg="'ON (tbl.id = c.id)\\nL...'"]
DEBUG      [PD:3  MD:9 ]	.........JoinClauseSegment                        	Ref.match OUT       	+   	[match=<MatchResult 1/11: 'ON (tbl.id = c.id)'>, seg="'ON (tbl.id = c.id)\\nL...'"]
INFO       [PD:3  MD:8 ]	........JoinClauseSegment                         	OneOf.match OUT     	+   	[match=<MatchResult 1/11: 'ON (tbl.id = c.id)'>, seg="'ON (tbl.id = c.id)\\nL...'"]
INFO       [PD:3  MD:7 ]	.......JoinClauseSegment                          	Seque.match OUT     	+   	[match=<MatchResult 3/13: 'c ON (tbl.id = c.id)'>, seg="'c ON (tbl.id = c.id)...'"]
INFO       [PD:3  MD:6 ]	......JoinClauseSegment                           	Seque.match OUT     	+   	[match=<MatchResult 7/17: 'JOIN c ON (tbl.id = c.id)'>, seg="'JOIN c ON (tbl.id = ...'"]
DEBUG      [PD:3  MD:5 ]	.....JoinClauseSegment                            	JoinC.match OUT     	+   	[match=<MatchResult 1/11: 'JOIN c ON (tbl.id = c.id)'>, seg="'JOIN c ON (tbl.id = ...'"]
DEBUG      [PD:3  MD:5 ]	.....FromExpressionSegment                        	Ref.match OUT       	+   	[match=<MatchResult 1/11: 'JOIN c ON (tbl.id = c.id)'>, seg="'JOIN c ON (tbl.id = ...'"]
DEBUG      [PD:3  MD:5 ]	.....FromExpressionSegment                        	Ref.match OUT       	    	[match=<MatchResult 0/17: ''>, seg="'JOIN c ON (tbl.id = ...'"]
INFO       [PD:3  MD:4 ]	....FromExpressionSegment                         	AnyNu.match PRN     	    	[ns=1, ps=0, ms=1, pruned=[], opts=[<Ref: JoinClauseSegment>, <Ref: JoinLikeClauseGrammar>]]
INFO       [PD:3  MD:7 ]	.......JoinClauseSegment                          	OneOf.match PRN     	    	[ns=0, ps=2, ms=1, pruned=[<Ref: CrossKeywordSegment>, <Ref: InnerKeywordSegment>], opts=[<Sequence: [<OneOf: [<Ref: FullKeywordSegment>, <Ref..., <Ref: OuterKeywordSegment [opt]>]>]]
INFO       [PD:3  MD:9 ]	.........JoinClauseSegment                        	OneOf.match PRN     	    	[ns=0, ps=2, ms=1, pruned=[<Ref: FullKeywordSegment>, <Ref: RightKeywordSegment>], opts=[<Ref: LeftKeywordSegment>]]
DEBUG      [PD:3  MD:10]	..........JoinClauseSegment                       	Ref.match OUT       	+   	[match=<MatchResult 1/9: 'LEFT'>, seg="'LEFT JOIN d ON (tbl....'"]
INFO       [PD:3  MD:9 ]	.........JoinClauseSegment                        	OneOf.match OUT     	+   	[match=<MatchResult 1/9: 'LEFT'>, seg="'LEFT JOIN d ON (tbl....'"]
DEBUG      [PD:3  MD:9 ]	.........JoinClauseSegment                        	Ref.match OUT       	    	[match=<MatchResult 0/7: ''>, seg="'JOIN d ON (tbl.id = ...'"]
INFO       [PD:3  MD:8 ]	........JoinClauseSegment                         	Seque.match OUT     	+   	[match=<MatchResult 1/9: 'LEFT'>, seg="'LEFT JOIN d ON (tbl....'"]
INFO       [PD:3  MD:7 ]	.......JoinClauseSegment                          	OneOf.match OUT     	+   	[match=<MatchResult 1/9: 'LEFT'>, seg="'LEFT JOIN d ON (tbl....'"]
DEBUG      [PD:3  MD:8 ]	........JoinKeywords                              	Ref.match OUT       	+   	[match=<MatchResult 1/7: 'JOIN'>, seg="'JOIN d ON (tbl.id = ...'"]
INFO       [PD:3  MD:7 ]	.......JoinKeywords                               	Seque.match OUT     	+   	[match=<MatchResult 1/7: 'JOIN'>, seg="'JOIN d ON (tbl.id = ...'"]
DEBUG      [PD:3  MD:7 ]	.......JoinClauseSegment                          	Ref.match OUT       	+   	[match=<MatchResult 1/7: 'JOIN'>, seg="'JOIN d ON (tbl.id = ...'"]
DEBUG      [PD:3  MD:10]	..........FromExpressionElementSegment            	Ref.match OUT       	    	[match=<MatchResult 0/5: ''>, seg="'d ON (tbl.id = d.oth...'"]
INFO       [PD:3  MD:10]	..........FromExpressionElementSegment            	Optio.match PRN     	    	[ns=1, ps=1, ms=0, pruned=[<Bracketed: [<Ref: TableExpressionSegment>]>], opts=[<Ref: TableExpressionSegment>]]
INFO       [PD:3  MD:12]	............TableExpressionSegment                	OneOf.match PRN     	    	[ns=3, ps=1, ms=0, pruned=[<Bracketed: [<Ref: SelectableGrammar>]>], opts=[<Ref: BareFunctionSegment>, <Ref: FunctionSegment>, <Ref: TableReferenceSegment>]]
DEBUG      [PD:3  MD:13]	.............TableExpressionSegment               	Ref.match OUT       	    	[match=<MatchResult 0/5: ''>, seg="'d ON (tbl.id = d.oth...'"]
INFO       [PD:3  MD:14]	..............FunctionSegment                     	OneOf.match PRN     	    	[ns=1, ps=1, ms=0, pruned=[<Sequence: [<Sequence: [<Ref: DateAddFunctionNameSeg...]>], opts=[<Sequence: [<Sequence: [<AnyNumberOf: [<Ref: Functio..., <Ref: PostFunctionGrammar [opt]>]>]]
DEBUG      [PD:3  MD:20]	....................DateAddFunctionNameSegment    	Ref.match OUT       	    	[match=<MatchResult 0/5: ''>, seg="'d ON (tbl.id = d.oth...'"]
INFO       [PD:3  MD:19]	...................DateAddFunctionNameSegment     	Seque.match OUT     	    	[match=<MatchResult 0/5: ''>, seg="'d ON (tbl.id = d.oth...'"]
DEBUG      [PD:3  MD:18]	..................DateAddFunctionNameSegment      	DateA.match OUT     	    	[match=<MatchResult 0/5: ''>, seg="'d ON (tbl.id = d.oth...'"]
DEBUG      [PD:3  MD:18]	..................FunctionSegment                 	Ref.match OUT       	    	[match=<MatchResult 0/5: ''>, seg="'d ON (tbl.id = d.oth...'"]
INFO       [PD:3  MD:17]	.................FunctionSegment                  	AnyNu.match PRN     	    	[ns=1, ps=0, ms=0, pruned=[], opts=[<Ref: FunctionNameSegment>]]
INFO       [PD:3  MD:20]	....................FunctionNameSegment           	AnyNu.match PRN     	    	[ns=1, ps=0, ms=0, pruned=[], opts=[<Sequence: [<Ref: SingleIdentifierGrammar>, <Ref: DotSegment>]>]]
INFO       [PD:3  MD:22]	......................SingleIdentifierGrammar     	OneOf.match PRN     	    	[ns=2, ps=0, ms=0, pruned=[], opts=[<Ref: NakedIdentifierSegment>, <Ref: QuotedIdentifierSegment>]]
DEBUG      [PD:3  MD:23]	.......................SingleIdentifierGrammar    	Ref.match OUT       	+   	[match=<MatchResult 1/5: 'd'>, seg="'d ON (tbl.id = d.oth...'"]
DEBUG      [PD:3  MD:23]	.......................SingleIdentifierGrammar    	Ref.match OUT       	    	[match=<MatchResult 0/5: ''>, seg="'d ON (tbl.id = d.oth...'"]
INFO       [PD:3  MD:22]	......................SingleIdentifierGrammar     	OneOf.match OUT     	+   	[match=<MatchResult 1/5: 'd'>, seg="'d ON (tbl.id = d.oth...'"]
DEBUG      [PD:3  MD:22]	......................FunctionNameSegment         	Ref.match OUT       	+   	[match=<MatchResult 1/5: 'd'>, seg="'d ON (tbl.id = d.oth...'"]
DEBUG      [PD:3  MD:22]	......................FunctionNameSegment         	Ref.match OUT       	    	[match=<MatchResult 0/3: ''>, seg="'ON (tbl.id = d.other...'"]
INFO       [PD:3  MD:21]	.....................FunctionNameSegment          	Seque.match OUT     	    	[match=<MatchResult 0/5: ''>, seg="'d ON (tbl.id = d.oth...'"]
INFO       [PD:3  MD:20]	....................FunctionNameSegment           	AnyNu.match OUT     	    	[match=<MatchResult 0/5: ''>, seg="'d ON (tbl.id = d.oth...'"]
INFO       [PD:3  MD:20]	....................FunctionNameSegment           	OneOf.match PRN     	    	[ns=2, ps=0, ms=0, pruned=[], opts=[<Ref: FunctionNameIdentifierSegment>, <Ref: QuotedIdentifierSegment>]]
DEBUG      [PD:3  MD:21]	.....................FunctionNameSegment          	Ref.match OUT       	+   	[match=<MatchResult 1/5: 'd'>, seg="'d ON (tbl.id = d.oth...'"]
DEBUG      [PD:3  MD:21]	.....................FunctionNameSegment          	Ref.match OUT       	    	[match=<MatchResult 0/5: ''>, seg="'d ON (tbl.id = d.oth...'"]
INFO       [PD:3  MD:20]	....................FunctionNameSegment           	OneOf.match OUT     	+   	[match=<MatchResult 1/5: 'd'>, seg="'d ON (tbl.id = d.oth...'"]
INFO       [PD:3  MD:19]	...................FunctionNameSegment            	Seque.match OUT     	+   	[match=<MatchResult 1/5: 'd'>, seg="'d ON (tbl.id = d.oth...'"]
DEBUG      [PD:3  MD:18]	..................FunctionNameSegment             	Funct.match OUT     	+   	[match=<MatchResult 1/5: 'd'>, seg="'d ON (tbl.id = d.oth...'"]
DEBUG      [PD:3  MD:18]	..................FunctionSegment                 	Ref.match OUT       	+   	[match=<MatchResult 1/5: 'd'>, seg="'d ON (tbl.id = d.oth...'"]
INFO       [PD:3  MD:17]	.................FunctionSegment                  	AnyNu.match OUT     	+   	[match=<MatchResult 1/5: 'd'>, seg="'d ON (tbl.id = d.oth...'"]
INFO       [PD:3  MD:17]	.................FunctionSegment                  	Brack.match OUT     	    	[match=<MatchResult 0/3: ''>, seg="'ON (tbl.id = d.other...'"]
INFO       [PD:3  MD:16]	................FunctionSegment                   	Seque.match OUT     	    	[match=<MatchResult 0/5: ''>, seg="'d ON (tbl.id = d.oth...'"]
INFO       [PD:3  MD:15]	...............FunctionSegment                    	Seque.match OUT     	    	[match=<MatchResult 0/5: ''>, seg="'d ON (tbl.id = d.oth...'"]
INFO       [PD:3  MD:14]	..............FunctionSegment                     	OneOf.match OUT     	    	[match=<MatchResult 0/5: ''>, seg="'d ON (tbl.id = d.oth...'"]
DEBUG      [PD:3  MD:13]	.............FunctionSegment                      	Funct.match OUT     	    	[match=<MatchResult 0/5: ''>, seg="'d ON (tbl.id = d.oth...'"]
DEBUG      [PD:3  MD:13]	.............TableExpressionSegment               	Ref.match OUT       	    	[match=<MatchResult 0/5: ''>, seg="'d ON (tbl.id = d.oth...'"]
DEBUG      [PD:3  MD:15]	...............TableReferenceSegment              	Delim._look_ahead_match IN	    	[ls=5, seg='d ON (tbl.id = d.oth...']
DEBUG      [PD:3  MD:15]	...............TableReferenceSegment              	Delim._look_ahead_match SI	    	[mq=[], sb=['D', '', 'ON', '', '(TBL.ID']]
INFO       [PD:3  MD:15]	...............TableReferenceSegment              	OneOf.match PRN     	    	[ns=1, ps=10, ms=0, pruned=[<Ref: OnKeywordSegment>, <Ref: AsKeywordSegment>, <Ref: UsingKeywordSegment>, <Ref: CommaSegment>, <Ref: CastOperatorSegment>, <Ref: StartSquareBracketSegment>, <Ref: StartBracketSegment>, <Ref: ColonSegment>, <Ref: DelimiterSegment>, <class 'sqlfluff.core.parser.segments.base.BracketedSegment'>], opts=[<Ref: BinaryOperatorGrammar>]]
INFO       [PD:3  MD:16]	................BinaryOperatorGrammar             	OneOf.match PRN     	    	[ns=1, ps=3, ms=0, pruned=[<Ref: ArithmeticBinaryOperatorGrammar>, <Ref: StringBinaryOperatorGrammar>, <Ref: BooleanBinaryOperatorGrammar>], opts=[<Ref: ComparisonOperatorGrammar>]]
INFO       [PD:3  MD:17]	.................ComparisonOperatorGrammar        	OneOf.match PRN     	    	[ns=1, ps=7, ms=0, pruned=[<Ref: EqualsSegment>, <Ref: GreaterThanSegment>, <Ref: LessThanSegment>, <Ref: GreaterThanOrEqualToSegment>, <Ref: LessThanOrEqualToSegment>, <Ref: NotEqualToSegment_a>, <Ref: NotEqualToSegment_b>], opts=[<Ref: LikeOperatorSegment>]]
DEBUG      [PD:3  MD:18]	..................ComparisonOperatorGrammar       	Ref.match OUT       	    	[match=<MatchResult 0/5: ''>, seg="'d ON (tbl.id = d.oth...'"]
INFO       [PD:3  MD:17]	.................ComparisonOperatorGrammar        	OneOf.match OUT     	    	[match=<MatchResult 0/5: ''>, seg="'d ON (tbl.id = d.oth...'"]
DEBUG      [PD:3  MD:17]	.................BinaryOperatorGrammar            	Ref.match OUT       	    	[match=<MatchResult 0/5: ''>, seg="'d ON (tbl.id = d.oth...'"]
INFO       [PD:3  MD:16]	................BinaryOperatorGrammar             	OneOf.match OUT     	    	[match=<MatchResult 0/5: ''>, seg="'d ON (tbl.id = d.oth...'"]
DEBUG      [PD:3  MD:16]	................TableReferenceSegment             	Ref.match OUT       	    	[match=<MatchResult 0/5: ''>, seg="'d ON (tbl.id = d.oth...'"]
INFO       [PD:3  MD:15]	...............TableReferenceSegment              	OneOf.match OUT     	    	[match=<MatchResult 0/5: ''>, seg="'d ON (tbl.id = d.oth...'"]
DEBUG      [PD:3  MD:15]	...............TableReferenceSegment              	NonCo.match OUT     	    	[match=<MatchResult 0/5: ''>, seg="'d ON (tbl.id = d.oth...'"]
INFO       [PD:3  MD:15]	...............TableReferenceSegment              	OneOf.match PRN     	    	[ns=1, ps=9, ms=1, pruned=[<Ref: AsKeywordSegment>, <Ref: UsingKeywordSegment>, <Ref: CommaSegment>, <Ref: CastOperatorSegment>, <Ref: StartSquareBracketSegment>, <Ref: StartBracketSegment>, <Ref: ColonSegment>, <Ref: DelimiterSegment>, <class 'sqlfluff.core.parser.segments.base.BracketedSegment'>], opts=[<Ref: OnKeywordSegment>, <Ref: BinaryOperatorGrammar>]]
DEBUG      [PD:3  MD:16]	................TableReferenceSegment             	Ref.match OUT       	    	[match=<MatchResult 0/4: ''>, seg="' ON (tbl.id = d.othe...'"]
INFO       [PD:3  MD:16]	................BinaryOperatorGrammar             	OneOf.match PRN     	    	[ns=1, ps=3, ms=0, pruned=[<Ref: ArithmeticBinaryOperatorGrammar>, <Ref: StringBinaryOperatorGrammar>, <Ref: BooleanBinaryOperatorGrammar>], opts=[<Ref: ComparisonOperatorGrammar>]]
INFO       [PD:3  MD:17]	.................ComparisonOperatorGrammar        	OneOf.match PRN     	    	[ns=1, ps=7, ms=0, pruned=[<Ref: EqualsSegment>, <Ref: GreaterThanSegment>, <Ref: LessThanSegment>, <Ref: GreaterThanOrEqualToSegment>, <Ref: LessThanOrEqualToSegment>, <Ref: NotEqualToSegment_a>, <Ref: NotEqualToSegment_b>], opts=[<Ref: LikeOperatorSegment>]]
DEBUG      [PD:3  MD:18]	..................ComparisonOperatorGrammar       	Ref.match OUT       	    	[match=<MatchResult 0/4: ''>, seg="' ON (tbl.id = d.othe...'"]
INFO       [PD:3  MD:17]	.................ComparisonOperatorGrammar        	OneOf.match OUT     	    	[match=<MatchResult 0/4: ''>, seg="' ON (tbl.id = d.othe...'"]
DEBUG      [PD:3  MD:17]	.................BinaryOperatorGrammar            	Ref.match OUT       	    	[match=<MatchResult 0/4: ''>, seg="' ON (tbl.id = d.othe...'"]
INFO       [PD:3  MD:16]	................BinaryOperatorGrammar             	OneOf.match OUT     	    	[match=<MatchResult 0/4: ''>, seg="' ON (tbl.id = d.othe...'"]
DEBUG      [PD:3  MD:16]	................TableReferenceSegment             	Ref.match OUT       	    	[match=<MatchResult 0/4: ''>, seg="' ON (tbl.id = d.othe...'"]
INFO       [PD:3  MD:15]	...............TableReferenceSegment              	OneOf.match OUT     	    	[match=<MatchResult 0/4: ''>, seg="' ON (tbl.id = d.othe...'"]
DEBUG      [PD:3  MD:15]	...............TableReferenceSegment              	NonCo.match OUT     	+   	[match=<MatchResult 1/4: ' '>, seg="' ON (tbl.id = d.othe...'"]
INFO       [PD:3  MD:15]	...............SingleIdentifierGrammar            	OneOf.match PRN     	    	[ns=2, ps=0, ms=0, pruned=[], opts=[<Ref: NakedIdentifierSegment>, <Ref: QuotedIdentifierSegment>]]
DEBUG      [PD:3  MD:16]	................SingleIdentifierGrammar           	Ref.match OUT       	++  	[match=<MatchResult 1/1: 'd'>, seg="'d'"]
INFO       [PD:3  MD:15]	...............SingleIdentifierGrammar            	OneOf.match OUT     	++  	[match=<MatchResult 1/1: 'd'>, seg="'d'"]
DEBUG      [PD:3  MD:15]	...............TableReferenceSegment              	Ref.match OUT       	++  	[match=<MatchResult 1/1: 'd'>, seg="'d'"]
INFO       [PD:3  MD:14]	..............TableReferenceSegment               	Delim.match OUT     	+   	[match=<MatchResult 1/5: 'd'>, seg="'d ON (tbl.id = d.oth...'"]
DEBUG      [PD:3  MD:13]	.............TableReferenceSegment                	Table.match OUT     	+   	[match=<MatchResult 1/5: 'd'>, seg="'d ON (tbl.id = d.oth...'"]
DEBUG      [PD:3  MD:13]	.............TableExpressionSegment               	Ref.match OUT       	+   	[match=<MatchResult 1/5: 'd'>, seg="'d ON (tbl.id = d.oth...'"]
INFO       [PD:3  MD:12]	............TableExpressionSegment                	OneOf.match OUT     	+   	[match=<MatchResult 1/5: 'd'>, seg="'d ON (tbl.id = d.oth...'"]
DEBUG      [PD:3  MD:11]	...........TableExpressionSegment                 	Table.match OUT     	+   	[match=<MatchResult 1/5: 'd'>, seg="'d ON (tbl.id = d.oth...'"]
DEBUG      [PD:3  MD:11]	...........FromExpressionElementSegment           	Ref.match OUT       	+   	[match=<MatchResult 1/5: 'd'>, seg="'d ON (tbl.id = d.oth...'"]
INFO       [PD:3  MD:10]	..........FromExpressionElementSegment            	Optio.match OUT     	+   	[match=<MatchResult 1/5: 'd'>, seg="'d ON (tbl.id = d.oth...'"]
DEBUG      [PD:3  MD:11]	...........FromExpressionElementSegment           	Ref.match OUT       	    	[match=<MatchResult 0/3: ''>, seg="'ON (tbl.id = d.other...'"]
INFO       [PD:3  MD:10]	..........FromExpressionElementSegment            	Seque.match OUT     	    	[match=<MatchResult 0/3: ''>, seg="'ON (tbl.id = d.other...'"]
DEBUG      [PD:3  MD:12]	............AliasExpressionSegment                	Ref.match OUT       	    	[match=<MatchResult 0/3: ''>, seg="'ON (tbl.id = d.other...'"]
INFO       [PD:3  MD:12]	............AliasExpressionSegment                	OneOf.match PRN     	    	[ns=2, ps=0, ms=0, pruned=[], opts=[<Sequence: [<Ref: SingleIdentifierGrammar>, <Bracketed: [<Ref: SingleIdentifierListS...]>, <Ref: QuotedLiteralSegment>]]
INFO       [PD:3  MD:14]	..............SingleIdentifierGrammar             	OneOf.match PRN     	    	[ns=2, ps=0, ms=0, pruned=[], opts=[<Ref: NakedIdentifierSegment>, <Ref: QuotedIdentifierSegment>]]
DEBUG      [PD:3  MD:15]	...............SingleIdentifierGrammar            	Ref.match OUT       	    	[match=<MatchResult 0/3: ''>, seg="'ON (tbl.id = d.other...'"]
DEBUG      [PD:3  MD:15]	...............SingleIdentifierGrammar            	Ref.match OUT       	    	[match=<MatchResult 0/3: ''>, seg="'ON (tbl.id = d.other...'"]
INFO       [PD:3  MD:14]	..............SingleIdentifierGrammar             	OneOf.match OUT     	    	[match=<MatchResult 0/3: ''>, seg="'ON (tbl.id = d.other...'"]
DEBUG      [PD:3  MD:14]	..............AliasExpressionSegment              	Ref.match OUT       	    	[match=<MatchResult 0/3: ''>, seg="'ON (tbl.id = d.other...'"]
INFO       [PD:3  MD:13]	.............AliasExpressionSegment               	Seque.match OUT     	    	[match=<MatchResult 0/3: ''>, seg="'ON (tbl.id = d.other...'"]
DEBUG      [PD:3  MD:13]	.............AliasExpressionSegment               	Ref.match OUT       	    	[match=<MatchResult 0/3: ''>, seg="'ON (tbl.id = d.other...'"]
INFO       [PD:3  MD:12]	............AliasExpressionSegment                	OneOf.match OUT     	    	[match=<MatchResult 0/3: ''>, seg="'ON (tbl.id = d.other...'"]
INFO       [PD:3  MD:11]	...........AliasExpressionSegment                 	Seque.match OUT     	    	[match=<MatchResult 0/3: ''>, seg="'ON (tbl.id = d.other...'"]
DEBUG      [PD:3  MD:10]	..........AliasExpressionSegment                  	Alias.match OUT     	    	[match=<MatchResult 0/3: ''>, seg="'ON (tbl.id = d.other...'"]
DEBUG      [PD:3  MD:10]	..........FromExpressionElementSegment            	Ref.match OUT       	    	[match=<MatchResult 0/3: ''>, seg="'ON (tbl.id = d.other...'"]
DEBUG      [PD:3  MD:10]	..........FromExpressionElementSegment            	Ref.match OUT       	    	[match=<MatchResult 0/3: ''>, seg="'ON (tbl.id = d.other...'"]
INFO       [PD:3  MD:9 ]	.........FromExpressionElementSegment             	Seque.match OUT     	+   	[match=<MatchResult 1/5: 'd'>, seg="'d ON (tbl.id = d.oth...'"]
DEBUG      [PD:3  MD:8 ]	........FromExpressionElementSegment              	FromE.match OUT     	+   	[match=<MatchResult 1/5: 'd'>, seg="'d ON (tbl.id = d.oth...'"]
DEBUG      [PD:3  MD:8 ]	........JoinClauseSegment                         	Ref.match OUT       	+   	[match=<MatchResult 1/5: 'd'>, seg="'d ON (tbl.id = d.oth...'"]
INFO       [PD:3  MD:8 ]	........JoinClauseSegment                         	OneOf.match PRN     	    	[ns=0, ps=1, ms=1, pruned=[<Sequence: [<Ref: UsingKeywordSegment>, <class 'sqlfluff.core.parser.segments.me..., <Bracketed: [<Delimited: [<...]>], opts=[<Ref: JoinOnConditionSegment>]]
DEBUG      [PD:3  MD:11]	...........JoinOnConditionSegment                 	Ref.match OUT       	+   	[match=<MatchResult 1/3: 'ON'>, seg="'ON (tbl.id = d.other...'"]
INFO       [PD:3  MD:11]	...........JoinOnConditionSegment                 	Optio.match PRN     	    	[ns=1, ps=0, ms=1, pruned=[], opts=[<Bracketed: [<Ref: ExpressionSegment>]>, <Ref: ExpressionSegment>]]
INFO       [PD:3  MD:16]	................Expression_A_Grammar              	OneOf.match PRN     	    	[ns=1, ps=1, ms=0, pruned=[<Sequence: [<OneOf: [<Ref: PositiveSegment>, <Ref: N..., <Ref: Expression_C_Grammar>]>], opts=[<Ref: Expression_C_Grammar>]]
INFO       [PD:3  MD:17]	.................Expression_C_Grammar             	OneOf.match PRN     	    	[ns=1, ps=2, ms=0, pruned=[<Sequence: [<Ref: ExistsKeywordSegment>, <Bracketed: [<Ref: SelectStatementSegmen...]>, <Ref: CaseExpressionSegment>], opts=[<Ref: Expression_D_Grammar>]]
INFO       [PD:3  MD:19]	...................Expression_D_Grammar           	OneOf.match PRN     	    	[ns=6, ps=3, ms=0, pruned=[<Bracketed: [<OneOf: [<Ref: ExpressionSegment>, <Ref:...]>, <Ref: SelectStatementSegment>, <Ref: IntervalExpressionSegment>], opts=[<Ref: BareFunctionSegment>, <Ref: FunctionSegment>, <Ref: LiteralGrammar>, <Ref: ColumnReferenceSegment>, <Sequence: [<Ref: SimpleArrayTypeGrammar [opt]>, <Ref: ArrayLiteralSegment>]>, <Sequence: [<Ref: DatatypeSegment>, <OneOf: [<Ref: QuotedLiteralSegment>, <R...]>]]
DEBUG      [PD:3  MD:20]	....................Expression_D_Grammar          	Ref.match OUT       	    	[match=<MatchResult 0/9: ''>, seg="'tbl.id = d.other_id'"]
INFO       [PD:3  MD:21]	.....................FunctionSegment              	OneOf.match PRN     	    	[ns=1, ps=1, ms=0, pruned=[<Sequence: [<Sequence: [<Ref: DateAddFunctionNameSeg...]>], opts=[<Sequence: [<Sequence: [<AnyNumberOf: [<Ref: Functio..., <Ref: PostFunctionGrammar [opt]>]>]]
DEBUG      [PD:3  MD:27]	...........................DateAddFunctionNameSegment	Ref.match OUT       	    	[match=<MatchResult 0/9: ''>, seg="'tbl.id = d.other_id'"]
INFO       [PD:3  MD:26]	..........................DateAddFunctionNameSegment	Seque.match OUT     	    	[match=<MatchResult 0/9: ''>, seg="'tbl.id = d.other_id'"]
DEBUG      [PD:3  MD:25]	.........................DateAddFunctionNameSegment	DateA.match OUT     	    	[match=<MatchResult 0/9: ''>, seg="'tbl.id = d.other_id'"]
DEBUG      [PD:3  MD:25]	.........................FunctionSegment          	Ref.match OUT       	    	[match=<MatchResult 0/9: ''>, seg="'tbl.id = d.other_id'"]
INFO       [PD:3  MD:24]	........................FunctionSegment           	AnyNu.match PRN     	    	[ns=1, ps=0, ms=0, pruned=[], opts=[<Ref: FunctionNameSegment>]]
INFO       [PD:3  MD:27]	...........................FunctionNameSegment    	AnyNu.match PRN     	    	[ns=1, ps=0, ms=0, pruned=[], opts=[<Sequence: [<Ref: SingleIdentifierGrammar>, <Ref: DotSegment>]>]]
INFO       [PD:3  MD:29]	.............................SingleIdentifierGrammar	OneOf.match PRN     	    	[ns=2, ps=0, ms=0, pruned=[], opts=[<Ref: NakedIdentifierSegment>, <Ref: QuotedIdentifierSegment>]]
DEBUG      [PD:3  MD:30]	..............................SingleIdentifierGrammar	Ref.match OUT       	+   	[match=<MatchResult 1/9: 'tbl'>, seg="'tbl.id = d.other_id'"]
DEBUG      [PD:3  MD:30]	..............................SingleIdentifierGrammar	Ref.match OUT       	    	[match=<MatchResult 0/9: ''>, seg="'tbl.id = d.other_id'"]
INFO       [PD:3  MD:29]	.............................SingleIdentifierGrammar	OneOf.match OUT     	+   	[match=<MatchResult 1/9: 'tbl'>, seg="'tbl.id = d.other_id'"]
DEBUG      [PD:3  MD:29]	.............................FunctionNameSegment  	Ref.match OUT       	+   	[match=<MatchResult 1/9: 'tbl'>, seg="'tbl.id = d.other_id'"]
DEBUG      [PD:3  MD:29]	.............................FunctionNameSegment  	Ref.match OUT       	+   	[match=<MatchResult 1/8: '.'>, seg="'.id = d.other_id'"]
INFO       [PD:3  MD:28]	............................FunctionNameSegment   	Seque.match OUT     	+   	[match=<MatchResult 2/9: 'tbl.'>, seg="'tbl.id = d.other_id'"]
INFO       [PD:3  MD:27]	...........................FunctionNameSegment    	AnyNu.match PRN     	    	[ns=1, ps=0, ms=0, pruned=[], opts=[<Sequence: [<Ref: SingleIdentifierGrammar>, <Ref: DotSegment>]>]]
INFO       [PD:3  MD:29]	.............................SingleIdentifierGrammar	OneOf.match PRN     	    	[ns=2, ps=0, ms=0, pruned=[], opts=[<Ref: NakedIdentifierSegment>, <Ref: QuotedIdentifierSegment>]]
DEBUG      [PD:3  MD:30]	..............................SingleIdentifierGrammar	Ref.match OUT       	+   	[match=<MatchResult 1/7: 'id'>, seg="'id = d.other_id'"]
DEBUG      [PD:3  MD:30]	..............................SingleIdentifierGrammar	Ref.match OUT       	    	[match=<MatchResult 0/7: ''>, seg="'id = d.other_id'"]
INFO       [PD:3  MD:29]	.............................SingleIdentifierGrammar	OneOf.match OUT     	+   	[match=<MatchResult 1/7: 'id'>, seg="'id = d.other_id'"]
DEBUG      [PD:3  MD:29]	.............................FunctionNameSegment  	Ref.match OUT       	+   	[match=<MatchResult 1/7: 'id'>, seg="'id = d.other_id'"]
DEBUG      [PD:3  MD:29]	.............................FunctionNameSegment  	Ref.match OUT       	    	[match=<MatchResult 0/5: ''>, seg="'= d.other_id'"]
INFO       [PD:3  MD:28]	............................FunctionNameSegment   	Seque.match OUT     	    	[match=<MatchResult 0/7: ''>, seg="'id = d.other_id'"]
INFO       [PD:3  MD:27]	...........................FunctionNameSegment    	AnyNu.match OUT     	+   	[match=<MatchResult 2/9: 'tbl.'>, seg="'tbl.id = d.other_id'"]
INFO       [PD:3  MD:27]	...........................FunctionNameSegment    	OneOf.match PRN     	    	[ns=2, ps=0, ms=0, pruned=[], opts=[<Ref: FunctionNameIdentifierSegment>, <Ref: QuotedIdentifierSegment>]]
DEBUG      [PD:3  MD:28]	............................FunctionNameSegment   	Ref.match OUT       	+   	[match=<MatchResult 1/7: 'id'>, seg="'id = d.other_id'"]
DEBUG      [PD:3  MD:28]	............................FunctionNameSegment   	Ref.match OUT       	    	[match=<MatchResult 0/7: ''>, seg="'id = d.other_id'"]
INFO       [PD:3  MD:27]	...........................FunctionNameSegment    	OneOf.match OUT     	+   	[match=<MatchResult 1/7: 'id'>, seg="'id = d.other_id'"]
INFO       [PD:3  MD:26]	..........................FunctionNameSegment     	Seque.match OUT     	+   	[match=<MatchResult 3/9: 'tbl.id'>, seg="'tbl.id = d.other_id'"]
DEBUG      [PD:3  MD:25]	.........................FunctionNameSegment      	Funct.match OUT     	+   	[match=<MatchResult 1/7: 'tbl.id'>, seg="'tbl.id = d.other_id'"]
DEBUG      [PD:3  MD:25]	.........................FunctionSegment          	Ref.match OUT       	+   	[match=<MatchResult 1/7: 'tbl.id'>, seg="'tbl.id = d.other_id'"]
INFO       [PD:3  MD:24]	........................FunctionSegment           	AnyNu.match OUT     	+   	[match=<MatchResult 1/7: 'tbl.id'>, seg="'tbl.id = d.other_id'"]
INFO       [PD:3  MD:24]	........................FunctionSegment           	Brack.match OUT     	    	[match=<MatchResult 0/5: ''>, seg="'= d.other_id'"]
INFO       [PD:3  MD:23]	.......................FunctionSegment            	Seque.match OUT     	    	[match=<MatchResult 0/9: ''>, seg="'tbl.id = d.other_id'"]
INFO       [PD:3  MD:22]	......................FunctionSegment             	Seque.match OUT     	    	[match=<MatchResult 0/9: ''>, seg="'tbl.id = d.other_id'"]
INFO       [PD:3  MD:21]	.....................FunctionSegment              	OneOf.match OUT     	    	[match=<MatchResult 0/9: ''>, seg="'tbl.id = d.other_id'"]
DEBUG      [PD:3  MD:20]	....................FunctionSegment               	Funct.match OUT     	    	[match=<MatchResult 0/9: ''>, seg="'tbl.id = d.other_id'"]
DEBUG      [PD:3  MD:20]	....................Expression_D_Grammar          	Ref.match OUT       	    	[match=<MatchResult 0/9: ''>, seg="'tbl.id = d.other_id'"]
INFO       [PD:3  MD:20]	....................LiteralGrammar                	OneOf.match PRN     	    	[ns=2, ps=4, ms=0, pruned=[<Ref: BooleanLiteralGrammar>, <Ref: QualifiedNumericLiteralSegment>, <Ref: NullLiteralSegment>, <Ref: DateTimeLiteralGrammar>], opts=[<Ref: QuotedLiteralSegment>, <Ref: NumericLiteralSegment>]]
DEBUG      [PD:3  MD:21]	.....................LiteralGrammar               	Ref.match OUT       	    	[match=<MatchResult 0/9: ''>, seg="'tbl.id = d.other_id'"]
DEBUG      [PD:3  MD:21]	.....................LiteralGrammar               	Ref.match OUT       	    	[match=<MatchResult 0/9: ''>, seg="'tbl.id = d.other_id'"]
INFO       [PD:3  MD:20]	....................LiteralGrammar                	OneOf.match OUT     	    	[match=<MatchResult 0/9: ''>, seg="'tbl.id = d.other_id'"]
DEBUG      [PD:3  MD:20]	....................Expression_D_Grammar          	Ref.match OUT       	    	[match=<MatchResult 0/9: ''>, seg="'tbl.id = d.other_id'"]
DEBUG      [PD:3  MD:22]	......................ColumnReferenceSegment      	Delim._look_ahead_match IN	    	[ls=9, seg='tbl.id = d.other_id']
DEBUG      [PD:3  MD:22]	......................ColumnReferenceSegment      	Delim._look_ahead_match SI	    	[mq=[(<OneOf: [<Ref: DotSegment>, <Sequence: [<Ref: DotSegment>, <Ref: Dot...]>, 1, '.'), (<OneOf: [<Ref: DotSegment>, <Sequence: [<Ref: DotSegment>, <Ref: Dot...]>, 1, '.'), (<OneOf: [<Ref: DotSegment>, <Sequence: [<Ref: DotSegment>, <Ref: Dot...]>, 7, '.'), (<OneOf: [<Ref: DotSegment>, <Sequence: [<Ref: DotSegment>, <Ref: Dot...]>, 7, '.')], sb=['TBL', '.', 'ID', '', '=', '', 'D', '.', 'OTHER_ID']]
INFO       [PD:3  MD:22]	......................ColumnReferenceSegment      	OneOf.match PRN     	    	[ns=0, ps=0, ms=2, pruned=[], opts=[<Ref: DotSegment>, <Sequence: [<Ref: DotSegment>, <Ref: DotSegment>]>]]
DEBUG      [PD:3  MD:23]	.......................ColumnReferenceSegment     	Ref.match OUT       	+   	[match=<MatchResult 1/2: '.'>, seg="'.other_id'"]
DEBUG      [PD:3  MD:24]	........................ColumnReferenceSegment    	Ref.match OUT       	+   	[match=<MatchResult 1/2: '.'>, seg="'.other_id'"]
DEBUG      [PD:3  MD:24]	........................ColumnReferenceSegment    	Ref.match OUT       	    	[match=<MatchResult 0/1: ''>, seg="'other_id'"]
INFO       [PD:3  MD:23]	.......................ColumnReferenceSegment     	Seque.match OUT     	    	[match=<MatchResult 0/2: ''>, seg="'.other_id'"]
INFO       [PD:3  MD:22]	......................ColumnReferenceSegment      	OneOf.match OUT     	+   	[match=<MatchResult 1/2: '.'>, seg="'.other_id'"]
INFO       [PD:3  MD:22]	......................ColumnReferenceSegment      	OneOf.match PRN     	    	[ns=0, ps=0, ms=2, pruned=[], opts=[<Ref: DotSegment>, <Sequence: [<Ref: DotSegment>, <Ref: DotSegment>]>]]
DEBUG      [PD:3  MD:23]	.......................ColumnReferenceSegment     	Ref.match OUT       	+   	[match=<MatchResult 1/2: '.'>, seg="'.other_id'"]
DEBUG      [PD:3  MD:24]	........................ColumnReferenceSegment    	Ref.match OUT       	+   	[match=<MatchResult 1/2: '.'>, seg="'.other_id'"]
DEBUG      [PD:3  MD:24]	........................ColumnReferenceSegment    	Ref.match OUT       	    	[match=<MatchResult 0/1: ''>, seg="'other_id'"]
INFO       [PD:3  MD:23]	.......................ColumnReferenceSegment     	Seque.match OUT     	    	[match=<MatchResult 0/2: ''>, seg="'.other_id'"]
INFO       [PD:3  MD:22]	......................ColumnReferenceSegment      	OneOf.match OUT     	+   	[match=<MatchResult 1/2: '.'>, seg="'.other_id'"]
INFO       [PD:3  MD:22]	......................ColumnReferenceSegment      	OneOf.match PRN     	    	[ns=0, ps=0, ms=2, pruned=[], opts=[<Ref: DotSegment>, <Sequence: [<Ref: DotSegment>, <Ref: DotSegment>]>]]
DEBUG      [PD:3  MD:23]	.......................ColumnReferenceSegment     	Ref.match OUT       	+   	[match=<MatchResult 1/8: '.'>, seg="'.id = d.other_id'"]
DEBUG      [PD:3  MD:24]	........................ColumnReferenceSegment    	Ref.match OUT       	+   	[match=<MatchResult 1/8: '.'>, seg="'.id = d.other_id'"]
DEBUG      [PD:3  MD:24]	........................ColumnReferenceSegment    	Ref.match OUT       	    	[match=<MatchResult 0/7: ''>, seg="'id = d.other_id'"]
INFO       [PD:3  MD:23]	.......................ColumnReferenceSegment     	Seque.match OUT     	    	[match=<MatchResult 0/8: ''>, seg="'.id = d.other_id'"]
INFO       [PD:3  MD:22]	......................ColumnReferenceSegment      	OneOf.match OUT     	+   	[match=<MatchResult 1/8: '.'>, seg="'.id = d.other_id'"]
INFO       [PD:3  MD:22]	......................ColumnReferenceSegment      	OneOf.match PRN     	    	[ns=0, ps=0, ms=2, pruned=[], opts=[<Ref: DotSegment>, <Sequence: [<Ref: DotSegment>, <Ref: DotSegment>]>]]
DEBUG      [PD:3  MD:23]	.......................ColumnReferenceSegment     	Ref.match OUT       	+   	[match=<MatchResult 1/8: '.'>, seg="'.id = d.other_id'"]
DEBUG      [PD:3  MD:24]	........................ColumnReferenceSegment    	Ref.match OUT       	+   	[match=<MatchResult 1/8: '.'>, seg="'.id = d.other_id'"]
DEBUG      [PD:3  MD:24]	........................ColumnReferenceSegment    	Ref.match OUT       	    	[match=<MatchResult 0/7: ''>, seg="'id = d.other_id'"]
INFO       [PD:3  MD:23]	.......................ColumnReferenceSegment     	Seque.match OUT     	    	[match=<MatchResult 0/8: ''>, seg="'.id = d.other_id'"]
INFO       [PD:3  MD:22]	......................ColumnReferenceSegment      	OneOf.match OUT     	+   	[match=<MatchResult 1/8: '.'>, seg="'.id = d.other_id'"]
INFO       [PD:3  MD:22]	......................ColumnReferenceSegment      	OneOf.match PRN     	    	[ns=1, ps=10, ms=0, pruned=[<Ref: OnKeywordSegment>, <Ref: AsKeywordSegment>, <Ref: UsingKeywordSegment>, <Ref: CommaSegment>, <Ref: CastOperatorSegment>, <Ref: StartSquareBracketSegment>, <Ref: StartBracketSegment>, <Ref: ColonSegment>, <Ref: DelimiterSegment>, <class 'sqlfluff.core.parser.segments.base.BracketedSegment'>], opts=[<Ref: BinaryOperatorGrammar>]]
INFO       [PD:3  MD:23]	.......................BinaryOperatorGrammar      	OneOf.match PRN     	    	[ns=1, ps=3, ms=0, pruned=[<Ref: ArithmeticBinaryOperatorGrammar>, <Ref: StringBinaryOperatorGrammar>, <Ref: BooleanBinaryOperatorGrammar>], opts=[<Ref: ComparisonOperatorGrammar>]]
INFO       [PD:3  MD:24]	........................ComparisonOperatorGrammar 	OneOf.match PRN     	    	[ns=1, ps=7, ms=0, pruned=[<Ref: EqualsSegment>, <Ref: GreaterThanSegment>, <Ref: LessThanSegment>, <Ref: GreaterThanOrEqualToSegment>, <Ref: LessThanOrEqualToSegment>, <Ref: NotEqualToSegment_a>, <Ref: NotEqualToSegment_b>], opts=[<Ref: LikeOperatorSegment>]]
DEBUG      [PD:3  MD:25]	.........................ComparisonOperatorGrammar	Ref.match OUT       	    	[match=<MatchResult 0/9: ''>, seg="'tbl.id = d.other_id'"]
INFO       [PD:3  MD:24]	........................ComparisonOperatorGrammar 	OneOf.match OUT     	    	[match=<MatchResult 0/9: ''>, seg="'tbl.id = d.other_id'"]
DEBUG      [PD:3  MD:24]	........................BinaryOperatorGrammar     	Ref.match OUT       	    	[match=<MatchResult 0/9: ''>, seg="'tbl.id = d.other_id'"]
INFO       [PD:3  MD:23]	.......................BinaryOperatorGrammar      	OneOf.match OUT     	    	[match=<MatchResult 0/9: ''>, seg="'tbl.id = d.other_id'"]
DEBUG      [PD:3  MD:23]	.......................ColumnReferenceSegment     	Ref.match OUT       	    	[match=<MatchResult 0/9: ''>, seg="'tbl.id = d.other_id'"]
INFO       [PD:3  MD:22]	......................ColumnReferenceSegment      	OneOf.match OUT     	    	[match=<MatchResult 0/9: ''>, seg="'tbl.id = d.other_id'"]
DEBUG      [PD:3  MD:22]	......................ColumnReferenceSegment      	NonCo.match OUT     	    	[match=<MatchResult 0/9: ''>, seg="'tbl.id = d.other_id'"]
INFO       [PD:3  MD:22]	......................ColumnReferenceSegment      	OneOf.match PRN     	    	[ns=1, ps=10, ms=0, pruned=[<Ref: OnKeywordSegment>, <Ref: AsKeywordSegment>, <Ref: UsingKeywordSegment>, <Ref: CommaSegment>, <Ref: CastOperatorSegment>, <Ref: StartSquareBracketSegment>, <Ref: StartBracketSegment>, <Ref: ColonSegment>, <Ref: DelimiterSegment>, <class 'sqlfluff.core.parser.segments.base.BracketedSegment'>], opts=[<Ref: BinaryOperatorGrammar>]]
INFO       [PD:3  MD:23]	.......................BinaryOperatorGrammar      	OneOf.match PRN     	    	[ns=1, ps=3, ms=0, pruned=[<Ref: ArithmeticBinaryOperatorGrammar>, <Ref: StringBinaryOperatorGrammar>, <Ref: BooleanBinaryOperatorGrammar>], opts=[<Ref: ComparisonOperatorGrammar>]]
INFO       [PD:3  MD:24]	........................ComparisonOperatorGrammar 	OneOf.match PRN     	    	[ns=1, ps=7, ms=0, pruned=[<Ref: EqualsSegment>, <Ref: GreaterThanSegment>, <Ref: LessThanSegment>, <Ref: GreaterThanOrEqualToSegment>, <Ref: LessThanOrEqualToSegment>, <Ref: NotEqualToSegment_a>, <Ref: NotEqualToSegment_b>], opts=[<Ref: LikeOperatorSegment>]]
DEBUG      [PD:3  MD:25]	.........................ComparisonOperatorGrammar	Ref.match OUT       	    	[match=<MatchResult 0/8: ''>, seg="'.id = d.other_id'"]
INFO       [PD:3  MD:24]	........................ComparisonOperatorGrammar 	OneOf.match OUT     	    	[match=<MatchResult 0/8: ''>, seg="'.id = d.other_id'"]
DEBUG      [PD:3  MD:24]	........................BinaryOperatorGrammar     	Ref.match OUT       	    	[match=<MatchResult 0/8: ''>, seg="'.id = d.other_id'"]
INFO       [PD:3  MD:23]	.......................BinaryOperatorGrammar      	OneOf.match OUT     	    	[match=<MatchResult 0/8: ''>, seg="'.id = d.other_id'"]
DEBUG      [PD:3  MD:23]	.......................ColumnReferenceSegment     	Ref.match OUT       	    	[match=<MatchResult 0/8: ''>, seg="'.id = d.other_id'"]
INFO       [PD:3  MD:22]	......................ColumnReferenceSegment      	OneOf.match OUT     	    	[match=<MatchResult 0/8: ''>, seg="'.id = d.other_id'"]
DEBUG      [PD:3  MD:22]	......................ColumnReferenceSegment      	NonCo.match OUT     	    	[match=<MatchResult 0/8: ''>, seg="'.id = d.other_id'"]
INFO       [PD:3  MD:22]	......................SingleIdentifierGrammar     	OneOf.match PRN     	    	[ns=2, ps=0, ms=0, pruned=[], opts=[<Ref: NakedIdentifierSegment>, <Ref: QuotedIdentifierSegment>]]
DEBUG      [PD:3  MD:23]	.......................SingleIdentifierGrammar    	Ref.match OUT       	++  	[match=<MatchResult 1/1: 'tbl'>, seg="'tbl'"]
INFO       [PD:3  MD:22]	......................SingleIdentifierGrammar     	OneOf.match OUT     	++  	[match=<MatchResult 1/1: 'tbl'>, seg="'tbl'"]
DEBUG      [PD:3  MD:22]	......................ColumnReferenceSegment      	Ref.match OUT       	++  	[match=<MatchResult 1/1: 'tbl'>, seg="'tbl'"]
DEBUG      [PD:3  MD:22]	......................ColumnReferenceSegment      	Delim._look_ahead_match IN	    	[ls=7, seg='id = d.other_id']
DEBUG      [PD:3  MD:22]	......................ColumnReferenceSegment      	Delim._look_ahead_match SI	    	[mq=[(<OneOf: [<Ref: DotSegment>, <Sequence: [<Ref: DotSegment>, <Ref: Dot...]>, 5, '.'), (<OneOf: [<Ref: DotSegment>, <Sequence: [<Ref: DotSegment>, <Ref: Dot...]>, 5, '.')], sb=['ID', '', '=', '', 'D', '.', 'OTHER_ID']]
INFO       [PD:3  MD:22]	......................ColumnReferenceSegment      	OneOf.match PRN     	    	[ns=0, ps=0, ms=2, pruned=[], opts=[<Ref: DotSegment>, <Sequence: [<Ref: DotSegment>, <Ref: DotSegment>]>]]
DEBUG      [PD:3  MD:23]	.......................ColumnReferenceSegment     	Ref.match OUT       	+   	[match=<MatchResult 1/2: '.'>, seg="'.other_id'"]
DEBUG      [PD:3  MD:24]	........................ColumnReferenceSegment    	Ref.match OUT       	+   	[match=<MatchResult 1/2: '.'>, seg="'.other_id'"]
DEBUG      [PD:3  MD:24]	........................ColumnReferenceSegment    	Ref.match OUT       	    	[match=<MatchResult 0/1: ''>, seg="'other_id'"]
INFO       [PD:3  MD:23]	.......................ColumnReferenceSegment     	Seque.match OUT     	    	[match=<MatchResult 0/2: ''>, seg="'.other_id'"]
INFO       [PD:3  MD:22]	......................ColumnReferenceSegment      	OneOf.match OUT     	+   	[match=<MatchResult 1/2: '.'>, seg="'.other_id'"]
INFO       [PD:3  MD:22]	......................ColumnReferenceSegment      	OneOf.match PRN     	    	[ns=0, ps=0, ms=2, pruned=[], opts=[<Ref: DotSegment>, <Sequence: [<Ref: DotSegment>, <Ref: DotSegment>]>]]
DEBUG      [PD:3  MD:23]	.......................ColumnReferenceSegment     	Ref.match OUT       	+   	[match=<MatchResult 1/2: '.'>, seg="'.other_id'"]
DEBUG      [PD:3  MD:24]	........................ColumnReferenceSegment    	Ref.match OUT       	+   	[match=<MatchResult 1/2: '.'>, seg="'.other_id'"]
DEBUG      [PD:3  MD:24]	........................ColumnReferenceSegment    	Ref.match OUT       	    	[match=<MatchResult 0/1: ''>, seg="'other_id'"]
INFO       [PD:3  MD:23]	.......................ColumnReferenceSegment     	Seque.match OUT     	    	[match=<MatchResult 0/2: ''>, seg="'.other_id'"]
INFO       [PD:3  MD:22]	......................ColumnReferenceSegment      	OneOf.match OUT     	+   	[match=<MatchResult 1/2: '.'>, seg="'.other_id'"]
INFO       [PD:3  MD:22]	......................ColumnReferenceSegment      	OneOf.match PRN     	    	[ns=1, ps=10, ms=0, pruned=[<Ref: OnKeywordSegment>, <Ref: AsKeywordSegment>, <Ref: UsingKeywordSegment>, <Ref: CommaSegment>, <Ref: CastOperatorSegment>, <Ref: StartSquareBracketSegment>, <Ref: StartBracketSegment>, <Ref: ColonSegment>, <Ref: DelimiterSegment>, <class 'sqlfluff.core.parser.segments.base.BracketedSegment'>], opts=[<Ref: BinaryOperatorGrammar>]]
INFO       [PD:3  MD:23]	.......................BinaryOperatorGrammar      	OneOf.match PRN     	    	[ns=1, ps=3, ms=0, pruned=[<Ref: ArithmeticBinaryOperatorGrammar>, <Ref: StringBinaryOperatorGrammar>, <Ref: BooleanBinaryOperatorGrammar>], opts=[<Ref: ComparisonOperatorGrammar>]]
INFO       [PD:3  MD:24]	........................ComparisonOperatorGrammar 	OneOf.match PRN     	    	[ns=1, ps=7, ms=0, pruned=[<Ref: EqualsSegment>, <Ref: GreaterThanSegment>, <Ref: LessThanSegment>, <Ref: GreaterThanOrEqualToSegment>, <Ref: LessThanOrEqualToSegment>, <Ref: NotEqualToSegment_a>, <Ref: NotEqualToSegment_b>], opts=[<Ref: LikeOperatorSegment>]]
DEBUG      [PD:3  MD:25]	.........................ComparisonOperatorGrammar	Ref.match OUT       	    	[match=<MatchResult 0/7: ''>, seg="'id = d.other_id'"]
INFO       [PD:3  MD:24]	........................ComparisonOperatorGrammar 	OneOf.match OUT     	    	[match=<MatchResult 0/7: ''>, seg="'id = d.other_id'"]
DEBUG      [PD:3  MD:24]	........................BinaryOperatorGrammar     	Ref.match OUT       	    	[match=<MatchResult 0/7: ''>, seg="'id = d.other_id'"]
INFO       [PD:3  MD:23]	.......................BinaryOperatorGrammar      	OneOf.match OUT     	    	[match=<MatchResult 0/7: ''>, seg="'id = d.other_id'"]
DEBUG      [PD:3  MD:23]	.......................ColumnReferenceSegment     	Ref.match OUT       	    	[match=<MatchResult 0/7: ''>, seg="'id = d.other_id'"]
INFO       [PD:3  MD:22]	......................ColumnReferenceSegment      	OneOf.match OUT     	    	[match=<MatchResult 0/7: ''>, seg="'id = d.other_id'"]
DEBUG      [PD:3  MD:22]	......................ColumnReferenceSegment      	NonCo.match OUT     	    	[match=<MatchResult 0/7: ''>, seg="'id = d.other_id'"]
INFO       [PD:3  MD:22]	......................ColumnReferenceSegment      	OneOf.match PRN     	    	[ns=1, ps=10, ms=0, pruned=[<Ref: OnKeywordSegment>, <Ref: AsKeywordSegment>, <Ref: UsingKeywordSegment>, <Ref: CommaSegment>, <Ref: CastOperatorSegment>, <Ref: StartSquareBracketSegment>, <Ref: StartBracketSegment>, <Ref: ColonSegment>, <Ref: DelimiterSegment>, <class 'sqlfluff.core.parser.segments.base.BracketedSegment'>], opts=[<Ref: BinaryOperatorGrammar>]]
INFO       [PD:3  MD:23]	.......................BinaryOperatorGrammar      	OneOf.match PRN     	    	[ns=1, ps=3, ms=0, pruned=[<Ref: ArithmeticBinaryOperatorGrammar>, <Ref: StringBinaryOperatorGrammar>, <Ref: BooleanBinaryOperatorGrammar>], opts=[<Ref: ComparisonOperatorGrammar>]]
INFO       [PD:3  MD:24]	........................ComparisonOperatorGrammar 	OneOf.match PRN     	    	[ns=1, ps=6, ms=1, pruned=[<Ref: GreaterThanSegment>, <Ref: LessThanSegment>, <Ref: GreaterThanOrEqualToSegment>, <Ref: LessThanOrEqualToSegment>, <Ref: NotEqualToSegment_a>, <Ref: NotEqualToSegment_b>], opts=[<Ref: EqualsSegment>, <Ref: LikeOperatorSegment>]]
DEBUG      [PD:3  MD:25]	.........................ComparisonOperatorGrammar	Ref.match OUT       	    	[match=<MatchResult 0/6: ''>, seg="' = d.other_id'"]
DEBUG      [PD:3  MD:25]	.........................ComparisonOperatorGrammar	Ref.match OUT       	    	[match=<MatchResult 0/6: ''>, seg="' = d.other_id'"]
INFO       [PD:3  MD:24]	........................ComparisonOperatorGrammar 	OneOf.match OUT     	    	[match=<MatchResult 0/6: ''>, seg="' = d.other_id'"]
DEBUG      [PD:3  MD:24]	........................BinaryOperatorGrammar     	Ref.match OUT       	    	[match=<MatchResult 0/6: ''>, seg="' = d.other_id'"]
INFO       [PD:3  MD:23]	.......................BinaryOperatorGrammar      	OneOf.match OUT     	    	[match=<MatchResult 0/6: ''>, seg="' = d.other_id'"]
DEBUG      [PD:3  MD:23]	.......................ColumnReferenceSegment     	Ref.match OUT       	    	[match=<MatchResult 0/6: ''>, seg="' = d.other_id'"]
INFO       [PD:3  MD:22]	......................ColumnReferenceSegment      	OneOf.match OUT     	    	[match=<MatchResult 0/6: ''>, seg="' = d.other_id'"]
DEBUG      [PD:3  MD:22]	......................ColumnReferenceSegment      	NonCo.match OUT     	+   	[match=<MatchResult 1/6: ' '>, seg="' = d.other_id'"]
INFO       [PD:3  MD:22]	......................SingleIdentifierGrammar     	OneOf.match PRN     	    	[ns=2, ps=0, ms=0, pruned=[], opts=[<Ref: NakedIdentifierSegment>, <Ref: QuotedIdentifierSegment>]]
DEBUG      [PD:3  MD:23]	.......................SingleIdentifierGrammar    	Ref.match OUT       	++  	[match=<MatchResult 1/1: 'id'>, seg="'id'"]
INFO       [PD:3  MD:22]	......................SingleIdentifierGrammar     	OneOf.match OUT     	++  	[match=<MatchResult 1/1: 'id'>, seg="'id'"]
DEBUG      [PD:3  MD:22]	......................ColumnReferenceSegment      	Ref.match OUT       	++  	[match=<MatchResult 1/1: 'id'>, seg="'id'"]
INFO       [PD:3  MD:21]	.....................ColumnReferenceSegment       	Delim.match OUT     	+   	[match=<MatchResult 3/9: 'tbl.id'>, seg="'tbl.id = d.other_id'"]
DEBUG      [PD:3  MD:20]	....................ColumnReferenceSegment        	Colum.match OUT     	+   	[match=<MatchResult 1/7: 'tbl.id'>, seg="'tbl.id = d.other_id'"]
DEBUG      [PD:3  MD:20]	....................Expression_D_Grammar          	Ref.match OUT       	+   	[match=<MatchResult 1/7: 'tbl.id'>, seg="'tbl.id = d.other_id'"]
DEBUG      [PD:3  MD:21]	.....................Expression_D_Grammar         	Ref.match OUT       	    	[match=<MatchResult 0/9: ''>, seg="'tbl.id = d.other_id'"]
INFO       [PD:3  MD:22]	......................ArrayLiteralSegment         	Brack.match OUT     	    	[match=<MatchResult 0/9: ''>, seg="'tbl.id = d.other_id'"]
DEBUG      [PD:3  MD:21]	.....................ArrayLiteralSegment          	Array.match OUT     	    	[match=<MatchResult 0/9: ''>, seg="'tbl.id = d.other_id'"]
DEBUG      [PD:3  MD:21]	.....................Expression_D_Grammar         	Ref.match OUT       	    	[match=<MatchResult 0/9: ''>, seg="'tbl.id = d.other_id'"]
INFO       [PD:3  MD:20]	....................Expression_D_Grammar          	Seque.match OUT     	    	[match=<MatchResult 0/9: ''>, seg="'tbl.id = d.other_id'"]
INFO       [PD:3  MD:22]	......................DatatypeSegment             	OneOf.match PRN     	    	[ns=1, ps=2, ms=0, pruned=[<Sequence: [<OneOf: [<Ref: TimeKeywordSegment>, <Ref..., <Bracketed: [<Ref: NumericLiteralSegment..., <Sequence:...]>, <Sequence: [<Ref: DoubleKeywordSegment>, <Ref: PrecisionKeywordSegment>]>], opts=[<Sequence: [<OneOf: [<Sequence: [<OneOf: [<Ref: Char..., <Bracketed: [<OneOf: [<Delimited: [<Ref:..., <Ref: Char...]>]]
INFO       [PD:3  MD:24]	........................DatatypeSegment           	OneOf.match PRN     	    	[ns=1, ps=1, ms=0, pruned=[<Sequence: [<OneOf: [<Ref: CharacterKeywordSegment>,..., <OneOf: [<Ref: VaryingKeywordSegment>, <...]>], opts=[<Sequence: [<Sequence: [<Ref: SingleIdentifierGramma..., <Ref: DatatypeIdentifierSegment>]>]]
INFO       [PD:3  MD:27]	...........................SingleIdentifierGrammar	OneOf.match PRN     	    	[ns=2, ps=0, ms=0, pruned=[], opts=[<Ref: NakedIdentifierSegment>, <Ref: QuotedIdentifierSegment>]]
DEBUG      [PD:3  MD:28]	............................SingleIdentifierGrammar	Ref.match OUT       	+   	[match=<MatchResult 1/9: 'tbl'>, seg="'tbl.id = d.other_id'"]
DEBUG      [PD:3  MD:28]	............................SingleIdentifierGrammar	Ref.match OUT       	    	[match=<MatchResult 0/9: ''>, seg="'tbl.id = d.other_id'"]
INFO       [PD:3  MD:27]	...........................SingleIdentifierGrammar	OneOf.match OUT     	+   	[match=<MatchResult 1/9: 'tbl'>, seg="'tbl.id = d.other_id'"]
DEBUG      [PD:3  MD:27]	...........................DatatypeSegment        	Ref.match OUT       	+   	[match=<MatchResult 1/9: 'tbl'>, seg="'tbl.id = d.other_id'"]
DEBUG      [PD:3  MD:27]	...........................DatatypeSegment        	Ref.match OUT       	+   	[match=<MatchResult 1/8: '.'>, seg="'.id = d.other_id'"]
INFO       [PD:3  MD:26]	..........................DatatypeSegment         	Seque.match OUT     	+   	[match=<MatchResult 2/9: 'tbl.'>, seg="'tbl.id = d.other_id'"]
DEBUG      [PD:3  MD:26]	..........................DatatypeSegment         	Ref.match OUT       	+   	[match=<MatchResult 1/7: 'id'>, seg="'id = d.other_id'"]
INFO       [PD:3  MD:25]	.........................DatatypeSegment          	Seque.match OUT     	+   	[match=<MatchResult 3/9: 'tbl.id'>, seg="'tbl.id = d.other_id'"]
INFO       [PD:3  MD:24]	........................DatatypeSegment           	OneOf.match OUT     	+   	[match=<MatchResult 3/9: 'tbl.id'>, seg="'tbl.id = d.other_id'"]
INFO       [PD:3  MD:24]	........................DatatypeSegment           	Brack.match OUT     	    	[match=<MatchResult 0/5: ''>, seg="'= d.other_id'"]
DEBUG      [PD:3  MD:24]	........................DatatypeSegment           	Ref.match OUT       	    	[match=<MatchResult 0/5: ''>, seg="'= d.other_id'"]
INFO       [PD:3  MD:23]	.......................DatatypeSegment            	Seque.match OUT     	+   	[match=<MatchResult 3/9: 'tbl.id'>, seg="'tbl.id = d.other_id'"]
INFO       [PD:3  MD:22]	......................DatatypeSegment             	OneOf.match OUT     	+   	[match=<MatchResult 3/9: 'tbl.id'>, seg="'tbl.id = d.other_id'"]
DEBUG      [PD:3  MD:21]	.....................DatatypeSegment              	Datat.match OUT     	+   	[match=<MatchResult 1/7: 'tbl.id'>, seg="'tbl.id = d.other_id'"]
DEBUG      [PD:3  MD:21]	.....................Expression_D_Grammar         	Ref.match OUT       	+   	[match=<MatchResult 1/7: 'tbl.id'>, seg="'tbl.id = d.other_id'"]
INFO       [PD:3  MD:21]	.....................Expression_D_Grammar         	OneOf.match PRN     	    	[ns=2, ps=3, ms=0, pruned=[<Ref: BooleanLiteralGrammar>, <Ref: NullLiteralSegment>, <Ref: DateTimeLiteralGrammar>], opts=[<Ref: QuotedLiteralSegment>, <Ref: NumericLiteralSegment>]]
DEBUG      [PD:3  MD:22]	......................Expression_D_Grammar        	Ref.match OUT       	    	[match=<MatchResult 0/5: ''>, seg="'= d.other_id'"]
DEBUG      [PD:3  MD:22]	......................Expression_D_Grammar        	Ref.match OUT       	    	[match=<MatchResult 0/5: ''>, seg="'= d.other_id'"]
INFO       [PD:3  MD:21]	.....................Expression_D_Grammar         	OneOf.match OUT     	    	[match=<MatchResult 0/5: ''>, seg="'= d.other_id'"]
INFO       [PD:3  MD:20]	....................Expression_D_Grammar          	Seque.match OUT     	    	[match=<MatchResult 0/9: ''>, seg="'tbl.id = d.other_id'"]
INFO       [PD:3  MD:19]	...................Expression_D_Grammar           	OneOf.match OUT     	+   	[match=<MatchResult 1/7: 'tbl.id'>, seg="'tbl.id = d.other_id'"]
INFO       [PD:3  MD:19]	...................Accessor_Grammar               	AnyNu.match PRN     	    	[ns=0, ps=1, ms=0, pruned=[<Ref: ArrayAccessorSegment>], opts='ALL']
INFO       [PD:3  MD:19]	...................Accessor_Grammar               	AnyNu.match OUT     	    	[match=<MatchResult 0/5: ''>, seg="'= d.other_id'"]
DEBUG      [PD:3  MD:19]	...................Expression_D_Grammar           	Ref.match OUT       	    	[match=<MatchResult 0/5: ''>, seg="'= d.other_id'"]
INFO       [PD:3  MD:19]	...................Expression_D_Grammar           	AnyNu.match PRN     	    	[ns=0, ps=1, ms=0, pruned=[<Ref: ShorthandCastSegment>], opts='ALL']
INFO       [PD:3  MD:19]	...................Expression_D_Grammar           	AnyNu.match OUT     	    	[match=<MatchResult 0/5: ''>, seg="'= d.other_id'"]
INFO       [PD:3  MD:18]	..................Expression_D_Grammar            	Seque.match OUT     	+   	[match=<MatchResult 1/7: 'tbl.id'>, seg="'tbl.id = d.other_id'"]
DEBUG      [PD:3  MD:18]	..................Expression_C_Grammar            	Ref.match OUT       	+   	[match=<MatchResult 1/7: 'tbl.id'>, seg="'tbl.id = d.other_id'"]
INFO       [PD:3  MD:17]	.................Expression_C_Grammar             	OneOf.match OUT     	+   	[match=<MatchResult 1/7: 'tbl.id'>, seg="'tbl.id = d.other_id'"]
DEBUG      [PD:3  MD:17]	.................Expression_A_Grammar             	Ref.match OUT       	+   	[match=<MatchResult 1/7: 'tbl.id'>, seg="'tbl.id = d.other_id'"]
INFO       [PD:3  MD:16]	................Expression_A_Grammar              	OneOf.match OUT     	+   	[match=<MatchResult 1/7: 'tbl.id'>, seg="'tbl.id = d.other_id'"]
INFO       [PD:3  MD:16]	................Expression_A_Grammar              	AnyNu.match PRN     	    	[ns=1, ps=0, ms=0, pruned=[], opts=[<OneOf: [<Sequence: [<OneOf: [<Sequence: [<Ref: N..., <Sequence: [<Ref: NotKeywordSegment [opt..., <Sequence:...]>]]
INFO       [PD:3  MD:17]	.................Expression_A_Grammar             	OneOf.match PRN     	    	[ns=3, ps=5, ms=0, pruned=[<Sequence: [<Ref: NotKeywordSegment [opt]>, <Ref: InKeywordSegment>, <Bracketed: [<OneOf: [<Delimited: [<Ref:...]>, <Sequence: [<Ref: NotKeywordSegment [opt]>, <Ref: InKeywordSegment>, <Ref: FunctionSegment>]>, <Sequence: [<Ref: IsKeywordSegment>, <Ref: NotKeywordSegment [opt]>, <Ref: IsClauseGrammar>]>, <Sequence: [<Ref: NotKeywordSegment>, <Ref: Expression_C_Grammar>]>, <Sequence: [<Ref: NotKeywordSegment [opt]>, <Ref: BetweenKeywordSegment>, <Ref: Expression_C_Grammar>, <AnyNumbe...]>], opts=[<Sequence: [<OneOf: [<Sequence: [<Ref: NotKeywordSeg..., <Ref: Expression_C_Grammar>, <Sequence: [<Ref: EscapeKe...]>, <Ref: IsNullGrammar>, <Ref: NotNullGrammar>]]
INFO       [PD:3  MD:19]	...................Expression_A_Grammar           	OneOf.match PRN     	    	[ns=1, ps=1, ms=0, pruned=[<Sequence: [<Ref: NotKeywordSegment [opt]>, <Ref: LikeGrammar>]>], opts=[<Sequence: [<Ref: BinaryOperatorGrammar>, <Ref: NotKeywordSegment [opt]>]>]]
INFO       [PD:3  MD:21]	.....................BinaryOperatorGrammar        	OneOf.match PRN     	    	[ns=1, ps=3, ms=0, pruned=[<Ref: ArithmeticBinaryOperatorGrammar>, <Ref: StringBinaryOperatorGrammar>, <Ref: BooleanBinaryOperatorGrammar>], opts=[<Ref: ComparisonOperatorGrammar>]]
INFO       [PD:3  MD:22]	......................ComparisonOperatorGrammar   	OneOf.match PRN     	    	[ns=1, ps=6, ms=1, pruned=[<Ref: GreaterThanSegment>, <Ref: LessThanSegment>, <Ref: GreaterThanOrEqualToSegment>, <Ref: LessThanOrEqualToSegment>, <Ref: NotEqualToSegment_a>, <Ref: NotEqualToSegment_b>], opts=[<Ref: EqualsSegment>, <Ref: LikeOperatorSegment>]]
DEBUG      [PD:3  MD:23]	.......................ComparisonOperatorGrammar  	Ref.match OUT       	+   	[match=<MatchResult 1/5: '='>, seg="'= d.other_id'"]
DEBUG      [PD:3  MD:23]	.......................ComparisonOperatorGrammar  	Ref.match OUT       	    	[match=<MatchResult 0/5: ''>, seg="'= d.other_id'"]
INFO       [PD:3  MD:22]	......................ComparisonOperatorGrammar   	OneOf.match OUT     	+   	[match=<MatchResult 1/5: '='>, seg="'= d.other_id'"]
DEBUG      [PD:3  MD:22]	......................BinaryOperatorGrammar       	Ref.match OUT       	+   	[match=<MatchResult 1/5: '='>, seg="'= d.other_id'"]
INFO       [PD:3  MD:21]	.....................BinaryOperatorGrammar        	OneOf.match OUT     	+   	[match=<MatchResult 1/5: '='>, seg="'= d.other_id'"]
DEBUG      [PD:3  MD:21]	.....................Expression_A_Grammar         	Ref.match OUT       	+   	[match=<MatchResult 1/5: '='>, seg="'= d.other_id'"]
DEBUG      [PD:3  MD:21]	.....................Expression_A_Grammar         	Ref.match OUT       	    	[match=<MatchResult 0/3: ''>, seg="'d.other_id'"]
INFO       [PD:3  MD:20]	....................Expression_A_Grammar          	Seque.match OUT     	+   	[match=<MatchResult 1/5: '='>, seg="'= d.other_id'"]
INFO       [PD:3  MD:19]	...................Expression_A_Grammar           	OneOf.match OUT     	+   	[match=<MatchResult 1/5: '='>, seg="'= d.other_id'"]
INFO       [PD:3  MD:19]	...................Expression_C_Grammar           	OneOf.match PRN     	    	[ns=1, ps=2, ms=0, pruned=[<Sequence: [<Ref: ExistsKeywordSegment>, <Bracketed: [<Ref: SelectStatementSegmen...]>, <Ref: CaseExpressionSegment>], opts=[<Ref: Expression_D_Grammar>]]
INFO       [PD:3  MD:21]	.....................Expression_D_Grammar         	OneOf.match PRN     	    	[ns=6, ps=3, ms=0, pruned=[<Bracketed: [<OneOf: [<Ref: ExpressionSegment>, <Ref:...]>, <Ref: SelectStatementSegment>, <Ref: IntervalExpressionSegment>], opts=[<Ref: BareFunctionSegment>, <Ref: FunctionSegment>, <Ref: LiteralGrammar>, <Ref: ColumnReferenceSegment>, <Sequence: [<Ref: SimpleArrayTypeGrammar [opt]>, <Ref: ArrayLiteralSegment>]>, <Sequence: [<Ref: DatatypeSegment>, <OneOf: [<Ref: QuotedLiteralSegment>, <R...]>]]
DEBUG      [PD:3  MD:22]	......................Expression_D_Grammar        	Ref.match OUT       	    	[match=<MatchResult 0/3: ''>, seg="'d.other_id'"]
INFO       [PD:3  MD:23]	.......................FunctionSegment            	OneOf.match PRN     	    	[ns=1, ps=1, ms=0, pruned=[<Sequence: [<Sequence: [<Ref: DateAddFunctionNameSeg...]>], opts=[<Sequence: [<Sequence: [<AnyNumberOf: [<Ref: Functio..., <Ref: PostFunctionGrammar [opt]>]>]]
DEBUG      [PD:3  MD:29]	.............................DateAddFunctionNameSegment	Ref.match OUT       	    	[match=<MatchResult 0/3: ''>, seg="'d.other_id'"]
INFO       [PD:3  MD:28]	............................DateAddFunctionNameSegment	Seque.match OUT     	    	[match=<MatchResult 0/3: ''>, seg="'d.other_id'"]
DEBUG      [PD:3  MD:27]	...........................DateAddFunctionNameSegment	DateA.match OUT     	    	[match=<MatchResult 0/3: ''>, seg="'d.other_id'"]
DEBUG      [PD:3  MD:27]	...........................FunctionSegment        	Ref.match OUT       	    	[match=<MatchResult 0/3: ''>, seg="'d.other_id'"]
INFO       [PD:3  MD:26]	..........................FunctionSegment         	AnyNu.match PRN     	    	[ns=1, ps=0, ms=0, pruned=[], opts=[<Ref: FunctionNameSegment>]]
INFO       [PD:3  MD:29]	.............................FunctionNameSegment  	AnyNu.match PRN     	    	[ns=1, ps=0, ms=0, pruned=[], opts=[<Sequence: [<Ref: SingleIdentifierGrammar>, <Ref: DotSegment>]>]]
INFO       [PD:3  MD:31]	...............................SingleIdentifierGrammar	OneOf.match PRN     	    	[ns=2, ps=0, ms=0, pruned=[], opts=[<Ref: NakedIdentifierSegment>, <Ref: QuotedIdentifierSegment>]]
DEBUG      [PD:3  MD:32]	................................SingleIdentifierGrammar	Ref.match OUT       	+   	[match=<MatchResult 1/3: 'd'>, seg="'d.other_id'"]
DEBUG      [PD:3  MD:32]	................................SingleIdentifierGrammar	Ref.match OUT       	    	[match=<MatchResult 0/3: ''>, seg="'d.other_id'"]
INFO       [PD:3  MD:31]	...............................SingleIdentifierGrammar	OneOf.match OUT     	+   	[match=<MatchResult 1/3: 'd'>, seg="'d.other_id'"]
DEBUG      [PD:3  MD:31]	...............................FunctionNameSegment	Ref.match OUT       	+   	[match=<MatchResult 1/3: 'd'>, seg="'d.other_id'"]
DEBUG      [PD:3  MD:31]	...............................FunctionNameSegment	Ref.match OUT       	+   	[match=<MatchResult 1/2: '.'>, seg="'.other_id'"]
INFO       [PD:3  MD:30]	..............................FunctionNameSegment 	Seque.match OUT     	+   	[match=<MatchResult 2/3: 'd.'>, seg="'d.other_id'"]
INFO       [PD:3  MD:29]	.............................FunctionNameSegment  	AnyNu.match PRN     	    	[ns=1, ps=0, ms=0, pruned=[], opts=[<Sequence: [<Ref: SingleIdentifierGrammar>, <Ref: DotSegment>]>]]
INFO       [PD:3  MD:31]	...............................SingleIdentifierGrammar	OneOf.match PRN     	    	[ns=2, ps=0, ms=0, pruned=[], opts=[<Ref: NakedIdentifierSegment>, <Ref: QuotedIdentifierSegment>]]
DEBUG      [PD:3  MD:32]	................................SingleIdentifierGrammar	Ref.match OUT       	++  	[match=<MatchResult 1/1: 'other_id'>, seg="'other_id'"]
INFO       [PD:3  MD:31]	...............................SingleIdentifierGrammar	OneOf.match OUT     	++  	[match=<MatchResult 1/1: 'other_id'>, seg="'other_id'"]
DEBUG      [PD:3  MD:31]	...............................FunctionNameSegment	Ref.match OUT       	++  	[match=<MatchResult 1/1: 'other_id'>, seg="'other_id'"]
INFO       [PD:3  MD:30]	..............................FunctionNameSegment 	Seque.match OUT     	    	[match=<MatchResult 0/1: ''>, seg="'other_id'"]
INFO       [PD:3  MD:29]	.............................FunctionNameSegment  	AnyNu.match OUT     	+   	[match=<MatchResult 2/3: 'd.'>, seg="'d.other_id'"]
INFO       [PD:3  MD:29]	.............................FunctionNameSegment  	OneOf.match PRN     	    	[ns=2, ps=0, ms=0, pruned=[], opts=[<Ref: FunctionNameIdentifierSegment>, <Ref: QuotedIdentifierSegment>]]
DEBUG      [PD:3  MD:30]	..............................FunctionNameSegment 	Ref.match OUT       	++  	[match=<MatchResult 1/1: 'other_id'>, seg="'other_id'"]
INFO       [PD:3  MD:29]	.............................FunctionNameSegment  	OneOf.match OUT     	++  	[match=<MatchResult 1/1: 'other_id'>, seg="'other_id'"]
INFO       [PD:3  MD:28]	............................FunctionNameSegment   	Seque.match OUT     	++  	[match=<MatchResult 3/3: 'd.other_id'>, seg="'d.other_id'"]
DEBUG      [PD:3  MD:27]	...........................FunctionNameSegment    	Funct.match OUT     	++  	[match=<MatchResult 1/1: 'd.other_id'>, seg="'d.other_id'"]
DEBUG      [PD:3  MD:27]	...........................FunctionSegment        	Ref.match OUT       	++  	[match=<MatchResult 1/1: 'd.other_id'>, seg="'d.other_id'"]
INFO       [PD:3  MD:26]	..........................FunctionSegment         	AnyNu.match OUT     	++  	[match=<MatchResult 1/1: 'd.other_id'>, seg="'d.other_id'"]
INFO       [PD:3  MD:25]	.........................FunctionSegment          	Seque.match OUT     	    	[match=<MatchResult 0/3: ''>, seg="'d.other_id'"]
INFO       [PD:3  MD:24]	........................FunctionSegment           	Seque.match OUT     	    	[match=<MatchResult 0/3: ''>, seg="'d.other_id'"]
INFO       [PD:3  MD:23]	.......................FunctionSegment            	OneOf.match OUT     	    	[match=<MatchResult 0/3: ''>, seg="'d.other_id'"]
DEBUG      [PD:3  MD:22]	......................FunctionSegment             	Funct.match OUT     	    	[match=<MatchResult 0/3: ''>, seg="'d.other_id'"]
DEBUG      [PD:3  MD:22]	......................Expression_D_Grammar        	Ref.match OUT       	    	[match=<MatchResult 0/3: ''>, seg="'d.other_id'"]
INFO       [PD:3  MD:22]	......................LiteralGrammar              	OneOf.match PRN     	    	[ns=2, ps=4, ms=0, pruned=[<Ref: BooleanLiteralGrammar>, <Ref: QualifiedNumericLiteralSegment>, <Ref: NullLiteralSegment>, <Ref: DateTimeLiteralGrammar>], opts=[<Ref: QuotedLiteralSegment>, <Ref: NumericLiteralSegment>]]
DEBUG      [PD:3  MD:23]	.......................LiteralGrammar             	Ref.match OUT       	    	[match=<MatchResult 0/3: ''>, seg="'d.other_id'"]
DEBUG      [PD:3  MD:23]	.......................LiteralGrammar             	Ref.match OUT       	    	[match=<MatchResult 0/3: ''>, seg="'d.other_id'"]
INFO       [PD:3  MD:22]	......................LiteralGrammar              	OneOf.match OUT     	    	[match=<MatchResult 0/3: ''>, seg="'d.other_id'"]
DEBUG      [PD:3  MD:22]	......................Expression_D_Grammar        	Ref.match OUT       	    	[match=<MatchResult 0/3: ''>, seg="'d.other_id'"]
DEBUG      [PD:3  MD:24]	........................ColumnReferenceSegment    	Delim._look_ahead_match IN	    	[ls=3, seg='d.other_id']
DEBUG      [PD:3  MD:24]	........................ColumnReferenceSegment    	Delim._look_ahead_match SI	    	[mq=[(<OneOf: [<Ref: DotSegment>, <Sequence: [<Ref: DotSegment>, <Ref: Dot...]>, 1, '.'), (<OneOf: [<Ref: DotSegment>, <Sequence: [<Ref: DotSegment>, <Ref: Dot...]>, 1, '.')], sb=['D', '.', 'OTHER_ID']]
INFO       [PD:3  MD:24]	........................ColumnReferenceSegment    	OneOf.match PRN     	    	[ns=0, ps=0, ms=2, pruned=[], opts=[<Ref: DotSegment>, <Sequence: [<Ref: DotSegment>, <Ref: DotSegment>]>]]
DEBUG      [PD:3  MD:25]	.........................ColumnReferenceSegment   	Ref.match OUT       	+   	[match=<MatchResult 1/2: '.'>, seg="'.other_id'"]
DEBUG      [PD:3  MD:26]	..........................ColumnReferenceSegment  	Ref.match OUT       	+   	[match=<MatchResult 1/2: '.'>, seg="'.other_id'"]
DEBUG      [PD:3  MD:26]	..........................ColumnReferenceSegment  	Ref.match OUT       	    	[match=<MatchResult 0/1: ''>, seg="'other_id'"]
INFO       [PD:3  MD:25]	.........................ColumnReferenceSegment   	Seque.match OUT     	    	[match=<MatchResult 0/2: ''>, seg="'.other_id'"]
INFO       [PD:3  MD:24]	........................ColumnReferenceSegment    	OneOf.match OUT     	+   	[match=<MatchResult 1/2: '.'>, seg="'.other_id'"]
INFO       [PD:3  MD:24]	........................ColumnReferenceSegment    	OneOf.match PRN     	    	[ns=0, ps=0, ms=2, pruned=[], opts=[<Ref: DotSegment>, <Sequence: [<Ref: DotSegment>, <Ref: DotSegment>]>]]
DEBUG      [PD:3  MD:25]	.........................ColumnReferenceSegment   	Ref.match OUT       	+   	[match=<MatchResult 1/2: '.'>, seg="'.other_id'"]
DEBUG      [PD:3  MD:26]	..........................ColumnReferenceSegment  	Ref.match OUT       	+   	[match=<MatchResult 1/2: '.'>, seg="'.other_id'"]
DEBUG      [PD:3  MD:26]	..........................ColumnReferenceSegment  	Ref.match OUT       	    	[match=<MatchResult 0/1: ''>, seg="'other_id'"]
INFO       [PD:3  MD:25]	.........................ColumnReferenceSegment   	Seque.match OUT     	    	[match=<MatchResult 0/2: ''>, seg="'.other_id'"]
INFO       [PD:3  MD:24]	........................ColumnReferenceSegment    	OneOf.match OUT     	+   	[match=<MatchResult 1/2: '.'>, seg="'.other_id'"]
INFO       [PD:3  MD:24]	........................ColumnReferenceSegment    	OneOf.match PRN     	    	[ns=1, ps=10, ms=0, pruned=[<Ref: OnKeywordSegment>, <Ref: AsKeywordSegment>, <Ref: UsingKeywordSegment>, <Ref: CommaSegment>, <Ref: CastOperatorSegment>, <Ref: StartSquareBracketSegment>, <Ref: StartBracketSegment>, <Ref: ColonSegment>, <Ref: DelimiterSegment>, <class 'sqlfluff.core.parser.segments.base.BracketedSegment'>], opts=[<Ref: BinaryOperatorGrammar>]]
INFO       [PD:3  MD:25]	.........................BinaryOperatorGrammar    	OneOf.match PRN     	    	[ns=1, ps=3, ms=0, pruned=[<Ref: ArithmeticBinaryOperatorGrammar>, <Ref: StringBinaryOperatorGrammar>, <Ref: BooleanBinaryOperatorGrammar>], opts=[<Ref: ComparisonOperatorGrammar>]]
INFO       [PD:3  MD:26]	..........................ComparisonOperatorGrammar	OneOf.match PRN     	    	[ns=1, ps=7, ms=0, pruned=[<Ref: EqualsSegment>, <Ref: GreaterThanSegment>, <Ref: LessThanSegment>, <Ref: GreaterThanOrEqualToSegment>, <Ref: LessThanOrEqualToSegment>, <Ref: NotEqualToSegment_a>, <Ref: NotEqualToSegment_b>], opts=[<Ref: LikeOperatorSegment>]]
DEBUG      [PD:3  MD:27]	...........................ComparisonOperatorGrammar	Ref.match OUT       	    	[match=<MatchResult 0/3: ''>, seg="'d.other_id'"]
INFO       [PD:3  MD:26]	..........................ComparisonOperatorGrammar	OneOf.match OUT     	    	[match=<MatchResult 0/3: ''>, seg="'d.other_id'"]
DEBUG      [PD:3  MD:26]	..........................BinaryOperatorGrammar   	Ref.match OUT       	    	[match=<MatchResult 0/3: ''>, seg="'d.other_id'"]
INFO       [PD:3  MD:25]	.........................BinaryOperatorGrammar    	OneOf.match OUT     	    	[match=<MatchResult 0/3: ''>, seg="'d.other_id'"]
DEBUG      [PD:3  MD:25]	.........................ColumnReferenceSegment   	Ref.match OUT       	    	[match=<MatchResult 0/3: ''>, seg="'d.other_id'"]
INFO       [PD:3  MD:24]	........................ColumnReferenceSegment    	OneOf.match OUT     	    	[match=<MatchResult 0/3: ''>, seg="'d.other_id'"]
DEBUG      [PD:3  MD:24]	........................ColumnReferenceSegment    	NonCo.match OUT     	    	[match=<MatchResult 0/3: ''>, seg="'d.other_id'"]
INFO       [PD:3  MD:24]	........................ColumnReferenceSegment    	OneOf.match PRN     	    	[ns=1, ps=10, ms=0, pruned=[<Ref: OnKeywordSegment>, <Ref: AsKeywordSegment>, <Ref: UsingKeywordSegment>, <Ref: CommaSegment>, <Ref: CastOperatorSegment>, <Ref: StartSquareBracketSegment>, <Ref: StartBracketSegment>, <Ref: ColonSegment>, <Ref: DelimiterSegment>, <class 'sqlfluff.core.parser.segments.base.BracketedSegment'>], opts=[<Ref: BinaryOperatorGrammar>]]
INFO       [PD:3  MD:25]	.........................BinaryOperatorGrammar    	OneOf.match PRN     	    	[ns=1, ps=3, ms=0, pruned=[<Ref: ArithmeticBinaryOperatorGrammar>, <Ref: StringBinaryOperatorGrammar>, <Ref: BooleanBinaryOperatorGrammar>], opts=[<Ref: ComparisonOperatorGrammar>]]
INFO       [PD:3  MD:26]	..........................ComparisonOperatorGrammar	OneOf.match PRN     	    	[ns=1, ps=7, ms=0, pruned=[<Ref: EqualsSegment>, <Ref: GreaterThanSegment>, <Ref: LessThanSegment>, <Ref: GreaterThanOrEqualToSegment>, <Ref: LessThanOrEqualToSegment>, <Ref: NotEqualToSegment_a>, <Ref: NotEqualToSegment_b>], opts=[<Ref: LikeOperatorSegment>]]
DEBUG      [PD:3  MD:27]	...........................ComparisonOperatorGrammar	Ref.match OUT       	    	[match=<MatchResult 0/2: ''>, seg="'.other_id'"]
INFO       [PD:3  MD:26]	..........................ComparisonOperatorGrammar	OneOf.match OUT     	    	[match=<MatchResult 0/2: ''>, seg="'.other_id'"]
DEBUG      [PD:3  MD:26]	..........................BinaryOperatorGrammar   	Ref.match OUT       	    	[match=<MatchResult 0/2: ''>, seg="'.other_id'"]
INFO       [PD:3  MD:25]	.........................BinaryOperatorGrammar    	OneOf.match OUT     	    	[match=<MatchResult 0/2: ''>, seg="'.other_id'"]
DEBUG      [PD:3  MD:25]	.........................ColumnReferenceSegment   	Ref.match OUT       	    	[match=<MatchResult 0/2: ''>, seg="'.other_id'"]
INFO       [PD:3  MD:24]	........................ColumnReferenceSegment    	OneOf.match OUT     	    	[match=<MatchResult 0/2: ''>, seg="'.other_id'"]
DEBUG      [PD:3  MD:24]	........................ColumnReferenceSegment    	NonCo.match OUT     	    	[match=<MatchResult 0/2: ''>, seg="'.other_id'"]
INFO       [PD:3  MD:24]	........................SingleIdentifierGrammar   	OneOf.match PRN     	    	[ns=2, ps=0, ms=0, pruned=[], opts=[<Ref: NakedIdentifierSegment>, <Ref: QuotedIdentifierSegment>]]
DEBUG      [PD:3  MD:25]	.........................SingleIdentifierGrammar  	Ref.match OUT       	++  	[match=<MatchResult 1/1: 'd'>, seg="'d'"]
INFO       [PD:3  MD:24]	........................SingleIdentifierGrammar   	OneOf.match OUT     	++  	[match=<MatchResult 1/1: 'd'>, seg="'d'"]
DEBUG      [PD:3  MD:24]	........................ColumnReferenceSegment    	Ref.match OUT       	++  	[match=<MatchResult 1/1: 'd'>, seg="'d'"]
DEBUG      [PD:3  MD:24]	........................ColumnReferenceSegment    	Delim._look_ahead_match IN	    	[ls=1, seg='other_id']
DEBUG      [PD:3  MD:24]	........................ColumnReferenceSegment    	Delim._look_ahead_match SI	    	[mq=[], sb=['OTHER_ID']]
INFO       [PD:3  MD:24]	........................ColumnReferenceSegment    	OneOf.match PRN     	    	[ns=1, ps=10, ms=0, pruned=[<Ref: OnKeywordSegment>, <Ref: AsKeywordSegment>, <Ref: UsingKeywordSegment>, <Ref: CommaSegment>, <Ref: CastOperatorSegment>, <Ref: StartSquareBracketSegment>, <Ref: StartBracketSegment>, <Ref: ColonSegment>, <Ref: DelimiterSegment>, <class 'sqlfluff.core.parser.segments.base.BracketedSegment'>], opts=[<Ref: BinaryOperatorGrammar>]]
INFO       [PD:3  MD:25]	.........................BinaryOperatorGrammar    	OneOf.match PRN     	    	[ns=1, ps=3, ms=0, pruned=[<Ref: ArithmeticBinaryOperatorGrammar>, <Ref: StringBinaryOperatorGrammar>, <Ref: BooleanBinaryOperatorGrammar>], opts=[<Ref: ComparisonOperatorGrammar>]]
INFO       [PD:3  MD:26]	..........................ComparisonOperatorGrammar	OneOf.match PRN     	    	[ns=1, ps=7, ms=0, pruned=[<Ref: EqualsSegment>, <Ref: GreaterThanSegment>, <Ref: LessThanSegment>, <Ref: GreaterThanOrEqualToSegment>, <Ref: LessThanOrEqualToSegment>, <Ref: NotEqualToSegment_a>, <Ref: NotEqualToSegment_b>], opts=[<Ref: LikeOperatorSegment>]]
DEBUG      [PD:3  MD:27]	...........................ComparisonOperatorGrammar	Ref.match OUT       	    	[match=<MatchResult 0/1: ''>, seg="'other_id'"]
INFO       [PD:3  MD:26]	..........................ComparisonOperatorGrammar	OneOf.match OUT     	    	[match=<MatchResult 0/1: ''>, seg="'other_id'"]
DEBUG      [PD:3  MD:26]	..........................BinaryOperatorGrammar   	Ref.match OUT       	    	[match=<MatchResult 0/1: ''>, seg="'other_id'"]
INFO       [PD:3  MD:25]	.........................BinaryOperatorGrammar    	OneOf.match OUT     	    	[match=<MatchResult 0/1: ''>, seg="'other_id'"]
DEBUG      [PD:3  MD:25]	.........................ColumnReferenceSegment   	Ref.match OUT       	    	[match=<MatchResult 0/1: ''>, seg="'other_id'"]
INFO       [PD:3  MD:24]	........................ColumnReferenceSegment    	OneOf.match OUT     	    	[match=<MatchResult 0/1: ''>, seg="'other_id'"]
DEBUG      [PD:3  MD:24]	........................ColumnReferenceSegment    	NonCo.match OUT     	    	[match=<MatchResult 0/1: ''>, seg="'other_id'"]
INFO       [PD:3  MD:24]	........................SingleIdentifierGrammar   	OneOf.match PRN     	    	[ns=2, ps=0, ms=0, pruned=[], opts=[<Ref: NakedIdentifierSegment>, <Ref: QuotedIdentifierSegment>]]
DEBUG      [PD:3  MD:25]	.........................SingleIdentifierGrammar  	Ref.match OUT       	++  	[match=<MatchResult 1/1: 'other_id'>, seg="'other_id'"]
INFO       [PD:3  MD:24]	........................SingleIdentifierGrammar   	OneOf.match OUT     	++  	[match=<MatchResult 1/1: 'other_id'>, seg="'other_id'"]
DEBUG      [PD:3  MD:24]	........................ColumnReferenceSegment    	Ref.match OUT       	++  	[match=<MatchResult 1/1: 'other_id'>, seg="'other_id'"]
INFO       [PD:3  MD:23]	.......................ColumnReferenceSegment     	Delim.match OUT     	++  	[match=<MatchResult 3/3: 'd.other_id'>, seg="'d.other_id'"]
DEBUG      [PD:3  MD:22]	......................ColumnReferenceSegment      	Colum.match OUT     	++  	[match=<MatchResult 1/1: 'd.other_id'>, seg="'d.other_id'"]
DEBUG      [PD:3  MD:22]	......................Expression_D_Grammar        	Ref.match OUT       	++  	[match=<MatchResult 1/1: 'd.other_id'>, seg="'d.other_id'"]
INFO       [PD:3  MD:21]	.....................Expression_D_Grammar         	OneOf.match OUT     	++  	[match=<MatchResult 1/1: 'd.other_id'>, seg="'d.other_id'"]
INFO       [PD:3  MD:20]	....................Expression_D_Grammar          	Seque.match OUT     	++  	[match=<MatchResult 1/1: 'd.other_id'>, seg="'d.other_id'"]
DEBUG      [PD:3  MD:20]	....................Expression_C_Grammar          	Ref.match OUT       	++  	[match=<MatchResult 1/1: 'd.other_id'>, seg="'d.other_id'"]
INFO       [PD:3  MD:19]	...................Expression_C_Grammar           	OneOf.match OUT     	++  	[match=<MatchResult 1/1: 'd.other_id'>, seg="'d.other_id'"]
DEBUG      [PD:3  MD:19]	...................Expression_A_Grammar           	Ref.match OUT       	++  	[match=<MatchResult 1/1: 'd.other_id'>, seg="'d.other_id'"]
INFO       [PD:3  MD:18]	..................Expression_A_Grammar            	Seque.match OUT     	++  	[match=<MatchResult 3/3: '= d.other_id'>, seg="'= d.other_id'"]
INFO       [PD:3  MD:17]	.................Expression_A_Grammar             	OneOf.match OUT     	++  	[match=<MatchResult 3/3: '= d.other_id'>, seg="'= d.other_id'"]
INFO       [PD:3  MD:16]	................Expression_A_Grammar              	AnyNu.match OUT     	++  	[match=<MatchResult 3/3: '= d.other_id'>, seg="'= d.other_id'"]
INFO       [PD:3  MD:15]	...............Expression_A_Grammar               	Seque.match OUT     	++  	[match=<MatchResult 5/5: 'tbl.id = d.other_id'>, seg="'tbl.id = d.other_id'"]
DEBUG      [PD:3  MD:15]	...............ExpressionSegment                  	Ref.match OUT       	++  	[match=<MatchResult 5/5: 'tbl.id = d.other_id'>, seg="'tbl.id = d.other_id'"]
DEBUG      [PD:3  MD:14]	..............ExpressionSegment                   	Expre.match OUT     	++  	[match=<MatchResult 1/1: 'tbl.id = d.other_id'>, seg="'tbl.id = d.other_id'"]
DEBUG      [PD:3  MD:14]	..............JoinOnConditionSegment              	Ref.match OUT       	++  	[match=<MatchResult 1/1: 'tbl.id = d.other_id'>, seg="'tbl.id = d.other_id'"]
INFO       [PD:3  MD:13]	.............JoinOnConditionSegment               	Brack.match OUT     	++  	[match=<MatchResult 1/1: 'tbl.id = d.other_id'>, seg="'tbl.id = d.other_id'"]
INFO       [PD:3  MD:12]	............JoinOnConditionSegment                	Brack.match OUT     	++  	[match=<MatchResult 1/1: '(tbl.id = d.other_id)'>, seg="'(tbl.id = d.other_id...'"]
INFO       [PD:3  MD:11]	...........JoinOnConditionSegment                 	Optio.match OUT     	++  	[match=<MatchResult 1/1: '(tbl.id = d.other_id)'>, seg="'(tbl.id = d.other_id...'"]
INFO       [PD:3  MD:10]	..........JoinOnConditionSegment                  	Seque.match OUT     	++  	[match=<MatchResult 5/5: 'ON (tbl.id = d.other_id)'>, seg="'ON (tbl.id = d.other...'"]
DEBUG      [PD:3  MD:9 ]	.........JoinOnConditionSegment                   	JoinO.match OUT     	++  	[match=<MatchResult 1/1: 'ON (tbl.id = d.other_id)'>, seg="'ON (tbl.id = d.other...'"]
DEBUG      [PD:3  MD:9 ]	.........JoinClauseSegment                        	Ref.match OUT       	++  	[match=<MatchResult 1/1: 'ON (tbl.id = d.other_id)'>, seg="'ON (tbl.id = d.other...'"]
INFO       [PD:3  MD:8 ]	........JoinClauseSegment                         	OneOf.match OUT     	++  	[match=<MatchResult 1/1: 'ON (tbl.id = d.other_id)'>, seg="'ON (tbl.id = d.other...'"]
INFO       [PD:3  MD:7 ]	.......JoinClauseSegment                          	Seque.match OUT     	++  	[match=<MatchResult 3/3: 'd ON (tbl.id = d.other_id)'>, seg="'d ON (tbl.id = d.oth...'"]
INFO       [PD:3  MD:6 ]	......JoinClauseSegment                           	Seque.match OUT     	++  	[match=<MatchResult 9/9: 'LEFT JOIN d ON ...d = d.other_id)'>, seg="'LEFT JOIN d ON (tbl....'"]
DEBUG      [PD:3  MD:5 ]	.....JoinClauseSegment                            	JoinC.match OUT     	++  	[match=<MatchResult 1/1: 'LEFT JOIN d ON ...d = d.other_id)'>, seg="'LEFT JOIN d ON (tbl....'"]
DEBUG      [PD:3  MD:5 ]	.....FromExpressionSegment                        	Ref.match OUT       	++  	[match=<MatchResult 1/1: 'LEFT JOIN d ON ...d = d.other_id)'>, seg="'LEFT JOIN d ON (tbl....'"]
INFO       [PD:3  MD:4 ]	....FromExpressionSegment                         	AnyNu.match OUT     	++  	[match=<MatchResult 5/5: 'INNER JOIN b ON...d = d.other_id)'>, seg="'INNER JOIN b ON (tbl...'"]
INFO       [PD:3  MD:3 ]	...FromExpressionSegment                          	Seque.match OUT     	++  	[match=<MatchResult 9/9: 'tbl\nINNER JOIN ...d = d.other_id)'>, seg="'tbl\\nINNER JOIN b ON ...'"]
DEBUG      [PD:3  MD:2 ]	..FromExpressionSegment                           	FromE.match OUT     	++  	[match=<MatchResult 1/1: 'tbl\nINNER JOIN ...d = d.other_id)'>, seg="'tbl\\nINNER JOIN b ON ...'"]
DEBUG      [PD:3  MD:2 ]	..FromClauseSegment                               	Ref.match OUT       	++  	[match=<MatchResult 1/1: 'tbl\nINNER JOIN ...d = d.other_id)'>, seg="'tbl\\nINNER JOIN b ON ...'"]
INFO       [PD:3  MD:1 ]	.FromClauseSegment                                	Delim.match OUT     	++  	[match=<MatchResult 1/1: 'tbl\nINNER JOIN ...d = d.other_id)'>, seg="'tbl\\nINNER JOIN b ON ...'"]
INFO       [PD:3  MD:0 ]	FromClauseSegment                                 	Seque.match OUT     	++  	[match=<MatchResult 3/3: 'FROM tbl\nINNER ...d = d.other_id)'>, seg="'FROM tbl\\nINNER JOIN ...'"]
DEBUG      FromClauseSegment.parse: Done Parse. Plotting Recursion. Recurse=True
DEBUG      ###
#
# Beginning Parse Depth 4: FromClauseSegment
#
###
Initial Structure:
[L: 10, P:  1]      |from_clause:
[L: 10, P:  1]      |    keyword:                                                  'FROM'
[L: 10, P:  5]      |    whitespace:                                               ' '
[L: 10, P:  6]      |    from_expression:
[L: 10, P:  6]      |        [META] indent:
[L: 10, P:  6]      |        from_expression_element:
[L: 10, P:  6]      |            table_expression:
[L: 10, P:  6]      |                table_reference:
[L: 10, P:  6]      |                    identifier:                               'tbl'
[L: 10, P:  9]      |        newline:                                              '\n'
[L: 11, P:  1]      |        [META] dedent:
[L: 11, P:  1]      |        join_clause:
[L: 11, P:  1]      |            keyword:                                          'INNER'
[L: 11, P:  6]      |            whitespace:                                       ' '
[L: 11, P:  7]      |            keyword:                                          'JOIN'
[L: 11, P: 11]      |            [META] indent:
[L: 11, P: 11]      |            whitespace:                                       ' '
[L: 11, P: 12]      |            from_expression_element:
[L: 11, P: 12]      |                table_expression:
[L: 11, P: 12]      |                    table_reference:
[L: 11, P: 12]      |                        identifier:                           'b'
[L: 11, P: 13]      |            whitespace:                                       ' '
[L: 11, P: 14]      |            join_on_condition:
[L: 11, P: 14]      |                keyword:                                      'ON'
[L: 11, P: 16]      |                [META] indent:
[L: 11, P: 16]      |                whitespace:                                   ' '
[L: 11, P: 17]      |                bracketed:
[L: 11, P: 17]      |                    start_bracket:                            '('
[L: 11, P: 18]      |                    [META] indent:
[L: 11, P: 18]      |                    ephemeral:
[L: 11, P: 18]      |                        expression:
[L: 11, P: 18]      |                            column_reference:
[L: 11, P: 18]      |                                identifier:                   'tbl'
[L: 11, P: 21]      |                                dot:                          '.'
[L: 11, P: 22]      |                                identifier:                   'common_id'
[L: 11, P: 31]      |                            whitespace:                       ' '
[L: 11, P: 32]      |                            comparison_operator:              '='
[L: 11, P: 33]      |                            whitespace:                       ' '
[L: 11, P: 34]      |                            column_reference:
[L: 11, P: 34]      |                                identifier:                   'b'
[L: 11, P: 35]      |                                dot:                          '.'
[L: 11, P: 36]      |                                identifier:                   'common_id'
[L: 11, P: 45]      |                    [META] dedent:
[L: 11, P: 45]      |                    end_bracket:                              ')'
[L: 11, P: 46]      |                [META] dedent:
[L: 11, P: 46]      |            [META] dedent:
[L: 11, P: 46]      |        newline:                                              '\n'
[L: 12, P:  1]      |        join_clause:
[L: 12, P:  1]      |            keyword:                                          'JOIN'
[L: 12, P:  5]      |            [META] indent:
[L: 12, P:  5]      |            whitespace:                                       ' '
[L: 12, P:  6]      |            from_expression_element:
[L: 12, P:  6]      |                table_expression:
[L: 12, P:  6]      |                    table_reference:
[L: 12, P:  6]      |                        identifier:                           'c'
[L: 12, P:  7]      |            whitespace:                                       ' '
[L: 12, P:  8]      |            join_on_condition:
[L: 12, P:  8]      |                keyword:                                      'ON'
[L: 12, P: 10]      |                [META] indent:
[L: 12, P: 10]      |                whitespace:                                   ' '
[L: 12, P: 11]      |                bracketed:
[L: 12, P: 11]      |                    start_bracket:                            '('
[L: 12, P: 12]      |                    [META] indent:
[L: 12, P: 12]      |                    ephemeral:
[L: 12, P: 12]      |                        expression:
[L: 12, P: 12]      |                            column_reference:
[L: 12, P: 12]      |                                identifier:                   'tbl'
[L: 12, P: 15]      |                                dot:                          '.'
[L: 12, P: 16]      |                                identifier:                   'id'
[L: 12, P: 18]      |                            whitespace:                       ' '
[L: 12, P: 19]      |                            comparison_operator:              '='
[L: 12, P: 20]      |                            whitespace:                       ' '
[L: 12, P: 21]      |                            column_reference:
[L: 12, P: 21]      |                                identifier:                   'c'
[L: 12, P: 22]      |                                dot:                          '.'
[L: 12, P: 23]      |                                identifier:                   'id'
[L: 12, P: 25]      |                    [META] dedent:
[L: 12, P: 25]      |                    end_bracket:                              ')'
[L: 12, P: 26]      |                [META] dedent:
[L: 12, P: 26]      |            [META] dedent:
[L: 12, P: 26]      |        newline:                                              '\n'
[L: 13, P:  1]      |        join_clause:
[L: 13, P:  1]      |            keyword:                                          'LEFT'
[L: 13, P:  5]      |            whitespace:                                       ' '
[L: 13, P:  6]      |            keyword:                                          'JOIN'
[L: 13, P: 10]      |            [META] indent:
[L: 13, P: 10]      |            whitespace:                                       ' '
[L: 13, P: 11]      |            from_expression_element:
[L: 13, P: 11]      |                table_expression:
[L: 13, P: 11]      |                    table_reference:
[L: 13, P: 11]      |                        identifier:                           'd'
[L: 13, P: 12]      |            whitespace:                                       ' '
[L: 13, P: 13]      |            join_on_condition:
[L: 13, P: 13]      |                keyword:                                      'ON'
[L: 13, P: 15]      |                [META] indent:
[L: 13, P: 15]      |                whitespace:                                   ' '
[L: 13, P: 16]      |                bracketed:
[L: 13, P: 16]      |                    start_bracket:                            '('
[L: 13, P: 17]      |                    [META] indent:
[L: 13, P: 17]      |                    expression:
[L: 13, P: 17]      |                        column_reference:
[L: 13, P: 17]      |                            identifier:                       'tbl'
[L: 13, P: 20]      |                            dot:                              '.'
[L: 13, P: 21]      |                            identifier:                       'id'
[L: 13, P: 23]      |                        whitespace:                           ' '
[L: 13, P: 24]      |                        comparison_operator:                  '='
[L: 13, P: 25]      |                        whitespace:                           ' '
[L: 13, P: 26]      |                        column_reference:
[L: 13, P: 26]      |                            identifier:                       'd'
[L: 13, P: 27]      |                            dot:                              '.'
[L: 13, P: 28]      |                            identifier:                       'other_id'
[L: 13, P: 36]      |                    [META] dedent:
[L: 13, P: 36]      |                    end_bracket:                              ')'
[L: 13, P: 37]      |                [META] dedent:
[L: 13, P: 37]      |            [META] dedent:

INFO       [PD:4] Skipping expansion of <KeywordSegment: ([L: 10, P:  1]) 'FROM'>...
INFO       [PD:4] Skipping expansion of <WhitespaceSegment: ([L: 10, P:  5]) ' '>...
INFO       
###
#
# Parse Depth 4. Expanding: FromExpressionSegment: 'tbl\nINNER JOIN b ON (tbl.common_id = b.c...'
#
###
DEBUG      FromExpressionSegment.parse: no grammar. Going straight to expansion
DEBUG      FromExpressionSegment.parse: Done Parse. Plotting Recursion. Recurse=True
DEBUG      ###
#
# Beginning Parse Depth 5: FromExpressionSegment
#
###
Initial Structure:
[L: 10, P:  6]      |from_expression:
[L: 10, P:  6]      |    [META] indent:
[L: 10, P:  6]      |    from_expression_element:
[L: 10, P:  6]      |        table_expression:
[L: 10, P:  6]      |            table_reference:
[L: 10, P:  6]      |                identifier:                                   'tbl'
[L: 10, P:  9]      |    newline:                                                  '\n'
[L: 11, P:  1]      |    [META] dedent:
[L: 11, P:  1]      |    join_clause:
[L: 11, P:  1]      |        keyword:                                              'INNER'
[L: 11, P:  6]      |        whitespace:                                           ' '
[L: 11, P:  7]      |        keyword:                                              'JOIN'
[L: 11, P: 11]      |        [META] indent:
[L: 11, P: 11]      |        whitespace:                                           ' '
[L: 11, P: 12]      |        from_expression_element:
[L: 11, P: 12]      |            table_expression:
[L: 11, P: 12]      |                table_reference:
[L: 11, P: 12]      |                    identifier:                               'b'
[L: 11, P: 13]      |        whitespace:                                           ' '
[L: 11, P: 14]      |        join_on_condition:
[L: 11, P: 14]      |            keyword:                                          'ON'
[L: 11, P: 16]      |            [META] indent:
[L: 11, P: 16]      |            whitespace:                                       ' '
[L: 11, P: 17]      |            bracketed:
[L: 11, P: 17]      |                start_bracket:                                '('
[L: 11, P: 18]      |                [META] indent:
[L: 11, P: 18]      |                ephemeral:
[L: 11, P: 18]      |                    expression:
[L: 11, P: 18]      |                        column_reference:
[L: 11, P: 18]      |                            identifier:                       'tbl'
[L: 11, P: 21]      |                            dot:                              '.'
[L: 11, P: 22]      |                            identifier:                       'common_id'
[L: 11, P: 31]      |                        whitespace:                           ' '
[L: 11, P: 32]      |                        comparison_operator:                  '='
[L: 11, P: 33]      |                        whitespace:                           ' '
[L: 11, P: 34]      |                        column_reference:
[L: 11, P: 34]      |                            identifier:                       'b'
[L: 11, P: 35]      |                            dot:                              '.'
[L: 11, P: 36]      |                            identifier:                       'common_id'
[L: 11, P: 45]      |                [META] dedent:
[L: 11, P: 45]      |                end_bracket:                                  ')'
[L: 11, P: 46]      |            [META] dedent:
[L: 11, P: 46]      |        [META] dedent:
[L: 11, P: 46]      |    newline:                                                  '\n'
[L: 12, P:  1]      |    join_clause:
[L: 12, P:  1]      |        keyword:                                              'JOIN'
[L: 12, P:  5]      |        [META] indent:
[L: 12, P:  5]      |        whitespace:                                           ' '
[L: 12, P:  6]      |        from_expression_element:
[L: 12, P:  6]      |            table_expression:
[L: 12, P:  6]      |                table_reference:
[L: 12, P:  6]      |                    identifier:                               'c'
[L: 12, P:  7]      |        whitespace:                                           ' '
[L: 12, P:  8]      |        join_on_condition:
[L: 12, P:  8]      |            keyword:                                          'ON'
[L: 12, P: 10]      |            [META] indent:
[L: 12, P: 10]      |            whitespace:                                       ' '
[L: 12, P: 11]      |            bracketed:
[L: 12, P: 11]      |                start_bracket:                                '('
[L: 12, P: 12]      |                [META] indent:
[L: 12, P: 12]      |                ephemeral:
[L: 12, P: 12]      |                    expression:
[L: 12, P: 12]      |                        column_reference:
[L: 12, P: 12]      |                            identifier:                       'tbl'
[L: 12, P: 15]      |                            dot:                              '.'
[L: 12, P: 16]      |                            identifier:                       'id'
[L: 12, P: 18]      |                        whitespace:                           ' '
[L: 12, P: 19]      |                        comparison_operator:                  '='
[L: 12, P: 20]      |                        whitespace:                           ' '
[L: 12, P: 21]      |                        column_reference:
[L: 12, P: 21]      |                            identifier:                       'c'
[L: 12, P: 22]      |                            dot:                              '.'
[L: 12, P: 23]      |                            identifier:                       'id'
[L: 12, P: 25]      |                [META] dedent:
[L: 12, P: 25]      |                end_bracket:                                  ')'
[L: 12, P: 26]      |            [META] dedent:
[L: 12, P: 26]      |        [META] dedent:
[L: 12, P: 26]      |    newline:                                                  '\n'
[L: 13, P:  1]      |    join_clause:
[L: 13, P:  1]      |        keyword:                                              'LEFT'
[L: 13, P:  5]      |        whitespace:                                           ' '
[L: 13, P:  6]      |        keyword:                                              'JOIN'
[L: 13, P: 10]      |        [META] indent:
[L: 13, P: 10]      |        whitespace:                                           ' '
[L: 13, P: 11]      |        from_expression_element:
[L: 13, P: 11]      |            table_expression:
[L: 13, P: 11]      |                table_reference:
[L: 13, P: 11]      |                    identifier:                               'd'
[L: 13, P: 12]      |        whitespace:                                           ' '
[L: 13, P: 13]      |        join_on_condition:
[L: 13, P: 13]      |            keyword:                                          'ON'
[L: 13, P: 15]      |            [META] indent:
[L: 13, P: 15]      |            whitespace:                                       ' '
[L: 13, P: 16]      |            bracketed:
[L: 13, P: 16]      |                start_bracket:                                '('
[L: 13, P: 17]      |                [META] indent:
[L: 13, P: 17]      |                expression:
[L: 13, P: 17]      |                    column_reference:
[L: 13, P: 17]      |                        identifier:                           'tbl'
[L: 13, P: 20]      |                        dot:                                  '.'
[L: 13, P: 21]      |                        identifier:                           'id'
[L: 13, P: 23]      |                    whitespace:                               ' '
[L: 13, P: 24]      |                    comparison_operator:                      '='
[L: 13, P: 25]      |                    whitespace:                               ' '
[L: 13, P: 26]      |                    column_reference:
[L: 13, P: 26]      |                        identifier:                           'd'
[L: 13, P: 27]      |                        dot:                                  '.'
[L: 13, P: 28]      |                        identifier:                           'other_id'
[L: 13, P: 36]      |                [META] dedent:
[L: 13, P: 36]      |                end_bracket:                                  ')'
[L: 13, P: 37]      |            [META] dedent:
[L: 13, P: 37]      |        [META] dedent:

INFO       [PD:5] Skipping expansion of <Indent: ([L: 10, P:  6]) ''>...
INFO       [PD:5] Skipping expansion of <FromExpressionElementSegment: ([L: 10, P:  6])>...
INFO       [PD:5] Skipping expansion of <NewlineSegment: ([L: 10, P:  9]) '\n'>...
INFO       [PD:5] Skipping expansion of <Dedent: ([L: 11, P:  1]) ''>...
INFO       
###
#
# Parse Depth 5. Expanding: JoinClauseSegment: 'INNER JOIN b ON (tbl.common_id = b.commo...'
#
###
DEBUG      JoinClauseSegment.parse: no grammar. Going straight to expansion
DEBUG      JoinClauseSegment.parse: Done Parse. Plotting Recursion. Recurse=True
DEBUG      ###
#
# Beginning Parse Depth 6: JoinClauseSegment
#
###
Initial Structure:
[L: 11, P:  1]      |join_clause:
[L: 11, P:  1]      |    keyword:                                                  'INNER'
[L: 11, P:  6]      |    whitespace:                                               ' '
[L: 11, P:  7]      |    keyword:                                                  'JOIN'
[L: 11, P: 11]      |    [META] indent:
[L: 11, P: 11]      |    whitespace:                                               ' '
[L: 11, P: 12]      |    from_expression_element:
[L: 11, P: 12]      |        table_expression:
[L: 11, P: 12]      |            table_reference:
[L: 11, P: 12]      |                identifier:                                   'b'
[L: 11, P: 13]      |    whitespace:                                               ' '
[L: 11, P: 14]      |    join_on_condition:
[L: 11, P: 14]      |        keyword:                                              'ON'
[L: 11, P: 16]      |        [META] indent:
[L: 11, P: 16]      |        whitespace:                                           ' '
[L: 11, P: 17]      |        bracketed:
[L: 11, P: 17]      |            start_bracket:                                    '('
[L: 11, P: 18]      |            [META] indent:
[L: 11, P: 18]      |            ephemeral:
[L: 11, P: 18]      |                expression:
[L: 11, P: 18]      |                    column_reference:
[L: 11, P: 18]      |                        identifier:                           'tbl'
[L: 11, P: 21]      |                        dot:                                  '.'
[L: 11, P: 22]      |                        identifier:                           'common_id'
[L: 11, P: 31]      |                    whitespace:                               ' '
[L: 11, P: 32]      |                    comparison_operator:                      '='
[L: 11, P: 33]      |                    whitespace:                               ' '
[L: 11, P: 34]      |                    column_reference:
[L: 11, P: 34]      |                        identifier:                           'b'
[L: 11, P: 35]      |                        dot:                                  '.'
[L: 11, P: 36]      |                        identifier:                           'common_id'
[L: 11, P: 45]      |            [META] dedent:
[L: 11, P: 45]      |            end_bracket:                                      ')'
[L: 11, P: 46]      |        [META] dedent:
[L: 11, P: 46]      |    [META] dedent:

INFO       [PD:6] Skipping expansion of <KeywordSegment: ([L: 11, P:  1]) 'INNER'>...
INFO       [PD:6] Skipping expansion of <WhitespaceSegment: ([L: 11, P:  6]) ' '>...
INFO       [PD:6] Skipping expansion of <KeywordSegment: ([L: 11, P:  7]) 'JOIN'>...
INFO       [PD:6] Skipping expansion of <Indent: ([L: 11, P: 11]) ''>...
INFO       [PD:6] Skipping expansion of <WhitespaceSegment: ([L: 11, P: 11]) ' '>...
INFO       [PD:6] Skipping expansion of <FromExpressionElementSegment: ([L: 11, P: 12])>...
INFO       [PD:6] Skipping expansion of <WhitespaceSegment: ([L: 11, P: 13]) ' '>...
INFO       
###
#
# Parse Depth 6. Expanding: JoinOnConditionSegment: 'ON (tbl.common_id = b.common_id)'
#
###
DEBUG      JoinOnConditionSegment.parse: no grammar. Going straight to expansion
DEBUG      JoinOnConditionSegment.parse: Done Parse. Plotting Recursion. Recurse=True
DEBUG      ###
#
# Beginning Parse Depth 7: JoinOnConditionSegment
#
###
Initial Structure:
[L: 11, P: 14]      |join_on_condition:
[L: 11, P: 14]      |    keyword:                                                  'ON'
[L: 11, P: 16]      |    [META] indent:
[L: 11, P: 16]      |    whitespace:                                               ' '
[L: 11, P: 17]      |    bracketed:
[L: 11, P: 17]      |        start_bracket:                                        '('
[L: 11, P: 18]      |        [META] indent:
[L: 11, P: 18]      |        ephemeral:
[L: 11, P: 18]      |            expression:
[L: 11, P: 18]      |                column_reference:
[L: 11, P: 18]      |                    identifier:                               'tbl'
[L: 11, P: 21]      |                    dot:                                      '.'
[L: 11, P: 22]      |                    identifier:                               'common_id'
[L: 11, P: 31]      |                whitespace:                                   ' '
[L: 11, P: 32]      |                comparison_operator:                          '='
[L: 11, P: 33]      |                whitespace:                                   ' '
[L: 11, P: 34]      |                column_reference:
[L: 11, P: 34]      |                    identifier:                               'b'
[L: 11, P: 35]      |                    dot:                                      '.'
[L: 11, P: 36]      |                    identifier:                               'common_id'
[L: 11, P: 45]      |        [META] dedent:
[L: 11, P: 45]      |        end_bracket:                                          ')'
[L: 11, P: 46]      |    [META] dedent:

INFO       [PD:7] Skipping expansion of <KeywordSegment: ([L: 11, P: 14]) 'ON'>...
INFO       [PD:7] Skipping expansion of <Indent: ([L: 11, P: 16]) ''>...
INFO       [PD:7] Skipping expansion of <WhitespaceSegment: ([L: 11, P: 16]) ' '>...
INFO       
###
#
# Parse Depth 7. Expanding: BracketedSegment: '(tbl.common_id = b.common_id)'
#
###
DEBUG      BracketedSegment.parse: no grammar. Going straight to expansion
DEBUG      BracketedSegment.parse: Done Parse. Plotting Recursion. Recurse=True
DEBUG      ###
#
# Beginning Parse Depth 8: BracketedSegment
#
###
Initial Structure:
[L: 11, P: 17]      |bracketed:
[L: 11, P: 17]      |    start_bracket:                                            '('
[L: 11, P: 18]      |    [META] indent:
[L: 11, P: 18]      |    ephemeral:
[L: 11, P: 18]      |        expression:
[L: 11, P: 18]      |            column_reference:
[L: 11, P: 18]      |                identifier:                                   'tbl'
[L: 11, P: 21]      |                dot:                                          '.'
[L: 11, P: 22]      |                identifier:                                   'common_id'
[L: 11, P: 31]      |            whitespace:                                       ' '
[L: 11, P: 32]      |            comparison_operator:                              '='
[L: 11, P: 33]      |            whitespace:                                       ' '
[L: 11, P: 34]      |            column_reference:
[L: 11, P: 34]      |                identifier:                                   'b'
[L: 11, P: 35]      |                dot:                                          '.'
[L: 11, P: 36]      |                identifier:                                   'common_id'
[L: 11, P: 45]      |    [META] dedent:
[L: 11, P: 45]      |    end_bracket:                                              ')'

INFO       [PD:8] Skipping expansion of <SymbolSegment: ([L: 11, P: 17]) '('>...
INFO       [PD:8] Skipping expansion of <Indent: ([L: 11, P: 18]) ''>...
INFO       
###
#
# Parse Depth 8. Expanding: EphemeralSegment: 'tbl.common_id = b.common_id'
#
###
INFO       [PD:8  MD:0 ]	EphemeralSegment                                  	OneOf.match PRN     	    	[ns=2, ps=1, ms=0, pruned=[<Ref: SelectableGrammar>], opts=[<Ref: ExpressionSegment>, <Delimited: [<Ref: ColumnReferenceSegment>, <Ref: FunctionSegment>, <Ref: LiteralGrammar>]>]]
INFO       [PD:8  MD:1 ]	.ExpressionSegment                                	Expre._match SELF   	    
DEBUG      [PD:8  MD:1 ]	.ExpressionSegment                                	Expre.match OUT     	++  	[match=<MatchResult 1/1: 'tbl.common_id = b.common_id'>, seg="'tbl.common_id = b.co...'"]
DEBUG      [PD:8  MD:1 ]	.EphemeralSegment                                 	Ref.match OUT       	++  	[match=<MatchResult 1/1: 'tbl.common_id = b.common_id'>, seg="'tbl.common_id = b.co...'"]
INFO       [PD:8  MD:0 ]	EphemeralSegment                                  	OneOf.match OUT     	++  	[match=<MatchResult 1/1: 'tbl.common_id = b.common_id'>, seg="'tbl.common_id = b.co...'"]
DEBUG      EphemeralSegment.parse: Done Parse. Plotting Recursion. Recurse=True
DEBUG      ###
#
# Beginning Parse Depth 9: EphemeralSegment
#
###
Initial Structure:
[L: 11, P: 18]      |ephemeral:
[L: 11, P: 18]      |    expression:
[L: 11, P: 18]      |        column_reference:
[L: 11, P: 18]      |            identifier:                                       'tbl'
[L: 11, P: 21]      |            dot:                                              '.'
[L: 11, P: 22]      |            identifier:                                       'common_id'
[L: 11, P: 31]      |        whitespace:                                           ' '
[L: 11, P: 32]      |        comparison_operator:                                  '='
[L: 11, P: 33]      |        whitespace:                                           ' '
[L: 11, P: 34]      |        column_reference:
[L: 11, P: 34]      |            identifier:                                       'b'
[L: 11, P: 35]      |            dot:                                              '.'
[L: 11, P: 36]      |            identifier:                                       'common_id'

INFO       [PD:9] Skipping expansion of <ExpressionSegment: ([L: 11, P: 18])>...
INFO       [PD:8] Skipping expansion of <Dedent: ([L: 11, P: 45]) ''>...
INFO       [PD:8] Skipping expansion of <SymbolSegment: ([L: 11, P: 45]) ')'>...
INFO       [PD:7] Skipping expansion of <Dedent: ([L: 11, P: 46]) ''>...
INFO       [PD:6] Skipping expansion of <Dedent: ([L: 11, P: 46]) ''>...
INFO       [PD:5] Skipping expansion of <NewlineSegment: ([L: 11, P: 46]) '\n'>...
INFO       
###
#
# Parse Depth 5. Expanding: JoinClauseSegment: 'JOIN c ON (tbl.id = c.id)'
#
###
DEBUG      JoinClauseSegment.parse: no grammar. Going straight to expansion
DEBUG      JoinClauseSegment.parse: Done Parse. Plotting Recursion. Recurse=True
DEBUG      ###
#
# Beginning Parse Depth 6: JoinClauseSegment
#
###
Initial Structure:
[L: 12, P:  1]      |join_clause:
[L: 12, P:  1]      |    keyword:                                                  'JOIN'
[L: 12, P:  5]      |    [META] indent:
[L: 12, P:  5]      |    whitespace:                                               ' '
[L: 12, P:  6]      |    from_expression_element:
[L: 12, P:  6]      |        table_expression:
[L: 12, P:  6]      |            table_reference:
[L: 12, P:  6]      |                identifier:                                   'c'
[L: 12, P:  7]      |    whitespace:                                               ' '
[L: 12, P:  8]      |    join_on_condition:
[L: 12, P:  8]      |        keyword:                                              'ON'
[L: 12, P: 10]      |        [META] indent:
[L: 12, P: 10]      |        whitespace:                                           ' '
[L: 12, P: 11]      |        bracketed:
[L: 12, P: 11]      |            start_bracket:                                    '('
[L: 12, P: 12]      |            [META] indent:
[L: 12, P: 12]      |            ephemeral:
[L: 12, P: 12]      |                expression:
[L: 12, P: 12]      |                    column_reference:
[L: 12, P: 12]      |                        identifier:                           'tbl'
[L: 12, P: 15]      |                        dot:                                  '.'
[L: 12, P: 16]      |                        identifier:                           'id'
[L: 12, P: 18]      |                    whitespace:                               ' '
[L: 12, P: 19]      |                    comparison_operator:                      '='
[L: 12, P: 20]      |                    whitespace:                               ' '
[L: 12, P: 21]      |                    column_reference:
[L: 12, P: 21]      |                        identifier:                           'c'
[L: 12, P: 22]      |                        dot:                                  '.'
[L: 12, P: 23]      |                        identifier:                           'id'
[L: 12, P: 25]      |            [META] dedent:
[L: 12, P: 25]      |            end_bracket:                                      ')'
[L: 12, P: 26]      |        [META] dedent:
[L: 12, P: 26]      |    [META] dedent:

INFO       [PD:6] Skipping expansion of <KeywordSegment: ([L: 12, P:  1]) 'JOIN'>...
INFO       [PD:6] Skipping expansion of <Indent: ([L: 12, P:  5]) ''>...
INFO       [PD:6] Skipping expansion of <WhitespaceSegment: ([L: 12, P:  5]) ' '>...
INFO       [PD:6] Skipping expansion of <FromExpressionElementSegment: ([L: 12, P:  6])>...
INFO       [PD:6] Skipping expansion of <WhitespaceSegment: ([L: 12, P:  7]) ' '>...
INFO       
###
#
# Parse Depth 6. Expanding: JoinOnConditionSegment: 'ON (tbl.id = c.id)'
#
###
DEBUG      JoinOnConditionSegment.parse: no grammar. Going straight to expansion
DEBUG      JoinOnConditionSegment.parse: Done Parse. Plotting Recursion. Recurse=True
DEBUG      ###
#
# Beginning Parse Depth 7: JoinOnConditionSegment
#
###
Initial Structure:
[L: 12, P:  8]      |join_on_condition:
[L: 12, P:  8]      |    keyword:                                                  'ON'
[L: 12, P: 10]      |    [META] indent:
[L: 12, P: 10]      |    whitespace:                                               ' '
[L: 12, P: 11]      |    bracketed:
[L: 12, P: 11]      |        start_bracket:                                        '('
[L: 12, P: 12]      |        [META] indent:
[L: 12, P: 12]      |        ephemeral:
[L: 12, P: 12]      |            expression:
[L: 12, P: 12]      |                column_reference:
[L: 12, P: 12]      |                    identifier:                               'tbl'
[L: 12, P: 15]      |                    dot:                                      '.'
[L: 12, P: 16]      |                    identifier:                               'id'
[L: 12, P: 18]      |                whitespace:                                   ' '
[L: 12, P: 19]      |                comparison_operator:                          '='
[L: 12, P: 20]      |                whitespace:                                   ' '
[L: 12, P: 21]      |                column_reference:
[L: 12, P: 21]      |                    identifier:                               'c'
[L: 12, P: 22]      |                    dot:                                      '.'
[L: 12, P: 23]      |                    identifier:                               'id'
[L: 12, P: 25]      |        [META] dedent:
[L: 12, P: 25]      |        end_bracket:                                          ')'
[L: 12, P: 26]      |    [META] dedent:

INFO       [PD:7] Skipping expansion of <KeywordSegment: ([L: 12, P:  8]) 'ON'>...
INFO       [PD:7] Skipping expansion of <Indent: ([L: 12, P: 10]) ''>...
INFO       [PD:7] Skipping expansion of <WhitespaceSegment: ([L: 12, P: 10]) ' '>...
INFO       
###
#
# Parse Depth 7. Expanding: BracketedSegment: '(tbl.id = c.id)'
#
###
DEBUG      BracketedSegment.parse: no grammar. Going straight to expansion
DEBUG      BracketedSegment.parse: Done Parse. Plotting Recursion. Recurse=True
DEBUG      ###
#
# Beginning Parse Depth 8: BracketedSegment
#
###
Initial Structure:
[L: 12, P: 11]      |bracketed:
[L: 12, P: 11]      |    start_bracket:                                            '('
[L: 12, P: 12]      |    [META] indent:
[L: 12, P: 12]      |    ephemeral:
[L: 12, P: 12]      |        expression:
[L: 12, P: 12]      |            column_reference:
[L: 12, P: 12]      |                identifier:                                   'tbl'
[L: 12, P: 15]      |                dot:                                          '.'
[L: 12, P: 16]      |                identifier:                                   'id'
[L: 12, P: 18]      |            whitespace:                                       ' '
[L: 12, P: 19]      |            comparison_operator:                              '='
[L: 12, P: 20]      |            whitespace:                                       ' '
[L: 12, P: 21]      |            column_reference:
[L: 12, P: 21]      |                identifier:                                   'c'
[L: 12, P: 22]      |                dot:                                          '.'
[L: 12, P: 23]      |                identifier:                                   'id'
[L: 12, P: 25]      |    [META] dedent:
[L: 12, P: 25]      |    end_bracket:                                              ')'

INFO       [PD:8] Skipping expansion of <SymbolSegment: ([L: 12, P: 11]) '('>...
INFO       [PD:8] Skipping expansion of <Indent: ([L: 12, P: 12]) ''>...
INFO       
###
#
# Parse Depth 8. Expanding: EphemeralSegment: 'tbl.id = c.id'
#
###
INFO       [PD:8  MD:0 ]	EphemeralSegment                                  	OneOf.match PRN     	    	[ns=2, ps=1, ms=0, pruned=[<Ref: SelectableGrammar>], opts=[<Ref: ExpressionSegment>, <Delimited: [<Ref: ColumnReferenceSegment>, <Ref: FunctionSegment>, <Ref: LiteralGrammar>]>]]
INFO       [PD:8  MD:1 ]	.ExpressionSegment                                	Expre._match SELF   	    
DEBUG      [PD:8  MD:1 ]	.ExpressionSegment                                	Expre.match OUT     	++  	[match=<MatchResult 1/1: 'tbl.id = c.id'>, seg="'tbl.id = c.id'"]
DEBUG      [PD:8  MD:1 ]	.EphemeralSegment                                 	Ref.match OUT       	++  	[match=<MatchResult 1/1: 'tbl.id = c.id'>, seg="'tbl.id = c.id'"]
INFO       [PD:8  MD:0 ]	EphemeralSegment                                  	OneOf.match OUT     	++  	[match=<MatchResult 1/1: 'tbl.id = c.id'>, seg="'tbl.id = c.id'"]
DEBUG      EphemeralSegment.parse: Done Parse. Plotting Recursion. Recurse=True
DEBUG      ###
#
# Beginning Parse Depth 9: EphemeralSegment
#
###
Initial Structure:
[L: 12, P: 12]      |ephemeral:
[L: 12, P: 12]      |    expression:
[L: 12, P: 12]      |        column_reference:
[L: 12, P: 12]      |            identifier:                                       'tbl'
[L: 12, P: 15]      |            dot:                                              '.'
[L: 12, P: 16]      |            identifier:                                       'id'
[L: 12, P: 18]      |        whitespace:                                           ' '
[L: 12, P: 19]      |        comparison_operator:                                  '='
[L: 12, P: 20]      |        whitespace:                                           ' '
[L: 12, P: 21]      |        column_reference:
[L: 12, P: 21]      |            identifier:                                       'c'
[L: 12, P: 22]      |            dot:                                              '.'
[L: 12, P: 23]      |            identifier:                                       'id'

INFO       [PD:9] Skipping expansion of <ExpressionSegment: ([L: 12, P: 12])>...
INFO       [PD:8] Skipping expansion of <Dedent: ([L: 12, P: 25]) ''>...
INFO       [PD:8] Skipping expansion of <SymbolSegment: ([L: 12, P: 25]) ')'>...
INFO       [PD:7] Skipping expansion of <Dedent: ([L: 12, P: 26]) ''>...
INFO       [PD:6] Skipping expansion of <Dedent: ([L: 12, P: 26]) ''>...
INFO       [PD:5] Skipping expansion of <NewlineSegment: ([L: 12, P: 26]) '\n'>...
INFO       [PD:5] Skipping expansion of <JoinClauseSegment: ([L: 13, P:  1])>...
INFO       [PD:3] Skipping expansion of <NewlineSegment: ([L: 13, P: 37]) '\n'>...
INFO       
###
#
# Parse Depth 3. Expanding: OrderByClauseSegment: 'ORDER BY tbl.name ASC'
#
###
DEBUG      [PD:3  MD:1 ]	.OrderByClauseSegment                             	Ref.match OUT       	+   	[match=<MatchResult 1/9: 'ORDER'>, seg="'ORDER BY tbl.name AS...'"]
DEBUG      [PD:3  MD:1 ]	.OrderByClauseSegment                             	Ref.match OUT       	+   	[match=<MatchResult 1/7: 'BY'>, seg="'BY tbl.name ASC'"]
DEBUG      [PD:3  MD:2 ]	..OrderByClauseSegment                            	Delim._look_ahead_match IN	    	[ls=5, seg='tbl.name ASC']
DEBUG      [PD:3  MD:2 ]	..OrderByClauseSegment                            	Delim._look_ahead_match SI	    	[mq=[], sb=['TBL', '.', 'NAME', '', 'ASC']]
DEBUG      [PD:3  MD:2 ]	..OrderByClauseSegment                            	Delim._look_ahead_match SC	    	[bsm=None]
INFO       [PD:3  MD:3 ]	...OrderByClauseSegment                           	OneOf.match PRN     	    	[ns=3, ps=0, ms=0, pruned=[], opts=[<Ref: ColumnReferenceSegment>, <Ref: NumericLiteralSegment>, <Ref: ExpressionSegment>]]
DEBUG      [PD:3  MD:6 ]	......ColumnReferenceSegment                      	Delim._look_ahead_match IN	    	[ls=5, seg='tbl.name ASC']
DEBUG      [PD:3  MD:6 ]	......ColumnReferenceSegment                      	Delim._look_ahead_match SI	    	[mq=[(<OneOf: [<Ref: DotSegment>, <Sequence: [<Ref: DotSegment>, <Ref: Dot...]>, 1, '.'), (<OneOf: [<Ref: DotSegment>, <Sequence: [<Ref: DotSegment>, <Ref: Dot...]>, 1, '.')], sb=['TBL', '.', 'NAME', '', 'ASC']]
INFO       [PD:3  MD:6 ]	......ColumnReferenceSegment                      	OneOf.match PRN     	    	[ns=0, ps=0, ms=2, pruned=[], opts=[<Ref: DotSegment>, <Sequence: [<Ref: DotSegment>, <Ref: DotSegment>]>]]
DEBUG      [PD:3  MD:7 ]	.......ColumnReferenceSegment                     	Ref.match OUT       	+   	[match=<MatchResult 1/4: '.'>, seg="'.name ASC'"]
DEBUG      [PD:3  MD:8 ]	........ColumnReferenceSegment                    	Ref.match OUT       	+   	[match=<MatchResult 1/4: '.'>, seg="'.name ASC'"]
DEBUG      [PD:3  MD:8 ]	........ColumnReferenceSegment                    	Ref.match OUT       	    	[match=<MatchResult 0/3: ''>, seg="'name ASC'"]
INFO       [PD:3  MD:7 ]	.......ColumnReferenceSegment                     	Seque.match OUT     	    	[match=<MatchResult 0/4: ''>, seg="'.name ASC'"]
INFO       [PD:3  MD:6 ]	......ColumnReferenceSegment                      	OneOf.match OUT     	+   	[match=<MatchResult 1/4: '.'>, seg="'.name ASC'"]
INFO       [PD:3  MD:6 ]	......ColumnReferenceSegment                      	OneOf.match PRN     	    	[ns=0, ps=0, ms=2, pruned=[], opts=[<Ref: DotSegment>, <Sequence: [<Ref: DotSegment>, <Ref: DotSegment>]>]]
DEBUG      [PD:3  MD:7 ]	.......ColumnReferenceSegment                     	Ref.match OUT       	+   	[match=<MatchResult 1/4: '.'>, seg="'.name ASC'"]
DEBUG      [PD:3  MD:8 ]	........ColumnReferenceSegment                    	Ref.match OUT       	+   	[match=<MatchResult 1/4: '.'>, seg="'.name ASC'"]
DEBUG      [PD:3  MD:8 ]	........ColumnReferenceSegment                    	Ref.match OUT       	    	[match=<MatchResult 0/3: ''>, seg="'name ASC'"]
INFO       [PD:3  MD:7 ]	.......ColumnReferenceSegment                     	Seque.match OUT     	    	[match=<MatchResult 0/4: ''>, seg="'.name ASC'"]
INFO       [PD:3  MD:6 ]	......ColumnReferenceSegment                      	OneOf.match OUT     	+   	[match=<MatchResult 1/4: '.'>, seg="'.name ASC'"]
INFO       [PD:3  MD:6 ]	......ColumnReferenceSegment                      	OneOf.match PRN     	    	[ns=1, ps=10, ms=0, pruned=[<Ref: OnKeywordSegment>, <Ref: AsKeywordSegment>, <Ref: UsingKeywordSegment>, <Ref: CommaSegment>, <Ref: CastOperatorSegment>, <Ref: StartSquareBracketSegment>, <Ref: StartBracketSegment>, <Ref: ColonSegment>, <Ref: DelimiterSegment>, <class 'sqlfluff.core.parser.segments.base.BracketedSegment'>], opts=[<Ref: BinaryOperatorGrammar>]]
INFO       [PD:3  MD:7 ]	.......BinaryOperatorGrammar                      	OneOf.match PRN     	    	[ns=1, ps=3, ms=0, pruned=[<Ref: ArithmeticBinaryOperatorGrammar>, <Ref: StringBinaryOperatorGrammar>, <Ref: BooleanBinaryOperatorGrammar>], opts=[<Ref: ComparisonOperatorGrammar>]]
INFO       [PD:3  MD:8 ]	........ComparisonOperatorGrammar                 	OneOf.match PRN     	    	[ns=1, ps=7, ms=0, pruned=[<Ref: EqualsSegment>, <Ref: GreaterThanSegment>, <Ref: LessThanSegment>, <Ref: GreaterThanOrEqualToSegment>, <Ref: LessThanOrEqualToSegment>, <Ref: NotEqualToSegment_a>, <Ref: NotEqualToSegment_b>], opts=[<Ref: LikeOperatorSegment>]]
DEBUG      [PD:3  MD:9 ]	.........ComparisonOperatorGrammar                	Ref.match OUT       	    	[match=<MatchResult 0/5: ''>, seg="'tbl.name ASC'"]
INFO       [PD:3  MD:8 ]	........ComparisonOperatorGrammar                 	OneOf.match OUT     	    	[match=<MatchResult 0/5: ''>, seg="'tbl.name ASC'"]
DEBUG      [PD:3  MD:8 ]	........BinaryOperatorGrammar                     	Ref.match OUT       	    	[match=<MatchResult 0/5: ''>, seg="'tbl.name ASC'"]
INFO       [PD:3  MD:7 ]	.......BinaryOperatorGrammar                      	OneOf.match OUT     	    	[match=<MatchResult 0/5: ''>, seg="'tbl.name ASC'"]
DEBUG      [PD:3  MD:7 ]	.......ColumnReferenceSegment                     	Ref.match OUT       	    	[match=<MatchResult 0/5: ''>, seg="'tbl.name ASC'"]
INFO       [PD:3  MD:6 ]	......ColumnReferenceSegment                      	OneOf.match OUT     	    	[match=<MatchResult 0/5: ''>, seg="'tbl.name ASC'"]
DEBUG      [PD:3  MD:6 ]	......ColumnReferenceSegment                      	NonCo.match OUT     	    	[match=<MatchResult 0/5: ''>, seg="'tbl.name ASC'"]
INFO       [PD:3  MD:6 ]	......ColumnReferenceSegment                      	OneOf.match PRN     	    	[ns=1, ps=10, ms=0, pruned=[<Ref: OnKeywordSegment>, <Ref: AsKeywordSegment>, <Ref: UsingKeywordSegment>, <Ref: CommaSegment>, <Ref: CastOperatorSegment>, <Ref: StartSquareBracketSegment>, <Ref: StartBracketSegment>, <Ref: ColonSegment>, <Ref: DelimiterSegment>, <class 'sqlfluff.core.parser.segments.base.BracketedSegment'>], opts=[<Ref: BinaryOperatorGrammar>]]
INFO       [PD:3  MD:7 ]	.......BinaryOperatorGrammar                      	OneOf.match PRN     	    	[ns=1, ps=3, ms=0, pruned=[<Ref: ArithmeticBinaryOperatorGrammar>, <Ref: StringBinaryOperatorGrammar>, <Ref: BooleanBinaryOperatorGrammar>], opts=[<Ref: ComparisonOperatorGrammar>]]
INFO       [PD:3  MD:8 ]	........ComparisonOperatorGrammar                 	OneOf.match PRN     	    	[ns=1, ps=7, ms=0, pruned=[<Ref: EqualsSegment>, <Ref: GreaterThanSegment>, <Ref: LessThanSegment>, <Ref: GreaterThanOrEqualToSegment>, <Ref: LessThanOrEqualToSegment>, <Ref: NotEqualToSegment_a>, <Ref: NotEqualToSegment_b>], opts=[<Ref: LikeOperatorSegment>]]
DEBUG      [PD:3  MD:9 ]	.........ComparisonOperatorGrammar                	Ref.match OUT       	    	[match=<MatchResult 0/4: ''>, seg="'.name ASC'"]
INFO       [PD:3  MD:8 ]	........ComparisonOperatorGrammar                 	OneOf.match OUT     	    	[match=<MatchResult 0/4: ''>, seg="'.name ASC'"]
DEBUG      [PD:3  MD:8 ]	........BinaryOperatorGrammar                     	Ref.match OUT       	    	[match=<MatchResult 0/4: ''>, seg="'.name ASC'"]
INFO       [PD:3  MD:7 ]	.......BinaryOperatorGrammar                      	OneOf.match OUT     	    	[match=<MatchResult 0/4: ''>, seg="'.name ASC'"]
DEBUG      [PD:3  MD:7 ]	.......ColumnReferenceSegment                     	Ref.match OUT       	    	[match=<MatchResult 0/4: ''>, seg="'.name ASC'"]
INFO       [PD:3  MD:6 ]	......ColumnReferenceSegment                      	OneOf.match OUT     	    	[match=<MatchResult 0/4: ''>, seg="'.name ASC'"]
DEBUG      [PD:3  MD:6 ]	......ColumnReferenceSegment                      	NonCo.match OUT     	    	[match=<MatchResult 0/4: ''>, seg="'.name ASC'"]
INFO       [PD:3  MD:6 ]	......SingleIdentifierGrammar                     	OneOf.match PRN     	    	[ns=2, ps=0, ms=0, pruned=[], opts=[<Ref: NakedIdentifierSegment>, <Ref: QuotedIdentifierSegment>]]
DEBUG      [PD:3  MD:7 ]	.......SingleIdentifierGrammar                    	Ref.match OUT       	++  	[match=<MatchResult 1/1: 'tbl'>, seg="'tbl'"]
INFO       [PD:3  MD:6 ]	......SingleIdentifierGrammar                     	OneOf.match OUT     	++  	[match=<MatchResult 1/1: 'tbl'>, seg="'tbl'"]
DEBUG      [PD:3  MD:6 ]	......ColumnReferenceSegment                      	Ref.match OUT       	++  	[match=<MatchResult 1/1: 'tbl'>, seg="'tbl'"]
DEBUG      [PD:3  MD:6 ]	......ColumnReferenceSegment                      	Delim._look_ahead_match IN	    	[ls=3, seg='name ASC']
DEBUG      [PD:3  MD:6 ]	......ColumnReferenceSegment                      	Delim._look_ahead_match SI	    	[mq=[], sb=['NAME', '', 'ASC']]
INFO       [PD:3  MD:6 ]	......ColumnReferenceSegment                      	OneOf.match PRN     	    	[ns=1, ps=10, ms=0, pruned=[<Ref: OnKeywordSegment>, <Ref: AsKeywordSegment>, <Ref: UsingKeywordSegment>, <Ref: CommaSegment>, <Ref: CastOperatorSegment>, <Ref: StartSquareBracketSegment>, <Ref: StartBracketSegment>, <Ref: ColonSegment>, <Ref: DelimiterSegment>, <class 'sqlfluff.core.parser.segments.base.BracketedSegment'>], opts=[<Ref: BinaryOperatorGrammar>]]
INFO       [PD:3  MD:7 ]	.......BinaryOperatorGrammar                      	OneOf.match PRN     	    	[ns=1, ps=3, ms=0, pruned=[<Ref: ArithmeticBinaryOperatorGrammar>, <Ref: StringBinaryOperatorGrammar>, <Ref: BooleanBinaryOperatorGrammar>], opts=[<Ref: ComparisonOperatorGrammar>]]
INFO       [PD:3  MD:8 ]	........ComparisonOperatorGrammar                 	OneOf.match PRN     	    	[ns=1, ps=7, ms=0, pruned=[<Ref: EqualsSegment>, <Ref: GreaterThanSegment>, <Ref: LessThanSegment>, <Ref: GreaterThanOrEqualToSegment>, <Ref: LessThanOrEqualToSegment>, <Ref: NotEqualToSegment_a>, <Ref: NotEqualToSegment_b>], opts=[<Ref: LikeOperatorSegment>]]
DEBUG      [PD:3  MD:9 ]	.........ComparisonOperatorGrammar                	Ref.match OUT       	    	[match=<MatchResult 0/3: ''>, seg="'name ASC'"]
INFO       [PD:3  MD:8 ]	........ComparisonOperatorGrammar                 	OneOf.match OUT     	    	[match=<MatchResult 0/3: ''>, seg="'name ASC'"]
DEBUG      [PD:3  MD:8 ]	........BinaryOperatorGrammar                     	Ref.match OUT       	    	[match=<MatchResult 0/3: ''>, seg="'name ASC'"]
INFO       [PD:3  MD:7 ]	.......BinaryOperatorGrammar                      	OneOf.match OUT     	    	[match=<MatchResult 0/3: ''>, seg="'name ASC'"]
DEBUG      [PD:3  MD:7 ]	.......ColumnReferenceSegment                     	Ref.match OUT       	    	[match=<MatchResult 0/3: ''>, seg="'name ASC'"]
INFO       [PD:3  MD:6 ]	......ColumnReferenceSegment                      	OneOf.match OUT     	    	[match=<MatchResult 0/3: ''>, seg="'name ASC'"]
DEBUG      [PD:3  MD:6 ]	......ColumnReferenceSegment                      	NonCo.match OUT     	    	[match=<MatchResult 0/3: ''>, seg="'name ASC'"]
INFO       [PD:3  MD:6 ]	......ColumnReferenceSegment                      	OneOf.match PRN     	    	[ns=1, ps=10, ms=0, pruned=[<Ref: OnKeywordSegment>, <Ref: AsKeywordSegment>, <Ref: UsingKeywordSegment>, <Ref: CommaSegment>, <Ref: CastOperatorSegment>, <Ref: StartSquareBracketSegment>, <Ref: StartBracketSegment>, <Ref: ColonSegment>, <Ref: DelimiterSegment>, <class 'sqlfluff.core.parser.segments.base.BracketedSegment'>], opts=[<Ref: BinaryOperatorGrammar>]]
INFO       [PD:3  MD:7 ]	.......BinaryOperatorGrammar                      	OneOf.match PRN     	    	[ns=1, ps=3, ms=0, pruned=[<Ref: ArithmeticBinaryOperatorGrammar>, <Ref: StringBinaryOperatorGrammar>, <Ref: BooleanBinaryOperatorGrammar>], opts=[<Ref: ComparisonOperatorGrammar>]]
INFO       [PD:3  MD:8 ]	........ComparisonOperatorGrammar                 	OneOf.match PRN     	    	[ns=1, ps=7, ms=0, pruned=[<Ref: EqualsSegment>, <Ref: GreaterThanSegment>, <Ref: LessThanSegment>, <Ref: GreaterThanOrEqualToSegment>, <Ref: LessThanOrEqualToSegment>, <Ref: NotEqualToSegment_a>, <Ref: NotEqualToSegment_b>], opts=[<Ref: LikeOperatorSegment>]]
DEBUG      [PD:3  MD:9 ]	.........ComparisonOperatorGrammar                	Ref.match OUT       	    	[match=<MatchResult 0/2: ''>, seg="' ASC'"]
INFO       [PD:3  MD:8 ]	........ComparisonOperatorGrammar                 	OneOf.match OUT     	    	[match=<MatchResult 0/2: ''>, seg="' ASC'"]
DEBUG      [PD:3  MD:8 ]	........BinaryOperatorGrammar                     	Ref.match OUT       	    	[match=<MatchResult 0/2: ''>, seg="' ASC'"]
INFO       [PD:3  MD:7 ]	.......BinaryOperatorGrammar                      	OneOf.match OUT     	    	[match=<MatchResult 0/2: ''>, seg="' ASC'"]
DEBUG      [PD:3  MD:7 ]	.......ColumnReferenceSegment                     	Ref.match OUT       	    	[match=<MatchResult 0/2: ''>, seg="' ASC'"]
INFO       [PD:3  MD:6 ]	......ColumnReferenceSegment                      	OneOf.match OUT     	    	[match=<MatchResult 0/2: ''>, seg="' ASC'"]
DEBUG      [PD:3  MD:6 ]	......ColumnReferenceSegment                      	NonCo.match OUT     	+   	[match=<MatchResult 1/2: ' '>, seg="' ASC'"]
INFO       [PD:3  MD:6 ]	......SingleIdentifierGrammar                     	OneOf.match PRN     	    	[ns=2, ps=0, ms=0, pruned=[], opts=[<Ref: NakedIdentifierSegment>, <Ref: QuotedIdentifierSegment>]]
DEBUG      [PD:3  MD:7 ]	.......SingleIdentifierGrammar                    	Ref.match OUT       	++  	[match=<MatchResult 1/1: 'name'>, seg="'name'"]
INFO       [PD:3  MD:6 ]	......SingleIdentifierGrammar                     	OneOf.match OUT     	++  	[match=<MatchResult 1/1: 'name'>, seg="'name'"]
DEBUG      [PD:3  MD:6 ]	......ColumnReferenceSegment                      	Ref.match OUT       	++  	[match=<MatchResult 1/1: 'name'>, seg="'name'"]
INFO       [PD:3  MD:5 ]	.....ColumnReferenceSegment                       	Delim.match OUT     	+   	[match=<MatchResult 3/5: 'tbl.name'>, seg="'tbl.name ASC'"]
DEBUG      [PD:3  MD:4 ]	....ColumnReferenceSegment                        	Colum.match OUT     	+   	[match=<MatchResult 1/3: 'tbl.name'>, seg="'tbl.name ASC'"]
DEBUG      [PD:3  MD:4 ]	....OrderByClauseSegment                          	Ref.match OUT       	+   	[match=<MatchResult 1/3: 'tbl.name'>, seg="'tbl.name ASC'"]
DEBUG      [PD:3  MD:4 ]	....OrderByClauseSegment                          	Ref.match OUT       	    	[match=<MatchResult 0/5: ''>, seg="'tbl.name ASC'"]
INFO       [PD:3  MD:6 ]	......Expression_A_Grammar                        	OneOf.match PRN     	    	[ns=1, ps=1, ms=0, pruned=[<Sequence: [<OneOf: [<Ref: PositiveSegment>, <Ref: N..., <Ref: Expression_C_Grammar>]>], opts=[<Ref: Expression_C_Grammar>]]
INFO       [PD:3  MD:7 ]	.......Expression_C_Grammar                       	OneOf.match PRN     	    	[ns=1, ps=2, ms=0, pruned=[<Sequence: [<Ref: ExistsKeywordSegment>, <Bracketed: [<Ref: SelectStatementSegmen...]>, <Ref: CaseExpressionSegment>], opts=[<Ref: Expression_D_Grammar>]]
INFO       [PD:3  MD:9 ]	.........Expression_D_Grammar                     	OneOf.match PRN     	    	[ns=6, ps=3, ms=0, pruned=[<Bracketed: [<OneOf: [<Ref: ExpressionSegment>, <Ref:...]>, <Ref: SelectStatementSegment>, <Ref: IntervalExpressionSegment>], opts=[<Ref: BareFunctionSegment>, <Ref: FunctionSegment>, <Ref: LiteralGrammar>, <Ref: ColumnReferenceSegment>, <Sequence: [<Ref: SimpleArrayTypeGrammar [opt]>, <Ref: ArrayLiteralSegment>]>, <Sequence: [<Ref: DatatypeSegment>, <OneOf: [<Ref: QuotedLiteralSegment>, <R...]>]]
DEBUG      [PD:3  MD:10]	..........Expression_D_Grammar                    	Ref.match OUT       	    	[match=<MatchResult 0/5: ''>, seg="'tbl.name ASC'"]
INFO       [PD:3  MD:11]	...........FunctionSegment                        	OneOf.match PRN     	    	[ns=1, ps=1, ms=0, pruned=[<Sequence: [<Sequence: [<Ref: DateAddFunctionNameSeg...]>], opts=[<Sequence: [<Sequence: [<AnyNumberOf: [<Ref: Functio..., <Ref: PostFunctionGrammar [opt]>]>]]
DEBUG      [PD:3  MD:17]	.................DateAddFunctionNameSegment       	Ref.match OUT       	    	[match=<MatchResult 0/5: ''>, seg="'tbl.name ASC'"]
INFO       [PD:3  MD:16]	................DateAddFunctionNameSegment        	Seque.match OUT     	    	[match=<MatchResult 0/5: ''>, seg="'tbl.name ASC'"]
DEBUG      [PD:3  MD:15]	...............DateAddFunctionNameSegment         	DateA.match OUT     	    	[match=<MatchResult 0/5: ''>, seg="'tbl.name ASC'"]
DEBUG      [PD:3  MD:15]	...............FunctionSegment                    	Ref.match OUT       	    	[match=<MatchResult 0/5: ''>, seg="'tbl.name ASC'"]
INFO       [PD:3  MD:14]	..............FunctionSegment                     	AnyNu.match PRN     	    	[ns=1, ps=0, ms=0, pruned=[], opts=[<Ref: FunctionNameSegment>]]
INFO       [PD:3  MD:17]	.................FunctionNameSegment              	AnyNu.match PRN     	    	[ns=1, ps=0, ms=0, pruned=[], opts=[<Sequence: [<Ref: SingleIdentifierGrammar>, <Ref: DotSegment>]>]]
INFO       [PD:3  MD:19]	...................SingleIdentifierGrammar        	OneOf.match PRN     	    	[ns=2, ps=0, ms=0, pruned=[], opts=[<Ref: NakedIdentifierSegment>, <Ref: QuotedIdentifierSegment>]]
DEBUG      [PD:3  MD:20]	....................SingleIdentifierGrammar       	Ref.match OUT       	+   	[match=<MatchResult 1/5: 'tbl'>, seg="'tbl.name ASC'"]
DEBUG      [PD:3  MD:20]	....................SingleIdentifierGrammar       	Ref.match OUT       	    	[match=<MatchResult 0/5: ''>, seg="'tbl.name ASC'"]
INFO       [PD:3  MD:19]	...................SingleIdentifierGrammar        	OneOf.match OUT     	+   	[match=<MatchResult 1/5: 'tbl'>, seg="'tbl.name ASC'"]
DEBUG      [PD:3  MD:19]	...................FunctionNameSegment            	Ref.match OUT       	+   	[match=<MatchResult 1/5: 'tbl'>, seg="'tbl.name ASC'"]
DEBUG      [PD:3  MD:19]	...................FunctionNameSegment            	Ref.match OUT       	+   	[match=<MatchResult 1/4: '.'>, seg="'.name ASC'"]
INFO       [PD:3  MD:18]	..................FunctionNameSegment             	Seque.match OUT     	+   	[match=<MatchResult 2/5: 'tbl.'>, seg="'tbl.name ASC'"]
INFO       [PD:3  MD:17]	.................FunctionNameSegment              	AnyNu.match PRN     	    	[ns=1, ps=0, ms=0, pruned=[], opts=[<Sequence: [<Ref: SingleIdentifierGrammar>, <Ref: DotSegment>]>]]
INFO       [PD:3  MD:19]	...................SingleIdentifierGrammar        	OneOf.match PRN     	    	[ns=2, ps=0, ms=0, pruned=[], opts=[<Ref: NakedIdentifierSegment>, <Ref: QuotedIdentifierSegment>]]
DEBUG      [PD:3  MD:20]	....................SingleIdentifierGrammar       	Ref.match OUT       	+   	[match=<MatchResult 1/3: 'name'>, seg="'name ASC'"]
DEBUG      [PD:3  MD:20]	....................SingleIdentifierGrammar       	Ref.match OUT       	    	[match=<MatchResult 0/3: ''>, seg="'name ASC'"]
INFO       [PD:3  MD:19]	...................SingleIdentifierGrammar        	OneOf.match OUT     	+   	[match=<MatchResult 1/3: 'name'>, seg="'name ASC'"]
DEBUG      [PD:3  MD:19]	...................FunctionNameSegment            	Ref.match OUT       	+   	[match=<MatchResult 1/3: 'name'>, seg="'name ASC'"]
DEBUG      [PD:3  MD:19]	...................FunctionNameSegment            	Ref.match OUT       	    	[match=<MatchResult 0/1: ''>, seg="'ASC'"]
INFO       [PD:3  MD:18]	..................FunctionNameSegment             	Seque.match OUT     	    	[match=<MatchResult 0/3: ''>, seg="'name ASC'"]
INFO       [PD:3  MD:17]	.................FunctionNameSegment              	AnyNu.match OUT     	+   	[match=<MatchResult 2/5: 'tbl.'>, seg="'tbl.name ASC'"]
INFO       [PD:3  MD:17]	.................FunctionNameSegment              	OneOf.match PRN     	    	[ns=2, ps=0, ms=0, pruned=[], opts=[<Ref: FunctionNameIdentifierSegment>, <Ref: QuotedIdentifierSegment>]]
DEBUG      [PD:3  MD:18]	..................FunctionNameSegment             	Ref.match OUT       	+   	[match=<MatchResult 1/3: 'name'>, seg="'name ASC'"]
DEBUG      [PD:3  MD:18]	..................FunctionNameSegment             	Ref.match OUT       	    	[match=<MatchResult 0/3: ''>, seg="'name ASC'"]
INFO       [PD:3  MD:17]	.................FunctionNameSegment              	OneOf.match OUT     	+   	[match=<MatchResult 1/3: 'name'>, seg="'name ASC'"]
INFO       [PD:3  MD:16]	................FunctionNameSegment               	Seque.match OUT     	+   	[match=<MatchResult 3/5: 'tbl.name'>, seg="'tbl.name ASC'"]
DEBUG      [PD:3  MD:15]	...............FunctionNameSegment                	Funct.match OUT     	+   	[match=<MatchResult 1/3: 'tbl.name'>, seg="'tbl.name ASC'"]
DEBUG      [PD:3  MD:15]	...............FunctionSegment                    	Ref.match OUT       	+   	[match=<MatchResult 1/3: 'tbl.name'>, seg="'tbl.name ASC'"]
INFO       [PD:3  MD:14]	..............FunctionSegment                     	AnyNu.match OUT     	+   	[match=<MatchResult 1/3: 'tbl.name'>, seg="'tbl.name ASC'"]
INFO       [PD:3  MD:14]	..............FunctionSegment                     	Brack.match OUT     	    	[match=<MatchResult 0/1: ''>, seg="'ASC'"]
INFO       [PD:3  MD:13]	.............FunctionSegment                      	Seque.match OUT     	    	[match=<MatchResult 0/5: ''>, seg="'tbl.name ASC'"]
INFO       [PD:3  MD:12]	............FunctionSegment                       	Seque.match OUT     	    	[match=<MatchResult 0/5: ''>, seg="'tbl.name ASC'"]
INFO       [PD:3  MD:11]	...........FunctionSegment                        	OneOf.match OUT     	    	[match=<MatchResult 0/5: ''>, seg="'tbl.name ASC'"]
DEBUG      [PD:3  MD:10]	..........FunctionSegment                         	Funct.match OUT     	    	[match=<MatchResult 0/5: ''>, seg="'tbl.name ASC'"]
DEBUG      [PD:3  MD:10]	..........Expression_D_Grammar                    	Ref.match OUT       	    	[match=<MatchResult 0/5: ''>, seg="'tbl.name ASC'"]
INFO       [PD:3  MD:10]	..........LiteralGrammar                          	OneOf.match PRN     	    	[ns=2, ps=4, ms=0, pruned=[<Ref: BooleanLiteralGrammar>, <Ref: QualifiedNumericLiteralSegment>, <Ref: NullLiteralSegment>, <Ref: DateTimeLiteralGrammar>], opts=[<Ref: QuotedLiteralSegment>, <Ref: NumericLiteralSegment>]]
DEBUG      [PD:3  MD:11]	...........LiteralGrammar                         	Ref.match OUT       	    	[match=<MatchResult 0/5: ''>, seg="'tbl.name ASC'"]
DEBUG      [PD:3  MD:11]	...........LiteralGrammar                         	Ref.match OUT       	    	[match=<MatchResult 0/5: ''>, seg="'tbl.name ASC'"]
INFO       [PD:3  MD:10]	..........LiteralGrammar                          	OneOf.match OUT     	    	[match=<MatchResult 0/5: ''>, seg="'tbl.name ASC'"]
DEBUG      [PD:3  MD:10]	..........Expression_D_Grammar                    	Ref.match OUT       	    	[match=<MatchResult 0/5: ''>, seg="'tbl.name ASC'"]
DEBUG      [PD:3  MD:12]	............ColumnReferenceSegment                	Delim._look_ahead_match IN	    	[ls=5, seg='tbl.name ASC']
DEBUG      [PD:3  MD:12]	............ColumnReferenceSegment                	Delim._look_ahead_match SI	    	[mq=[(<OneOf: [<Ref: DotSegment>, <Sequence: [<Ref: DotSegment>, <Ref: Dot...]>, 1, '.'), (<OneOf: [<Ref: DotSegment>, <Sequence: [<Ref: DotSegment>, <Ref: Dot...]>, 1, '.')], sb=['TBL', '.', 'NAME', '', 'ASC']]
INFO       [PD:3  MD:12]	............ColumnReferenceSegment                	OneOf.match PRN     	    	[ns=0, ps=0, ms=2, pruned=[], opts=[<Ref: DotSegment>, <Sequence: [<Ref: DotSegment>, <Ref: DotSegment>]>]]
DEBUG      [PD:3  MD:13]	.............ColumnReferenceSegment               	Ref.match OUT       	+   	[match=<MatchResult 1/4: '.'>, seg="'.name ASC'"]
DEBUG      [PD:3  MD:14]	..............ColumnReferenceSegment              	Ref.match OUT       	+   	[match=<MatchResult 1/4: '.'>, seg="'.name ASC'"]
DEBUG      [PD:3  MD:14]	..............ColumnReferenceSegment              	Ref.match OUT       	    	[match=<MatchResult 0/3: ''>, seg="'name ASC'"]
INFO       [PD:3  MD:13]	.............ColumnReferenceSegment               	Seque.match OUT     	    	[match=<MatchResult 0/4: ''>, seg="'.name ASC'"]
INFO       [PD:3  MD:12]	............ColumnReferenceSegment                	OneOf.match OUT     	+   	[match=<MatchResult 1/4: '.'>, seg="'.name ASC'"]
INFO       [PD:3  MD:12]	............ColumnReferenceSegment                	OneOf.match PRN     	    	[ns=0, ps=0, ms=2, pruned=[], opts=[<Ref: DotSegment>, <Sequence: [<Ref: DotSegment>, <Ref: DotSegment>]>]]
DEBUG      [PD:3  MD:13]	.............ColumnReferenceSegment               	Ref.match OUT       	+   	[match=<MatchResult 1/4: '.'>, seg="'.name ASC'"]
DEBUG      [PD:3  MD:14]	..............ColumnReferenceSegment              	Ref.match OUT       	+   	[match=<MatchResult 1/4: '.'>, seg="'.name ASC'"]
DEBUG      [PD:3  MD:14]	..............ColumnReferenceSegment              	Ref.match OUT       	    	[match=<MatchResult 0/3: ''>, seg="'name ASC'"]
INFO       [PD:3  MD:13]	.............ColumnReferenceSegment               	Seque.match OUT     	    	[match=<MatchResult 0/4: ''>, seg="'.name ASC'"]
INFO       [PD:3  MD:12]	............ColumnReferenceSegment                	OneOf.match OUT     	+   	[match=<MatchResult 1/4: '.'>, seg="'.name ASC'"]
INFO       [PD:3  MD:12]	............ColumnReferenceSegment                	OneOf.match PRN     	    	[ns=1, ps=10, ms=0, pruned=[<Ref: OnKeywordSegment>, <Ref: AsKeywordSegment>, <Ref: UsingKeywordSegment>, <Ref: CommaSegment>, <Ref: CastOperatorSegment>, <Ref: StartSquareBracketSegment>, <Ref: StartBracketSegment>, <Ref: ColonSegment>, <Ref: DelimiterSegment>, <class 'sqlfluff.core.parser.segments.base.BracketedSegment'>], opts=[<Ref: BinaryOperatorGrammar>]]
INFO       [PD:3  MD:13]	.............BinaryOperatorGrammar                	OneOf.match PRN     	    	[ns=1, ps=3, ms=0, pruned=[<Ref: ArithmeticBinaryOperatorGrammar>, <Ref: StringBinaryOperatorGrammar>, <Ref: BooleanBinaryOperatorGrammar>], opts=[<Ref: ComparisonOperatorGrammar>]]
INFO       [PD:3  MD:14]	..............ComparisonOperatorGrammar           	OneOf.match PRN     	    	[ns=1, ps=7, ms=0, pruned=[<Ref: EqualsSegment>, <Ref: GreaterThanSegment>, <Ref: LessThanSegment>, <Ref: GreaterThanOrEqualToSegment>, <Ref: LessThanOrEqualToSegment>, <Ref: NotEqualToSegment_a>, <Ref: NotEqualToSegment_b>], opts=[<Ref: LikeOperatorSegment>]]
DEBUG      [PD:3  MD:15]	...............ComparisonOperatorGrammar          	Ref.match OUT       	    	[match=<MatchResult 0/5: ''>, seg="'tbl.name ASC'"]
INFO       [PD:3  MD:14]	..............ComparisonOperatorGrammar           	OneOf.match OUT     	    	[match=<MatchResult 0/5: ''>, seg="'tbl.name ASC'"]
DEBUG      [PD:3  MD:14]	..............BinaryOperatorGrammar               	Ref.match OUT       	    	[match=<MatchResult 0/5: ''>, seg="'tbl.name ASC'"]
INFO       [PD:3  MD:13]	.............BinaryOperatorGrammar                	OneOf.match OUT     	    	[match=<MatchResult 0/5: ''>, seg="'tbl.name ASC'"]
DEBUG      [PD:3  MD:13]	.............ColumnReferenceSegment               	Ref.match OUT       	    	[match=<MatchResult 0/5: ''>, seg="'tbl.name ASC'"]
INFO       [PD:3  MD:12]	............ColumnReferenceSegment                	OneOf.match OUT     	    	[match=<MatchResult 0/5: ''>, seg="'tbl.name ASC'"]
DEBUG      [PD:3  MD:12]	............ColumnReferenceSegment                	NonCo.match OUT     	    	[match=<MatchResult 0/5: ''>, seg="'tbl.name ASC'"]
INFO       [PD:3  MD:12]	............ColumnReferenceSegment                	OneOf.match PRN     	    	[ns=1, ps=10, ms=0, pruned=[<Ref: OnKeywordSegment>, <Ref: AsKeywordSegment>, <Ref: UsingKeywordSegment>, <Ref: CommaSegment>, <Ref: CastOperatorSegment>, <Ref: StartSquareBracketSegment>, <Ref: StartBracketSegment>, <Ref: ColonSegment>, <Ref: DelimiterSegment>, <class 'sqlfluff.core.parser.segments.base.BracketedSegment'>], opts=[<Ref: BinaryOperatorGrammar>]]
INFO       [PD:3  MD:13]	.............BinaryOperatorGrammar                	OneOf.match PRN     	    	[ns=1, ps=3, ms=0, pruned=[<Ref: ArithmeticBinaryOperatorGrammar>, <Ref: StringBinaryOperatorGrammar>, <Ref: BooleanBinaryOperatorGrammar>], opts=[<Ref: ComparisonOperatorGrammar>]]
INFO       [PD:3  MD:14]	..............ComparisonOperatorGrammar           	OneOf.match PRN     	    	[ns=1, ps=7, ms=0, pruned=[<Ref: EqualsSegment>, <Ref: GreaterThanSegment>, <Ref: LessThanSegment>, <Ref: GreaterThanOrEqualToSegment>, <Ref: LessThanOrEqualToSegment>, <Ref: NotEqualToSegment_a>, <Ref: NotEqualToSegment_b>], opts=[<Ref: LikeOperatorSegment>]]
DEBUG      [PD:3  MD:15]	...............ComparisonOperatorGrammar          	Ref.match OUT       	    	[match=<MatchResult 0/4: ''>, seg="'.name ASC'"]
INFO       [PD:3  MD:14]	..............ComparisonOperatorGrammar           	OneOf.match OUT     	    	[match=<MatchResult 0/4: ''>, seg="'.name ASC'"]
DEBUG      [PD:3  MD:14]	..............BinaryOperatorGrammar               	Ref.match OUT       	    	[match=<MatchResult 0/4: ''>, seg="'.name ASC'"]
INFO       [PD:3  MD:13]	.............BinaryOperatorGrammar                	OneOf.match OUT     	    	[match=<MatchResult 0/4: ''>, seg="'.name ASC'"]
DEBUG      [PD:3  MD:13]	.............ColumnReferenceSegment               	Ref.match OUT       	    	[match=<MatchResult 0/4: ''>, seg="'.name ASC'"]
INFO       [PD:3  MD:12]	............ColumnReferenceSegment                	OneOf.match OUT     	    	[match=<MatchResult 0/4: ''>, seg="'.name ASC'"]
DEBUG      [PD:3  MD:12]	............ColumnReferenceSegment                	NonCo.match OUT     	    	[match=<MatchResult 0/4: ''>, seg="'.name ASC'"]
INFO       [PD:3  MD:12]	............SingleIdentifierGrammar               	OneOf.match PRN     	    	[ns=2, ps=0, ms=0, pruned=[], opts=[<Ref: NakedIdentifierSegment>, <Ref: QuotedIdentifierSegment>]]
DEBUG      [PD:3  MD:13]	.............SingleIdentifierGrammar              	Ref.match OUT       	++  	[match=<MatchResult 1/1: 'tbl'>, seg="'tbl'"]
INFO       [PD:3  MD:12]	............SingleIdentifierGrammar               	OneOf.match OUT     	++  	[match=<MatchResult 1/1: 'tbl'>, seg="'tbl'"]
DEBUG      [PD:3  MD:12]	............ColumnReferenceSegment                	Ref.match OUT       	++  	[match=<MatchResult 1/1: 'tbl'>, seg="'tbl'"]
DEBUG      [PD:3  MD:12]	............ColumnReferenceSegment                	Delim._look_ahead_match IN	    	[ls=3, seg='name ASC']
DEBUG      [PD:3  MD:12]	............ColumnReferenceSegment                	Delim._look_ahead_match SI	    	[mq=[], sb=['NAME', '', 'ASC']]
INFO       [PD:3  MD:12]	............ColumnReferenceSegment                	OneOf.match PRN     	    	[ns=1, ps=10, ms=0, pruned=[<Ref: OnKeywordSegment>, <Ref: AsKeywordSegment>, <Ref: UsingKeywordSegment>, <Ref: CommaSegment>, <Ref: CastOperatorSegment>, <Ref: StartSquareBracketSegment>, <Ref: StartBracketSegment>, <Ref: ColonSegment>, <Ref: DelimiterSegment>, <class 'sqlfluff.core.parser.segments.base.BracketedSegment'>], opts=[<Ref: BinaryOperatorGrammar>]]
INFO       [PD:3  MD:13]	.............BinaryOperatorGrammar                	OneOf.match PRN     	    	[ns=1, ps=3, ms=0, pruned=[<Ref: ArithmeticBinaryOperatorGrammar>, <Ref: StringBinaryOperatorGrammar>, <Ref: BooleanBinaryOperatorGrammar>], opts=[<Ref: ComparisonOperatorGrammar>]]
INFO       [PD:3  MD:14]	..............ComparisonOperatorGrammar           	OneOf.match PRN     	    	[ns=1, ps=7, ms=0, pruned=[<Ref: EqualsSegment>, <Ref: GreaterThanSegment>, <Ref: LessThanSegment>, <Ref: GreaterThanOrEqualToSegment>, <Ref: LessThanOrEqualToSegment>, <Ref: NotEqualToSegment_a>, <Ref: NotEqualToSegment_b>], opts=[<Ref: LikeOperatorSegment>]]
DEBUG      [PD:3  MD:15]	...............ComparisonOperatorGrammar          	Ref.match OUT       	    	[match=<MatchResult 0/3: ''>, seg="'name ASC'"]
INFO       [PD:3  MD:14]	..............ComparisonOperatorGrammar           	OneOf.match OUT     	    	[match=<MatchResult 0/3: ''>, seg="'name ASC'"]
DEBUG      [PD:3  MD:14]	..............BinaryOperatorGrammar               	Ref.match OUT       	    	[match=<MatchResult 0/3: ''>, seg="'name ASC'"]
INFO       [PD:3  MD:13]	.............BinaryOperatorGrammar                	OneOf.match OUT     	    	[match=<MatchResult 0/3: ''>, seg="'name ASC'"]
DEBUG      [PD:3  MD:13]	.............ColumnReferenceSegment               	Ref.match OUT       	    	[match=<MatchResult 0/3: ''>, seg="'name ASC'"]
INFO       [PD:3  MD:12]	............ColumnReferenceSegment                	OneOf.match OUT     	    	[match=<MatchResult 0/3: ''>, seg="'name ASC'"]
DEBUG      [PD:3  MD:12]	............ColumnReferenceSegment                	NonCo.match OUT     	    	[match=<MatchResult 0/3: ''>, seg="'name ASC'"]
INFO       [PD:3  MD:12]	............ColumnReferenceSegment                	OneOf.match PRN     	    	[ns=1, ps=10, ms=0, pruned=[<Ref: OnKeywordSegment>, <Ref: AsKeywordSegment>, <Ref: UsingKeywordSegment>, <Ref: CommaSegment>, <Ref: CastOperatorSegment>, <Ref: StartSquareBracketSegment>, <Ref: StartBracketSegment>, <Ref: ColonSegment>, <Ref: DelimiterSegment>, <class 'sqlfluff.core.parser.segments.base.BracketedSegment'>], opts=[<Ref: BinaryOperatorGrammar>]]
INFO       [PD:3  MD:13]	.............BinaryOperatorGrammar                	OneOf.match PRN     	    	[ns=1, ps=3, ms=0, pruned=[<Ref: ArithmeticBinaryOperatorGrammar>, <Ref: StringBinaryOperatorGrammar>, <Ref: BooleanBinaryOperatorGrammar>], opts=[<Ref: ComparisonOperatorGrammar>]]
INFO       [PD:3  MD:14]	..............ComparisonOperatorGrammar           	OneOf.match PRN     	    	[ns=1, ps=7, ms=0, pruned=[<Ref: EqualsSegment>, <Ref: GreaterThanSegment>, <Ref: LessThanSegment>, <Ref: GreaterThanOrEqualToSegment>, <Ref: LessThanOrEqualToSegment>, <Ref: NotEqualToSegment_a>, <Ref: NotEqualToSegment_b>], opts=[<Ref: LikeOperatorSegment>]]
DEBUG      [PD:3  MD:15]	...............ComparisonOperatorGrammar          	Ref.match OUT       	    	[match=<MatchResult 0/2: ''>, seg="' ASC'"]
INFO       [PD:3  MD:14]	..............ComparisonOperatorGrammar           	OneOf.match OUT     	    	[match=<MatchResult 0/2: ''>, seg="' ASC'"]
DEBUG      [PD:3  MD:14]	..............BinaryOperatorGrammar               	Ref.match OUT       	    	[match=<MatchResult 0/2: ''>, seg="' ASC'"]
INFO       [PD:3  MD:13]	.............BinaryOperatorGrammar                	OneOf.match OUT     	    	[match=<MatchResult 0/2: ''>, seg="' ASC'"]
DEBUG      [PD:3  MD:13]	.............ColumnReferenceSegment               	Ref.match OUT       	    	[match=<MatchResult 0/2: ''>, seg="' ASC'"]
INFO       [PD:3  MD:12]	............ColumnReferenceSegment                	OneOf.match OUT     	    	[match=<MatchResult 0/2: ''>, seg="' ASC'"]
DEBUG      [PD:3  MD:12]	............ColumnReferenceSegment                	NonCo.match OUT     	+   	[match=<MatchResult 1/2: ' '>, seg="' ASC'"]
INFO       [PD:3  MD:12]	............SingleIdentifierGrammar               	OneOf.match PRN     	    	[ns=2, ps=0, ms=0, pruned=[], opts=[<Ref: NakedIdentifierSegment>, <Ref: QuotedIdentifierSegment>]]
DEBUG      [PD:3  MD:13]	.............SingleIdentifierGrammar              	Ref.match OUT       	++  	[match=<MatchResult 1/1: 'name'>, seg="'name'"]
INFO       [PD:3  MD:12]	............SingleIdentifierGrammar               	OneOf.match OUT     	++  	[match=<MatchResult 1/1: 'name'>, seg="'name'"]
DEBUG      [PD:3  MD:12]	............ColumnReferenceSegment                	Ref.match OUT       	++  	[match=<MatchResult 1/1: 'name'>, seg="'name'"]
INFO       [PD:3  MD:11]	...........ColumnReferenceSegment                 	Delim.match OUT     	+   	[match=<MatchResult 3/5: 'tbl.name'>, seg="'tbl.name ASC'"]
DEBUG      [PD:3  MD:10]	..........ColumnReferenceSegment                  	Colum.match OUT     	+   	[match=<MatchResult 1/3: 'tbl.name'>, seg="'tbl.name ASC'"]
DEBUG      [PD:3  MD:10]	..........Expression_D_Grammar                    	Ref.match OUT       	+   	[match=<MatchResult 1/3: 'tbl.name'>, seg="'tbl.name ASC'"]
DEBUG      [PD:3  MD:11]	...........Expression_D_Grammar                   	Ref.match OUT       	    	[match=<MatchResult 0/5: ''>, seg="'tbl.name ASC'"]
INFO       [PD:3  MD:12]	............ArrayLiteralSegment                   	Brack.match OUT     	    	[match=<MatchResult 0/5: ''>, seg="'tbl.name ASC'"]
DEBUG      [PD:3  MD:11]	...........ArrayLiteralSegment                    	Array.match OUT     	    	[match=<MatchResult 0/5: ''>, seg="'tbl.name ASC'"]
DEBUG      [PD:3  MD:11]	...........Expression_D_Grammar                   	Ref.match OUT       	    	[match=<MatchResult 0/5: ''>, seg="'tbl.name ASC'"]
INFO       [PD:3  MD:10]	..........Expression_D_Grammar                    	Seque.match OUT     	    	[match=<MatchResult 0/5: ''>, seg="'tbl.name ASC'"]
INFO       [PD:3  MD:12]	............DatatypeSegment                       	OneOf.match PRN     	    	[ns=1, ps=2, ms=0, pruned=[<Sequence: [<OneOf: [<Ref: TimeKeywordSegment>, <Ref..., <Bracketed: [<Ref: NumericLiteralSegment..., <Sequence:...]>, <Sequence: [<Ref: DoubleKeywordSegment>, <Ref: PrecisionKeywordSegment>]>], opts=[<Sequence: [<OneOf: [<Sequence: [<OneOf: [<Ref: Char..., <Bracketed: [<OneOf: [<Delimited: [<Ref:..., <Ref: Char...]>]]
INFO       [PD:3  MD:14]	..............DatatypeSegment                     	OneOf.match PRN     	    	[ns=1, ps=1, ms=0, pruned=[<Sequence: [<OneOf: [<Ref: CharacterKeywordSegment>,..., <OneOf: [<Ref: VaryingKeywordSegment>, <...]>], opts=[<Sequence: [<Sequence: [<Ref: SingleIdentifierGramma..., <Ref: DatatypeIdentifierSegment>]>]]
INFO       [PD:3  MD:17]	.................SingleIdentifierGrammar          	OneOf.match PRN     	    	[ns=2, ps=0, ms=0, pruned=[], opts=[<Ref: NakedIdentifierSegment>, <Ref: QuotedIdentifierSegment>]]
DEBUG      [PD:3  MD:18]	..................SingleIdentifierGrammar         	Ref.match OUT       	+   	[match=<MatchResult 1/5: 'tbl'>, seg="'tbl.name ASC'"]
DEBUG      [PD:3  MD:18]	..................SingleIdentifierGrammar         	Ref.match OUT       	    	[match=<MatchResult 0/5: ''>, seg="'tbl.name ASC'"]
INFO       [PD:3  MD:17]	.................SingleIdentifierGrammar          	OneOf.match OUT     	+   	[match=<MatchResult 1/5: 'tbl'>, seg="'tbl.name ASC'"]
DEBUG      [PD:3  MD:17]	.................DatatypeSegment                  	Ref.match OUT       	+   	[match=<MatchResult 1/5: 'tbl'>, seg="'tbl.name ASC'"]
DEBUG      [PD:3  MD:17]	.................DatatypeSegment                  	Ref.match OUT       	+   	[match=<MatchResult 1/4: '.'>, seg="'.name ASC'"]
INFO       [PD:3  MD:16]	................DatatypeSegment                   	Seque.match OUT     	+   	[match=<MatchResult 2/5: 'tbl.'>, seg="'tbl.name ASC'"]
DEBUG      [PD:3  MD:16]	................DatatypeSegment                   	Ref.match OUT       	+   	[match=<MatchResult 1/3: 'name'>, seg="'name ASC'"]
INFO       [PD:3  MD:15]	...............DatatypeSegment                    	Seque.match OUT     	+   	[match=<MatchResult 3/5: 'tbl.name'>, seg="'tbl.name ASC'"]
INFO       [PD:3  MD:14]	..............DatatypeSegment                     	OneOf.match OUT     	+   	[match=<MatchResult 3/5: 'tbl.name'>, seg="'tbl.name ASC'"]
INFO       [PD:3  MD:14]	..............DatatypeSegment                     	Brack.match OUT     	    	[match=<MatchResult 0/1: ''>, seg="'ASC'"]
DEBUG      [PD:3  MD:14]	..............DatatypeSegment                     	Ref.match OUT       	    	[match=<MatchResult 0/1: ''>, seg="'ASC'"]
INFO       [PD:3  MD:13]	.............DatatypeSegment                      	Seque.match OUT     	+   	[match=<MatchResult 3/5: 'tbl.name'>, seg="'tbl.name ASC'"]
INFO       [PD:3  MD:12]	............DatatypeSegment                       	OneOf.match OUT     	+   	[match=<MatchResult 3/5: 'tbl.name'>, seg="'tbl.name ASC'"]
DEBUG      [PD:3  MD:11]	...........DatatypeSegment                        	Datat.match OUT     	+   	[match=<MatchResult 1/3: 'tbl.name'>, seg="'tbl.name ASC'"]
DEBUG      [PD:3  MD:11]	...........Expression_D_Grammar                   	Ref.match OUT       	+   	[match=<MatchResult 1/3: 'tbl.name'>, seg="'tbl.name ASC'"]
INFO       [PD:3  MD:11]	...........Expression_D_Grammar                   	OneOf.match PRN     	    	[ns=2, ps=3, ms=0, pruned=[<Ref: BooleanLiteralGrammar>, <Ref: NullLiteralSegment>, <Ref: DateTimeLiteralGrammar>], opts=[<Ref: QuotedLiteralSegment>, <Ref: NumericLiteralSegment>]]
DEBUG      [PD:3  MD:12]	............Expression_D_Grammar                  	Ref.match OUT       	    	[match=<MatchResult 0/1: ''>, seg="'ASC'"]
DEBUG      [PD:3  MD:12]	............Expression_D_Grammar                  	Ref.match OUT       	    	[match=<MatchResult 0/1: ''>, seg="'ASC'"]
INFO       [PD:3  MD:11]	...........Expression_D_Grammar                   	OneOf.match OUT     	    	[match=<MatchResult 0/1: ''>, seg="'ASC'"]
INFO       [PD:3  MD:10]	..........Expression_D_Grammar                    	Seque.match OUT     	    	[match=<MatchResult 0/5: ''>, seg="'tbl.name ASC'"]
INFO       [PD:3  MD:9 ]	.........Expression_D_Grammar                     	OneOf.match OUT     	+   	[match=<MatchResult 1/3: 'tbl.name'>, seg="'tbl.name ASC'"]
INFO       [PD:3  MD:9 ]	.........Accessor_Grammar                         	AnyNu.match PRN     	    	[ns=0, ps=1, ms=0, pruned=[<Ref: ArrayAccessorSegment>], opts='ALL']
INFO       [PD:3  MD:9 ]	.........Accessor_Grammar                         	AnyNu.match OUT     	    	[match=<MatchResult 0/1: ''>, seg="'ASC'"]
DEBUG      [PD:3  MD:9 ]	.........Expression_D_Grammar                     	Ref.match OUT       	    	[match=<MatchResult 0/1: ''>, seg="'ASC'"]
INFO       [PD:3  MD:9 ]	.........Expression_D_Grammar                     	AnyNu.match PRN     	    	[ns=0, ps=1, ms=0, pruned=[<Ref: ShorthandCastSegment>], opts='ALL']
INFO       [PD:3  MD:9 ]	.........Expression_D_Grammar                     	AnyNu.match OUT     	    	[match=<MatchResult 0/1: ''>, seg="'ASC'"]
INFO       [PD:3  MD:8 ]	........Expression_D_Grammar                      	Seque.match OUT     	+   	[match=<MatchResult 1/3: 'tbl.name'>, seg="'tbl.name ASC'"]
DEBUG      [PD:3  MD:8 ]	........Expression_C_Grammar                      	Ref.match OUT       	+   	[match=<MatchResult 1/3: 'tbl.name'>, seg="'tbl.name ASC'"]
INFO       [PD:3  MD:7 ]	.......Expression_C_Grammar                       	OneOf.match OUT     	+   	[match=<MatchResult 1/3: 'tbl.name'>, seg="'tbl.name ASC'"]
DEBUG      [PD:3  MD:7 ]	.......Expression_A_Grammar                       	Ref.match OUT       	+   	[match=<MatchResult 1/3: 'tbl.name'>, seg="'tbl.name ASC'"]
INFO       [PD:3  MD:6 ]	......Expression_A_Grammar                        	OneOf.match OUT     	+   	[match=<MatchResult 1/3: 'tbl.name'>, seg="'tbl.name ASC'"]
INFO       [PD:3  MD:6 ]	......Expression_A_Grammar                        	AnyNu.match PRN     	    	[ns=1, ps=0, ms=0, pruned=[], opts=[<OneOf: [<Sequence: [<OneOf: [<Sequence: [<Ref: N..., <Sequence: [<Ref: NotKeywordSegment [opt..., <Sequence:...]>]]
INFO       [PD:3  MD:7 ]	.......Expression_A_Grammar                       	OneOf.match PRN     	    	[ns=3, ps=5, ms=0, pruned=[<Sequence: [<Ref: NotKeywordSegment [opt]>, <Ref: InKeywordSegment>, <Bracketed: [<OneOf: [<Delimited: [<Ref:...]>, <Sequence: [<Ref: NotKeywordSegment [opt]>, <Ref: InKeywordSegment>, <Ref: FunctionSegment>]>, <Sequence: [<Ref: IsKeywordSegment>, <Ref: NotKeywordSegment [opt]>, <Ref: IsClauseGrammar>]>, <Sequence: [<Ref: NotKeywordSegment>, <Ref: Expression_C_Grammar>]>, <Sequence: [<Ref: NotKeywordSegment [opt]>, <Ref: BetweenKeywordSegment>, <Ref: Expression_C_Grammar>, <AnyNumbe...]>], opts=[<Sequence: [<OneOf: [<Sequence: [<Ref: NotKeywordSeg..., <Ref: Expression_C_Grammar>, <Sequence: [<Ref: EscapeKe...]>, <Ref: IsNullGrammar>, <Ref: NotNullGrammar>]]
INFO       [PD:3  MD:9 ]	.........Expression_A_Grammar                     	OneOf.match PRN     	    	[ns=1, ps=1, ms=0, pruned=[<Sequence: [<Ref: NotKeywordSegment [opt]>, <Ref: LikeGrammar>]>], opts=[<Sequence: [<Ref: BinaryOperatorGrammar>, <Ref: NotKeywordSegment [opt]>]>]]
INFO       [PD:3  MD:11]	...........BinaryOperatorGrammar                  	OneOf.match PRN     	    	[ns=1, ps=3, ms=0, pruned=[<Ref: ArithmeticBinaryOperatorGrammar>, <Ref: StringBinaryOperatorGrammar>, <Ref: BooleanBinaryOperatorGrammar>], opts=[<Ref: ComparisonOperatorGrammar>]]
INFO       [PD:3  MD:12]	............ComparisonOperatorGrammar             	OneOf.match PRN     	    	[ns=1, ps=7, ms=0, pruned=[<Ref: EqualsSegment>, <Ref: GreaterThanSegment>, <Ref: LessThanSegment>, <Ref: GreaterThanOrEqualToSegment>, <Ref: LessThanOrEqualToSegment>, <Ref: NotEqualToSegment_a>, <Ref: NotEqualToSegment_b>], opts=[<Ref: LikeOperatorSegment>]]
DEBUG      [PD:3  MD:13]	.............ComparisonOperatorGrammar            	Ref.match OUT       	    	[match=<MatchResult 0/1: ''>, seg="'ASC'"]
INFO       [PD:3  MD:12]	............ComparisonOperatorGrammar             	OneOf.match OUT     	    	[match=<MatchResult 0/1: ''>, seg="'ASC'"]
DEBUG      [PD:3  MD:12]	............BinaryOperatorGrammar                 	Ref.match OUT       	    	[match=<MatchResult 0/1: ''>, seg="'ASC'"]
INFO       [PD:3  MD:11]	...........BinaryOperatorGrammar                  	OneOf.match OUT     	    	[match=<MatchResult 0/1: ''>, seg="'ASC'"]
DEBUG      [PD:3  MD:11]	...........Expression_A_Grammar                   	Ref.match OUT       	    	[match=<MatchResult 0/1: ''>, seg="'ASC'"]
INFO       [PD:3  MD:10]	..........Expression_A_Grammar                    	Seque.match OUT     	    	[match=<MatchResult 0/1: ''>, seg="'ASC'"]
INFO       [PD:3  MD:9 ]	.........Expression_A_Grammar                     	OneOf.match OUT     	    	[match=<MatchResult 0/1: ''>, seg="'ASC'"]
INFO       [PD:3  MD:8 ]	........Expression_A_Grammar                      	Seque.match OUT     	    	[match=<MatchResult 0/1: ''>, seg="'ASC'"]
DEBUG      [PD:3  MD:8 ]	........Expression_A_Grammar                      	Ref.match OUT       	    	[match=<MatchResult 0/1: ''>, seg="'ASC'"]
DEBUG      [PD:3  MD:8 ]	........Expression_A_Grammar                      	Ref.match OUT       	    	[match=<MatchResult 0/1: ''>, seg="'ASC'"]
INFO       [PD:3  MD:7 ]	.......Expression_A_Grammar                       	OneOf.match OUT     	    	[match=<MatchResult 0/1: ''>, seg="'ASC'"]
INFO       [PD:3  MD:6 ]	......Expression_A_Grammar                        	AnyNu.match OUT     	    	[match=<MatchResult 0/1: ''>, seg="'ASC'"]
INFO       [PD:3  MD:5 ]	.....Expression_A_Grammar                         	Seque.match OUT     	+   	[match=<MatchResult 1/3: 'tbl.name'>, seg="'tbl.name ASC'"]
DEBUG      [PD:3  MD:5 ]	.....ExpressionSegment                            	Ref.match OUT       	+   	[match=<MatchResult 1/3: 'tbl.name'>, seg="'tbl.name ASC'"]
DEBUG      [PD:3  MD:4 ]	....ExpressionSegment                             	Expre.match OUT     	+   	[match=<MatchResult 1/3: 'tbl.name'>, seg="'tbl.name ASC'"]
DEBUG      [PD:3  MD:4 ]	....OrderByClauseSegment                          	Ref.match OUT       	+   	[match=<MatchResult 1/3: 'tbl.name'>, seg="'tbl.name ASC'"]
INFO       [PD:3  MD:3 ]	...OrderByClauseSegment                           	OneOf.match OUT     	+   	[match=<MatchResult 1/3: 'tbl.name'>, seg="'tbl.name ASC'"]
INFO       [PD:3  MD:3 ]	...OrderByClauseSegment                           	OneOf.match PRN     	    	[ns=0, ps=1, ms=1, pruned=[<Ref: DescKeywordSegment>], opts=[<Ref: AscKeywordSegment>]]
DEBUG      [PD:3  MD:4 ]	....OrderByClauseSegment                          	Ref.match OUT       	++  	[match=<MatchResult 1/1: 'ASC'>, seg="'ASC'"]
INFO       [PD:3  MD:3 ]	...OrderByClauseSegment                           	OneOf.match OUT     	++  	[match=<MatchResult 1/1: 'ASC'>, seg="'ASC'"]
INFO       [PD:3  MD:2 ]	..OrderByClauseSegment                            	Seque.match OUT     	++  	[match=<MatchResult 3/3: 'tbl.name ASC'>, seg="'tbl.name ASC'"]
INFO       [PD:3  MD:1 ]	.OrderByClauseSegment                             	Delim.match OUT     	++  	[match=<MatchResult 3/3: 'tbl.name ASC'>, seg="'tbl.name ASC'"]
INFO       [PD:3  MD:0 ]	OrderByClauseSegment                              	Seque.match OUT     	++  	[match=<MatchResult 9/9: 'ORDER BY tbl.name ASC'>, seg="'ORDER BY tbl.name AS...'"]
DEBUG      OrderByClauseSegment.parse: Done Parse. Plotting Recursion. Recurse=True
DEBUG      ###
#
# Beginning Parse Depth 4: OrderByClauseSegment
#
###
Initial Structure:
[L: 14, P:  1]      |orderby_clause:
[L: 14, P:  1]      |    keyword:                                                  'ORDER'
[L: 14, P:  6]      |    whitespace:                                               ' '
[L: 14, P:  7]      |    keyword:                                                  'BY'
[L: 14, P:  9]      |    [META] indent:
[L: 14, P:  9]      |    whitespace:                                               ' '
[L: 14, P: 10]      |    column_reference:
[L: 14, P: 10]      |        identifier:                                           'tbl'
[L: 14, P: 13]      |        dot:                                                  '.'
[L: 14, P: 14]      |        identifier:                                           'name'
[L: 14, P: 18]      |    whitespace:                                               ' '
[L: 14, P: 19]      |    keyword:                                                  'ASC'
[L: 14, P: 22]      |    [META] dedent:

INFO       [PD:4] Skipping expansion of <KeywordSegment: ([L: 14, P:  1]) 'ORDER'>...
INFO       [PD:4] Skipping expansion of <WhitespaceSegment: ([L: 14, P:  6]) ' '>...
INFO       [PD:4] Skipping expansion of <KeywordSegment: ([L: 14, P:  7]) 'BY'>...
INFO       [PD:4] Skipping expansion of <Indent: ([L: 14, P:  9]) ''>...
INFO       [PD:4] Skipping expansion of <WhitespaceSegment: ([L: 14, P:  9]) ' '>...
INFO       [PD:4] Skipping expansion of <ColumnReferenceSegment: ([L: 14, P: 10])>...
INFO       [PD:4] Skipping expansion of <WhitespaceSegment: ([L: 14, P: 18]) ' '>...
INFO       [PD:4] Skipping expansion of <KeywordSegment: ([L: 14, P: 19]) 'ASC'>...
INFO       [PD:4] Skipping expansion of <Dedent: ([L: 14, P: 22]) ''>...
INFO       [PD:1] Skipping expansion of <NewlineSegment: ([L: 14, P: 22]) '\n'>...
INFO       
###
#
# Parsed Tree:
#
###
INFO       
[L:  1, P:  1]      |file:
[L:  1, P:  1]      |    statement:
[L:  1, P:  1]      |        select_statement:
[L:  1, P:  1]      |            select_clause:
[L:  1, P:  1]      |                keyword:                                      'SELECT'
[L:  1, P:  7]      |                [META] indent:
[L:  1, P:  7]      |                newline:                                      '\n'
[L:  2, P:  1]      |                whitespace:                                   '    '
[L:  2, P:  5]      |                select_clause_element:
[L:  2, P:  5]      |                    column_reference:
[L:  2, P:  5]      |                        identifier:                           'tbl'
[L:  2, P:  8]      |                        dot:                                  '.'
[L:  2, P:  9]      |                        identifier:                           'name'
[L:  2, P: 13]      |                comma:                                        ','
[L:  2, P: 14]      |                newline:                                      '\n'
[L:  3, P:  1]      |                whitespace:                                   '    '
[L:  3, P:  5]      |                select_clause_element:
[L:  3, P:  5]      |                    column_reference:
[L:  3, P:  5]      |                        identifier:                           'b'
[L:  3, P:  6]      |                        dot:                                  '.'
[L:  3, P:  7]      |                        identifier:                           'value'
[L:  3, P: 12]      |                comma:                                        ','
[L:  3, P: 13]      |                newline:                                      '\n'
[L:  4, P:  1]      |                whitespace:                                   '    '
[L:  4, P:  5]      |                comment:                                      '/*'
[L:  4, P:  7]      |                newline:                                      '\n'
[L:  5, P:  1]      |                whitespace:                                   '    '
[L:  5, P:  5]      |                comment:                                      'This is a block comment'
[L:  5, P: 28]      |                newline:                                      '\n'
[L:  6, P:  1]      |                whitespace:                                   '    '
[L:  6, P:  5]      |                comment:                                      '*/'
[L:  6, P:  7]      |                newline:                                      '\n'
[L:  7, P:  1]      |                whitespace:                                   '    '
[L:  7, P:  5]      |                select_clause_element:
[L:  7, P:  5]      |                    column_reference:
[L:  7, P:  5]      |                        identifier:                           'd'
[L:  7, P:  6]      |                        dot:                                  '.'
[L:  7, P:  7]      |                        identifier:                           'something'
[L:  7, P: 16]      |                comma:                                        ','
[L:  7, P: 17]      |                whitespace:                                   '    '
[L:  7, P: 21]      |                comment:                                      '-- Which a comment after it'
[L:  7, P: 48]      |                newline:                                      '\n'
[L:  8, P:  1]      |                whitespace:                                   '    '
[L:  8, P:  5]      |                select_clause_element:
[L:  8, P:  5]      |                    column_reference:
[L:  8, P:  5]      |                        identifier:                           'tbl'
[L:  8, P:  8]      |                        dot:                                  '.'
[L:  8, P:  9]      |                        identifier:                           'foo'
[L:  8, P: 12]      |                comma:                                        ','
[L:  8, P: 13]      |                newline:                                      '\n'
[L:  9, P:  1]      |                whitespace:                                   '    '
[L:  9, P:  5]      |                select_clause_element:
[L:  9, P:  5]      |                    expression:
[L:  9, P:  5]      |                        column_reference:
[L:  9, P:  5]      |                            identifier:                       'c'
[L:  9, P:  6]      |                            dot:                              '.'
[L:  9, P:  7]      |                            identifier:                       'val'
[L:  9, P: 10]      |                        whitespace:                           ' '
[L:  9, P: 11]      |                        binary_operator:                      '+'
[L:  9, P: 12]      |                        whitespace:                           ' '
[L:  9, P: 13]      |                        column_reference:
[L:  9, P: 13]      |                            identifier:                       'b'
[L:  9, P: 14]      |                            dot:                              '.'
[L:  9, P: 15]      |                            identifier:                       'val'
[L:  9, P: 18]      |                        whitespace:                           ' '
[L:  9, P: 19]      |                        binary_operator:                      '/'
[L:  9, P: 20]      |                        whitespace:                           ' '
[L:  9, P: 21]      |                        numeric_literal:
[L:  9, P: 21]      |                            binary_operator:                  '-'
[L:  9, P: 22]      |                            literal:                          '2'
[L:  9, P: 23]      |                    whitespace:                               ' '
[L:  9, P: 24]      |                    alias_expression:
[L:  9, P: 24]      |                        keyword:                              'AS'
[L:  9, P: 26]      |                        whitespace:                           ' '
[L:  9, P: 27]      |                        identifier:                           'a_calculation'
[L:  9, P: 40]      |            newline:                                          '\n'
[L: 10, P:  1]      |            [META] dedent:
[L: 10, P:  1]      |            from_clause:
[L: 10, P:  1]      |                keyword:                                      'FROM'
[L: 10, P:  5]      |                whitespace:                                   ' '
[L: 10, P:  6]      |                from_expression:
[L: 10, P:  6]      |                    [META] indent:
[L: 10, P:  6]      |                    from_expression_element:
[L: 10, P:  6]      |                        table_expression:
[L: 10, P:  6]      |                            table_reference:
[L: 10, P:  6]      |                                identifier:                   'tbl'
[L: 10, P:  9]      |                    newline:                                  '\n'
[L: 11, P:  1]      |                    [META] dedent:
[L: 11, P:  1]      |                    join_clause:
[L: 11, P:  1]      |                        keyword:                              'INNER'
[L: 11, P:  6]      |                        whitespace:                           ' '
[L: 11, P:  7]      |                        keyword:                              'JOIN'
[L: 11, P: 11]      |                        [META] indent:
[L: 11, P: 11]      |                        whitespace:                           ' '
[L: 11, P: 12]      |                        from_expression_element:
[L: 11, P: 12]      |                            table_expression:
[L: 11, P: 12]      |                                table_reference:
[L: 11, P: 12]      |                                    identifier:               'b'
[L: 11, P: 13]      |                        whitespace:                           ' '
[L: 11, P: 14]      |                        join_on_condition:
[L: 11, P: 14]      |                            keyword:                          'ON'
[L: 11, P: 16]      |                            [META] indent:
[L: 11, P: 16]      |                            whitespace:                       ' '
[L: 11, P: 17]      |                            bracketed:
[L: 11, P: 17]      |                                start_bracket:                '('
[L: 11, P: 18]      |                                [META] indent:
[L: 11, P: 18]      |                                expression:
[L: 11, P: 18]      |                                    column_reference:
[L: 11, P: 18]      |                                        identifier:           'tbl'
[L: 11, P: 21]      |                                        dot:                  '.'
[L: 11, P: 22]      |                                        identifier:           'common_id'
[L: 11, P: 31]      |                                    whitespace:               ' '
[L: 11, P: 32]      |                                    comparison_operator:      '='
[L: 11, P: 33]      |                                    whitespace:               ' '
[L: 11, P: 34]      |                                    column_reference:
[L: 11, P: 34]      |                                        identifier:           'b'
[L: 11, P: 35]      |                                        dot:                  '.'
[L: 11, P: 36]      |                                        identifier:           'common_id'
[L: 11, P: 45]      |                                [META] dedent:
[L: 11, P: 45]      |                                end_bracket:                  ')'
[L: 11, P: 46]      |                            [META] dedent:
[L: 11, P: 46]      |                        [META] dedent:
[L: 11, P: 46]      |                    newline:                                  '\n'
[L: 12, P:  1]      |                    join_clause:
[L: 12, P:  1]      |                        keyword:                              'JOIN'
[L: 12, P:  5]      |                        [META] indent:
[L: 12, P:  5]      |                        whitespace:                           ' '
[L: 12, P:  6]      |                        from_expression_element:
[L: 12, P:  6]      |                            table_expression:
[L: 12, P:  6]      |                                table_reference:
[L: 12, P:  6]      |                                    identifier:               'c'
[L: 12, P:  7]      |                        whitespace:                           ' '
[L: 12, P:  8]      |                        join_on_condition:
[L: 12, P:  8]      |                            keyword:                          'ON'
[L: 12, P: 10]      |                            [META] indent:
[L: 12, P: 10]      |                            whitespace:                       ' '
[L: 12, P: 11]      |                            bracketed:
[L: 12, P: 11]      |                                start_bracket:                '('
[L: 12, P: 12]      |                                [META] indent:
[L: 12, P: 12]      |                                expression:
[L: 12, P: 12]      |                                    column_reference:
[L: 12, P: 12]      |                                        identifier:           'tbl'
[L: 12, P: 15]      |                                        dot:                  '.'
[L: 12, P: 16]      |                                        identifier:           'id'
[L: 12, P: 18]      |                                    whitespace:               ' '
[L: 12, P: 19]      |                                    comparison_operator:      '='
[L: 12, P: 20]      |                                    whitespace:               ' '
[L: 12, P: 21]      |                                    column_reference:
[L: 12, P: 21]      |                                        identifier:           'c'
[L: 12, P: 22]      |                                        dot:                  '.'
[L: 12, P: 23]      |                                        identifier:           'id'
[L: 12, P: 25]      |                                [META] dedent:
[L: 12, P: 25]      |                                end_bracket:                  ')'
[L: 12, P: 26]      |                            [META] dedent:
[L: 12, P: 26]      |                        [META] dedent:
[L: 12, P: 26]      |                    newline:                                  '\n'
[L: 13, P:  1]      |                    join_clause:
[L: 13, P:  1]      |                        keyword:                              'LEFT'
[L: 13, P:  5]      |                        whitespace:                           ' '
[L: 13, P:  6]      |                        keyword:                              'JOIN'
[L: 13, P: 10]      |                        [META] indent:
[L: 13, P: 10]      |                        whitespace:                           ' '
[L: 13, P: 11]      |                        from_expression_element:
[L: 13, P: 11]      |                            table_expression:
[L: 13, P: 11]      |                                table_reference:
[L: 13, P: 11]      |                                    identifier:               'd'
[L: 13, P: 12]      |                        whitespace:                           ' '
[L: 13, P: 13]      |                        join_on_condition:
[L: 13, P: 13]      |                            keyword:                          'ON'
[L: 13, P: 15]      |                            [META] indent:
[L: 13, P: 15]      |                            whitespace:                       ' '
[L: 13, P: 16]      |                            bracketed:
[L: 13, P: 16]      |                                start_bracket:                '('
[L: 13, P: 17]      |                                [META] indent:
[L: 13, P: 17]      |                                expression:
[L: 13, P: 17]      |                                    column_reference:
[L: 13, P: 17]      |                                        identifier:           'tbl'
[L: 13, P: 20]      |                                        dot:                  '.'
[L: 13, P: 21]      |                                        identifier:           'id'
[L: 13, P: 23]      |                                    whitespace:               ' '
[L: 13, P: 24]      |                                    comparison_operator:      '='
[L: 13, P: 25]      |                                    whitespace:               ' '
[L: 13, P: 26]      |                                    column_reference:
[L: 13, P: 26]      |                                        identifier:           'd'
[L: 13, P: 27]      |                                        dot:                  '.'
[L: 13, P: 28]      |                                        identifier:           'other_id'
[L: 13, P: 36]      |                                [META] dedent:
[L: 13, P: 36]      |                                end_bracket:                  ')'
[L: 13, P: 37]      |                            [META] dedent:
[L: 13, P: 37]      |                        [META] dedent:
[L: 13, P: 37]      |            newline:                                          '\n'
[L: 14, P:  1]      |            orderby_clause:
[L: 14, P:  1]      |                keyword:                                      'ORDER'
[L: 14, P:  6]      |                whitespace:                                   ' '
[L: 14, P:  7]      |                keyword:                                      'BY'
[L: 14, P:  9]      |                [META] indent:
[L: 14, P:  9]      |                whitespace:                                   ' '
[L: 14, P: 10]      |                column_reference:
[L: 14, P: 10]      |                    identifier:                               'tbl'
[L: 14, P: 13]      |                    dot:                                      '.'
[L: 14, P: 14]      |                    identifier:                               'name'
[L: 14, P: 18]      |                whitespace:                                   ' '
[L: 14, P: 19]      |                keyword:                                      'ASC'
[L: 14, P: 22]      |                [META] dedent:
[L: 14, P: 22]      |    newline:                                                  '\n'

INFO       LINTING (test/fixtures/cli/passing_b.sql)
== [test/fixtures/cli/passing_b.sql] LINTING
DEBUG      [L003] Evaluating line #1. {'line_no': 1, 'indent_size': 0, 'indent_balance': 0, 'hanging_indent': None, 'clean_indent': False}
DEBUG      [L003] Evaluating line #2. {'line_no': 2, 'indent_size': 4, 'indent_balance': 1, 'hanging_indent': None, 'clean_indent': True}
DEBUG      [L003]     [deeper indent balance] Comparing to #1
DEBUG      [L003]     Comparison Line: {'line_no': 1, 'indent_size': 0, 'indent_balance': 0, 'hanging_indent': None, 'clean_indent': False}
DEBUG      [L003]     Indent deemed ok comparing to #1
DEBUG      [L003] Evaluating line #3. {'line_no': 3, 'indent_size': 4, 'indent_balance': 1, 'hanging_indent': None, 'clean_indent': False}
DEBUG      [L003]     [same indent balance] Comparing to #2
DEBUG      [L003]     Indent deemed ok comparing to #2
DEBUG      [L003] Evaluating line #4. {'line_no': 4, 'indent_size': 4, 'indent_balance': 1, 'hanging_indent': None, 'clean_indent': False}
DEBUG      [L003]     Comment Line. #4
DEBUG      [L003] Evaluating line #5. {'line_no': 5, 'indent_size': 4, 'indent_balance': 1, 'hanging_indent': None, 'clean_indent': False}
DEBUG      [L003]     Comment Line. #5
DEBUG      [L003] Evaluating line #6. {'line_no': 6, 'indent_size': 4, 'indent_balance': 1, 'hanging_indent': None, 'clean_indent': False}
DEBUG      [L003]     Comment Line. #6
DEBUG      [L003] Evaluating line #7. {'line_no': 7, 'indent_size': 4, 'indent_balance': 1, 'hanging_indent': None, 'clean_indent': False}
DEBUG      [L003]     [same indent balance] Comparing to #3
DEBUG      [L003]     Indent deemed ok comparing to #3
DEBUG      [L003] Evaluating line #8. {'line_no': 8, 'indent_size': 4, 'indent_balance': 1, 'hanging_indent': None, 'clean_indent': False}
DEBUG      [L003]     [same indent balance] Comparing to #7
DEBUG      [L003]     Indent deemed ok comparing to #7
DEBUG      [L003] Evaluating line #9. {'line_no': 9, 'indent_size': 4, 'indent_balance': 1, 'hanging_indent': None, 'clean_indent': False}
DEBUG      [L003]     [same indent balance] Comparing to #8
DEBUG      [L003]     Indent deemed ok comparing to #8
DEBUG      [L003] Evaluating line #10. {'line_no': 10, 'indent_size': 0, 'indent_balance': 0, 'hanging_indent': None, 'clean_indent': False}
DEBUG      [L003]     [same indent balance] Comparing to #1
DEBUG      [L003]     Indent deemed ok comparing to #1
DEBUG      [L003] Evaluating line #11. {'line_no': 11, 'indent_size': 0, 'indent_balance': 0, 'hanging_indent': None, 'clean_indent': False}
DEBUG      [L003]     [same indent balance] Comparing to #10
DEBUG      [L003]     Indent deemed ok comparing to #10
DEBUG      [L003] Evaluating line #12. {'line_no': 12, 'indent_size': 0, 'indent_balance': 0, 'hanging_indent': None, 'clean_indent': False}
DEBUG      [L003]     [same indent balance] Comparing to #11
DEBUG      [L003]     Indent deemed ok comparing to #11
DEBUG      [L003] Evaluating line #13. {'line_no': 13, 'indent_size': 0, 'indent_balance': 0, 'hanging_indent': None, 'clean_indent': False}
DEBUG      [L003]     [same indent balance] Comparing to #12
DEBUG      [L003]     Indent deemed ok comparing to #12
DEBUG      [L003] Evaluating line #14. {'line_no': 14, 'indent_size': 0, 'indent_balance': 0, 'hanging_indent': None, 'clean_indent': False}
DEBUG      [L003]     [same indent balance] Comparing to #13
DEBUG      [L003]     Indent deemed ok comparing to #13
DEBUG      [L006] Found Target [main] @[L:  9, P: 11]: '+'
DEBUG      [L006] Found Target [main] @[L:  9, P: 19]: '/'
DEBUG      [L006] Found Target [leading] @[L:  9, P: 21]: '-'
DEBUG      [L006] Found Target [main] @[L: 11, P: 32]: '='
DEBUG      [L006] Found Target [main] @[L: 12, P: 19]: '='
DEBUG      [L006] Found Target [main] @[L: 13, P: 24]: '='
DEBUG      [L010] Selected 'capitalisation_policy': 'consistent' from options ['upper', 'lower', 'capitalise']
DEBUG      [L010] Refuted cases after segment 'SELECT': {'lower', 'capitalise'}
DEBUG      [L010] Possible cases after segment 'SELECT': ['upper']
DEBUG      [L010] Consistent capitalization, returning with memory: {'refuted_cases': {'lower', 'capitalise'}, 'latest_possible_case': 'upper'}
DEBUG      [L010] Refuted cases after segment '+': {'lower', 'pascal', 'capitalise'}
DEBUG      [L010] Possible cases after segment '+': ['upper']
DEBUG      [L010] Consistent capitalization, returning with memory: {'refuted_cases': {'lower', 'pascal', 'capitalise'}, 'latest_possible_case': 'upper'}
DEBUG      [L010] Refuted cases after segment '/': {'lower', 'pascal', 'capitalise'}
DEBUG      [L010] Possible cases after segment '/': ['upper']
DEBUG      [L010] Consistent capitalization, returning with memory: {'refuted_cases': {'lower', 'pascal', 'capitalise'}, 'latest_possible_case': 'upper'}
DEBUG      [L010] Refuted cases after segment '-': {'lower', 'pascal', 'capitalise'}
DEBUG      [L010] Possible cases after segment '-': ['upper']
DEBUG      [L010] Consistent capitalization, returning with memory: {'refuted_cases': {'lower', 'pascal', 'capitalise'}, 'latest_possible_case': 'upper'}
DEBUG      [L010] Refuted cases after segment 'AS': {'lower', 'pascal', 'capitalise'}
DEBUG      [L010] Possible cases after segment 'AS': ['upper']
DEBUG      [L010] Consistent capitalization, returning with memory: {'refuted_cases': {'lower', 'pascal', 'capitalise'}, 'latest_possible_case': 'upper'}
DEBUG      [L010] Refuted cases after segment 'FROM': {'lower', 'pascal', 'capitalise'}
DEBUG      [L010] Possible cases after segment 'FROM': ['upper']
DEBUG      [L010] Consistent capitalization, returning with memory: {'refuted_cases': {'lower', 'pascal', 'capitalise'}, 'latest_possible_case': 'upper'}
DEBUG      [L010] Refuted cases after segment 'INNER': {'lower', 'pascal', 'capitalise'}
DEBUG      [L010] Possible cases after segment 'INNER': ['upper']
DEBUG      [L010] Consistent capitalization, returning with memory: {'refuted_cases': {'lower', 'pascal', 'capitalise'}, 'latest_possible_case': 'upper'}
DEBUG      [L010] Refuted cases after segment 'JOIN': {'lower', 'pascal', 'capitalise'}
DEBUG      [L010] Possible cases after segment 'JOIN': ['upper']
DEBUG      [L010] Consistent capitalization, returning with memory: {'refuted_cases': {'lower', 'pascal', 'capitalise'}, 'latest_possible_case': 'upper'}
DEBUG      [L010] Refuted cases after segment 'ON': {'lower', 'pascal', 'capitalise'}
DEBUG      [L010] Possible cases after segment 'ON': ['upper']
DEBUG      [L010] Consistent capitalization, returning with memory: {'refuted_cases': {'lower', 'pascal', 'capitalise'}, 'latest_possible_case': 'upper'}
DEBUG      [L010] Refuted cases after segment 'JOIN': {'lower', 'pascal', 'capitalise'}
DEBUG      [L010] Possible cases after segment 'JOIN': ['upper']
DEBUG      [L010] Consistent capitalization, returning with memory: {'refuted_cases': {'lower', 'pascal', 'capitalise'}, 'latest_possible_case': 'upper'}
DEBUG      [L010] Refuted cases after segment 'ON': {'lower', 'pascal', 'capitalise'}
DEBUG      [L010] Possible cases after segment 'ON': ['upper']
DEBUG      [L010] Consistent capitalization, returning with memory: {'refuted_cases': {'lower', 'pascal', 'capitalise'}, 'latest_possible_case': 'upper'}
DEBUG      [L010] Refuted cases after segment 'LEFT': {'lower', 'pascal', 'capitalise'}
DEBUG      [L010] Possible cases after segment 'LEFT': ['upper']
DEBUG      [L010] Consistent capitalization, returning with memory: {'refuted_cases': {'lower', 'pascal', 'capitalise'}, 'latest_possible_case': 'upper'}
DEBUG      [L010] Refuted cases after segment 'JOIN': {'lower', 'pascal', 'capitalise'}
DEBUG      [L010] Possible cases after segment 'JOIN': ['upper']
DEBUG      [L010] Consistent capitalization, returning with memory: {'refuted_cases': {'lower', 'pascal', 'capitalise'}, 'latest_possible_case': 'upper'}
DEBUG      [L010] Refuted cases after segment 'ON': {'lower', 'pascal', 'capitalise'}
DEBUG      [L010] Possible cases after segment 'ON': ['upper']
DEBUG      [L010] Consistent capitalization, returning with memory: {'refuted_cases': {'lower', 'pascal', 'capitalise'}, 'latest_possible_case': 'upper'}
DEBUG      [L010] Refuted cases after segment 'ORDER': {'lower', 'pascal', 'capitalise'}
DEBUG      [L010] Possible cases after segment 'ORDER': ['upper']
DEBUG      [L010] Consistent capitalization, returning with memory: {'refuted_cases': {'lower', 'pascal', 'capitalise'}, 'latest_possible_case': 'upper'}
DEBUG      [L010] Refuted cases after segment 'BY': {'lower', 'pascal', 'capitalise'}
DEBUG      [L010] Possible cases after segment 'BY': ['upper']
DEBUG      [L010] Consistent capitalization, returning with memory: {'refuted_cases': {'lower', 'pascal', 'capitalise'}, 'latest_possible_case': 'upper'}
DEBUG      [L010] Refuted cases after segment 'ASC': {'lower', 'pascal', 'capitalise'}
DEBUG      [L010] Possible cases after segment 'ASC': ['upper']
DEBUG      [L010] Consistent capitalization, returning with memory: {'refuted_cases': {'lower', 'pascal', 'capitalise'}, 'latest_possible_case': 'upper'}
DEBUG      [L014] Selected 'extended_capitalisation_policy': 'consistent' from options ['upper', 'lower', 'pascal', 'capitalise']
DEBUG      [L014] Refuted cases after segment 'tbl': {'upper', 'pascal', 'capitalise'}
DEBUG      [L014] Possible cases after segment 'tbl': ['lower']
DEBUG      [L014] Consistent capitalization, returning with memory: {'refuted_cases': {'upper', 'pascal', 'capitalise'}, 'latest_possible_case': 'lower'}
DEBUG      [L014] Refuted cases after segment 'name': {'upper', 'pascal', 'capitalise'}
DEBUG      [L014] Possible cases after segment 'name': ['lower']
DEBUG      [L014] Consistent capitalization, returning with memory: {'refuted_cases': {'upper', 'pascal', 'capitalise'}, 'latest_possible_case': 'lower'}
DEBUG      [L014] Refuted cases after segment 'b': {'upper', 'pascal', 'capitalise'}
DEBUG      [L014] Possible cases after segment 'b': ['lower']
DEBUG      [L014] Consistent capitalization, returning with memory: {'refuted_cases': {'upper', 'pascal', 'capitalise'}, 'latest_possible_case': 'lower'}
DEBUG      [L014] Refuted cases after segment 'value': {'upper', 'pascal', 'capitalise'}
DEBUG      [L014] Possible cases after segment 'value': ['lower']
DEBUG      [L014] Consistent capitalization, returning with memory: {'refuted_cases': {'upper', 'pascal', 'capitalise'}, 'latest_possible_case': 'lower'}
DEBUG      [L014] Refuted cases after segment 'd': {'upper', 'pascal', 'capitalise'}
DEBUG      [L014] Possible cases after segment 'd': ['lower']
DEBUG      [L014] Consistent capitalization, returning with memory: {'refuted_cases': {'upper', 'pascal', 'capitalise'}, 'latest_possible_case': 'lower'}
DEBUG      [L014] Refuted cases after segment 'something': {'upper', 'pascal', 'capitalise'}
DEBUG      [L014] Possible cases after segment 'something': ['lower']
DEBUG      [L014] Consistent capitalization, returning with memory: {'refuted_cases': {'upper', 'pascal', 'capitalise'}, 'latest_possible_case': 'lower'}
DEBUG      [L014] Refuted cases after segment 'tbl': {'upper', 'pascal', 'capitalise'}
DEBUG      [L014] Possible cases after segment 'tbl': ['lower']
DEBUG      [L014] Consistent capitalization, returning with memory: {'refuted_cases': {'upper', 'pascal', 'capitalise'}, 'latest_possible_case': 'lower'}
DEBUG      [L014] Refuted cases after segment 'foo': {'upper', 'pascal', 'capitalise'}
DEBUG      [L014] Possible cases after segment 'foo': ['lower']
DEBUG      [L014] Consistent capitalization, returning with memory: {'refuted_cases': {'upper', 'pascal', 'capitalise'}, 'latest_possible_case': 'lower'}
DEBUG      [L014] Refuted cases after segment 'c': {'upper', 'pascal', 'capitalise'}
DEBUG      [L014] Possible cases after segment 'c': ['lower']
DEBUG      [L014] Consistent capitalization, returning with memory: {'refuted_cases': {'upper', 'pascal', 'capitalise'}, 'latest_possible_case': 'lower'}
DEBUG      [L014] Refuted cases after segment 'val': {'upper', 'pascal', 'capitalise'}
DEBUG      [L014] Possible cases after segment 'val': ['lower']
DEBUG      [L014] Consistent capitalization, returning with memory: {'refuted_cases': {'upper', 'pascal', 'capitalise'}, 'latest_possible_case': 'lower'}
DEBUG      [L014] Refuted cases after segment 'b': {'upper', 'pascal', 'capitalise'}
DEBUG      [L014] Possible cases after segment 'b': ['lower']
DEBUG      [L014] Consistent capitalization, returning with memory: {'refuted_cases': {'upper', 'pascal', 'capitalise'}, 'latest_possible_case': 'lower'}
DEBUG      [L014] Refuted cases after segment 'val': {'upper', 'pascal', 'capitalise'}
DEBUG      [L014] Possible cases after segment 'val': ['lower']
DEBUG      [L014] Consistent capitalization, returning with memory: {'refuted_cases': {'upper', 'pascal', 'capitalise'}, 'latest_possible_case': 'lower'}
DEBUG      [L014] Refuted cases after segment 'a_calculation': {'upper', 'pascal', 'capitalise'}
DEBUG      [L014] Possible cases after segment 'a_calculation': ['lower']
DEBUG      [L014] Consistent capitalization, returning with memory: {'refuted_cases': {'upper', 'pascal', 'capitalise'}, 'latest_possible_case': 'lower'}
DEBUG      [L014] Refuted cases after segment 'tbl': {'upper', 'pascal', 'capitalise'}
DEBUG      [L014] Possible cases after segment 'tbl': ['lower']
DEBUG      [L014] Consistent capitalization, returning with memory: {'refuted_cases': {'upper', 'pascal', 'capitalise'}, 'latest_possible_case': 'lower'}
DEBUG      [L014] Refuted cases after segment 'b': {'upper', 'pascal', 'capitalise'}
DEBUG      [L014] Possible cases after segment 'b': ['lower']
DEBUG      [L014] Consistent capitalization, returning with memory: {'refuted_cases': {'upper', 'pascal', 'capitalise'}, 'latest_possible_case': 'lower'}
DEBUG      [L014] Refuted cases after segment 'tbl': {'upper', 'pascal', 'capitalise'}
DEBUG      [L014] Possible cases after segment 'tbl': ['lower']
DEBUG      [L014] Consistent capitalization, returning with memory: {'refuted_cases': {'upper', 'pascal', 'capitalise'}, 'latest_possible_case': 'lower'}
DEBUG      [L014] Refuted cases after segment 'common_id': {'upper', 'pascal', 'capitalise'}
DEBUG      [L014] Possible cases after segment 'common_id': ['lower']
DEBUG      [L014] Consistent capitalization, returning with memory: {'refuted_cases': {'upper', 'pascal', 'capitalise'}, 'latest_possible_case': 'lower'}
DEBUG      [L014] Refuted cases after segment 'b': {'upper', 'pascal', 'capitalise'}
DEBUG      [L014] Possible cases after segment 'b': ['lower']
DEBUG      [L014] Consistent capitalization, returning with memory: {'refuted_cases': {'upper', 'pascal', 'capitalise'}, 'latest_possible_case': 'lower'}
DEBUG      [L014] Refuted cases after segment 'common_id': {'upper', 'pascal', 'capitalise'}
DEBUG      [L014] Possible cases after segment 'common_id': ['lower']
DEBUG      [L014] Consistent capitalization, returning with memory: {'refuted_cases': {'upper', 'pascal', 'capitalise'}, 'latest_possible_case': 'lower'}
DEBUG      [L014] Refuted cases after segment 'c': {'upper', 'pascal', 'capitalise'}
DEBUG      [L014] Possible cases after segment 'c': ['lower']
DEBUG      [L014] Consistent capitalization, returning with memory: {'refuted_cases': {'upper', 'pascal', 'capitalise'}, 'latest_possible_case': 'lower'}
DEBUG      [L014] Refuted cases after segment 'tbl': {'upper', 'pascal', 'capitalise'}
DEBUG      [L014] Possible cases after segment 'tbl': ['lower']
DEBUG      [L014] Consistent capitalization, returning with memory: {'refuted_cases': {'upper', 'pascal', 'capitalise'}, 'latest_possible_case': 'lower'}
DEBUG      [L014] Refuted cases after segment 'id': {'upper', 'pascal', 'capitalise'}
DEBUG      [L014] Possible cases after segment 'id': ['lower']
DEBUG      [L014] Consistent capitalization, returning with memory: {'refuted_cases': {'upper', 'pascal', 'capitalise'}, 'latest_possible_case': 'lower'}
DEBUG      [L014] Refuted cases after segment 'c': {'upper', 'pascal', 'capitalise'}
DEBUG      [L014] Possible cases after segment 'c': ['lower']
DEBUG      [L014] Consistent capitalization, returning with memory: {'refuted_cases': {'upper', 'pascal', 'capitalise'}, 'latest_possible_case': 'lower'}
DEBUG      [L014] Refuted cases after segment 'id': {'upper', 'pascal', 'capitalise'}
DEBUG      [L014] Possible cases after segment 'id': ['lower']
DEBUG      [L014] Consistent capitalization, returning with memory: {'refuted_cases': {'upper', 'pascal', 'capitalise'}, 'latest_possible_case': 'lower'}
DEBUG      [L014] Refuted cases after segment 'd': {'upper', 'pascal', 'capitalise'}
DEBUG      [L014] Possible cases after segment 'd': ['lower']
DEBUG      [L014] Consistent capitalization, returning with memory: {'refuted_cases': {'upper', 'pascal', 'capitalise'}, 'latest_possible_case': 'lower'}
DEBUG      [L014] Refuted cases after segment 'tbl': {'upper', 'pascal', 'capitalise'}
DEBUG      [L014] Possible cases after segment 'tbl': ['lower']
DEBUG      [L014] Consistent capitalization, returning with memory: {'refuted_cases': {'upper', 'pascal', 'capitalise'}, 'latest_possible_case': 'lower'}
DEBUG      [L014] Refuted cases after segment 'id': {'upper', 'pascal', 'capitalise'}
DEBUG      [L014] Possible cases after segment 'id': ['lower']
DEBUG      [L014] Consistent capitalization, returning with memory: {'refuted_cases': {'upper', 'pascal', 'capitalise'}, 'latest_possible_case': 'lower'}
DEBUG      [L014] Refuted cases after segment 'd': {'upper', 'pascal', 'capitalise'}
DEBUG      [L014] Possible cases after segment 'd': ['lower']
DEBUG      [L014] Consistent capitalization, returning with memory: {'refuted_cases': {'upper', 'pascal', 'capitalise'}, 'latest_possible_case': 'lower'}
DEBUG      [L014] Refuted cases after segment 'other_id': {'upper', 'pascal', 'capitalise'}
DEBUG      [L014] Possible cases after segment 'other_id': ['lower']
DEBUG      [L014] Consistent capitalization, returning with memory: {'refuted_cases': {'upper', 'pascal', 'capitalise'}, 'latest_possible_case': 'lower'}
DEBUG      [L014] Refuted cases after segment 'tbl': {'upper', 'pascal', 'capitalise'}
DEBUG      [L014] Possible cases after segment 'tbl': ['lower']
DEBUG      [L014] Consistent capitalization, returning with memory: {'refuted_cases': {'upper', 'pascal', 'capitalise'}, 'latest_possible_case': 'lower'}
DEBUG      [L014] Refuted cases after segment 'name': {'upper', 'pascal', 'capitalise'}
DEBUG      [L014] Possible cases after segment 'name': ['lower']
DEBUG      [L014] Consistent capitalization, returning with memory: {'refuted_cases': {'upper', 'pascal', 'capitalise'}, 'latest_possible_case': 'lower'}
DEBUG      [L044] Analyzing query: SELECT
    tbl.name,
    b.value,
    /*
    This is a block comment
    */
    d.something,    -- Which a comment after it
    tbl.foo,
    c.val + b.val / -2 AS a_calculation
FROM tbl
INNER JOIN b ON (tbl.common_id = b.common_id)
JOIN c ON (tbl.id = c.id)
LEFT JOIN d ON (tbl.id = d.other_id)
ORDER BY tbl.name ASC
DEBUG      [L049] Found equals/not equals @[L: 11, P: 32]: '='
DEBUG      [L049] Found equals/not equals @[L: 12, P: 19]: '='
DEBUG      [L049] Found equals/not equals @[L: 13, P: 24]: '='
== [test/fixtures/cli/passing_b.sql] PASS
==== summary ====
files:             1 violations:        0
clean files:       1 unclean files:     0
avg per file:   0.00 unclean rate:     0%
status:         PASS
All Finished!

___________________ test__cli__command_lint_parse[command6] ____________________
----------------------------- Captured stdout call -----------------------------
==== sqlfluff ====
sqlfluff:              0.7.0a8 python:                 3.9.20
implementation:        cpython dialect:                  ansi
verbosity:                   3 templater:               jinja

== Raw Config:
core:                                   
    color:              False               
    dialect:            ansi                
    encoding:           autodetect          
    ignore:             []                  
    ignore_templated_areas:True                
    nocolor:            True                
    output_line_length: 80                  
    recurse:            True                
    runaway_limit:      10                  
    sql_file_exts:      .sql,.sql.j2,.dml,.ddl
    templater:          jinja               
    verbose:            3                   
indentation:                            
    indented_joins:     False               
    indented_using_on:  True                
    template_blocks_indent:True                
rules:                                  
    allow_scalar:       True                
    comma_style:        trailing            
    indent_unit:        space               
    max_line_length:    80                  
    single_table_references:consistent          
    tab_space_size:     4                   
    unquoted_identifiers_policy:all                 
    L007:                                   
        operator_new_lines: after               
    L010:                                   
        capitalisation_policy:consistent          
    L011:                                   
        aliasing:           explicit            
    L012:                                   
        aliasing:           explicit            
    L014:                                   
        extended_capitalisation_policy:consistent          
    L016:                                   
        ignore_comment_lines:False               
    L026:                                   
        force_enable:       False               
    L028:                                   
        force_enable:       False               
    L029:                                   
        unquoted_identifiers_policy:aliases             
    L030:                                   
        capitalisation_policy:consistent          
    L038:                                   
        select_clause_trailing_comma:forbid              
    L040:                                   
        capitalisation_policy:consistent          
    L042:                                   
        forbid_subquery_in: join                
    L047:                                   
        prefer_count_0:     False               
        prefer_count_1:     False               
templater:                              
    unwrap_wrapped_queries:True                
    jinja:                                  
        apply_dbt_builtins: True                
        macros:                                 
            dbt_config:         {% macro config() %}{% for k in kwargs %}{% endfor %}{% endmacro %}
            dbt_is_incremental: {% macro is_incremental() %}True{% endmacro %}
            dbt_ref:            {% macro ref(model_ref) %}{{model_ref}}{% endmacro %}
            dbt_source:         {% macro source(source_name, table) %}{{source_name}}_{{table}}{% endmacro %}
            dbt_var:            {% macro var(variable, default='') %}item{% endmacro %}

==== readout ====

=== [ path: test/fixtures/cli/passing_b.sql ] ===

== [test/fixtures/cli/passing_b.sql] LINTING
== [test/fixtures/cli/passing_b.sql] PASS
==== summary ====
files:             1 violations:        0
clean files:       1 unclean files:     0
avg per file:   0.00 unclean rate:     0%
status:         PASS
All Finished!

___________________ test__cli__command_lint_parse[command7] ____________________
----------------------------- Captured stdout call -----------------------------
[L:  1, P:  1]      |file:
[L:  1, P:  1]      |    statement:
[L:  1, P:  1]      |        select_statement:
[L:  1, P:  1]      |            select_clause:
[L:  1, P:  1]      |                keyword:                                      'SELECT'
[L:  1, P:  7]      |                [META] indent:
[L:  1, P:  7]      |                newline:                                      '\n'
[L:  2, P:  1]      |                whitespace:                                   '    '
[L:  2, P:  5]      |                select_clause_element:
[L:  2, P:  5]      |                    column_reference:
[L:  2, P:  5]      |                        identifier:                           'tbl'
[L:  2, P:  8]      |                        dot:                                  '.'
[L:  2, P:  9]      |                        identifier:                           'name'
[L:  2, P: 13]      |                comma:                                        ','
[L:  2, P: 14]      |                newline:                                      '\n'
[L:  3, P:  1]      |                whitespace:                                   '    '
[L:  3, P:  5]      |                select_clause_element:
[L:  3, P:  5]      |                    column_reference:
[L:  3, P:  5]      |                        identifier:                           'b'
[L:  3, P:  6]      |                        dot:                                  '.'
[L:  3, P:  7]      |                        identifier:                           'value'
[L:  3, P: 12]      |                comma:                                        ','
[L:  3, P: 13]      |                newline:                                      '\n'
[L:  4, P:  1]      |                whitespace:                                   '    '
[L:  4, P:  5]      |                comment:                                      '/*'
[L:  4, P:  7]      |                newline:                                      '\n'
[L:  5, P:  1]      |                whitespace:                                   '    '
[L:  5, P:  5]      |                comment:                                      'This is a block comment'
[L:  5, P: 28]      |                newline:                                      '\n'
[L:  6, P:  1]      |                whitespace:                                   '    '
[L:  6, P:  5]      |                comment:                                      '*/'
[L:  6, P:  7]      |                newline:                                      '\n'
[L:  7, P:  1]      |                whitespace:                                   '    '
[L:  7, P:  5]      |                select_clause_element:
[L:  7, P:  5]      |                    column_reference:
[L:  7, P:  5]      |                        identifier:                           'd'
[L:  7, P:  6]      |                        dot:                                  '.'
[L:  7, P:  7]      |                        identifier:                           'something'
[L:  7, P: 16]      |                comma:                                        ','
[L:  7, P: 17]      |                whitespace:                                   '    '
[L:  7, P: 21]      |                comment:                                      '-- Which a comment after it'
[L:  7, P: 48]      |                newline:                                      '\n'
[L:  8, P:  1]      |                whitespace:                                   '    '
[L:  8, P:  5]      |                select_clause_element:
[L:  8, P:  5]      |                    column_reference:
[L:  8, P:  5]      |                        identifier:                           'tbl'
[L:  8, P:  8]      |                        dot:                                  '.'
[L:  8, P:  9]      |                        identifier:                           'foo'
[L:  8, P: 12]      |                comma:                                        ','
[L:  8, P: 13]      |                newline:                                      '\n'
[L:  9, P:  1]      |                whitespace:                                   '    '
[L:  9, P:  5]      |                select_clause_element:
[L:  9, P:  5]      |                    expression:
[L:  9, P:  5]      |                        column_reference:
[L:  9, P:  5]      |                            identifier:                       'c'
[L:  9, P:  6]      |                            dot:                              '.'
[L:  9, P:  7]      |                            identifier:                       'val'
[L:  9, P: 10]      |                        whitespace:                           ' '
[L:  9, P: 11]      |                        binary_operator:                      '+'
[L:  9, P: 12]      |                        whitespace:                           ' '
[L:  9, P: 13]      |                        column_reference:
[L:  9, P: 13]      |                            identifier:                       'b'
[L:  9, P: 14]      |                            dot:                              '.'
[L:  9, P: 15]      |                            identifier:                       'val'
[L:  9, P: 18]      |                        whitespace:                           ' '
[L:  9, P: 19]      |                        binary_operator:                      '/'
[L:  9, P: 20]      |                        whitespace:                           ' '
[L:  9, P: 21]      |                        numeric_literal:
[L:  9, P: 21]      |                            binary_operator:                  '-'
[L:  9, P: 22]      |                            literal:                          '2'
[L:  9, P: 23]      |                    whitespace:                               ' '
[L:  9, P: 24]      |                    alias_expression:
[L:  9, P: 24]      |                        keyword:                              'AS'
[L:  9, P: 26]      |                        whitespace:                           ' '
[L:  9, P: 27]      |                        identifier:                           'a_calculation'
[L:  9, P: 40]      |            newline:                                          '\n'
[L: 10, P:  1]      |            [META] dedent:
[L: 10, P:  1]      |            from_clause:
[L: 10, P:  1]      |                keyword:                                      'FROM'
[L: 10, P:  5]      |                whitespace:                                   ' '
[L: 10, P:  6]      |                from_expression:
[L: 10, P:  6]      |                    [META] indent:
[L: 10, P:  6]      |                    from_expression_element:
[L: 10, P:  6]      |                        table_expression:
[L: 10, P:  6]      |                            table_reference:
[L: 10, P:  6]      |                                identifier:                   'tbl'
[L: 10, P:  9]      |                    newline:                                  '\n'
[L: 11, P:  1]      |                    [META] dedent:
[L: 11, P:  1]      |                    join_clause:
[L: 11, P:  1]      |                        keyword:                              'INNER'
[L: 11, P:  6]      |                        whitespace:                           ' '
[L: 11, P:  7]      |                        keyword:                              'JOIN'
[L: 11, P: 11]      |                        [META] indent:
[L: 11, P: 11]      |                        whitespace:                           ' '
[L: 11, P: 12]      |                        from_expression_element:
[L: 11, P: 12]      |                            table_expression:
[L: 11, P: 12]      |                                table_reference:
[L: 11, P: 12]      |                                    identifier:               'b'
[L: 11, P: 13]      |                        whitespace:                           ' '
[L: 11, P: 14]      |                        join_on_condition:
[L: 11, P: 14]      |                            keyword:                          'ON'
[L: 11, P: 16]      |                            [META] indent:
[L: 11, P: 16]      |                            whitespace:                       ' '
[L: 11, P: 17]      |                            bracketed:
[L: 11, P: 17]      |                                start_bracket:                '('
[L: 11, P: 18]      |                                [META] indent:
[L: 11, P: 18]      |                                expression:
[L: 11, P: 18]      |                                    column_reference:
[L: 11, P: 18]      |                                        identifier:           'tbl'
[L: 11, P: 21]      |                                        dot:                  '.'
[L: 11, P: 22]      |                                        identifier:           'common_id'
[L: 11, P: 31]      |                                    whitespace:               ' '
[L: 11, P: 32]      |                                    comparison_operator:      '='
[L: 11, P: 33]      |                                    whitespace:               ' '
[L: 11, P: 34]      |                                    column_reference:
[L: 11, P: 34]      |                                        identifier:           'b'
[L: 11, P: 35]      |                                        dot:                  '.'
[L: 11, P: 36]      |                                        identifier:           'common_id'
[L: 11, P: 45]      |                                [META] dedent:
[L: 11, P: 45]      |                                end_bracket:                  ')'
[L: 11, P: 46]      |                            [META] dedent:
[L: 11, P: 46]      |                        [META] dedent:
[L: 11, P: 46]      |                    newline:                                  '\n'
[L: 12, P:  1]      |                    join_clause:
[L: 12, P:  1]      |                        keyword:                              'JOIN'
[L: 12, P:  5]      |                        [META] indent:
[L: 12, P:  5]      |                        whitespace:                           ' '
[L: 12, P:  6]      |                        from_expression_element:
[L: 12, P:  6]      |                            table_expression:
[L: 12, P:  6]      |                                table_reference:
[L: 12, P:  6]      |                                    identifier:               'c'
[L: 12, P:  7]      |                        whitespace:                           ' '
[L: 12, P:  8]      |                        join_on_condition:
[L: 12, P:  8]      |                            keyword:                          'ON'
[L: 12, P: 10]      |                            [META] indent:
[L: 12, P: 10]      |                            whitespace:                       ' '
[L: 12, P: 11]      |                            bracketed:
[L: 12, P: 11]      |                                start_bracket:                '('
[L: 12, P: 12]      |                                [META] indent:
[L: 12, P: 12]      |                                expression:
[L: 12, P: 12]      |                                    column_reference:
[L: 12, P: 12]      |                                        identifier:           'tbl'
[L: 12, P: 15]      |                                        dot:                  '.'
[L: 12, P: 16]      |                                        identifier:           'id'
[L: 12, P: 18]      |                                    whitespace:               ' '
[L: 12, P: 19]      |                                    comparison_operator:      '='
[L: 12, P: 20]      |                                    whitespace:               ' '
[L: 12, P: 21]      |                                    column_reference:
[L: 12, P: 21]      |                                        identifier:           'c'
[L: 12, P: 22]      |                                        dot:                  '.'
[L: 12, P: 23]      |                                        identifier:           'id'
[L: 12, P: 25]      |                                [META] dedent:
[L: 12, P: 25]      |                                end_bracket:                  ')'
[L: 12, P: 26]      |                            [META] dedent:
[L: 12, P: 26]      |                        [META] dedent:
[L: 12, P: 26]      |                    newline:                                  '\n'
[L: 13, P:  1]      |                    join_clause:
[L: 13, P:  1]      |                        keyword:                              'LEFT'
[L: 13, P:  5]      |                        whitespace:                           ' '
[L: 13, P:  6]      |                        keyword:                              'JOIN'
[L: 13, P: 10]      |                        [META] indent:
[L: 13, P: 10]      |                        whitespace:                           ' '
[L: 13, P: 11]      |                        from_expression_element:
[L: 13, P: 11]      |                            table_expression:
[L: 13, P: 11]      |                                table_reference:
[L: 13, P: 11]      |                                    identifier:               'd'
[L: 13, P: 12]      |                        whitespace:                           ' '
[L: 13, P: 13]      |                        join_on_condition:
[L: 13, P: 13]      |                            keyword:                          'ON'
[L: 13, P: 15]      |                            [META] indent:
[L: 13, P: 15]      |                            whitespace:                       ' '
[L: 13, P: 16]      |                            bracketed:
[L: 13, P: 16]      |                                start_bracket:                '('
[L: 13, P: 17]      |                                [META] indent:
[L: 13, P: 17]      |                                expression:
[L: 13, P: 17]      |                                    column_reference:
[L: 13, P: 17]      |                                        identifier:           'tbl'
[L: 13, P: 20]      |                                        dot:                  '.'
[L: 13, P: 21]      |                                        identifier:           'id'
[L: 13, P: 23]      |                                    whitespace:               ' '
[L: 13, P: 24]      |                                    comparison_operator:      '='
[L: 13, P: 25]      |                                    whitespace:               ' '
[L: 13, P: 26]      |                                    column_reference:
[L: 13, P: 26]      |                                        identifier:           'd'
[L: 13, P: 27]      |                                        dot:                  '.'
[L: 13, P: 28]      |                                        identifier:           'other_id'
[L: 13, P: 36]      |                                [META] dedent:
[L: 13, P: 36]      |                                end_bracket:                  ')'
[L: 13, P: 37]      |                            [META] dedent:
[L: 13, P: 37]      |                        [META] dedent:
[L: 13, P: 37]      |            newline:                                          '\n'
[L: 14, P:  1]      |            orderby_clause:
[L: 14, P:  1]      |                keyword:                                      'ORDER'
[L: 14, P:  6]      |                whitespace:                                   ' '
[L: 14, P:  7]      |                keyword:                                      'BY'
[L: 14, P:  9]      |                [META] indent:
[L: 14, P:  9]      |                whitespace:                                   ' '
[L: 14, P: 10]      |                column_reference:
[L: 14, P: 10]      |                    identifier:                               'tbl'
[L: 14, P: 13]      |                    dot:                                      '.'
[L: 14, P: 14]      |                    identifier:                               'name'
[L: 14, P: 18]      |                whitespace:                                   ' '
[L: 14, P: 19]      |                keyword:                                      'ASC'
[L: 14, P: 22]      |                [META] dedent:
[L: 14, P: 22]      |    newline:                                                  '\n'


___________________ test__cli__command_lint_parse[command8] ____________________
----------------------------- Captured stdout call -----------------------------
==== sqlfluff ====
sqlfluff:              0.7.0a8 python:                 3.9.20
implementation:        cpython dialect:                  ansi
verbosity:                  11 templater:               jinja

== Raw Config:
core:                                   
    color:              False               
    dialect:            ansi                
    encoding:           autodetect          
    ignore:             []                  
    ignore_templated_areas:True                
    nocolor:            True                
    output_line_length: 80                  
    recurse:            True                
    runaway_limit:      10                  
    sql_file_exts:      .sql,.sql.j2,.dml,.ddl
    templater:          jinja               
    verbose:            11                  
indentation:                            
    indented_joins:     False               
    indented_using_on:  True                
    template_blocks_indent:True                
rules:                                  
    allow_scalar:       True                
    comma_style:        trailing            
    indent_unit:        space               
    max_line_length:    80                  
    single_table_references:consistent          
    tab_space_size:     4                   
    unquoted_identifiers_policy:all                 
    L007:                                   
        operator_new_lines: after               
    L010:                                   
        capitalisation_policy:consistent          
    L011:                                   
        aliasing:           explicit            
    L012:                                   
        aliasing:           explicit            
    L014:                                   
        extended_capitalisation_policy:consistent          
    L016:                                   
        ignore_comment_lines:False               
    L026:                                   
        force_enable:       False               
    L028:                                   
        force_enable:       False               
    L029:                                   
        unquoted_identifiers_policy:aliases             
    L030:                                   
        capitalisation_policy:consistent          
    L038:                                   
        select_clause_trailing_comma:forbid              
    L040:                                   
        capitalisation_policy:consistent          
    L042:                                   
        forbid_subquery_in: join                
    L047:                                   
        prefer_count_0:     False               
        prefer_count_1:     False               
templater:                              
    unwrap_wrapped_queries:True                
    jinja:                                  
        apply_dbt_builtins: True                
        macros:                                 
            dbt_config:         {% macro config() %}{% for k in kwargs %}{% endfor %}{% endmacro %}
            dbt_is_incremental: {% macro is_incremental() %}True{% endmacro %}
            dbt_ref:            {% macro ref(model_ref) %}{{model_ref}}{% endmacro %}
            dbt_source:         {% macro source(source_name, table) %}{{source_name}}_{{table}}{% endmacro %}
            dbt_var:            {% macro var(variable, default='') %}item{% endmacro %}

=== [ path: test/fixtures/cli/passing_b.sql ] ===

== [test/fixtures/cli/passing_b.sql] TEMPLATING
INFO       TEMPLATING RAW [jinja] (test/fixtures/cli/passing_b.sql)
INFO       Slicing File Template
DEBUG          Raw String: 'SELECT\n    tbl.name,\n    b.value,\n    /*\n    This is a block comment\n    */\n    d.something,    -- Which a comment after it\n    tbl.foo,\n    c.val + b.val / -2 AS a_calculation\nFROM tbl\nINNER JOIN b ON (tbl.common_id = b.common_id)\nJOIN c ON (tbl.id = c.id)\nLEFT JOIN d ON (tbl.id = d.other_id)\nORDER BY tbl.name ASC\n'
DEBUG          Templated String: 'SELECT\n    tbl.name,\n    b.value,\n    /*\n    This is a block comment\n    */\n    d.something,    -- Which a comment after it\n    tbl.foo,\n    c.val + b.val / -2 AS a_calculation\nFROM tbl\nINNER JOIN b ON (tbl.common_id = b.common_id)\nJOIN c ON (tbl.id = c.id)\nLEFT JOIN d ON (tbl.id = d.other_id)\nORDER BY tbl.name ASC\n'
DEBUG          Raw Sliced:
DEBUG              0: RawFileSlice(raw='SELECT\n    tbl.name,\n    b.value,\n    /*\n    This is a block comment\n    */\n    d.something,    -- Which a comment after it\n    tbl.foo,\n    c.val + b.val / -2 AS a_calculation\nFROM tbl\nINNER JOIN b ON (tbl.common_id = b.common_id)\nJOIN c ON (tbl.id = c.id)\nLEFT JOIN d ON (tbl.id = d.other_id)\nORDER BY tbl.name ASC\n', slice_type='literal', source_idx=0, slice_subtype=None)
DEBUG          Literals: ['SELECT\n    tbl.name,\n    b.value,\n    /*\n    This is a block comment\n    */\n    d.something,    -- Which a comment after it\n    tbl.foo,\n    c.val + b.val / -2 AS a_calculation\nFROM tbl\nINNER JOIN b ON (tbl.common_id = b.common_id)\nJOIN c ON (tbl.id = c.id)\nLEFT JOIN d ON (tbl.id = d.other_id)\nORDER BY tbl.name ASC\n']
DEBUG          # Slice Loop 0
DEBUG          Occurrences: Raw: {'SELECT\n    tbl.name,\n    b.value,\n    /*\n    This is a block comment\n    */\n    d.something,    -- Which a comment after it\n    tbl.foo,\n    c.val + b.val / -2 AS a_calculation\nFROM tbl\nINNER JOIN b ON (tbl.common_id = b.common_id)\nJOIN c ON (tbl.id = c.id)\nLEFT JOIN d ON (tbl.id = d.other_id)\nORDER BY tbl.name ASC\n': [0]}, Templated: {'SELECT\n    tbl.name,\n    b.value,\n    /*\n    This is a block comment\n    */\n    d.something,    -- Which a comment after it\n    tbl.foo,\n    c.val + b.val / -2 AS a_calculation\nFROM tbl\nINNER JOIN b ON (tbl.common_id = b.common_id)\nJOIN c ON (tbl.id = c.id)\nLEFT JOIN d ON (tbl.id = d.other_id)\nORDER BY tbl.name ASC\n': [0]}
DEBUG          Split Sliced:
DEBUG              0: IntermediateFileSlice(intermediate_type='invariant', source_slice=slice(0, 317, None), templated_slice=slice(0, 317, None), slice_buffer=[RawFileSlice(raw='SELECT\n    tbl.name,\n    b.value,\n    /*\n    This is a block comment\n    */\n    d.something,    -- Which a comment after it\n    tbl.foo,\n    c.val + b.val / -2 AS a_calculation\nFROM tbl\nINNER JOIN b ON (tbl.common_id = b.common_id)\nJOIN c ON (tbl.id = c.id)\nLEFT JOIN d ON (tbl.id = d.other_id)\nORDER BY tbl.name ASC\n', slice_type='literal', source_idx=0, slice_subtype=None)])
DEBUG          _split_uniques_coalesce_rest: [IntermediateFileSlice(intermediate_type='invariant', source_slice=slice(0, 317, None), templated_slice=slice(0, 317, None), slice_buffer=[RawFileSlice(raw='SELECT\n    tbl.name,\n    b.value,\n    /*\n    This is a block comment\n    */\n    d.something,    -- Which a comment after it\n    tbl.foo,\n    c.val + b.val / -2 AS a_calculation\nFROM tbl\nINNER JOIN b ON (tbl.common_id = b.common_id)\nJOIN c ON (tbl.id = c.id)\nLEFT JOIN d ON (tbl.id = d.other_id)\nORDER BY tbl.name ASC\n', slice_type='literal', source_idx=0, slice_subtype=None)])]
DEBUG              Yielding Simple: TemplatedFileSlice(slice_type='literal', source_slice=slice(0, 317, None), templated_slice=slice(0, 317, None))
DEBUG          Fully Sliced:
DEBUG              0: TemplatedFileSlice(slice_type='literal', source_slice=slice(0, 317, None), templated_slice=slice(0, 317, None))
== [test/fixtures/cli/passing_b.sql] PARSING
INFO       LEXING RAW (test/fixtures/cli/passing_b.sql)
INFO       Elements to Segments.
INFO       Source-only slices: []
DEBUG        0, TemplateElement(raw='SELECT', template_slice=slice(0, 6, None), matcher=<RegexLexer: code>), slice(0, 6, None), 'SELECT'
DEBUG        1, TemplateElement(raw='\n', template_slice=slice(6, 7, None), matcher=<RegexLexer: newline>), slice(6, 7, None), '\n'
DEBUG        2, TemplateElement(raw='    ', template_slice=slice(7, 11, None), matcher=<RegexLexer: whitespace>), slice(7, 11, None), '    '
DEBUG        3, TemplateElement(raw='tbl', template_slice=slice(11, 14, None), matcher=<RegexLexer: code>), slice(11, 14, None), 'tbl'
DEBUG        4, TemplateElement(raw='.', template_slice=slice(14, 15, None), matcher=<StringLexer: dot>), slice(14, 15, None), '.'
DEBUG        5, TemplateElement(raw='name', template_slice=slice(15, 19, None), matcher=<RegexLexer: code>), slice(15, 19, None), 'name'
DEBUG        6, TemplateElement(raw=',', template_slice=slice(19, 20, None), matcher=<StringLexer: comma>), slice(19, 20, None), ','
DEBUG        7, TemplateElement(raw='\n', template_slice=slice(20, 21, None), matcher=<RegexLexer: newline>), slice(20, 21, None), '\n'
DEBUG        8, TemplateElement(raw='    ', template_slice=slice(21, 25, None), matcher=<RegexLexer: whitespace>), slice(21, 25, None), '    '
DEBUG        9, TemplateElement(raw='b', template_slice=slice(25, 26, None), matcher=<RegexLexer: code>), slice(25, 26, None), 'b'
DEBUG        10, TemplateElement(raw='.', template_slice=slice(26, 27, None), matcher=<StringLexer: dot>), slice(26, 27, None), '.'
DEBUG        11, TemplateElement(raw='value', template_slice=slice(27, 32, None), matcher=<RegexLexer: code>), slice(27, 32, None), 'value'
DEBUG        12, TemplateElement(raw=',', template_slice=slice(32, 33, None), matcher=<StringLexer: comma>), slice(32, 33, None), ','
DEBUG        13, TemplateElement(raw='\n', template_slice=slice(33, 34, None), matcher=<RegexLexer: newline>), slice(33, 34, None), '\n'
DEBUG        14, TemplateElement(raw='    ', template_slice=slice(34, 38, None), matcher=<RegexLexer: whitespace>), slice(34, 38, None), '    '
DEBUG        15, TemplateElement(raw='/*', template_slice=slice(38, 40, None), matcher=<RegexLexer: block_comment>), slice(38, 40, None), '/*'
DEBUG        16, TemplateElement(raw='\n', template_slice=slice(40, 41, None), matcher=<RegexLexer: newline>), slice(40, 41, None), '\n'
DEBUG        17, TemplateElement(raw='    ', template_slice=slice(41, 45, None), matcher=<RegexLexer: whitespace>), slice(41, 45, None), '    '
DEBUG        18, TemplateElement(raw='This is a block comment', template_slice=slice(45, 68, None), matcher=<RegexLexer: block_comment>), slice(45, 68, None), 'This is a block comment'
DEBUG        19, TemplateElement(raw='\n', template_slice=slice(68, 69, None), matcher=<RegexLexer: newline>), slice(68, 69, None), '\n'
DEBUG        20, TemplateElement(raw='    ', template_slice=slice(69, 73, None), matcher=<RegexLexer: whitespace>), slice(69, 73, None), '    '
DEBUG        21, TemplateElement(raw='*/', template_slice=slice(73, 75, None), matcher=<RegexLexer: block_comment>), slice(73, 75, None), '*/'
DEBUG        22, TemplateElement(raw='\n', template_slice=slice(75, 76, None), matcher=<RegexLexer: newline>), slice(75, 76, None), '\n'
DEBUG        23, TemplateElement(raw='    ', template_slice=slice(76, 80, None), matcher=<RegexLexer: whitespace>), slice(76, 80, None), '    '
DEBUG        24, TemplateElement(raw='d', template_slice=slice(80, 81, None), matcher=<RegexLexer: code>), slice(80, 81, None), 'd'
DEBUG        25, TemplateElement(raw='.', template_slice=slice(81, 82, None), matcher=<StringLexer: dot>), slice(81, 82, None), '.'
DEBUG        26, TemplateElement(raw='something', template_slice=slice(82, 91, None), matcher=<RegexLexer: code>), slice(82, 91, None), 'something'
DEBUG        27, TemplateElement(raw=',', template_slice=slice(91, 92, None), matcher=<StringLexer: comma>), slice(91, 92, None), ','
DEBUG        28, TemplateElement(raw='    ', template_slice=slice(92, 96, None), matcher=<RegexLexer: whitespace>), slice(92, 96, None), '    '
DEBUG        29, TemplateElement(raw='-- Which a comment after it', template_slice=slice(96, 123, None), matcher=<RegexLexer: inline_comment>), slice(96, 123, None), '-- Which a comment after it'
DEBUG        30, TemplateElement(raw='\n', template_slice=slice(123, 124, None), matcher=<RegexLexer: newline>), slice(123, 124, None), '\n'
DEBUG        31, TemplateElement(raw='    ', template_slice=slice(124, 128, None), matcher=<RegexLexer: whitespace>), slice(124, 128, None), '    '
DEBUG        32, TemplateElement(raw='tbl', template_slice=slice(128, 131, None), matcher=<RegexLexer: code>), slice(128, 131, None), 'tbl'
DEBUG        33, TemplateElement(raw='.', template_slice=slice(131, 132, None), matcher=<StringLexer: dot>), slice(131, 132, None), '.'
DEBUG        34, TemplateElement(raw='foo', template_slice=slice(132, 135, None), matcher=<RegexLexer: code>), slice(132, 135, None), 'foo'
DEBUG        35, TemplateElement(raw=',', template_slice=slice(135, 136, None), matcher=<StringLexer: comma>), slice(135, 136, None), ','
DEBUG        36, TemplateElement(raw='\n', template_slice=slice(136, 137, None), matcher=<RegexLexer: newline>), slice(136, 137, None), '\n'
DEBUG        37, TemplateElement(raw='    ', template_slice=slice(137, 141, None), matcher=<RegexLexer: whitespace>), slice(137, 141, None), '    '
DEBUG        38, TemplateElement(raw='c', template_slice=slice(141, 142, None), matcher=<RegexLexer: code>), slice(141, 142, None), 'c'
DEBUG        39, TemplateElement(raw='.', template_slice=slice(142, 143, None), matcher=<StringLexer: dot>), slice(142, 143, None), '.'
DEBUG        40, TemplateElement(raw='val', template_slice=slice(143, 146, None), matcher=<RegexLexer: code>), slice(143, 146, None), 'val'
DEBUG        41, TemplateElement(raw=' ', template_slice=slice(146, 147, None), matcher=<RegexLexer: whitespace>), slice(146, 147, None), ' '
DEBUG        42, TemplateElement(raw='+', template_slice=slice(147, 148, None), matcher=<StringLexer: plus>), slice(147, 148, None), '+'
DEBUG        43, TemplateElement(raw=' ', template_slice=slice(148, 149, None), matcher=<RegexLexer: whitespace>), slice(148, 149, None), ' '
DEBUG        44, TemplateElement(raw='b', template_slice=slice(149, 150, None), matcher=<RegexLexer: code>), slice(149, 150, None), 'b'
DEBUG        45, TemplateElement(raw='.', template_slice=slice(150, 151, None), matcher=<StringLexer: dot>), slice(150, 151, None), '.'
DEBUG        46, TemplateElement(raw='val', template_slice=slice(151, 154, None), matcher=<RegexLexer: code>), slice(151, 154, None), 'val'
DEBUG        47, TemplateElement(raw=' ', template_slice=slice(154, 155, None), matcher=<RegexLexer: whitespace>), slice(154, 155, None), ' '
DEBUG        48, TemplateElement(raw='/', template_slice=slice(155, 156, None), matcher=<StringLexer: divide>), slice(155, 156, None), '/'
DEBUG        49, TemplateElement(raw=' ', template_slice=slice(156, 157, None), matcher=<RegexLexer: whitespace>), slice(156, 157, None), ' '
DEBUG        50, TemplateElement(raw='-', template_slice=slice(157, 158, None), matcher=<StringLexer: minus>), slice(157, 158, None), '-'
DEBUG        51, TemplateElement(raw='2', template_slice=slice(158, 159, None), matcher=<RegexLexer: numeric_literal>), slice(158, 159, None), '2'
DEBUG        52, TemplateElement(raw=' ', template_slice=slice(159, 160, None), matcher=<RegexLexer: whitespace>), slice(159, 160, None), ' '
DEBUG        53, TemplateElement(raw='AS', template_slice=slice(160, 162, None), matcher=<RegexLexer: code>), slice(160, 162, None), 'AS'
DEBUG        54, TemplateElement(raw=' ', template_slice=slice(162, 163, None), matcher=<RegexLexer: whitespace>), slice(162, 163, None), ' '
DEBUG        55, TemplateElement(raw='a_calculation', template_slice=slice(163, 176, None), matcher=<RegexLexer: code>), slice(163, 176, None), 'a_calculation'
DEBUG        56, TemplateElement(raw='\n', template_slice=slice(176, 177, None), matcher=<RegexLexer: newline>), slice(176, 177, None), '\n'
DEBUG        57, TemplateElement(raw='FROM', template_slice=slice(177, 181, None), matcher=<RegexLexer: code>), slice(177, 181, None), 'FROM'
DEBUG        58, TemplateElement(raw=' ', template_slice=slice(181, 182, None), matcher=<RegexLexer: whitespace>), slice(181, 182, None), ' '
DEBUG        59, TemplateElement(raw='tbl', template_slice=slice(182, 185, None), matcher=<RegexLexer: code>), slice(182, 185, None), 'tbl'
DEBUG        60, TemplateElement(raw='\n', template_slice=slice(185, 186, None), matcher=<RegexLexer: newline>), slice(185, 186, None), '\n'
DEBUG        61, TemplateElement(raw='INNER', template_slice=slice(186, 191, None), matcher=<RegexLexer: code>), slice(186, 191, None), 'INNER'
DEBUG        62, TemplateElement(raw=' ', template_slice=slice(191, 192, None), matcher=<RegexLexer: whitespace>), slice(191, 192, None), ' '
DEBUG        63, TemplateElement(raw='JOIN', template_slice=slice(192, 196, None), matcher=<RegexLexer: code>), slice(192, 196, None), 'JOIN'
DEBUG        64, TemplateElement(raw=' ', template_slice=slice(196, 197, None), matcher=<RegexLexer: whitespace>), slice(196, 197, None), ' '
DEBUG        65, TemplateElement(raw='b', template_slice=slice(197, 198, None), matcher=<RegexLexer: code>), slice(197, 198, None), 'b'
DEBUG        66, TemplateElement(raw=' ', template_slice=slice(198, 199, None), matcher=<RegexLexer: whitespace>), slice(198, 199, None), ' '
DEBUG        67, TemplateElement(raw='ON', template_slice=slice(199, 201, None), matcher=<RegexLexer: code>), slice(199, 201, None), 'ON'
DEBUG        68, TemplateElement(raw=' ', template_slice=slice(201, 202, None), matcher=<RegexLexer: whitespace>), slice(201, 202, None), ' '
DEBUG        69, TemplateElement(raw='(', template_slice=slice(202, 203, None), matcher=<StringLexer: bracket_open>), slice(202, 203, None), '('
DEBUG        70, TemplateElement(raw='tbl', template_slice=slice(203, 206, None), matcher=<RegexLexer: code>), slice(203, 206, None), 'tbl'
DEBUG        71, TemplateElement(raw='.', template_slice=slice(206, 207, None), matcher=<StringLexer: dot>), slice(206, 207, None), '.'
DEBUG        72, TemplateElement(raw='common_id', template_slice=slice(207, 216, None), matcher=<RegexLexer: code>), slice(207, 216, None), 'common_id'
DEBUG        73, TemplateElement(raw=' ', template_slice=slice(216, 217, None), matcher=<RegexLexer: whitespace>), slice(216, 217, None), ' '
DEBUG        74, TemplateElement(raw='=', template_slice=slice(217, 218, None), matcher=<StringLexer: equals>), slice(217, 218, None), '='
DEBUG        75, TemplateElement(raw=' ', template_slice=slice(218, 219, None), matcher=<RegexLexer: whitespace>), slice(218, 219, None), ' '
DEBUG        76, TemplateElement(raw='b', template_slice=slice(219, 220, None), matcher=<RegexLexer: code>), slice(219, 220, None), 'b'
DEBUG        77, TemplateElement(raw='.', template_slice=slice(220, 221, None), matcher=<StringLexer: dot>), slice(220, 221, None), '.'
DEBUG        78, TemplateElement(raw='common_id', template_slice=slice(221, 230, None), matcher=<RegexLexer: code>), slice(221, 230, None), 'common_id'
DEBUG        79, TemplateElement(raw=')', template_slice=slice(230, 231, None), matcher=<StringLexer: bracket_close>), slice(230, 231, None), ')'
DEBUG        80, TemplateElement(raw='\n', template_slice=slice(231, 232, None), matcher=<RegexLexer: newline>), slice(231, 232, None), '\n'
DEBUG        81, TemplateElement(raw='JOIN', template_slice=slice(232, 236, None), matcher=<RegexLexer: code>), slice(232, 236, None), 'JOIN'
DEBUG        82, TemplateElement(raw=' ', template_slice=slice(236, 237, None), matcher=<RegexLexer: whitespace>), slice(236, 237, None), ' '
DEBUG        83, TemplateElement(raw='c', template_slice=slice(237, 238, None), matcher=<RegexLexer: code>), slice(237, 238, None), 'c'
DEBUG        84, TemplateElement(raw=' ', template_slice=slice(238, 239, None), matcher=<RegexLexer: whitespace>), slice(238, 239, None), ' '
DEBUG        85, TemplateElement(raw='ON', template_slice=slice(239, 241, None), matcher=<RegexLexer: code>), slice(239, 241, None), 'ON'
DEBUG        86, TemplateElement(raw=' ', template_slice=slice(241, 242, None), matcher=<RegexLexer: whitespace>), slice(241, 242, None), ' '
DEBUG        87, TemplateElement(raw='(', template_slice=slice(242, 243, None), matcher=<StringLexer: bracket_open>), slice(242, 243, None), '('
DEBUG        88, TemplateElement(raw='tbl', template_slice=slice(243, 246, None), matcher=<RegexLexer: code>), slice(243, 246, None), 'tbl'
DEBUG        89, TemplateElement(raw='.', template_slice=slice(246, 247, None), matcher=<StringLexer: dot>), slice(246, 247, None), '.'
DEBUG        90, TemplateElement(raw='id', template_slice=slice(247, 249, None), matcher=<RegexLexer: code>), slice(247, 249, None), 'id'
DEBUG        91, TemplateElement(raw=' ', template_slice=slice(249, 250, None), matcher=<RegexLexer: whitespace>), slice(249, 250, None), ' '
DEBUG        92, TemplateElement(raw='=', template_slice=slice(250, 251, None), matcher=<StringLexer: equals>), slice(250, 251, None), '='
DEBUG        93, TemplateElement(raw=' ', template_slice=slice(251, 252, None), matcher=<RegexLexer: whitespace>), slice(251, 252, None), ' '
DEBUG        94, TemplateElement(raw='c', template_slice=slice(252, 253, None), matcher=<RegexLexer: code>), slice(252, 253, None), 'c'
DEBUG        95, TemplateElement(raw='.', template_slice=slice(253, 254, None), matcher=<StringLexer: dot>), slice(253, 254, None), '.'
DEBUG        96, TemplateElement(raw='id', template_slice=slice(254, 256, None), matcher=<RegexLexer: code>), slice(254, 256, None), 'id'
DEBUG        97, TemplateElement(raw=')', template_slice=slice(256, 257, None), matcher=<StringLexer: bracket_close>), slice(256, 257, None), ')'
DEBUG        98, TemplateElement(raw='\n', template_slice=slice(257, 258, None), matcher=<RegexLexer: newline>), slice(257, 258, None), '\n'
DEBUG        99, TemplateElement(raw='LEFT', template_slice=slice(258, 262, None), matcher=<RegexLexer: code>), slice(258, 262, None), 'LEFT'
DEBUG        100, TemplateElement(raw=' ', template_slice=slice(262, 263, None), matcher=<RegexLexer: whitespace>), slice(262, 263, None), ' '
DEBUG        101, TemplateElement(raw='JOIN', template_slice=slice(263, 267, None), matcher=<RegexLexer: code>), slice(263, 267, None), 'JOIN'
DEBUG        102, TemplateElement(raw=' ', template_slice=slice(267, 268, None), matcher=<RegexLexer: whitespace>), slice(267, 268, None), ' '
DEBUG        103, TemplateElement(raw='d', template_slice=slice(268, 269, None), matcher=<RegexLexer: code>), slice(268, 269, None), 'd'
DEBUG        104, TemplateElement(raw=' ', template_slice=slice(269, 270, None), matcher=<RegexLexer: whitespace>), slice(269, 270, None), ' '
DEBUG        105, TemplateElement(raw='ON', template_slice=slice(270, 272, None), matcher=<RegexLexer: code>), slice(270, 272, None), 'ON'
DEBUG        106, TemplateElement(raw=' ', template_slice=slice(272, 273, None), matcher=<RegexLexer: whitespace>), slice(272, 273, None), ' '
DEBUG        107, TemplateElement(raw='(', template_slice=slice(273, 274, None), matcher=<StringLexer: bracket_open>), slice(273, 274, None), '('
DEBUG        108, TemplateElement(raw='tbl', template_slice=slice(274, 277, None), matcher=<RegexLexer: code>), slice(274, 277, None), 'tbl'
DEBUG        109, TemplateElement(raw='.', template_slice=slice(277, 278, None), matcher=<StringLexer: dot>), slice(277, 278, None), '.'
DEBUG        110, TemplateElement(raw='id', template_slice=slice(278, 280, None), matcher=<RegexLexer: code>), slice(278, 280, None), 'id'
DEBUG        111, TemplateElement(raw=' ', template_slice=slice(280, 281, None), matcher=<RegexLexer: whitespace>), slice(280, 281, None), ' '
DEBUG        112, TemplateElement(raw='=', template_slice=slice(281, 282, None), matcher=<StringLexer: equals>), slice(281, 282, None), '='
DEBUG        113, TemplateElement(raw=' ', template_slice=slice(282, 283, None), matcher=<RegexLexer: whitespace>), slice(282, 283, None), ' '
DEBUG        114, TemplateElement(raw='d', template_slice=slice(283, 284, None), matcher=<RegexLexer: code>), slice(283, 284, None), 'd'
DEBUG        115, TemplateElement(raw='.', template_slice=slice(284, 285, None), matcher=<StringLexer: dot>), slice(284, 285, None), '.'
DEBUG        116, TemplateElement(raw='other_id', template_slice=slice(285, 293, None), matcher=<RegexLexer: code>), slice(285, 293, None), 'other_id'
DEBUG        117, TemplateElement(raw=')', template_slice=slice(293, 294, None), matcher=<StringLexer: bracket_close>), slice(293, 294, None), ')'
DEBUG        118, TemplateElement(raw='\n', template_slice=slice(294, 295, None), matcher=<RegexLexer: newline>), slice(294, 295, None), '\n'
DEBUG        119, TemplateElement(raw='ORDER', template_slice=slice(295, 300, None), matcher=<RegexLexer: code>), slice(295, 300, None), 'ORDER'
DEBUG        120, TemplateElement(raw=' ', template_slice=slice(300, 301, None), matcher=<RegexLexer: whitespace>), slice(300, 301, None), ' '
DEBUG        121, TemplateElement(raw='BY', template_slice=slice(301, 303, None), matcher=<RegexLexer: code>), slice(301, 303, None), 'BY'
DEBUG        122, TemplateElement(raw=' ', template_slice=slice(303, 304, None), matcher=<RegexLexer: whitespace>), slice(303, 304, None), ' '
DEBUG        123, TemplateElement(raw='tbl', template_slice=slice(304, 307, None), matcher=<RegexLexer: code>), slice(304, 307, None), 'tbl'
DEBUG        124, TemplateElement(raw='.', template_slice=slice(307, 308, None), matcher=<StringLexer: dot>), slice(307, 308, None), '.'
DEBUG        125, TemplateElement(raw='name', template_slice=slice(308, 312, None), matcher=<RegexLexer: code>), slice(308, 312, None), 'name'
DEBUG        126, TemplateElement(raw=' ', template_slice=slice(312, 313, None), matcher=<RegexLexer: whitespace>), slice(312, 313, None), ' '
DEBUG        127, TemplateElement(raw='ASC', template_slice=slice(313, 316, None), matcher=<RegexLexer: code>), slice(313, 316, None), 'ASC'
DEBUG        128, TemplateElement(raw='\n', template_slice=slice(316, 317, None), matcher=<RegexLexer: newline>), slice(316, 317, None), '\n'
INFO       Lexed tokens: ['SELECT', '\n', '    ', 'tbl', '.', 'name', ',', '\n', '    ', 'b', '.', 'value', ',', '\n', '    ', '/*', '\n', '    ', 'This is a block comment', '\n', '    ', '*/', '\n', '    ', 'd', '.', 'something', ',', '    ', '-- Which a comment after it', '\n', '    ', 'tbl', '.', 'foo', ',', '\n', '    ', 'c', '.', 'val', ' ', '+', ' ', 'b', '.', 'val', ' ', '/', ' ', '-', '2', ' ', 'AS', ' ', 'a_calculation', '\n', 'FROM', ' ', 'tbl', '\n', 'INNER', ' ', 'JOIN', ' ', 'b', ' ', 'ON', ' ', '(', 'tbl', '.', 'common_id', ' ', '=', ' ', 'b', '.', 'common_id', ')', '\n', 'JOIN', ' ', 'c', ' ', 'ON', ' ', '(', 'tbl', '.', 'id', ' ', '=', ' ', 'c', '.', 'id', ')', '\n', 'LEFT', ' ', 'JOIN', ' ', 'd', ' ', 'ON', ' ', '(', 'tbl', '.', 'id', ' ', '=', ' ', 'd', '.', 'other_id', ')', '\n', 'ORDER', ' ', 'BY', ' ', 'tbl', '.', 'name', ' ', 'ASC', '\n']
INFO       PARSING (test/fixtures/cli/passing_b.sql)
DEBUG      [PD:0  MD:1 ]	.FileSegment                                      	Delim._look_ahead_match IN	    	[ls=128, seg='SELECT\n    tbl.name,...']
DEBUG      [PD:0  MD:1 ]	.FileSegment                                      	Delim._look_ahead_match SI	    	[mq=[(<sqlfluff.core.parser.parsers.StringParser object at 0x7c08b844f0d0>, 69, '('), (<sqlfluff.core.parser.parsers.StringParser object at 0x7c08b844f070>, 79, ')'), (<sqlfluff.core.parser.parsers.StringParser object at 0x7c08b844f0d0>, 87, '('), (<sqlfluff.core.parser.parsers.StringParser object at 0x7c08b844f070>, 97, ')'), (<sqlfluff.core.parser.parsers.StringParser object at 0x7c08b844f0d0>, 107, '('), (<sqlfluff.core.parser.parsers.StringParser object at 0x7c08b844f070>, 117, ')')], sb=['SELECT', '', '', 'TBL', '.', 'NAME', ',', '', '', 'B', '.', 'VALUE', ',', '', '', '/*', '', '', 'THIS', '', '', '*/', '', '', 'D', '.', 'SOMETHING', ',', '', '--', '', '', 'TBL', '.', 'FOO', ',', '', '', 'C', '.', 'VAL', '', '+', '', 'B', '.', 'VAL', '', '/', '', '-', '2', '', 'AS', '', 'A_CALCULATION', '', 'FROM', '', 'TBL', '', 'INNER', '', 'JOIN', '', 'B', '', 'ON', '', '(', 'TBL', '.', 'COMMON_ID', '', '=', '', 'B', '.', 'COMMON_ID', ')', '', 'JOIN', '', 'C', '', 'ON', '', '(', 'TBL', '.', 'ID', '', '=', '', 'C', '.', 'ID', ')', '', 'LEFT', '', 'JOIN', '', 'D', '', 'ON', '', '(', 'TBL', '.', 'ID', '', '=', '', 'D', '.', 'OTHER_ID', ')', '', 'ORDER', '', 'BY', '', 'TBL', '.', 'NAME', '', 'ASC']]
DEBUG      [PD:0  MD:1 ]	.FileSegment                                      	Delim._look_ahead_match SC	    	[bsm=(69, 1, <sqlfluff.core.parser.parsers.StringParser object at 0x7c08b844f0d0>)]
DEBUG      [PD:0  MD:1 ]	.FileSegment                                      	Delim._look_ahead_match IN	    	[ls=58, seg='tbl.common_id = b.co...']
DEBUG      [PD:0  MD:1 ]	.FileSegment                                      	Delim._look_ahead_match SI	    	[mq=[(<sqlfluff.core.parser.parsers.StringParser object at 0x7c08b844f070>, 9, ')'), (<sqlfluff.core.parser.parsers.StringParser object at 0x7c08b844f0d0>, 17, '('), (<sqlfluff.core.parser.parsers.StringParser object at 0x7c08b844f070>, 27, ')'), (<sqlfluff.core.parser.parsers.StringParser object at 0x7c08b844f0d0>, 37, '('), (<sqlfluff.core.parser.parsers.StringParser object at 0x7c08b844f070>, 47, ')')], sb=['TBL', '.', 'COMMON_ID', '', '=', '', 'B', '.', 'COMMON_ID', ')', '', 'JOIN', '', 'C', '', 'ON', '', '(', 'TBL', '.', 'ID', '', '=', '', 'C', '.', 'ID', ')', '', 'LEFT', '', 'JOIN', '', 'D', '', 'ON', '', '(', 'TBL', '.', 'ID', '', '=', '', 'D', '.', 'OTHER_ID', ')', '', 'ORDER', '', 'BY', '', 'TBL', '.', 'NAME', '', 'ASC']]
DEBUG      [PD:0  MD:1 ]	.FileSegment                                      	Delim._look_ahead_match SC	    	[bsm=(9, 1, <sqlfluff.core.parser.parsers.StringParser object at 0x7c08b844f070>)]
DEBUG      [PD:0  MD:1 ]	.FileSegment                                      	Delim._look_ahead_match IN	    	[ls=48, seg='\nJOIN c ON (tbl.id =...']
DEBUG      [PD:0  MD:1 ]	.FileSegment                                      	Delim._look_ahead_match SI	    	[mq=[(<sqlfluff.core.parser.parsers.StringParser object at 0x7c08b844f0d0>, 7, '('), (<sqlfluff.core.parser.parsers.StringParser object at 0x7c08b844f070>, 17, ')'), (<sqlfluff.core.parser.parsers.StringParser object at 0x7c08b844f0d0>, 27, '('), (<sqlfluff.core.parser.parsers.StringParser object at 0x7c08b844f070>, 37, ')')], sb=['', 'JOIN', '', 'C', '', 'ON', '', '(', 'TBL', '.', 'ID', '', '=', '', 'C', '.', 'ID', ')', '', 'LEFT', '', 'JOIN', '', 'D', '', 'ON', '', '(', 'TBL', '.', 'ID', '', '=', '', 'D', '.', 'OTHER_ID', ')', '', 'ORDER', '', 'BY', '', 'TBL', '.', 'NAME', '', 'ASC']]
DEBUG      [PD:0  MD:1 ]	.FileSegment                                      	Delim._look_ahead_match SC	    	[bsm=(7, 1, <sqlfluff.core.parser.parsers.StringParser object at 0x7c08b844f0d0>)]
DEBUG      [PD:0  MD:1 ]	.FileSegment                                      	Delim._look_ahead_match IN	    	[ls=40, seg='tbl.id = c.id)\nLEFT ...']
DEBUG      [PD:0  MD:1 ]	.FileSegment                                      	Delim._look_ahead_match SI	    	[mq=[(<sqlfluff.core.parser.parsers.StringParser object at 0x7c08b844f070>, 9, ')'), (<sqlfluff.core.parser.parsers.StringParser object at 0x7c08b844f0d0>, 19, '('), (<sqlfluff.core.parser.parsers.StringParser object at 0x7c08b844f070>, 29, ')')], sb=['TBL', '.', 'ID', '', '=', '', 'C', '.', 'ID', ')', '', 'LEFT', '', 'JOIN', '', 'D', '', 'ON', '', '(', 'TBL', '.', 'ID', '', '=', '', 'D', '.', 'OTHER_ID', ')', '', 'ORDER', '', 'BY', '', 'TBL', '.', 'NAME', '', 'ASC']]
DEBUG      [PD:0  MD:1 ]	.FileSegment                                      	Delim._look_ahead_match SC	    	[bsm=(9, 1, <sqlfluff.core.parser.parsers.StringParser object at 0x7c08b844f070>)]
DEBUG      [PD:0  MD:1 ]	.FileSegment                                      	Delim._look_ahead_match IN	    	[ls=30, seg='\nLEFT JOIN d ON (tbl...']
DEBUG      [PD:0  MD:1 ]	.FileSegment                                      	Delim._look_ahead_match SI	    	[mq=[(<sqlfluff.core.parser.parsers.StringParser object at 0x7c08b844f0d0>, 9, '('), (<sqlfluff.core.parser.parsers.StringParser object at 0x7c08b844f070>, 19, ')')], sb=['', 'LEFT', '', 'JOIN', '', 'D', '', 'ON', '', '(', 'TBL', '.', 'ID', '', '=', '', 'D', '.', 'OTHER_ID', ')', '', 'ORDER', '', 'BY', '', 'TBL', '.', 'NAME', '', 'ASC']]
DEBUG      [PD:0  MD:1 ]	.FileSegment                                      	Delim._look_ahead_match SC	    	[bsm=(9, 1, <sqlfluff.core.parser.parsers.StringParser object at 0x7c08b844f0d0>)]
DEBUG      [PD:0  MD:1 ]	.FileSegment                                      	Delim._look_ahead_match IN	    	[ls=20, seg='tbl.id = d.other_id)...']
DEBUG      [PD:0  MD:1 ]	.FileSegment                                      	Delim._look_ahead_match SI	    	[mq=[(<sqlfluff.core.parser.parsers.StringParser object at 0x7c08b844f070>, 9, ')')], sb=['TBL', '.', 'ID', '', '=', '', 'D', '.', 'OTHER_ID', ')', '', 'ORDER', '', 'BY', '', 'TBL', '.', 'NAME', '', 'ASC']]
DEBUG      [PD:0  MD:1 ]	.FileSegment                                      	Delim._look_ahead_match SC	    	[bsm=(9, 1, <sqlfluff.core.parser.parsers.StringParser object at 0x7c08b844f070>)]
DEBUG      [PD:0  MD:1 ]	.FileSegment                                      	Delim._look_ahead_match IN	    	[ls=10, seg='\nORDER BY tbl.name A...']
DEBUG      [PD:0  MD:1 ]	.FileSegment                                      	Delim._look_ahead_match SI	    	[mq=[], sb=['', 'ORDER', '', 'BY', '', 'TBL', '.', 'NAME', '', 'ASC']]
DEBUG      [PD:0  MD:1 ]	.FileSegment                                      	Delim._look_ahead_match SC	    	[bsm=None]
DEBUG      [PD:0  MD:3 ]	...StatementSegment                               	Greed._look_ahead_match IN	    	[ls=98, seg='SELECT\n    tbl.name,...']
DEBUG      [PD:0  MD:3 ]	...StatementSegment                               	Greed._look_ahead_match SI	    	[mq=[], sb=['SELECT', '', '', 'TBL', '.', 'NAME', ',', '', '', 'B', '.', 'VALUE', ',', '', '', '/*', '', '', 'THIS', '', '', '*/', '', '', 'D', '.', 'SOMETHING', ',', '', '--', '', '', 'TBL', '.', 'FOO', ',', '', '', 'C', '.', 'VAL', '', '+', '', 'B', '.', 'VAL', '', '/', '', '-', '2', '', 'AS', '', 'A_CALCULATION', '', 'FROM', '', 'TBL', '', 'INNER', '', 'JOIN', '', 'B', '', 'ON', '', '(TBL.COMMON_ID', '', 'JOIN', '', 'C', '', 'ON', '', '(TBL.ID', '', 'LEFT', '', 'JOIN', '', 'D', '', 'ON', '', '(TBL.ID', '', 'ORDER', '', 'BY', '', 'TBL', '.', 'NAME', '', 'ASC']]
DEBUG      [PD:0  MD:3 ]	...StatementSegment                               	Greed._look_ahead_match SC	    	[bsm=None]
INFO       [PD:0  MD:2 ]	..StatementSegment                                	Greed.match OUT     	++  	[match=<MatchResult 98/98: 'SELECT\n    tbl....BY tbl.name ASC'>, seg="'SELECT\\n    tbl.name,...'"]
DEBUG      [PD:0  MD:1 ]	.StatementSegment                                 	State.match OUT     	++  	[match=<MatchResult 1/1: 'SELECT\n    tbl....BY tbl.name ASC'>, seg="'SELECT\\n    tbl.name,...'"]
DEBUG      [PD:0  MD:1 ]	.FileSegment                                      	Ref.match OUT       	++  	[match=<MatchResult 1/1: 'SELECT\n    tbl....BY tbl.name ASC'>, seg="'SELECT\\n    tbl.name,...'"]
INFO       [PD:0  MD:0 ]	FileSegment                                       	Delim.match OUT     	++  	[match=<MatchResult 1/1: 'SELECT\n    tbl....BY tbl.name ASC'>, seg="'SELECT\\n    tbl.name,...'"]
DEBUG      FileSegment.parse: Done Parse. Plotting Recursion. Recurse=True
DEBUG      ###
#
# Beginning Parse Depth 1: FileSegment
#
###
Initial Structure:
[L:  1, P:  1]      |file:
[L:  1, P:  1]      |    statement:
[L:  1, P:  1]      |        raw:                                                  'SELECT'
[L:  1, P:  7]      |        newline:                                              '\n'
[L:  2, P:  1]      |        whitespace:                                           '    '
[L:  2, P:  5]      |        raw:                                                  'tbl'
[L:  2, P:  8]      |        raw:                                                  '.'
[L:  2, P:  9]      |        raw:                                                  'name'
[L:  2, P: 13]      |        comma:                                                ','
[L:  2, P: 14]      |        newline:                                              '\n'
[L:  3, P:  1]      |        whitespace:                                           '    '
[L:  3, P:  5]      |        raw:                                                  'b'
[L:  3, P:  6]      |        raw:                                                  '.'
[L:  3, P:  7]      |        raw:                                                  'value'
[L:  3, P: 12]      |        comma:                                                ','
[L:  3, P: 13]      |        newline:                                              '\n'
[L:  4, P:  1]      |        whitespace:                                           '    '
[L:  4, P:  5]      |        comment:                                              '/*'
[L:  4, P:  7]      |        newline:                                              '\n'
[L:  5, P:  1]      |        whitespace:                                           '    '
[L:  5, P:  5]      |        comment:                                              'This is a block comment'
[L:  5, P: 28]      |        newline:                                              '\n'
[L:  6, P:  1]      |        whitespace:                                           '    '
[L:  6, P:  5]      |        comment:                                              '*/'
[L:  6, P:  7]      |        newline:                                              '\n'
[L:  7, P:  1]      |        whitespace:                                           '    '
[L:  7, P:  5]      |        raw:                                                  'd'
[L:  7, P:  6]      |        raw:                                                  '.'
[L:  7, P:  7]      |        raw:                                                  'something'
[L:  7, P: 16]      |        comma:                                                ','
[L:  7, P: 17]      |        whitespace:                                           '    '
[L:  7, P: 21]      |        comment:                                              '-- Which a comment after it'
[L:  7, P: 48]      |        newline:                                              '\n'
[L:  8, P:  1]      |        whitespace:                                           '    '
[L:  8, P:  5]      |        raw:                                                  'tbl'
[L:  8, P:  8]      |        raw:                                                  '.'
[L:  8, P:  9]      |        raw:                                                  'foo'
[L:  8, P: 12]      |        comma:                                                ','
[L:  8, P: 13]      |        newline:                                              '\n'
[L:  9, P:  1]      |        whitespace:                                           '    '
[L:  9, P:  5]      |        raw:                                                  'c'
[L:  9, P:  6]      |        raw:                                                  '.'
[L:  9, P:  7]      |        raw:                                                  'val'
[L:  9, P: 10]      |        whitespace:                                           ' '
[L:  9, P: 11]      |        raw:                                                  '+'
[L:  9, P: 12]      |        whitespace:                                           ' '
[L:  9, P: 13]      |        raw:                                                  'b'
[L:  9, P: 14]      |        raw:                                                  '.'
[L:  9, P: 15]      |        raw:                                                  'val'
[L:  9, P: 18]      |        whitespace:                                           ' '
[L:  9, P: 19]      |        raw:                                                  '/'
[L:  9, P: 20]      |        whitespace:                                           ' '
[L:  9, P: 21]      |        raw:                                                  '-'
[L:  9, P: 22]      |        raw:                                                  '2'
[L:  9, P: 23]      |        whitespace:                                           ' '
[L:  9, P: 24]      |        raw:                                                  'AS'
[L:  9, P: 26]      |        whitespace:                                           ' '
[L:  9, P: 27]      |        raw:                                                  'a_calculation'
[L:  9, P: 40]      |        newline:                                              '\n'
[L: 10, P:  1]      |        raw:                                                  'FROM'
[L: 10, P:  5]      |        whitespace:                                           ' '
[L: 10, P:  6]      |        raw:                                                  'tbl'
[L: 10, P:  9]      |        newline:                                              '\n'
[L: 11, P:  1]      |        raw:                                                  'INNER'
[L: 11, P:  6]      |        whitespace:                                           ' '
[L: 11, P:  7]      |        raw:                                                  'JOIN'
[L: 11, P: 11]      |        whitespace:                                           ' '
[L: 11, P: 12]      |        raw:                                                  'b'
[L: 11, P: 13]      |        whitespace:                                           ' '
[L: 11, P: 14]      |        raw:                                                  'ON'
[L: 11, P: 16]      |        whitespace:                                           ' '
[L: 11, P: 17]      |        bracketed:
[L: 11, P: 17]      |            start_bracket:                                    '('
[L: 11, P: 18]      |            raw:                                              'tbl'
[L: 11, P: 21]      |            raw:                                              '.'
[L: 11, P: 22]      |            raw:                                              'common_id'
[L: 11, P: 31]      |            whitespace:                                       ' '
[L: 11, P: 32]      |            raw:                                              '='
[L: 11, P: 33]      |            whitespace:                                       ' '
[L: 11, P: 34]      |            raw:                                              'b'
[L: 11, P: 35]      |            raw:                                              '.'
[L: 11, P: 36]      |            raw:                                              'common_id'
[L: 11, P: 45]      |            end_bracket:                                      ')'
[L: 11, P: 46]      |        newline:                                              '\n'
[L: 12, P:  1]      |        raw:                                                  'JOIN'
[L: 12, P:  5]      |        whitespace:                                           ' '
[L: 12, P:  6]      |        raw:                                                  'c'
[L: 12, P:  7]      |        whitespace:                                           ' '
[L: 12, P:  8]      |        raw:                                                  'ON'
[L: 12, P: 10]      |        whitespace:                                           ' '
[L: 12, P: 11]      |        bracketed:
[L: 12, P: 11]      |            start_bracket:                                    '('
[L: 12, P: 12]      |            raw:                                              'tbl'
[L: 12, P: 15]      |            raw:                                              '.'
[L: 12, P: 16]      |            raw:                                              'id'
[L: 12, P: 18]      |            whitespace:                                       ' '
[L: 12, P: 19]      |            raw:                                              '='
[L: 12, P: 20]      |            whitespace:                                       ' '
[L: 12, P: 21]      |            raw:                                              'c'
[L: 12, P: 22]      |            raw:                                              '.'
[L: 12, P: 23]      |            raw:                                              'id'
[L: 12, P: 25]      |            end_bracket:                                      ')'
[L: 12, P: 26]      |        newline:                                              '\n'
[L: 13, P:  1]      |        raw:                                                  'LEFT'
[L: 13, P:  5]      |        whitespace:                                           ' '
[L: 13, P:  6]      |        raw:                                                  'JOIN'
[L: 13, P: 10]      |        whitespace:                                           ' '
[L: 13, P: 11]      |        raw:                                                  'd'
[L: 13, P: 12]      |        whitespace:                                           ' '
[L: 13, P: 13]      |        raw:                                                  'ON'
[L: 13, P: 15]      |        whitespace:                                           ' '
[L: 13, P: 16]      |        bracketed:
[L: 13, P: 16]      |            start_bracket:                                    '('
[L: 13, P: 17]      |            raw:                                              'tbl'
[L: 13, P: 20]      |            raw:                                              '.'
[L: 13, P: 21]      |            raw:                                              'id'
[L: 13, P: 23]      |            whitespace:                                       ' '
[L: 13, P: 24]      |            raw:                                              '='
[L: 13, P: 25]      |            whitespace:                                       ' '
[L: 13, P: 26]      |            raw:                                              'd'
[L: 13, P: 27]      |            raw:                                              '.'
[L: 13, P: 28]      |            raw:                                              'other_id'
[L: 13, P: 36]      |            end_bracket:                                      ')'
[L: 13, P: 37]      |        newline:                                              '\n'
[L: 14, P:  1]      |        raw:                                                  'ORDER'
[L: 14, P:  6]      |        whitespace:                                           ' '
[L: 14, P:  7]      |        raw:                                                  'BY'
[L: 14, P:  9]      |        whitespace:                                           ' '
[L: 14, P: 10]      |        raw:                                                  'tbl'
[L: 14, P: 13]      |        raw:                                                  '.'
[L: 14, P: 14]      |        raw:                                                  'name'
[L: 14, P: 18]      |        whitespace:                                           ' '
[L: 14, P: 19]      |        raw:                                                  'ASC'
[L: 14, P: 22]      |    newline:                                                  '\n'

INFO       
###
#
# Parse Depth 1. Expanding: StatementSegment: 'SELECT\n    tbl.name,\n    b.value,\n    /*...'
#
###
INFO       [PD:1  MD:0 ]	StatementSegment                                  	OneOf.match PRN     	    	[ns=0, ps=28, ms=1, pruned=[<Ref: InsertStatementSegment>, <Ref: TransactionStatementSegment>, <Ref: DropStatementSegment>, <Ref: TruncateStatementSegment>, <Ref: AccessStatementSegment>, <Ref: CreateTableStatementSegment>, <Ref: CreateTypeStatementSegment>, <Ref: CreateRoleStatementSegment>, <Ref: AlterTableStatementSegment>, <Ref: CreateSchemaStatementSegment>, <Ref: SetSchemaStatementSegment>, <Ref: DropSchemaStatementSegment>, <Ref: CreateDatabaseStatementSegment>, <Ref: CreateExtensionStatementSegment>, <Ref: CreateIndexStatementSegment>, <Ref: DropIndexStatementSegment>, <Ref: CreateViewStatementSegment>, <Ref: DeleteStatementSegment>, <Ref: UpdateStatementSegment>, <Ref: CreateFunctionStatementSegment>, <Ref: CreateModelStatementSegment>, <Ref: DropModelStatementSegment>, <Ref: DescribeStatementSegment>, <Ref: UseStatementSegment>, <Ref: ExplainStatementSegment>, <Ref: CreateSequenceStatementSegment>, <Ref: AlterSequenceStatementSegment>, <Ref: DropSequenceStatementSegment>], opts=[<Ref: SelectableGrammar>]]
INFO       [PD:1  MD:1 ]	.SelectableGrammar                                	OneOf.match PRN     	    	[ns=0, ps=1, ms=1, pruned=[<Ref: WithCompoundStatementSegment>], opts=[<Ref: NonWithSelectableGrammar>]]
INFO       [PD:1  MD:2 ]	..NonWithSelectableGrammar                        	OneOf.match PRN     	    	[ns=0, ps=0, ms=3, pruned=[], opts=[<Ref: SetExpressionSegment>, <OptionallyBracketed: [<Bracketed: [<Ref: SelectStatementSegmen..., <Ref: SelectStatementSegment>]>, <Ref: NonSetSelectableGrammar>]]
INFO       [PD:1  MD:5 ]	.....NonSetSelectableGrammar                      	OneOf.match PRN     	    	[ns=0, ps=2, ms=1, pruned=[<Ref: ValuesClauseSegment>, <Bracketed: [<Ref: SelectStatementSegment>]>], opts=[<Ref: UnorderedSelectStatementSegment>]]
DEBUG      [PD:1  MD:11]	...........SelectClauseSegment                    	Ref.match OUT       	+   	[match=<MatchResult 1/98: 'SELECT'>, seg="'SELECT\\n    tbl.name,...'"]
INFO       [PD:1  MD:15]	...............WildcardIdentifierSegment          	AnyNu.match PRN     	    	[ns=1, ps=0, ms=0, pruned=[], opts=[<Sequence: [<Ref: SingleIdentifierGrammar>, <Ref: DotSegment>]>]]
INFO       [PD:1  MD:17]	.................SingleIdentifierGrammar          	OneOf.match PRN     	    	[ns=2, ps=0, ms=0, pruned=[], opts=[<Ref: NakedIdentifierSegment>, <Ref: QuotedIdentifierSegment>]]
DEBUG      [PD:1  MD:18]	..................SingleIdentifierGrammar         	Ref.match OUT       	+   	[match=<MatchResult 1/95: 'tbl'>, seg="'tbl.name,\\n    b.valu...'"]
DEBUG      [PD:1  MD:18]	..................SingleIdentifierGrammar         	Ref.match OUT       	    	[match=<MatchResult 0/95: ''>, seg="'tbl.name,\\n    b.valu...'"]
INFO       [PD:1  MD:17]	.................SingleIdentifierGrammar          	OneOf.match OUT     	+   	[match=<MatchResult 1/95: 'tbl'>, seg="'tbl.name,\\n    b.valu...'"]
DEBUG      [PD:1  MD:17]	.................WildcardIdentifierSegment        	Ref.match OUT       	+   	[match=<MatchResult 1/95: 'tbl'>, seg="'tbl.name,\\n    b.valu...'"]
DEBUG      [PD:1  MD:17]	.................WildcardIdentifierSegment        	Ref.match OUT       	+   	[match=<MatchResult 1/94: '.'>, seg="'.name,\\n    b.value,\\n...'"]
INFO       [PD:1  MD:16]	................WildcardIdentifierSegment         	Seque.match OUT     	+   	[match=<MatchResult 2/95: 'tbl.'>, seg="'tbl.name,\\n    b.valu...'"]
INFO       [PD:1  MD:15]	...............WildcardIdentifierSegment          	AnyNu.match PRN     	    	[ns=1, ps=0, ms=0, pruned=[], opts=[<Sequence: [<Ref: SingleIdentifierGrammar>, <Ref: DotSegment>]>]]
INFO       [PD:1  MD:17]	.................SingleIdentifierGrammar          	OneOf.match PRN     	    	[ns=2, ps=0, ms=0, pruned=[], opts=[<Ref: NakedIdentifierSegment>, <Ref: QuotedIdentifierSegment>]]
DEBUG      [PD:1  MD:18]	..................SingleIdentifierGrammar         	Ref.match OUT       	+   	[match=<MatchResult 1/93: 'name'>, seg="'name,\\n    b.value,\\n ...'"]
DEBUG      [PD:1  MD:18]	..................SingleIdentifierGrammar         	Ref.match OUT       	    	[match=<MatchResult 0/93: ''>, seg="'name,\\n    b.value,\\n ...'"]
INFO       [PD:1  MD:17]	.................SingleIdentifierGrammar          	OneOf.match OUT     	+   	[match=<MatchResult 1/93: 'name'>, seg="'name,\\n    b.value,\\n ...'"]
DEBUG      [PD:1  MD:17]	.................WildcardIdentifierSegment        	Ref.match OUT       	+   	[match=<MatchResult 1/93: 'name'>, seg="'name,\\n    b.value,\\n ...'"]
DEBUG      [PD:1  MD:17]	.................WildcardIdentifierSegment        	Ref.match OUT       	    	[match=<MatchResult 0/92: ''>, seg="',\\n    b.value,\\n    /...'"]
INFO       [PD:1  MD:16]	................WildcardIdentifierSegment         	Seque.match OUT     	    	[match=<MatchResult 0/93: ''>, seg="'name,\\n    b.value,\\n ...'"]
INFO       [PD:1  MD:15]	...............WildcardIdentifierSegment          	AnyNu.match OUT     	+   	[match=<MatchResult 2/95: 'tbl.'>, seg="'tbl.name,\\n    b.valu...'"]
DEBUG      [PD:1  MD:15]	...............WildcardIdentifierSegment          	Ref.match OUT       	    	[match=<MatchResult 0/93: ''>, seg="'name,\\n    b.value,\\n ...'"]
INFO       [PD:1  MD:14]	..............WildcardIdentifierSegment           	Seque.match OUT     	    	[match=<MatchResult 0/95: ''>, seg="'tbl.name,\\n    b.valu...'"]
DEBUG      [PD:1  MD:13]	.............WildcardIdentifierSegment            	Wildc.match OUT     	    	[match=<MatchResult 0/95: ''>, seg="'tbl.name,\\n    b.valu...'"]
DEBUG      [PD:1  MD:13]	.............WildcardExpressionSegment            	Ref.match OUT       	    	[match=<MatchResult 0/95: ''>, seg="'tbl.name,\\n    b.valu...'"]
INFO       [PD:1  MD:12]	............WildcardExpressionSegment             	Seque.match OUT     	    	[match=<MatchResult 0/95: ''>, seg="'tbl.name,\\n    b.valu...'"]
DEBUG      [PD:1  MD:11]	...........WildcardExpressionSegment              	Wildc.match OUT     	    	[match=<MatchResult 0/95: ''>, seg="'tbl.name,\\n    b.valu...'"]
DEBUG      [PD:1  MD:11]	...........SelectClauseSegment                    	Ref.match OUT       	    	[match=<MatchResult 0/95: ''>, seg="'tbl.name,\\n    b.valu...'"]
INFO       [PD:1  MD:10]	..........SelectClauseSegment                     	Seque.match OUT     	+   	[match=<MatchResult 1/98: 'SELECT'>, seg="'SELECT\\n    tbl.name,...'"]
DEBUG      [PD:1  MD:10]	..........SelectClauseSegment                     	Start._look_ahead_match IN	    	[ls=97, seg='\n    tbl.name,\n    b...']
DEBUG      [PD:1  MD:10]	..........SelectClauseSegment                     	Start._look_ahead_match SI	    	[mq=[(<OneOf: [<Ref: FromKeywordSegment>, <Ref: WhereKeywordSegment>, <Ref: OrderKeywordSegment>, <Ref: LimitKeywor...]>, 56, 'FROM'), (<OneOf: [<Ref: FromKeywordSegment>, <Ref: WhereKeywordSegment>, <Ref: OrderKeywordSegment>, <Ref: LimitKeywor...]>, 88, 'ORDER')], sb=['', '', 'TBL', '.', 'NAME', ',', '', '', 'B', '.', 'VALUE', ',', '', '', '/*', '', '', 'THIS', '', '', '*/', '', '', 'D', '.', 'SOMETHING', ',', '', '--', '', '', 'TBL', '.', 'FOO', ',', '', '', 'C', '.', 'VAL', '', '+', '', 'B', '.', 'VAL', '', '/', '', '-', '2', '', 'AS', '', 'A_CALCULATION', '', 'FROM', '', 'TBL', '', 'INNER', '', 'JOIN', '', 'B', '', 'ON', '', '(TBL.COMMON_ID', '', 'JOIN', '', 'C', '', 'ON', '', '(TBL.ID', '', 'LEFT', '', 'JOIN', '', 'D', '', 'ON', '', '(TBL.ID', '', 'ORDER', '', 'BY', '', 'TBL', '.', 'NAME', '', 'ASC']]
INFO       [PD:1  MD:10]	..........SelectClauseSegment                     	OneOf.match PRN     	    	[ns=0, ps=5, ms=1, pruned=[<Ref: FromKeywordSegment>, <Ref: WhereKeywordSegment>, <Ref: LimitKeywordSegment>, <Ref: OverlapsKeywordSegment>, <Ref: SetOperatorSegment>], opts=[<Ref: OrderKeywordSegment>]]
DEBUG      [PD:1  MD:11]	...........SelectClauseSegment                    	Ref.match OUT       	+   	[match=<MatchResult 1/9: 'ORDER'>, seg="'ORDER BY tbl.name AS...'"]
INFO       [PD:1  MD:10]	..........SelectClauseSegment                     	OneOf.match OUT     	+   	[match=<MatchResult 1/9: 'ORDER'>, seg="'ORDER BY tbl.name AS...'"]
INFO       [PD:1  MD:10]	..........SelectClauseSegment                     	OneOf.match PRN     	    	[ns=0, ps=5, ms=1, pruned=[<Ref: WhereKeywordSegment>, <Ref: OrderKeywordSegment>, <Ref: LimitKeywordSegment>, <Ref: OverlapsKeywordSegment>, <Ref: SetOperatorSegment>], opts=[<Ref: FromKeywordSegment>]]
DEBUG      [PD:1  MD:11]	...........SelectClauseSegment                    	Ref.match OUT       	+   	[match=<MatchResult 1/41: 'FROM'>, seg="'FROM tbl\\nINNER JOIN ...'"]
INFO       [PD:1  MD:10]	..........SelectClauseSegment                     	OneOf.match OUT     	+   	[match=<MatchResult 1/41: 'FROM'>, seg="'FROM tbl\\nINNER JOIN ...'"]
DEBUG      [PD:1  MD:10]	..........SelectClauseSegment                     	Start._look_ahead_match SC	    	[bsm=(56, 1, <OneOf: [<Ref: FromKeywordSegment>, <Ref: WhereKeywordSegment>, <Ref: OrderKeywordSegment>, <Ref: LimitKeywor...]>)]
INFO       [PD:1  MD:9 ]	.........SelectClauseSegment                      	Start.match OUT     	+   	[match=<MatchResult 56/98: 'SELECT\n    tbl....S a_calculation'>, seg="'SELECT\\n    tbl.name,...'"]
DEBUG      [PD:1  MD:8 ]	........SelectClauseSegment                       	Selec.match OUT     	+   	[match=<MatchResult 1/43: 'SELECT\n    tbl....S a_calculation'>, seg="'SELECT\\n    tbl.name,...'"]
DEBUG      [PD:1  MD:8 ]	........UnorderedSelectStatementSegment           	Ref.match OUT       	+   	[match=<MatchResult 1/43: 'SELECT\n    tbl....S a_calculation'>, seg="'SELECT\\n    tbl.name,...'"]
DEBUG      [PD:1  MD:8 ]	........UnorderedSelectStatementSegment           	Start._look_ahead_match IN	    	[ls=42, seg='\nFROM tbl\nINNER JOIN...']
DEBUG      [PD:1  MD:8 ]	........UnorderedSelectStatementSegment           	Start._look_ahead_match SI	    	[mq=[(<OneOf: [<Ref: SetOperatorSegment>, <Ref: WithNoSchemaBindingClauseSegment>, <Ref: OrderByClauseSegment>, <Re...]>, 33, 'ORDER')], sb=['', 'FROM', '', 'TBL', '', 'INNER', '', 'JOIN', '', 'B', '', 'ON', '', '(TBL.COMMON_ID', '', 'JOIN', '', 'C', '', 'ON', '', '(TBL.ID', '', 'LEFT', '', 'JOIN', '', 'D', '', 'ON', '', '(TBL.ID', '', 'ORDER', '', 'BY', '', 'TBL', '.', 'NAME', '', 'ASC']]
INFO       [PD:1  MD:8 ]	........UnorderedSelectStatementSegment           	OneOf.match PRN     	    	[ns=0, ps=4, ms=1, pruned=[<Ref: SetOperatorSegment>, <Ref: WithNoSchemaBindingClauseSegment>, <Ref: LimitClauseSegment>, <Ref: NamedWindowSegment>], opts=[<Ref: OrderByClauseSegment>]]
DEBUG      [PD:1  MD:11]	...........OrderByClauseSegment                   	Ref.match OUT       	+   	[match=<MatchResult 1/9: 'ORDER'>, seg="'ORDER BY tbl.name AS...'"]
DEBUG      [PD:1  MD:11]	...........OrderByClauseSegment                   	Start._look_ahead_match IN	    	[ls=8, seg=' BY tbl.name ASC']
DEBUG      [PD:1  MD:11]	...........OrderByClauseSegment                   	Start._look_ahead_match SI	    	[mq=[], sb=['', 'BY', '', 'TBL', '.', 'NAME', '', 'ASC']]
DEBUG      [PD:1  MD:11]	...........OrderByClauseSegment                   	Start._look_ahead_match SC	    	[bsm=None]
INFO       [PD:1  MD:10]	..........OrderByClauseSegment                    	Start.match OUT     	++  	[match=<MatchResult 9/9: 'ORDER BY tbl.name ASC'>, seg="'ORDER BY tbl.name AS...'"]
DEBUG      [PD:1  MD:9 ]	.........OrderByClauseSegment                     	Order.match OUT     	++  	[match=<MatchResult 1/1: 'ORDER BY tbl.name ASC'>, seg="'ORDER BY tbl.name AS...'"]
DEBUG      [PD:1  MD:9 ]	.........UnorderedSelectStatementSegment          	Ref.match OUT       	++  	[match=<MatchResult 1/1: 'ORDER BY tbl.name ASC'>, seg="'ORDER BY tbl.name AS...'"]
INFO       [PD:1  MD:8 ]	........UnorderedSelectStatementSegment           	OneOf.match OUT     	++  	[match=<MatchResult 1/1: 'ORDER BY tbl.name ASC'>, seg="'ORDER BY tbl.name AS...'"]
DEBUG      [PD:1  MD:8 ]	........UnorderedSelectStatementSegment           	Start._look_ahead_match SC	    	[bsm=(33, 1, <OneOf: [<Ref: SetOperatorSegment>, <Ref: WithNoSchemaBindingClauseSegment>, <Ref: OrderByClauseSegment>, <Re...]>)]
INFO       [PD:1  MD:7 ]	.......UnorderedSelectStatementSegment            	Start.match OUT     	+   	[match=<MatchResult 33/35: 'SELECT\n    tbl....d = d.other_id)'>, seg="'SELECT\\n    tbl.name,...'"]
DEBUG      [PD:1  MD:6 ]	......UnorderedSelectStatementSegment             	Unord.match OUT     	+   	[match=<MatchResult 1/3: 'SELECT\n    tbl....d = d.other_id)'>, seg="'SELECT\\n    tbl.name,...'"]
DEBUG      [PD:1  MD:6 ]	......NonSetSelectableGrammar                     	Ref.match OUT       	+   	[match=<MatchResult 1/3: 'SELECT\n    tbl....d = d.other_id)'>, seg="'SELECT\\n    tbl.name,...'"]
INFO       [PD:1  MD:5 ]	.....NonSetSelectableGrammar                      	OneOf.match OUT     	+   	[match=<MatchResult 1/3: 'SELECT\n    tbl....d = d.other_id)'>, seg="'SELECT\\n    tbl.name,...'"]
DEBUG      [PD:1  MD:5 ]	.....SetExpressionSegment                         	Ref.match OUT       	+   	[match=<MatchResult 1/3: 'SELECT\n    tbl....d = d.other_id)'>, seg="'SELECT\\n    tbl.name,...'"]
INFO       [PD:1  MD:5 ]	.....SetExpressionSegment                         	AnyNu.match PRN     	    	[ns=0, ps=1, ms=0, pruned=[<Sequence: [<Ref: SetOperatorSegment>, <Ref: NonSetSelectableGrammar>]>], opts='ALL']
INFO       [PD:1  MD:5 ]	.....SetExpressionSegment                         	AnyNu.match OUT     	    	[match=<MatchResult 0/1: ''>, seg="'ORDER BY tbl.name AS...'"]
INFO       [PD:1  MD:4 ]	....SetExpressionSegment                          	Seque.match OUT     	    	[match=<MatchResult 0/98: ''>, seg="'SELECT\\n    tbl.name,...'"]
DEBUG      [PD:1  MD:3 ]	...SetExpressionSegment                           	SetEx.match OUT     	    	[match=<MatchResult 0/98: ''>, seg="'SELECT\\n    tbl.name,...'"]
DEBUG      [PD:1  MD:3 ]	...NonWithSelectableGrammar                       	Ref.match OUT       	    	[match=<MatchResult 0/98: ''>, seg="'SELECT\\n    tbl.name,...'"]
INFO       [PD:1  MD:3 ]	...NonWithSelectableGrammar                       	Optio.match PRN     	    	[ns=0, ps=1, ms=1, pruned=[<Bracketed: [<Ref: SelectStatementSegment>]>], opts=[<Ref: SelectStatementSegment>]]
DEBUG      [PD:1  MD:9 ]	.........SelectClauseSegment                      	Ref.match OUT       	+   	[match=<MatchResult 1/98: 'SELECT'>, seg="'SELECT\\n    tbl.name,...'"]
INFO       [PD:1  MD:13]	.............WildcardIdentifierSegment            	AnyNu.match PRN     	    	[ns=1, ps=0, ms=0, pruned=[], opts=[<Sequence: [<Ref: SingleIdentifierGrammar>, <Ref: DotSegment>]>]]
INFO       [PD:1  MD:15]	...............SingleIdentifierGrammar            	OneOf.match PRN     	    	[ns=2, ps=0, ms=0, pruned=[], opts=[<Ref: NakedIdentifierSegment>, <Ref: QuotedIdentifierSegment>]]
DEBUG      [PD:1  MD:16]	................SingleIdentifierGrammar           	Ref.match OUT       	+   	[match=<MatchResult 1/95: 'tbl'>, seg="'tbl.name,\\n    b.valu...'"]
DEBUG      [PD:1  MD:16]	................SingleIdentifierGrammar           	Ref.match OUT       	    	[match=<MatchResult 0/95: ''>, seg="'tbl.name,\\n    b.valu...'"]
INFO       [PD:1  MD:15]	...............SingleIdentifierGrammar            	OneOf.match OUT     	+   	[match=<MatchResult 1/95: 'tbl'>, seg="'tbl.name,\\n    b.valu...'"]
DEBUG      [PD:1  MD:15]	...............WildcardIdentifierSegment          	Ref.match OUT       	+   	[match=<MatchResult 1/95: 'tbl'>, seg="'tbl.name,\\n    b.valu...'"]
DEBUG      [PD:1  MD:15]	...............WildcardIdentifierSegment          	Ref.match OUT       	+   	[match=<MatchResult 1/94: '.'>, seg="'.name,\\n    b.value,\\n...'"]
INFO       [PD:1  MD:14]	..............WildcardIdentifierSegment           	Seque.match OUT     	+   	[match=<MatchResult 2/95: 'tbl.'>, seg="'tbl.name,\\n    b.valu...'"]
INFO       [PD:1  MD:13]	.............WildcardIdentifierSegment            	AnyNu.match PRN     	    	[ns=1, ps=0, ms=0, pruned=[], opts=[<Sequence: [<Ref: SingleIdentifierGrammar>, <Ref: DotSegment>]>]]
INFO       [PD:1  MD:15]	...............SingleIdentifierGrammar            	OneOf.match PRN     	    	[ns=2, ps=0, ms=0, pruned=[], opts=[<Ref: NakedIdentifierSegment>, <Ref: QuotedIdentifierSegment>]]
DEBUG      [PD:1  MD:16]	................SingleIdentifierGrammar           	Ref.match OUT       	+   	[match=<MatchResult 1/93: 'name'>, seg="'name,\\n    b.value,\\n ...'"]
DEBUG      [PD:1  MD:16]	................SingleIdentifierGrammar           	Ref.match OUT       	    	[match=<MatchResult 0/93: ''>, seg="'name,\\n    b.value,\\n ...'"]
INFO       [PD:1  MD:15]	...............SingleIdentifierGrammar            	OneOf.match OUT     	+   	[match=<MatchResult 1/93: 'name'>, seg="'name,\\n    b.value,\\n ...'"]
DEBUG      [PD:1  MD:15]	...............WildcardIdentifierSegment          	Ref.match OUT       	+   	[match=<MatchResult 1/93: 'name'>, seg="'name,\\n    b.value,\\n ...'"]
DEBUG      [PD:1  MD:15]	...............WildcardIdentifierSegment          	Ref.match OUT       	    	[match=<MatchResult 0/92: ''>, seg="',\\n    b.value,\\n    /...'"]
INFO       [PD:1  MD:14]	..............WildcardIdentifierSegment           	Seque.match OUT     	    	[match=<MatchResult 0/93: ''>, seg="'name,\\n    b.value,\\n ...'"]
INFO       [PD:1  MD:13]	.............WildcardIdentifierSegment            	AnyNu.match OUT     	+   	[match=<MatchResult 2/95: 'tbl.'>, seg="'tbl.name,\\n    b.valu...'"]
DEBUG      [PD:1  MD:13]	.............WildcardIdentifierSegment            	Ref.match OUT       	    	[match=<MatchResult 0/93: ''>, seg="'name,\\n    b.value,\\n ...'"]
INFO       [PD:1  MD:12]	............WildcardIdentifierSegment             	Seque.match OUT     	    	[match=<MatchResult 0/95: ''>, seg="'tbl.name,\\n    b.valu...'"]
DEBUG      [PD:1  MD:11]	...........WildcardIdentifierSegment              	Wildc.match OUT     	    	[match=<MatchResult 0/95: ''>, seg="'tbl.name,\\n    b.valu...'"]
DEBUG      [PD:1  MD:11]	...........WildcardExpressionSegment              	Ref.match OUT       	    	[match=<MatchResult 0/95: ''>, seg="'tbl.name,\\n    b.valu...'"]
INFO       [PD:1  MD:10]	..........WildcardExpressionSegment               	Seque.match OUT     	    	[match=<MatchResult 0/95: ''>, seg="'tbl.name,\\n    b.valu...'"]
DEBUG      [PD:1  MD:9 ]	.........WildcardExpressionSegment                	Wildc.match OUT     	    	[match=<MatchResult 0/95: ''>, seg="'tbl.name,\\n    b.valu...'"]
DEBUG      [PD:1  MD:9 ]	.........SelectClauseSegment                      	Ref.match OUT       	    	[match=<MatchResult 0/95: ''>, seg="'tbl.name,\\n    b.valu...'"]
INFO       [PD:1  MD:8 ]	........SelectClauseSegment                       	Seque.match OUT     	+   	[match=<MatchResult 1/98: 'SELECT'>, seg="'SELECT\\n    tbl.name,...'"]
DEBUG      [PD:1  MD:8 ]	........SelectClauseSegment                       	Start._look_ahead_match IN	    	[ls=97, seg='\n    tbl.name,\n    b...']
DEBUG      [PD:1  MD:8 ]	........SelectClauseSegment                       	Start._look_ahead_match SI	    	[mq=[(<OneOf: [<Ref: FromKeywordSegment>, <Ref: WhereKeywordSegment>, <Ref: OrderKeywordSegment>, <Ref: LimitKeywor...]>, 56, 'FROM'), (<OneOf: [<Ref: FromKeywordSegment>, <Ref: WhereKeywordSegment>, <Ref: OrderKeywordSegment>, <Ref: LimitKeywor...]>, 88, 'ORDER')], sb=['', '', 'TBL', '.', 'NAME', ',', '', '', 'B', '.', 'VALUE', ',', '', '', '/*', '', '', 'THIS', '', '', '*/', '', '', 'D', '.', 'SOMETHING', ',', '', '--', '', '', 'TBL', '.', 'FOO', ',', '', '', 'C', '.', 'VAL', '', '+', '', 'B', '.', 'VAL', '', '/', '', '-', '2', '', 'AS', '', 'A_CALCULATION', '', 'FROM', '', 'TBL', '', 'INNER', '', 'JOIN', '', 'B', '', 'ON', '', '(TBL.COMMON_ID', '', 'JOIN', '', 'C', '', 'ON', '', '(TBL.ID', '', 'LEFT', '', 'JOIN', '', 'D', '', 'ON', '', '(TBL.ID', '', 'ORDER', '', 'BY', '', 'TBL', '.', 'NAME', '', 'ASC']]
INFO       [PD:1  MD:8 ]	........SelectClauseSegment                       	OneOf.match PRN     	    	[ns=0, ps=5, ms=1, pruned=[<Ref: FromKeywordSegment>, <Ref: WhereKeywordSegment>, <Ref: LimitKeywordSegment>, <Ref: OverlapsKeywordSegment>, <Ref: SetOperatorSegment>], opts=[<Ref: OrderKeywordSegment>]]
DEBUG      [PD:1  MD:9 ]	.........SelectClauseSegment                      	Ref.match OUT       	+   	[match=<MatchResult 1/9: 'ORDER'>, seg="'ORDER BY tbl.name AS...'"]
INFO       [PD:1  MD:8 ]	........SelectClauseSegment                       	OneOf.match OUT     	+   	[match=<MatchResult 1/9: 'ORDER'>, seg="'ORDER BY tbl.name AS...'"]
INFO       [PD:1  MD:8 ]	........SelectClauseSegment                       	OneOf.match PRN     	    	[ns=0, ps=5, ms=1, pruned=[<Ref: WhereKeywordSegment>, <Ref: OrderKeywordSegment>, <Ref: LimitKeywordSegment>, <Ref: OverlapsKeywordSegment>, <Ref: SetOperatorSegment>], opts=[<Ref: FromKeywordSegment>]]
DEBUG      [PD:1  MD:9 ]	.........SelectClauseSegment                      	Ref.match OUT       	+   	[match=<MatchResult 1/41: 'FROM'>, seg="'FROM tbl\\nINNER JOIN ...'"]
INFO       [PD:1  MD:8 ]	........SelectClauseSegment                       	OneOf.match OUT     	+   	[match=<MatchResult 1/41: 'FROM'>, seg="'FROM tbl\\nINNER JOIN ...'"]
DEBUG      [PD:1  MD:8 ]	........SelectClauseSegment                       	Start._look_ahead_match SC	    	[bsm=(56, 1, <OneOf: [<Ref: FromKeywordSegment>, <Ref: WhereKeywordSegment>, <Ref: OrderKeywordSegment>, <Ref: LimitKeywor...]>)]
INFO       [PD:1  MD:7 ]	.......SelectClauseSegment                        	Start.match OUT     	+   	[match=<MatchResult 56/98: 'SELECT\n    tbl....S a_calculation'>, seg="'SELECT\\n    tbl.name,...'"]
DEBUG      [PD:1  MD:6 ]	......SelectClauseSegment                         	Selec.match OUT     	+   	[match=<MatchResult 1/43: 'SELECT\n    tbl....S a_calculation'>, seg="'SELECT\\n    tbl.name,...'"]
DEBUG      [PD:1  MD:6 ]	......SelectStatementSegment                      	Ref.match OUT       	+   	[match=<MatchResult 1/43: 'SELECT\n    tbl....S a_calculation'>, seg="'SELECT\\n    tbl.name,...'"]
DEBUG      [PD:1  MD:6 ]	......SelectStatementSegment                      	Start._look_ahead_match IN	    	[ls=42, seg='\nFROM tbl\nINNER JOIN...']
DEBUG      [PD:1  MD:6 ]	......SelectStatementSegment                      	Start._look_ahead_match SI	    	[mq=[], sb=['', 'FROM', '', 'TBL', '', 'INNER', '', 'JOIN', '', 'B', '', 'ON', '', '(TBL.COMMON_ID', '', 'JOIN', '', 'C', '', 'ON', '', '(TBL.ID', '', 'LEFT', '', 'JOIN', '', 'D', '', 'ON', '', '(TBL.ID', '', 'ORDER', '', 'BY', '', 'TBL', '.', 'NAME', '', 'ASC']]
DEBUG      [PD:1  MD:6 ]	......SelectStatementSegment                      	Start._look_ahead_match SC	    	[bsm=None]
INFO       [PD:1  MD:5 ]	.....SelectStatementSegment                       	Start.match OUT     	++  	[match=<MatchResult 43/43: 'SELECT\n    tbl....BY tbl.name ASC'>, seg="'SELECT\\n    tbl.name,...'"]
DEBUG      [PD:1  MD:4 ]	....SelectStatementSegment                        	Selec.match OUT     	++  	[match=<MatchResult 1/1: 'SELECT\n    tbl....BY tbl.name ASC'>, seg="'SELECT\\n    tbl.name,...'"]
DEBUG      [PD:1  MD:4 ]	....NonWithSelectableGrammar                      	Ref.match OUT       	++  	[match=<MatchResult 1/1: 'SELECT\n    tbl....BY tbl.name ASC'>, seg="'SELECT\\n    tbl.name,...'"]
INFO       [PD:1  MD:3 ]	...NonWithSelectableGrammar                       	Optio.match OUT     	++  	[match=<MatchResult 1/1: 'SELECT\n    tbl....BY tbl.name ASC'>, seg="'SELECT\\n    tbl.name,...'"]
INFO       [PD:1  MD:2 ]	..NonWithSelectableGrammar                        	OneOf.match OUT     	++  	[match=<MatchResult 1/1: 'SELECT\n    tbl....BY tbl.name ASC'>, seg="'SELECT\\n    tbl.name,...'"]
DEBUG      [PD:1  MD:2 ]	..SelectableGrammar                               	Ref.match OUT       	++  	[match=<MatchResult 1/1: 'SELECT\n    tbl....BY tbl.name ASC'>, seg="'SELECT\\n    tbl.name,...'"]
INFO       [PD:1  MD:1 ]	.SelectableGrammar                                	OneOf.match OUT     	++  	[match=<MatchResult 1/1: 'SELECT\n    tbl....BY tbl.name ASC'>, seg="'SELECT\\n    tbl.name,...'"]
DEBUG      [PD:1  MD:1 ]	.StatementSegment                                 	Ref.match OUT       	++  	[match=<MatchResult 1/1: 'SELECT\n    tbl....BY tbl.name ASC'>, seg="'SELECT\\n    tbl.name,...'"]
INFO       [PD:1  MD:0 ]	StatementSegment                                  	OneOf.match OUT     	++  	[match=<MatchResult 1/1: 'SELECT\n    tbl....BY tbl.name ASC'>, seg="'SELECT\\n    tbl.name,...'"]
DEBUG      StatementSegment.parse: Done Parse. Plotting Recursion. Recurse=True
DEBUG      ###
#
# Beginning Parse Depth 2: StatementSegment
#
###
Initial Structure:
[L:  1, P:  1]      |statement:
[L:  1, P:  1]      |    select_statement:
[L:  1, P:  1]      |        select_clause:
[L:  1, P:  1]      |            keyword:                                          'SELECT'
[L:  1, P:  7]      |            newline:                                          '\n'
[L:  2, P:  1]      |            whitespace:                                       '    '
[L:  2, P:  5]      |            raw:                                              'tbl'
[L:  2, P:  8]      |            raw:                                              '.'
[L:  2, P:  9]      |            raw:                                              'name'
[L:  2, P: 13]      |            comma:                                            ','
[L:  2, P: 14]      |            newline:                                          '\n'
[L:  3, P:  1]      |            whitespace:                                       '    '
[L:  3, P:  5]      |            raw:                                              'b'
[L:  3, P:  6]      |            raw:                                              '.'
[L:  3, P:  7]      |            raw:                                              'value'
[L:  3, P: 12]      |            comma:                                            ','
[L:  3, P: 13]      |            newline:                                          '\n'
[L:  4, P:  1]      |            whitespace:                                       '    '
[L:  4, P:  5]      |            comment:                                          '/*'
[L:  4, P:  7]      |            newline:                                          '\n'
[L:  5, P:  1]      |            whitespace:                                       '    '
[L:  5, P:  5]      |            comment:                                          'This is a block comment'
[L:  5, P: 28]      |            newline:                                          '\n'
[L:  6, P:  1]      |            whitespace:                                       '    '
[L:  6, P:  5]      |            comment:                                          '*/'
[L:  6, P:  7]      |            newline:                                          '\n'
[L:  7, P:  1]      |            whitespace:                                       '    '
[L:  7, P:  5]      |            raw:                                              'd'
[L:  7, P:  6]      |            raw:                                              '.'
[L:  7, P:  7]      |            raw:                                              'something'
[L:  7, P: 16]      |            comma:                                            ','
[L:  7, P: 17]      |            whitespace:                                       '    '
[L:  7, P: 21]      |            comment:                                          '-- Which a comment after it'
[L:  7, P: 48]      |            newline:                                          '\n'
[L:  8, P:  1]      |            whitespace:                                       '    '
[L:  8, P:  5]      |            raw:                                              'tbl'
[L:  8, P:  8]      |            raw:                                              '.'
[L:  8, P:  9]      |            raw:                                              'foo'
[L:  8, P: 12]      |            comma:                                            ','
[L:  8, P: 13]      |            newline:                                          '\n'
[L:  9, P:  1]      |            whitespace:                                       '    '
[L:  9, P:  5]      |            raw:                                              'c'
[L:  9, P:  6]      |            raw:                                              '.'
[L:  9, P:  7]      |            raw:                                              'val'
[L:  9, P: 10]      |            whitespace:                                       ' '
[L:  9, P: 11]      |            raw:                                              '+'
[L:  9, P: 12]      |            whitespace:                                       ' '
[L:  9, P: 13]      |            raw:                                              'b'
[L:  9, P: 14]      |            raw:                                              '.'
[L:  9, P: 15]      |            raw:                                              'val'
[L:  9, P: 18]      |            whitespace:                                       ' '
[L:  9, P: 19]      |            raw:                                              '/'
[L:  9, P: 20]      |            whitespace:                                       ' '
[L:  9, P: 21]      |            raw:                                              '-'
[L:  9, P: 22]      |            raw:                                              '2'
[L:  9, P: 23]      |            whitespace:                                       ' '
[L:  9, P: 24]      |            raw:                                              'AS'
[L:  9, P: 26]      |            whitespace:                                       ' '
[L:  9, P: 27]      |            raw:                                              'a_calculation'
[L:  9, P: 40]      |        newline:                                              '\n'
[L: 10, P:  1]      |        keyword:                                              'FROM'
[L: 10, P:  5]      |        whitespace:                                           ' '
[L: 10, P:  6]      |        raw:                                                  'tbl'
[L: 10, P:  9]      |        newline:                                              '\n'
[L: 11, P:  1]      |        raw:                                                  'INNER'
[L: 11, P:  6]      |        whitespace:                                           ' '
[L: 11, P:  7]      |        raw:                                                  'JOIN'
[L: 11, P: 11]      |        whitespace:                                           ' '
[L: 11, P: 12]      |        raw:                                                  'b'
[L: 11, P: 13]      |        whitespace:                                           ' '
[L: 11, P: 14]      |        raw:                                                  'ON'
[L: 11, P: 16]      |        whitespace:                                           ' '
[L: 11, P: 17]      |        bracketed:
[L: 11, P: 17]      |            start_bracket:                                    '('
[L: 11, P: 18]      |            raw:                                              'tbl'
[L: 11, P: 21]      |            raw:                                              '.'
[L: 11, P: 22]      |            raw:                                              'common_id'
[L: 11, P: 31]      |            whitespace:                                       ' '
[L: 11, P: 32]      |            raw:                                              '='
[L: 11, P: 33]      |            whitespace:                                       ' '
[L: 11, P: 34]      |            raw:                                              'b'
[L: 11, P: 35]      |            raw:                                              '.'
[L: 11, P: 36]      |            raw:                                              'common_id'
[L: 11, P: 45]      |            end_bracket:                                      ')'
[L: 11, P: 46]      |        newline:                                              '\n'
[L: 12, P:  1]      |        raw:                                                  'JOIN'
[L: 12, P:  5]      |        whitespace:                                           ' '
[L: 12, P:  6]      |        raw:                                                  'c'
[L: 12, P:  7]      |        whitespace:                                           ' '
[L: 12, P:  8]      |        raw:                                                  'ON'
[L: 12, P: 10]      |        whitespace:                                           ' '
[L: 12, P: 11]      |        bracketed:
[L: 12, P: 11]      |            start_bracket:                                    '('
[L: 12, P: 12]      |            raw:                                              'tbl'
[L: 12, P: 15]      |            raw:                                              '.'
[L: 12, P: 16]      |            raw:                                              'id'
[L: 12, P: 18]      |            whitespace:                                       ' '
[L: 12, P: 19]      |            raw:                                              '='
[L: 12, P: 20]      |            whitespace:                                       ' '
[L: 12, P: 21]      |            raw:                                              'c'
[L: 12, P: 22]      |            raw:                                              '.'
[L: 12, P: 23]      |            raw:                                              'id'
[L: 12, P: 25]      |            end_bracket:                                      ')'
[L: 12, P: 26]      |        newline:                                              '\n'
[L: 13, P:  1]      |        raw:                                                  'LEFT'
[L: 13, P:  5]      |        whitespace:                                           ' '
[L: 13, P:  6]      |        raw:                                                  'JOIN'
[L: 13, P: 10]      |        whitespace:                                           ' '
[L: 13, P: 11]      |        raw:                                                  'd'
[L: 13, P: 12]      |        whitespace:                                           ' '
[L: 13, P: 13]      |        raw:                                                  'ON'
[L: 13, P: 15]      |        whitespace:                                           ' '
[L: 13, P: 16]      |        bracketed:
[L: 13, P: 16]      |            start_bracket:                                    '('
[L: 13, P: 17]      |            raw:                                              'tbl'
[L: 13, P: 20]      |            raw:                                              '.'
[L: 13, P: 21]      |            raw:                                              'id'
[L: 13, P: 23]      |            whitespace:                                       ' '
[L: 13, P: 24]      |            raw:                                              '='
[L: 13, P: 25]      |            whitespace:                                       ' '
[L: 13, P: 26]      |            raw:                                              'd'
[L: 13, P: 27]      |            raw:                                              '.'
[L: 13, P: 28]      |            raw:                                              'other_id'
[L: 13, P: 36]      |            end_bracket:                                      ')'
[L: 13, P: 37]      |        newline:                                              '\n'
[L: 14, P:  1]      |        raw:                                                  'ORDER'
[L: 14, P:  6]      |        whitespace:                                           ' '
[L: 14, P:  7]      |        raw:                                                  'BY'
[L: 14, P:  9]      |        whitespace:                                           ' '
[L: 14, P: 10]      |        raw:                                                  'tbl'
[L: 14, P: 13]      |        raw:                                                  '.'
[L: 14, P: 14]      |        raw:                                                  'name'
[L: 14, P: 18]      |        whitespace:                                           ' '
[L: 14, P: 19]      |        raw:                                                  'ASC'

INFO       
###
#
# Parse Depth 2. Expanding: SelectStatementSegment: 'SELECT\n    tbl.name,\n    b.value,\n    /*...'
#
###
INFO       [PD:2  MD:1 ]	.SelectClauseSegment                              	Selec._match SELF   	    
DEBUG      [PD:2  MD:1 ]	.SelectClauseSegment                              	Selec.match OUT     	+   	[match=<MatchResult 1/43: 'SELECT\n    tbl....S a_calculation'>, seg="'SELECT\\n    tbl.name,...'"]
DEBUG      [PD:2  MD:1 ]	.SelectStatementSegment                           	Ref.match OUT       	+   	[match=<MatchResult 1/43: 'SELECT\n    tbl....S a_calculation'>, seg="'SELECT\\n    tbl.name,...'"]
DEBUG      [PD:2  MD:3 ]	...FromClauseSegment                              	Ref.match OUT       	+   	[match=<MatchResult 1/41: 'FROM'>, seg="'FROM tbl\\nINNER JOIN ...'"]
DEBUG      [PD:2  MD:3 ]	...FromClauseSegment                              	Start._look_ahead_match IN	    	[ls=40, seg=' tbl\nINNER JOIN b ON...']
DEBUG      [PD:2  MD:3 ]	...FromClauseSegment                              	Start._look_ahead_match SI	    	[mq=[(<Ref: FromClauseTerminatorGrammar>, 31, 'ORDER')], sb=['', 'TBL', '', 'INNER', '', 'JOIN', '', 'B', '', 'ON', '', '(TBL.COMMON_ID', '', 'JOIN', '', 'C', '', 'ON', '', '(TBL.ID', '', 'LEFT', '', 'JOIN', '', 'D', '', 'ON', '', '(TBL.ID', '', 'ORDER', '', 'BY', '', 'TBL', '.', 'NAME', '', 'ASC']]
INFO       [PD:2  MD:3 ]	...FromClauseTerminatorGrammar                    	OneOf.match PRN     	    	[ns=0, ps=8, ms=1, pruned=[<Ref: WhereKeywordSegment>, <Ref: LimitKeywordSegment>, <Sequence: [<Ref: GroupKeywordSegment>, <Ref: ByKeywordSegment>]>, <Ref: HavingKeywordSegment>, <Ref: QualifyKeywordSegment>, <Ref: WindowKeywordSegment>, <Ref: SetOperatorSegment>, <Ref: WithNoSchemaBindingClauseSegment>], opts=[<Sequence: [<Ref: OrderKeywordSegment>, <Ref: ByKeywordSegment>]>]]
DEBUG      [PD:2  MD:5 ]	.....FromClauseTerminatorGrammar                  	Ref.match OUT       	+   	[match=<MatchResult 1/9: 'ORDER'>, seg="'ORDER BY tbl.name AS...'"]
DEBUG      [PD:2  MD:5 ]	.....FromClauseTerminatorGrammar                  	Ref.match OUT       	+   	[match=<MatchResult 1/7: 'BY'>, seg="'BY tbl.name ASC'"]
INFO       [PD:2  MD:4 ]	....FromClauseTerminatorGrammar                   	Seque.match OUT     	+   	[match=<MatchResult 3/9: 'ORDER BY'>, seg="'ORDER BY tbl.name AS...'"]
INFO       [PD:2  MD:3 ]	...FromClauseTerminatorGrammar                    	OneOf.match OUT     	+   	[match=<MatchResult 3/9: 'ORDER BY'>, seg="'ORDER BY tbl.name AS...'"]
DEBUG      [PD:2  MD:3 ]	...FromClauseSegment                              	Ref.match OUT       	+   	[match=<MatchResult 3/9: 'ORDER BY'>, seg="'ORDER BY tbl.name AS...'"]
DEBUG      [PD:2  MD:3 ]	...FromClauseSegment                              	Start._look_ahead_match SC	    	[bsm=(31, 3, <Ref: FromClauseTerminatorGrammar>)]
INFO       [PD:2  MD:2 ]	..FromClauseSegment                               	Start.match OUT     	+   	[match=<MatchResult 31/41: 'FROM tbl\nINNER ...d = d.other_id)'>, seg="'FROM tbl\\nINNER JOIN ...'"]
DEBUG      [PD:2  MD:1 ]	.FromClauseSegment                                	FromC.match OUT     	+   	[match=<MatchResult 1/11: 'FROM tbl\nINNER ...d = d.other_id)'>, seg="'FROM tbl\\nINNER JOIN ...'"]
DEBUG      [PD:2  MD:1 ]	.SelectStatementSegment                           	Ref.match OUT       	+   	[match=<MatchResult 1/11: 'FROM tbl\nINNER ...d = d.other_id)'>, seg="'FROM tbl\\nINNER JOIN ...'"]
DEBUG      [PD:2  MD:3 ]	...WhereClauseSegment                             	Ref.match OUT       	    	[match=<MatchResult 0/9: ''>, seg="'ORDER BY tbl.name AS...'"]
INFO       [PD:2  MD:2 ]	..WhereClauseSegment                              	Start.match OUT     	    	[match=<MatchResult 0/9: ''>, seg="'ORDER BY tbl.name AS...'"]
DEBUG      [PD:2  MD:1 ]	.WhereClauseSegment                               	Where.match OUT     	    	[match=<MatchResult 0/9: ''>, seg="'ORDER BY tbl.name AS...'"]
DEBUG      [PD:2  MD:1 ]	.SelectStatementSegment                           	Ref.match OUT       	    	[match=<MatchResult 0/9: ''>, seg="'ORDER BY tbl.name AS...'"]
DEBUG      [PD:2  MD:4 ]	....GroupByClauseSegment                          	Ref.match OUT       	    	[match=<MatchResult 0/9: ''>, seg="'ORDER BY tbl.name AS...'"]
INFO       [PD:2  MD:3 ]	...GroupByClauseSegment                           	Seque.match OUT     	    	[match=<MatchResult 0/9: ''>, seg="'ORDER BY tbl.name AS...'"]
INFO       [PD:2  MD:2 ]	..GroupByClauseSegment                            	Start.match OUT     	    	[match=<MatchResult 0/9: ''>, seg="'ORDER BY tbl.name AS...'"]
DEBUG      [PD:2  MD:1 ]	.GroupByClauseSegment                             	Group.match OUT     	    	[match=<MatchResult 0/9: ''>, seg="'ORDER BY tbl.name AS...'"]
DEBUG      [PD:2  MD:1 ]	.SelectStatementSegment                           	Ref.match OUT       	    	[match=<MatchResult 0/9: ''>, seg="'ORDER BY tbl.name AS...'"]
DEBUG      [PD:2  MD:3 ]	...HavingClauseSegment                            	Ref.match OUT       	    	[match=<MatchResult 0/9: ''>, seg="'ORDER BY tbl.name AS...'"]
INFO       [PD:2  MD:2 ]	..HavingClauseSegment                             	Start.match OUT     	    	[match=<MatchResult 0/9: ''>, seg="'ORDER BY tbl.name AS...'"]
DEBUG      [PD:2  MD:1 ]	.HavingClauseSegment                              	Havin.match OUT     	    	[match=<MatchResult 0/9: ''>, seg="'ORDER BY tbl.name AS...'"]
DEBUG      [PD:2  MD:1 ]	.SelectStatementSegment                           	Ref.match OUT       	    	[match=<MatchResult 0/9: ''>, seg="'ORDER BY tbl.name AS...'"]
DEBUG      [PD:2  MD:3 ]	...OverlapsClauseSegment                          	Ref.match OUT       	    	[match=<MatchResult 0/9: ''>, seg="'ORDER BY tbl.name AS...'"]
INFO       [PD:2  MD:2 ]	..OverlapsClauseSegment                           	Start.match OUT     	    	[match=<MatchResult 0/9: ''>, seg="'ORDER BY tbl.name AS...'"]
DEBUG      [PD:2  MD:1 ]	.OverlapsClauseSegment                            	Overl.match OUT     	    	[match=<MatchResult 0/9: ''>, seg="'ORDER BY tbl.name AS...'"]
DEBUG      [PD:2  MD:1 ]	.SelectStatementSegment                           	Ref.match OUT       	    	[match=<MatchResult 0/9: ''>, seg="'ORDER BY tbl.name AS...'"]
DEBUG      [PD:2  MD:3 ]	...OrderByClauseSegment                           	Ref.match OUT       	+   	[match=<MatchResult 1/9: 'ORDER'>, seg="'ORDER BY tbl.name AS...'"]
DEBUG      [PD:2  MD:3 ]	...OrderByClauseSegment                           	Start._look_ahead_match IN	    	[ls=8, seg=' BY tbl.name ASC']
DEBUG      [PD:2  MD:3 ]	...OrderByClauseSegment                           	Start._look_ahead_match SI	    	[mq=[], sb=['', 'BY', '', 'TBL', '.', 'NAME', '', 'ASC']]
DEBUG      [PD:2  MD:3 ]	...OrderByClauseSegment                           	Start._look_ahead_match SC	    	[bsm=None]
INFO       [PD:2  MD:2 ]	..OrderByClauseSegment                            	Start.match OUT     	++  	[match=<MatchResult 9/9: 'ORDER BY tbl.name ASC'>, seg="'ORDER BY tbl.name AS...'"]
DEBUG      [PD:2  MD:1 ]	.OrderByClauseSegment                             	Order.match OUT     	++  	[match=<MatchResult 1/1: 'ORDER BY tbl.name ASC'>, seg="'ORDER BY tbl.name AS...'"]
DEBUG      [PD:2  MD:1 ]	.SelectStatementSegment                           	Ref.match OUT       	++  	[match=<MatchResult 1/1: 'ORDER BY tbl.name ASC'>, seg="'ORDER BY tbl.name AS...'"]
INFO       [PD:2  MD:0 ]	SelectStatementSegment                            	Seque.match OUT     	++  	[match=<MatchResult 6/6: 'SELECT\n    tbl....BY tbl.name ASC'>, seg="'SELECT\\n    tbl.name,...'"]
DEBUG      SelectStatementSegment.parse: Done Parse. Plotting Recursion. Recurse=True
DEBUG      ###
#
# Beginning Parse Depth 3: SelectStatementSegment
#
###
Initial Structure:
[L:  1, P:  1]      |select_statement:
[L:  1, P:  1]      |    select_clause:
[L:  1, P:  1]      |        keyword:                                              'SELECT'
[L:  1, P:  7]      |        newline:                                              '\n'
[L:  2, P:  1]      |        whitespace:                                           '    '
[L:  2, P:  5]      |        raw:                                                  'tbl'
[L:  2, P:  8]      |        raw:                                                  '.'
[L:  2, P:  9]      |        raw:                                                  'name'
[L:  2, P: 13]      |        comma:                                                ','
[L:  2, P: 14]      |        newline:                                              '\n'
[L:  3, P:  1]      |        whitespace:                                           '    '
[L:  3, P:  5]      |        raw:                                                  'b'
[L:  3, P:  6]      |        raw:                                                  '.'
[L:  3, P:  7]      |        raw:                                                  'value'
[L:  3, P: 12]      |        comma:                                                ','
[L:  3, P: 13]      |        newline:                                              '\n'
[L:  4, P:  1]      |        whitespace:                                           '    '
[L:  4, P:  5]      |        comment:                                              '/*'
[L:  4, P:  7]      |        newline:                                              '\n'
[L:  5, P:  1]      |        whitespace:                                           '    '
[L:  5, P:  5]      |        comment:                                              'This is a block comment'
[L:  5, P: 28]      |        newline:                                              '\n'
[L:  6, P:  1]      |        whitespace:                                           '    '
[L:  6, P:  5]      |        comment:                                              '*/'
[L:  6, P:  7]      |        newline:                                              '\n'
[L:  7, P:  1]      |        whitespace:                                           '    '
[L:  7, P:  5]      |        raw:                                                  'd'
[L:  7, P:  6]      |        raw:                                                  '.'
[L:  7, P:  7]      |        raw:                                                  'something'
[L:  7, P: 16]      |        comma:                                                ','
[L:  7, P: 17]      |        whitespace:                                           '    '
[L:  7, P: 21]      |        comment:                                              '-- Which a comment after it'
[L:  7, P: 48]      |        newline:                                              '\n'
[L:  8, P:  1]      |        whitespace:                                           '    '
[L:  8, P:  5]      |        raw:                                                  'tbl'
[L:  8, P:  8]      |        raw:                                                  '.'
[L:  8, P:  9]      |        raw:                                                  'foo'
[L:  8, P: 12]      |        comma:                                                ','
[L:  8, P: 13]      |        newline:                                              '\n'
[L:  9, P:  1]      |        whitespace:                                           '    '
[L:  9, P:  5]      |        raw:                                                  'c'
[L:  9, P:  6]      |        raw:                                                  '.'
[L:  9, P:  7]      |        raw:                                                  'val'
[L:  9, P: 10]      |        whitespace:                                           ' '
[L:  9, P: 11]      |        raw:                                                  '+'
[L:  9, P: 12]      |        whitespace:                                           ' '
[L:  9, P: 13]      |        raw:                                                  'b'
[L:  9, P: 14]      |        raw:                                                  '.'
[L:  9, P: 15]      |        raw:                                                  'val'
[L:  9, P: 18]      |        whitespace:                                           ' '
[L:  9, P: 19]      |        raw:                                                  '/'
[L:  9, P: 20]      |        whitespace:                                           ' '
[L:  9, P: 21]      |        raw:                                                  '-'
[L:  9, P: 22]      |        raw:                                                  '2'
[L:  9, P: 23]      |        whitespace:                                           ' '
[L:  9, P: 24]      |        raw:                                                  'AS'
[L:  9, P: 26]      |        whitespace:                                           ' '
[L:  9, P: 27]      |        raw:                                                  'a_calculation'
[L:  9, P: 40]      |    newline:                                                  '\n'
[L: 10, P:  1]      |    [META] dedent:
[L: 10, P:  1]      |    from_clause:
[L: 10, P:  1]      |        keyword:                                              'FROM'
[L: 10, P:  5]      |        whitespace:                                           ' '
[L: 10, P:  6]      |        raw:                                                  'tbl'
[L: 10, P:  9]      |        newline:                                              '\n'
[L: 11, P:  1]      |        raw:                                                  'INNER'
[L: 11, P:  6]      |        whitespace:                                           ' '
[L: 11, P:  7]      |        raw:                                                  'JOIN'
[L: 11, P: 11]      |        whitespace:                                           ' '
[L: 11, P: 12]      |        raw:                                                  'b'
[L: 11, P: 13]      |        whitespace:                                           ' '
[L: 11, P: 14]      |        raw:                                                  'ON'
[L: 11, P: 16]      |        whitespace:                                           ' '
[L: 11, P: 17]      |        bracketed:
[L: 11, P: 17]      |            start_bracket:                                    '('
[L: 11, P: 18]      |            raw:                                              'tbl'
[L: 11, P: 21]      |            raw:                                              '.'
[L: 11, P: 22]      |            raw:                                              'common_id'
[L: 11, P: 31]      |            whitespace:                                       ' '
[L: 11, P: 32]      |            raw:                                              '='
[L: 11, P: 33]      |            whitespace:                                       ' '
[L: 11, P: 34]      |            raw:                                              'b'
[L: 11, P: 35]      |            raw:                                              '.'
[L: 11, P: 36]      |            raw:                                              'common_id'
[L: 11, P: 45]      |            end_bracket:                                      ')'
[L: 11, P: 46]      |        newline:                                              '\n'
[L: 12, P:  1]      |        raw:                                                  'JOIN'
[L: 12, P:  5]      |        whitespace:                                           ' '
[L: 12, P:  6]      |        raw:                                                  'c'
[L: 12, P:  7]      |        whitespace:                                           ' '
[L: 12, P:  8]      |        raw:                                                  'ON'
[L: 12, P: 10]      |        whitespace:                                           ' '
[L: 12, P: 11]      |        bracketed:
[L: 12, P: 11]      |            start_bracket:                                    '('
[L: 12, P: 12]      |            raw:                                              'tbl'
[L: 12, P: 15]      |            raw:                                              '.'
[L: 12, P: 16]      |            raw:                                              'id'
[L: 12, P: 18]      |            whitespace:                                       ' '
[L: 12, P: 19]      |            raw:                                              '='
[L: 12, P: 20]      |            whitespace:                                       ' '
[L: 12, P: 21]      |            raw:                                              'c'
[L: 12, P: 22]      |            raw:                                              '.'
[L: 12, P: 23]      |            raw:                                              'id'
[L: 12, P: 25]      |            end_bracket:                                      ')'
[L: 12, P: 26]      |        newline:                                              '\n'
[L: 13, P:  1]      |        raw:                                                  'LEFT'
[L: 13, P:  5]      |        whitespace:                                           ' '
[L: 13, P:  6]      |        raw:                                                  'JOIN'
[L: 13, P: 10]      |        whitespace:                                           ' '
[L: 13, P: 11]      |        raw:                                                  'd'
[L: 13, P: 12]      |        whitespace:                                           ' '
[L: 13, P: 13]      |        raw:                                                  'ON'
[L: 13, P: 15]      |        whitespace:                                           ' '
[L: 13, P: 16]      |        bracketed:
[L: 13, P: 16]      |            start_bracket:                                    '('
[L: 13, P: 17]      |            raw:                                              'tbl'
[L: 13, P: 20]      |            raw:                                              '.'
[L: 13, P: 21]      |            raw:                                              'id'
[L: 13, P: 23]      |            whitespace:                                       ' '
[L: 13, P: 24]      |            raw:                                              '='
[L: 13, P: 25]      |            whitespace:                                       ' '
[L: 13, P: 26]      |            raw:                                              'd'
[L: 13, P: 27]      |            raw:                                              '.'
[L: 13, P: 28]      |            raw:                                              'other_id'
[L: 13, P: 36]      |            end_bracket:                                      ')'
[L: 13, P: 37]      |    newline:                                                  '\n'
[L: 14, P:  1]      |    orderby_clause:
[L: 14, P:  1]      |        keyword:                                              'ORDER'
[L: 14, P:  6]      |        whitespace:                                           ' '
[L: 14, P:  7]      |        keyword:                                              'BY'
[L: 14, P:  9]      |        whitespace:                                           ' '
[L: 14, P: 10]      |        raw:                                                  'tbl'
[L: 14, P: 13]      |        raw:                                                  '.'
[L: 14, P: 14]      |        raw:                                                  'name'
[L: 14, P: 18]      |        whitespace:                                           ' '
[L: 14, P: 19]      |        raw:                                                  'ASC'

INFO       
###
#
# Parse Depth 3. Expanding: SelectClauseSegment: 'SELECT\n    tbl.name,\n    b.value,\n    /*...'
#
###
DEBUG      [PD:3  MD:1 ]	.SelectClauseSegmentGrammar                       	Ref.match OUT       	+   	[match=<MatchResult 1/56: 'SELECT'>, seg="'SELECT\\n    tbl.name,...'"]
INFO       [PD:3  MD:2 ]	..SelectClauseModifierSegment                     	OneOf.match PRN     	    	[ns=0, ps=2, ms=0, pruned=[<Ref: DistinctKeywordSegment>, <Ref: AllKeywordSegment>], opts='ALL']
INFO       [PD:3  MD:2 ]	..SelectClauseModifierSegment                     	OneOf.match OUT     	    	[match=<MatchResult 0/53: ''>, seg="'tbl.name,\\n    b.valu...'"]
DEBUG      [PD:3  MD:1 ]	.SelectClauseModifierSegment                      	Selec.match OUT     	    	[match=<MatchResult 0/53: ''>, seg="'tbl.name,\\n    b.valu...'"]
DEBUG      [PD:3  MD:1 ]	.SelectClauseSegmentGrammar                       	Ref.match OUT       	    	[match=<MatchResult 0/53: ''>, seg="'tbl.name,\\n    b.valu...'"]
DEBUG      [PD:3  MD:2 ]	..SelectClauseSegmentGrammar                      	Delim._look_ahead_match IN	    	[ls=53, seg='tbl.name,\n    b.valu...']
DEBUG      [PD:3  MD:2 ]	..SelectClauseSegmentGrammar                      	Delim._look_ahead_match SI	    	[mq=[(<Ref: CommaSegment>, 3, ','), (<Ref: CommaSegment>, 9, ','), (<Ref: CommaSegment>, 24, ','), (<Ref: CommaSegment>, 32, ',')], sb=['TBL', '.', 'NAME', ',', '', '', 'B', '.', 'VALUE', ',', '', '', '/*', '', '', 'THIS', '', '', '*/', '', '', 'D', '.', 'SOMETHING', ',', '', '--', '', '', 'TBL', '.', 'FOO', ',', '', '', 'C', '.', 'VAL', '', '+', '', 'B', '.', 'VAL', '', '/', '', '-', '2', '', 'AS', '', 'A_CALCULATION']]
DEBUG      [PD:3  MD:2 ]	..SelectClauseSegmentGrammar                      	Ref.match OUT       	+   	[match=<MatchResult 1/21: ','>, seg="',\\n    c.val + b.val ...'"]
DEBUG      [PD:3  MD:2 ]	..SelectClauseSegmentGrammar                      	Ref.match OUT       	+   	[match=<MatchResult 1/29: ','>, seg="',    -- Which a comm...'"]
DEBUG      [PD:3  MD:2 ]	..SelectClauseSegmentGrammar                      	Ref.match OUT       	+   	[match=<MatchResult 1/44: ','>, seg="',\\n    /*\\n    This is...'"]
DEBUG      [PD:3  MD:2 ]	..SelectClauseSegmentGrammar                      	Ref.match OUT       	+   	[match=<MatchResult 1/50: ','>, seg="',\\n    b.value,\\n    /...'"]
DEBUG      [PD:3  MD:2 ]	..SelectClauseSegmentGrammar                      	Delim._look_ahead_match SC	    	[bsm=(3, 1, <Ref: CommaSegment>)]
DEBUG      [PD:3  MD:4 ]	....SelectClauseElementSegment                    	Greed._look_ahead_match IN	    	[ls=3, seg='tbl.name']
DEBUG      [PD:3  MD:4 ]	....SelectClauseElementSegment                    	Greed._look_ahead_match SI	    	[mq=[], sb=['TBL', '.', 'NAME']]
DEBUG      [PD:3  MD:4 ]	....SelectClauseElementSegment                    	Greed._look_ahead_match SC	    	[bsm=None]
INFO       [PD:3  MD:3 ]	...SelectClauseElementSegment                     	Greed.match OUT     	++  	[match=<MatchResult 3/3: 'tbl.name'>, seg="'tbl.name'"]
DEBUG      [PD:3  MD:2 ]	..SelectClauseElementSegment                      	Selec.match OUT     	++  	[match=<MatchResult 1/1: 'tbl.name'>, seg="'tbl.name'"]
DEBUG      [PD:3  MD:2 ]	..SelectClauseSegmentGrammar                      	Ref.match OUT       	++  	[match=<MatchResult 1/1: 'tbl.name'>, seg="'tbl.name'"]
DEBUG      [PD:3  MD:2 ]	..SelectClauseSegmentGrammar                      	Delim._look_ahead_match IN	    	[ls=49, seg='\n    b.value,\n    /*...']
DEBUG      [PD:3  MD:2 ]	..SelectClauseSegmentGrammar                      	Delim._look_ahead_match SI	    	[mq=[(<Ref: CommaSegment>, 5, ','), (<Ref: CommaSegment>, 20, ','), (<Ref: CommaSegment>, 28, ',')], sb=['', '', 'B', '.', 'VALUE', ',', '', '', '/*', '', '', 'THIS', '', '', '*/', '', '', 'D', '.', 'SOMETHING', ',', '', '--', '', '', 'TBL', '.', 'FOO', ',', '', '', 'C', '.', 'VAL', '', '+', '', 'B', '.', 'VAL', '', '/', '', '-', '2', '', 'AS', '', 'A_CALCULATION']]
DEBUG      [PD:3  MD:2 ]	..SelectClauseSegmentGrammar                      	Ref.match OUT       	+   	[match=<MatchResult 1/21: ','>, seg="',\\n    c.val + b.val ...'"]
DEBUG      [PD:3  MD:2 ]	..SelectClauseSegmentGrammar                      	Ref.match OUT       	+   	[match=<MatchResult 1/29: ','>, seg="',    -- Which a comm...'"]
DEBUG      [PD:3  MD:2 ]	..SelectClauseSegmentGrammar                      	Ref.match OUT       	+   	[match=<MatchResult 1/44: ','>, seg="',\\n    /*\\n    This is...'"]
DEBUG      [PD:3  MD:2 ]	..SelectClauseSegmentGrammar                      	Delim._look_ahead_match SC	    	[bsm=(5, 1, <Ref: CommaSegment>)]
DEBUG      [PD:3  MD:4 ]	....SelectClauseElementSegment                    	Greed._look_ahead_match IN	    	[ls=3, seg='b.value']
DEBUG      [PD:3  MD:4 ]	....SelectClauseElementSegment                    	Greed._look_ahead_match SI	    	[mq=[], sb=['B', '.', 'VALUE']]
DEBUG      [PD:3  MD:4 ]	....SelectClauseElementSegment                    	Greed._look_ahead_match SC	    	[bsm=None]
INFO       [PD:3  MD:3 ]	...SelectClauseElementSegment                     	Greed.match OUT     	++  	[match=<MatchResult 3/3: 'b.value'>, seg="'b.value'"]
DEBUG      [PD:3  MD:2 ]	..SelectClauseElementSegment                      	Selec.match OUT     	++  	[match=<MatchResult 1/1: 'b.value'>, seg="'b.value'"]
DEBUG      [PD:3  MD:2 ]	..SelectClauseSegmentGrammar                      	Ref.match OUT       	++  	[match=<MatchResult 1/1: 'b.value'>, seg="'b.value'"]
DEBUG      [PD:3  MD:2 ]	..SelectClauseSegmentGrammar                      	Delim._look_ahead_match IN	    	[ls=43, seg='\n    /*\n    This is ...']
DEBUG      [PD:3  MD:2 ]	..SelectClauseSegmentGrammar                      	Delim._look_ahead_match SI	    	[mq=[(<Ref: CommaSegment>, 14, ','), (<Ref: CommaSegment>, 22, ',')], sb=['', '', '/*', '', '', 'THIS', '', '', '*/', '', '', 'D', '.', 'SOMETHING', ',', '', '--', '', '', 'TBL', '.', 'FOO', ',', '', '', 'C', '.', 'VAL', '', '+', '', 'B', '.', 'VAL', '', '/', '', '-', '2', '', 'AS', '', 'A_CALCULATION']]
DEBUG      [PD:3  MD:2 ]	..SelectClauseSegmentGrammar                      	Ref.match OUT       	+   	[match=<MatchResult 1/21: ','>, seg="',\\n    c.val + b.val ...'"]
DEBUG      [PD:3  MD:2 ]	..SelectClauseSegmentGrammar                      	Ref.match OUT       	+   	[match=<MatchResult 1/29: ','>, seg="',    -- Which a comm...'"]
DEBUG      [PD:3  MD:2 ]	..SelectClauseSegmentGrammar                      	Delim._look_ahead_match SC	    	[bsm=(14, 1, <Ref: CommaSegment>)]
DEBUG      [PD:3  MD:4 ]	....SelectClauseElementSegment                    	Greed._look_ahead_match IN	    	[ls=3, seg='d.something']
DEBUG      [PD:3  MD:4 ]	....SelectClauseElementSegment                    	Greed._look_ahead_match SI	    	[mq=[], sb=['D', '.', 'SOMETHING']]
DEBUG      [PD:3  MD:4 ]	....SelectClauseElementSegment                    	Greed._look_ahead_match SC	    	[bsm=None]
INFO       [PD:3  MD:3 ]	...SelectClauseElementSegment                     	Greed.match OUT     	++  	[match=<MatchResult 3/3: 'd.something'>, seg="'d.something'"]
DEBUG      [PD:3  MD:2 ]	..SelectClauseElementSegment                      	Selec.match OUT     	++  	[match=<MatchResult 1/1: 'd.something'>, seg="'d.something'"]
DEBUG      [PD:3  MD:2 ]	..SelectClauseSegmentGrammar                      	Ref.match OUT       	++  	[match=<MatchResult 1/1: 'd.something'>, seg="'d.something'"]
DEBUG      [PD:3  MD:2 ]	..SelectClauseSegmentGrammar                      	Delim._look_ahead_match IN	    	[ls=28, seg='    -- Which a comme...']
DEBUG      [PD:3  MD:2 ]	..SelectClauseSegmentGrammar                      	Delim._look_ahead_match SI	    	[mq=[(<Ref: CommaSegment>, 7, ',')], sb=['', '--', '', '', 'TBL', '.', 'FOO', ',', '', '', 'C', '.', 'VAL', '', '+', '', 'B', '.', 'VAL', '', '/', '', '-', '2', '', 'AS', '', 'A_CALCULATION']]
DEBUG      [PD:3  MD:2 ]	..SelectClauseSegmentGrammar                      	Ref.match OUT       	+   	[match=<MatchResult 1/21: ','>, seg="',\\n    c.val + b.val ...'"]
DEBUG      [PD:3  MD:2 ]	..SelectClauseSegmentGrammar                      	Delim._look_ahead_match SC	    	[bsm=(7, 1, <Ref: CommaSegment>)]
DEBUG      [PD:3  MD:4 ]	....SelectClauseElementSegment                    	Greed._look_ahead_match IN	    	[ls=3, seg='tbl.foo']
DEBUG      [PD:3  MD:4 ]	....SelectClauseElementSegment                    	Greed._look_ahead_match SI	    	[mq=[], sb=['TBL', '.', 'FOO']]
DEBUG      [PD:3  MD:4 ]	....SelectClauseElementSegment                    	Greed._look_ahead_match SC	    	[bsm=None]
INFO       [PD:3  MD:3 ]	...SelectClauseElementSegment                     	Greed.match OUT     	++  	[match=<MatchResult 3/3: 'tbl.foo'>, seg="'tbl.foo'"]
DEBUG      [PD:3  MD:2 ]	..SelectClauseElementSegment                      	Selec.match OUT     	++  	[match=<MatchResult 1/1: 'tbl.foo'>, seg="'tbl.foo'"]
DEBUG      [PD:3  MD:2 ]	..SelectClauseSegmentGrammar                      	Ref.match OUT       	++  	[match=<MatchResult 1/1: 'tbl.foo'>, seg="'tbl.foo'"]
DEBUG      [PD:3  MD:2 ]	..SelectClauseSegmentGrammar                      	Delim._look_ahead_match IN	    	[ls=20, seg='\n    c.val + b.val /...']
DEBUG      [PD:3  MD:2 ]	..SelectClauseSegmentGrammar                      	Delim._look_ahead_match SI	    	[mq=[], sb=['', '', 'C', '.', 'VAL', '', '+', '', 'B', '.', 'VAL', '', '/', '', '-', '2', '', 'AS', '', 'A_CALCULATION']]
DEBUG      [PD:3  MD:2 ]	..SelectClauseSegmentGrammar                      	Delim._look_ahead_match SC	    	[bsm=None]
DEBUG      [PD:3  MD:4 ]	....SelectClauseElementSegment                    	Greed._look_ahead_match IN	    	[ls=18, seg='c.val + b.val / -2 A...']
DEBUG      [PD:3  MD:4 ]	....SelectClauseElementSegment                    	Greed._look_ahead_match SI	    	[mq=[], sb=['C', '.', 'VAL', '', '+', '', 'B', '.', 'VAL', '', '/', '', '-', '2', '', 'AS', '', 'A_CALCULATION']]
DEBUG      [PD:3  MD:4 ]	....SelectClauseElementSegment                    	Greed._look_ahead_match SC	    	[bsm=None]
INFO       [PD:3  MD:3 ]	...SelectClauseElementSegment                     	Greed.match OUT     	++  	[match=<MatchResult 18/18: 'c.val + b.val /...S a_calculation'>, seg="'c.val + b.val / -2 A...'"]
DEBUG      [PD:3  MD:2 ]	..SelectClauseElementSegment                      	Selec.match OUT     	++  	[match=<MatchResult 1/1: 'c.val + b.val /...S a_calculation'>, seg="'c.val + b.val / -2 A...'"]
DEBUG      [PD:3  MD:2 ]	..SelectClauseSegmentGrammar                      	Ref.match OUT       	++  	[match=<MatchResult 1/1: 'c.val + b.val /...S a_calculation'>, seg="'c.val + b.val / -2 A...'"]
INFO       [PD:3  MD:1 ]	.SelectClauseSegmentGrammar                       	Delim.match OUT     	++  	[match=<MatchResult 28/28: 'tbl.name,\n    b...S a_calculation'>, seg="'tbl.name,\\n    b.valu...'"]
INFO       [PD:3  MD:0 ]	SelectClauseSegmentGrammar                        	Seque.match OUT     	++  	[match=<MatchResult 32/32: 'SELECT\n    tbl....S a_calculation'>, seg="'SELECT\\n    tbl.name,...'"]
DEBUG      [PD:3  MD:0 ]	SelectClauseSegment                               	Ref.match OUT       	++  	[match=<MatchResult 32/32: 'SELECT\n    tbl....S a_calculation'>, seg="'SELECT\\n    tbl.name,...'"]
DEBUG      SelectClauseSegment.parse: Done Parse. Plotting Recursion. Recurse=True
DEBUG      ###
#
# Beginning Parse Depth 4: SelectClauseSegment
#
###
Initial Structure:
[L:  1, P:  1]      |select_clause:
[L:  1, P:  1]      |    keyword:                                                  'SELECT'
[L:  1, P:  7]      |    [META] indent:
[L:  1, P:  7]      |    newline:                                                  '\n'
[L:  2, P:  1]      |    whitespace:                                               '    '
[L:  2, P:  5]      |    select_clause_element:
[L:  2, P:  5]      |        raw:                                                  'tbl'
[L:  2, P:  8]      |        raw:                                                  '.'
[L:  2, P:  9]      |        raw:                                                  'name'
[L:  2, P: 13]      |    comma:                                                    ','
[L:  2, P: 14]      |    newline:                                                  '\n'
[L:  3, P:  1]      |    whitespace:                                               '    '
[L:  3, P:  5]      |    select_clause_element:
[L:  3, P:  5]      |        raw:                                                  'b'
[L:  3, P:  6]      |        raw:                                                  '.'
[L:  3, P:  7]      |        raw:                                                  'value'
[L:  3, P: 12]      |    comma:                                                    ','
[L:  3, P: 13]      |    newline:                                                  '\n'
[L:  4, P:  1]      |    whitespace:                                               '    '
[L:  4, P:  5]      |    comment:                                                  '/*'
[L:  4, P:  7]      |    newline:                                                  '\n'
[L:  5, P:  1]      |    whitespace:                                               '    '
[L:  5, P:  5]      |    comment:                                                  'This is a block comment'
[L:  5, P: 28]      |    newline:                                                  '\n'
[L:  6, P:  1]      |    whitespace:                                               '    '
[L:  6, P:  5]      |    comment:                                                  '*/'
[L:  6, P:  7]      |    newline:                                                  '\n'
[L:  7, P:  1]      |    whitespace:                                               '    '
[L:  7, P:  5]      |    select_clause_element:
[L:  7, P:  5]      |        raw:                                                  'd'
[L:  7, P:  6]      |        raw:                                                  '.'
[L:  7, P:  7]      |        raw:                                                  'something'
[L:  7, P: 16]      |    comma:                                                    ','
[L:  7, P: 17]      |    whitespace:                                               '    '
[L:  7, P: 21]      |    comment:                                                  '-- Which a comment after it'
[L:  7, P: 48]      |    newline:                                                  '\n'
[L:  8, P:  1]      |    whitespace:                                               '    '
[L:  8, P:  5]      |    select_clause_element:
[L:  8, P:  5]      |        raw:                                                  'tbl'
[L:  8, P:  8]      |        raw:                                                  '.'
[L:  8, P:  9]      |        raw:                                                  'foo'
[L:  8, P: 12]      |    comma:                                                    ','
[L:  8, P: 13]      |    newline:                                                  '\n'
[L:  9, P:  1]      |    whitespace:                                               '    '
[L:  9, P:  5]      |    select_clause_element:
[L:  9, P:  5]      |        raw:                                                  'c'
[L:  9, P:  6]      |        raw:                                                  '.'
[L:  9, P:  7]      |        raw:                                                  'val'
[L:  9, P: 10]      |        whitespace:                                           ' '
[L:  9, P: 11]      |        raw:                                                  '+'
[L:  9, P: 12]      |        whitespace:                                           ' '
[L:  9, P: 13]      |        raw:                                                  'b'
[L:  9, P: 14]      |        raw:                                                  '.'
[L:  9, P: 15]      |        raw:                                                  'val'
[L:  9, P: 18]      |        whitespace:                                           ' '
[L:  9, P: 19]      |        raw:                                                  '/'
[L:  9, P: 20]      |        whitespace:                                           ' '
[L:  9, P: 21]      |        raw:                                                  '-'
[L:  9, P: 22]      |        raw:                                                  '2'
[L:  9, P: 23]      |        whitespace:                                           ' '
[L:  9, P: 24]      |        raw:                                                  'AS'
[L:  9, P: 26]      |        whitespace:                                           ' '
[L:  9, P: 27]      |        raw:                                                  'a_calculation'

INFO       [PD:4] Skipping expansion of <KeywordSegment: ([L:  1, P:  1]) 'SELECT'>...
INFO       [PD:4] Skipping expansion of <Indent: ([L:  1, P:  7]) ''>...
INFO       [PD:4] Skipping expansion of <NewlineSegment: ([L:  1, P:  7]) '\n'>...
INFO       [PD:4] Skipping expansion of <WhitespaceSegment: ([L:  2, P:  1]) '    '>...
INFO       
###
#
# Parse Depth 4. Expanding: SelectClauseElementSegment: 'tbl.name'
#
###
INFO       [PD:4  MD:0 ]	SelectClauseElementSegment                        	OneOf.match PRN     	    	[ns=2, ps=0, ms=0, pruned=[], opts=[<Ref: WildcardExpressionSegment>, <Sequence: [<Ref: BaseExpressionElementGrammar>, <Ref: AliasExpressionSegment [opt]>]>]]
INFO       [PD:4  MD:5 ]	.....WildcardIdentifierSegment                    	AnyNu.match PRN     	    	[ns=1, ps=0, ms=0, pruned=[], opts=[<Sequence: [<Ref: SingleIdentifierGrammar>, <Ref: DotSegment>]>]]
INFO       [PD:4  MD:7 ]	.......SingleIdentifierGrammar                    	OneOf.match PRN     	    	[ns=2, ps=0, ms=0, pruned=[], opts=[<Ref: NakedIdentifierSegment>, <Ref: QuotedIdentifierSegment>]]
DEBUG      [PD:4  MD:8 ]	........SingleIdentifierGrammar                   	Ref.match OUT       	+   	[match=<MatchResult 1/3: 'tbl'>, seg="'tbl.name'"]
DEBUG      [PD:4  MD:8 ]	........SingleIdentifierGrammar                   	Ref.match OUT       	    	[match=<MatchResult 0/3: ''>, seg="'tbl.name'"]
INFO       [PD:4  MD:7 ]	.......SingleIdentifierGrammar                    	OneOf.match OUT     	+   	[match=<MatchResult 1/3: 'tbl'>, seg="'tbl.name'"]
DEBUG      [PD:4  MD:7 ]	.......WildcardIdentifierSegment                  	Ref.match OUT       	+   	[match=<MatchResult 1/3: 'tbl'>, seg="'tbl.name'"]
DEBUG      [PD:4  MD:7 ]	.......WildcardIdentifierSegment                  	Ref.match OUT       	+   	[match=<MatchResult 1/2: '.'>, seg="'.name'"]
INFO       [PD:4  MD:6 ]	......WildcardIdentifierSegment                   	Seque.match OUT     	+   	[match=<MatchResult 2/3: 'tbl.'>, seg="'tbl.name'"]
INFO       [PD:4  MD:5 ]	.....WildcardIdentifierSegment                    	AnyNu.match PRN     	    	[ns=1, ps=0, ms=0, pruned=[], opts=[<Sequence: [<Ref: SingleIdentifierGrammar>, <Ref: DotSegment>]>]]
INFO       [PD:4  MD:7 ]	.......SingleIdentifierGrammar                    	OneOf.match PRN     	    	[ns=2, ps=0, ms=0, pruned=[], opts=[<Ref: NakedIdentifierSegment>, <Ref: QuotedIdentifierSegment>]]
DEBUG      [PD:4  MD:8 ]	........SingleIdentifierGrammar                   	Ref.match OUT       	++  	[match=<MatchResult 1/1: 'name'>, seg="'name'"]
INFO       [PD:4  MD:7 ]	.......SingleIdentifierGrammar                    	OneOf.match OUT     	++  	[match=<MatchResult 1/1: 'name'>, seg="'name'"]
DEBUG      [PD:4  MD:7 ]	.......WildcardIdentifierSegment                  	Ref.match OUT       	++  	[match=<MatchResult 1/1: 'name'>, seg="'name'"]
INFO       [PD:4  MD:6 ]	......WildcardIdentifierSegment                   	Seque.match OUT     	    	[match=<MatchResult 0/1: ''>, seg="'name'"]
INFO       [PD:4  MD:5 ]	.....WildcardIdentifierSegment                    	AnyNu.match OUT     	+   	[match=<MatchResult 2/3: 'tbl.'>, seg="'tbl.name'"]
DEBUG      [PD:4  MD:5 ]	.....WildcardIdentifierSegment                    	Ref.match OUT       	    	[match=<MatchResult 0/1: ''>, seg="'name'"]
INFO       [PD:4  MD:4 ]	....WildcardIdentifierSegment                     	Seque.match OUT     	    	[match=<MatchResult 0/3: ''>, seg="'tbl.name'"]
DEBUG      [PD:4  MD:3 ]	...WildcardIdentifierSegment                      	Wildc.match OUT     	    	[match=<MatchResult 0/3: ''>, seg="'tbl.name'"]
DEBUG      [PD:4  MD:3 ]	...WildcardExpressionSegment                      	Ref.match OUT       	    	[match=<MatchResult 0/3: ''>, seg="'tbl.name'"]
INFO       [PD:4  MD:2 ]	..WildcardExpressionSegment                       	Seque.match OUT     	    	[match=<MatchResult 0/3: ''>, seg="'tbl.name'"]
DEBUG      [PD:4  MD:1 ]	.WildcardExpressionSegment                        	Wildc.match OUT     	    	[match=<MatchResult 0/3: ''>, seg="'tbl.name'"]
DEBUG      [PD:4  MD:1 ]	.SelectClauseElementSegment                       	Ref.match OUT       	    	[match=<MatchResult 0/3: ''>, seg="'tbl.name'"]
INFO       [PD:4  MD:2 ]	..BaseExpressionElementGrammar                    	OneOf.match PRN     	    	[ns=5, ps=1, ms=0, pruned=[<Ref: IntervalExpressionSegment>], opts=[<Ref: LiteralGrammar>, <Ref: BareFunctionSegment>, <Ref: FunctionSegment>, <Ref: ColumnReferenceSegment>, <Ref: ExpressionSegment>]]
INFO       [PD:4  MD:3 ]	...LiteralGrammar                                 	OneOf.match PRN     	    	[ns=2, ps=4, ms=0, pruned=[<Ref: BooleanLiteralGrammar>, <Ref: QualifiedNumericLiteralSegment>, <Ref: NullLiteralSegment>, <Ref: DateTimeLiteralGrammar>], opts=[<Ref: QuotedLiteralSegment>, <Ref: NumericLiteralSegment>]]
DEBUG      [PD:4  MD:4 ]	....LiteralGrammar                                	Ref.match OUT       	    	[match=<MatchResult 0/3: ''>, seg="'tbl.name'"]
DEBUG      [PD:4  MD:4 ]	....LiteralGrammar                                	Ref.match OUT       	    	[match=<MatchResult 0/3: ''>, seg="'tbl.name'"]
INFO       [PD:4  MD:3 ]	...LiteralGrammar                                 	OneOf.match OUT     	    	[match=<MatchResult 0/3: ''>, seg="'tbl.name'"]
DEBUG      [PD:4  MD:3 ]	...BaseExpressionElementGrammar                   	Ref.match OUT       	    	[match=<MatchResult 0/3: ''>, seg="'tbl.name'"]
DEBUG      [PD:4  MD:3 ]	...BaseExpressionElementGrammar                   	Ref.match OUT       	    	[match=<MatchResult 0/3: ''>, seg="'tbl.name'"]
INFO       [PD:4  MD:4 ]	....FunctionSegment                               	OneOf.match PRN     	    	[ns=1, ps=1, ms=0, pruned=[<Sequence: [<Sequence: [<Ref: DateAddFunctionNameSeg...]>], opts=[<Sequence: [<Sequence: [<AnyNumberOf: [<Ref: Functio..., <Ref: PostFunctionGrammar [opt]>]>]]
DEBUG      [PD:4  MD:10]	..........DateAddFunctionNameSegment              	Ref.match OUT       	    	[match=<MatchResult 0/3: ''>, seg="'tbl.name'"]
INFO       [PD:4  MD:9 ]	.........DateAddFunctionNameSegment               	Seque.match OUT     	    	[match=<MatchResult 0/3: ''>, seg="'tbl.name'"]
DEBUG      [PD:4  MD:8 ]	........DateAddFunctionNameSegment                	DateA.match OUT     	    	[match=<MatchResult 0/3: ''>, seg="'tbl.name'"]
DEBUG      [PD:4  MD:8 ]	........FunctionSegment                           	Ref.match OUT       	    	[match=<MatchResult 0/3: ''>, seg="'tbl.name'"]
INFO       [PD:4  MD:7 ]	.......FunctionSegment                            	AnyNu.match PRN     	    	[ns=1, ps=0, ms=0, pruned=[], opts=[<Ref: FunctionNameSegment>]]
INFO       [PD:4  MD:10]	..........FunctionNameSegment                     	AnyNu.match PRN     	    	[ns=1, ps=0, ms=0, pruned=[], opts=[<Sequence: [<Ref: SingleIdentifierGrammar>, <Ref: DotSegment>]>]]
INFO       [PD:4  MD:12]	............SingleIdentifierGrammar               	OneOf.match PRN     	    	[ns=2, ps=0, ms=0, pruned=[], opts=[<Ref: NakedIdentifierSegment>, <Ref: QuotedIdentifierSegment>]]
DEBUG      [PD:4  MD:13]	.............SingleIdentifierGrammar              	Ref.match OUT       	+   	[match=<MatchResult 1/3: 'tbl'>, seg="'tbl.name'"]
DEBUG      [PD:4  MD:13]	.............SingleIdentifierGrammar              	Ref.match OUT       	    	[match=<MatchResult 0/3: ''>, seg="'tbl.name'"]
INFO       [PD:4  MD:12]	............SingleIdentifierGrammar               	OneOf.match OUT     	+   	[match=<MatchResult 1/3: 'tbl'>, seg="'tbl.name'"]
DEBUG      [PD:4  MD:12]	............FunctionNameSegment                   	Ref.match OUT       	+   	[match=<MatchResult 1/3: 'tbl'>, seg="'tbl.name'"]
DEBUG      [PD:4  MD:12]	............FunctionNameSegment                   	Ref.match OUT       	+   	[match=<MatchResult 1/2: '.'>, seg="'.name'"]
INFO       [PD:4  MD:11]	...........FunctionNameSegment                    	Seque.match OUT     	+   	[match=<MatchResult 2/3: 'tbl.'>, seg="'tbl.name'"]
INFO       [PD:4  MD:10]	..........FunctionNameSegment                     	AnyNu.match PRN     	    	[ns=1, ps=0, ms=0, pruned=[], opts=[<Sequence: [<Ref: SingleIdentifierGrammar>, <Ref: DotSegment>]>]]
INFO       [PD:4  MD:12]	............SingleIdentifierGrammar               	OneOf.match PRN     	    	[ns=2, ps=0, ms=0, pruned=[], opts=[<Ref: NakedIdentifierSegment>, <Ref: QuotedIdentifierSegment>]]
DEBUG      [PD:4  MD:13]	.............SingleIdentifierGrammar              	Ref.match OUT       	++  	[match=<MatchResult 1/1: 'name'>, seg="'name'"]
INFO       [PD:4  MD:12]	............SingleIdentifierGrammar               	OneOf.match OUT     	++  	[match=<MatchResult 1/1: 'name'>, seg="'name'"]
DEBUG      [PD:4  MD:12]	............FunctionNameSegment                   	Ref.match OUT       	++  	[match=<MatchResult 1/1: 'name'>, seg="'name'"]
INFO       [PD:4  MD:11]	...........FunctionNameSegment                    	Seque.match OUT     	    	[match=<MatchResult 0/1: ''>, seg="'name'"]
INFO       [PD:4  MD:10]	..........FunctionNameSegment                     	AnyNu.match OUT     	+   	[match=<MatchResult 2/3: 'tbl.'>, seg="'tbl.name'"]
INFO       [PD:4  MD:10]	..........FunctionNameSegment                     	OneOf.match PRN     	    	[ns=2, ps=0, ms=0, pruned=[], opts=[<Ref: FunctionNameIdentifierSegment>, <Ref: QuotedIdentifierSegment>]]
DEBUG      [PD:4  MD:11]	...........FunctionNameSegment                    	Ref.match OUT       	++  	[match=<MatchResult 1/1: 'name'>, seg="'name'"]
INFO       [PD:4  MD:10]	..........FunctionNameSegment                     	OneOf.match OUT     	++  	[match=<MatchResult 1/1: 'name'>, seg="'name'"]
INFO       [PD:4  MD:9 ]	.........FunctionNameSegment                      	Seque.match OUT     	++  	[match=<MatchResult 3/3: 'tbl.name'>, seg="'tbl.name'"]
DEBUG      [PD:4  MD:8 ]	........FunctionNameSegment                       	Funct.match OUT     	++  	[match=<MatchResult 1/1: 'tbl.name'>, seg="'tbl.name'"]
DEBUG      [PD:4  MD:8 ]	........FunctionSegment                           	Ref.match OUT       	++  	[match=<MatchResult 1/1: 'tbl.name'>, seg="'tbl.name'"]
INFO       [PD:4  MD:7 ]	.......FunctionSegment                            	AnyNu.match OUT     	++  	[match=<MatchResult 1/1: 'tbl.name'>, seg="'tbl.name'"]
INFO       [PD:4  MD:6 ]	......FunctionSegment                             	Seque.match OUT     	    	[match=<MatchResult 0/3: ''>, seg="'tbl.name'"]
INFO       [PD:4  MD:5 ]	.....FunctionSegment                              	Seque.match OUT     	    	[match=<MatchResult 0/3: ''>, seg="'tbl.name'"]
INFO       [PD:4  MD:4 ]	....FunctionSegment                               	OneOf.match OUT     	    	[match=<MatchResult 0/3: ''>, seg="'tbl.name'"]
DEBUG      [PD:4  MD:3 ]	...FunctionSegment                                	Funct.match OUT     	    	[match=<MatchResult 0/3: ''>, seg="'tbl.name'"]
DEBUG      [PD:4  MD:3 ]	...BaseExpressionElementGrammar                   	Ref.match OUT       	    	[match=<MatchResult 0/3: ''>, seg="'tbl.name'"]
DEBUG      [PD:4  MD:5 ]	.....ColumnReferenceSegment                       	Delim._look_ahead_match IN	    	[ls=3, seg='tbl.name']
DEBUG      [PD:4  MD:5 ]	.....ColumnReferenceSegment                       	Delim._look_ahead_match SI	    	[mq=[(<OneOf: [<Ref: DotSegment>, <Sequence: [<Ref: DotSegment>, <Ref: Dot...]>, 1, '.'), (<OneOf: [<Ref: DotSegment>, <Sequence: [<Ref: DotSegment>, <Ref: Dot...]>, 1, '.')], sb=['TBL', '.', 'NAME']]
INFO       [PD:4  MD:5 ]	.....ColumnReferenceSegment                       	OneOf.match PRN     	    	[ns=0, ps=0, ms=2, pruned=[], opts=[<Ref: DotSegment>, <Sequence: [<Ref: DotSegment>, <Ref: DotSegment>]>]]
DEBUG      [PD:4  MD:6 ]	......ColumnReferenceSegment                      	Ref.match OUT       	+   	[match=<MatchResult 1/2: '.'>, seg="'.name'"]
DEBUG      [PD:4  MD:7 ]	.......ColumnReferenceSegment                     	Ref.match OUT       	+   	[match=<MatchResult 1/2: '.'>, seg="'.name'"]
DEBUG      [PD:4  MD:7 ]	.......ColumnReferenceSegment                     	Ref.match OUT       	    	[match=<MatchResult 0/1: ''>, seg="'name'"]
INFO       [PD:4  MD:6 ]	......ColumnReferenceSegment                      	Seque.match OUT     	    	[match=<MatchResult 0/2: ''>, seg="'.name'"]
INFO       [PD:4  MD:5 ]	.....ColumnReferenceSegment                       	OneOf.match OUT     	+   	[match=<MatchResult 1/2: '.'>, seg="'.name'"]
INFO       [PD:4  MD:5 ]	.....ColumnReferenceSegment                       	OneOf.match PRN     	    	[ns=0, ps=0, ms=2, pruned=[], opts=[<Ref: DotSegment>, <Sequence: [<Ref: DotSegment>, <Ref: DotSegment>]>]]
DEBUG      [PD:4  MD:6 ]	......ColumnReferenceSegment                      	Ref.match OUT       	+   	[match=<MatchResult 1/2: '.'>, seg="'.name'"]
DEBUG      [PD:4  MD:7 ]	.......ColumnReferenceSegment                     	Ref.match OUT       	+   	[match=<MatchResult 1/2: '.'>, seg="'.name'"]
DEBUG      [PD:4  MD:7 ]	.......ColumnReferenceSegment                     	Ref.match OUT       	    	[match=<MatchResult 0/1: ''>, seg="'name'"]
INFO       [PD:4  MD:6 ]	......ColumnReferenceSegment                      	Seque.match OUT     	    	[match=<MatchResult 0/2: ''>, seg="'.name'"]
INFO       [PD:4  MD:5 ]	.....ColumnReferenceSegment                       	OneOf.match OUT     	+   	[match=<MatchResult 1/2: '.'>, seg="'.name'"]
INFO       [PD:4  MD:5 ]	.....ColumnReferenceSegment                       	OneOf.match PRN     	    	[ns=1, ps=10, ms=0, pruned=[<Ref: OnKeywordSegment>, <Ref: AsKeywordSegment>, <Ref: UsingKeywordSegment>, <Ref: CommaSegment>, <Ref: CastOperatorSegment>, <Ref: StartSquareBracketSegment>, <Ref: StartBracketSegment>, <Ref: ColonSegment>, <Ref: DelimiterSegment>, <class 'sqlfluff.core.parser.segments.base.BracketedSegment'>], opts=[<Ref: BinaryOperatorGrammar>]]
INFO       [PD:4  MD:6 ]	......BinaryOperatorGrammar                       	OneOf.match PRN     	    	[ns=1, ps=3, ms=0, pruned=[<Ref: ArithmeticBinaryOperatorGrammar>, <Ref: StringBinaryOperatorGrammar>, <Ref: BooleanBinaryOperatorGrammar>], opts=[<Ref: ComparisonOperatorGrammar>]]
INFO       [PD:4  MD:7 ]	.......ComparisonOperatorGrammar                  	OneOf.match PRN     	    	[ns=1, ps=7, ms=0, pruned=[<Ref: EqualsSegment>, <Ref: GreaterThanSegment>, <Ref: LessThanSegment>, <Ref: GreaterThanOrEqualToSegment>, <Ref: LessThanOrEqualToSegment>, <Ref: NotEqualToSegment_a>, <Ref: NotEqualToSegment_b>], opts=[<Ref: LikeOperatorSegment>]]
DEBUG      [PD:4  MD:8 ]	........ComparisonOperatorGrammar                 	Ref.match OUT       	    	[match=<MatchResult 0/3: ''>, seg="'tbl.name'"]
INFO       [PD:4  MD:7 ]	.......ComparisonOperatorGrammar                  	OneOf.match OUT     	    	[match=<MatchResult 0/3: ''>, seg="'tbl.name'"]
DEBUG      [PD:4  MD:7 ]	.......BinaryOperatorGrammar                      	Ref.match OUT       	    	[match=<MatchResult 0/3: ''>, seg="'tbl.name'"]
INFO       [PD:4  MD:6 ]	......BinaryOperatorGrammar                       	OneOf.match OUT     	    	[match=<MatchResult 0/3: ''>, seg="'tbl.name'"]
DEBUG      [PD:4  MD:6 ]	......ColumnReferenceSegment                      	Ref.match OUT       	    	[match=<MatchResult 0/3: ''>, seg="'tbl.name'"]
INFO       [PD:4  MD:5 ]	.....ColumnReferenceSegment                       	OneOf.match OUT     	    	[match=<MatchResult 0/3: ''>, seg="'tbl.name'"]
DEBUG      [PD:4  MD:5 ]	.....ColumnReferenceSegment                       	NonCo.match OUT     	    	[match=<MatchResult 0/3: ''>, seg="'tbl.name'"]
INFO       [PD:4  MD:5 ]	.....ColumnReferenceSegment                       	OneOf.match PRN     	    	[ns=1, ps=10, ms=0, pruned=[<Ref: OnKeywordSegment>, <Ref: AsKeywordSegment>, <Ref: UsingKeywordSegment>, <Ref: CommaSegment>, <Ref: CastOperatorSegment>, <Ref: StartSquareBracketSegment>, <Ref: StartBracketSegment>, <Ref: ColonSegment>, <Ref: DelimiterSegment>, <class 'sqlfluff.core.parser.segments.base.BracketedSegment'>], opts=[<Ref: BinaryOperatorGrammar>]]
INFO       [PD:4  MD:6 ]	......BinaryOperatorGrammar                       	OneOf.match PRN     	    	[ns=1, ps=3, ms=0, pruned=[<Ref: ArithmeticBinaryOperatorGrammar>, <Ref: StringBinaryOperatorGrammar>, <Ref: BooleanBinaryOperatorGrammar>], opts=[<Ref: ComparisonOperatorGrammar>]]
INFO       [PD:4  MD:7 ]	.......ComparisonOperatorGrammar                  	OneOf.match PRN     	    	[ns=1, ps=7, ms=0, pruned=[<Ref: EqualsSegment>, <Ref: GreaterThanSegment>, <Ref: LessThanSegment>, <Ref: GreaterThanOrEqualToSegment>, <Ref: LessThanOrEqualToSegment>, <Ref: NotEqualToSegment_a>, <Ref: NotEqualToSegment_b>], opts=[<Ref: LikeOperatorSegment>]]
DEBUG      [PD:4  MD:8 ]	........ComparisonOperatorGrammar                 	Ref.match OUT       	    	[match=<MatchResult 0/2: ''>, seg="'.name'"]
INFO       [PD:4  MD:7 ]	.......ComparisonOperatorGrammar                  	OneOf.match OUT     	    	[match=<MatchResult 0/2: ''>, seg="'.name'"]
DEBUG      [PD:4  MD:7 ]	.......BinaryOperatorGrammar                      	Ref.match OUT       	    	[match=<MatchResult 0/2: ''>, seg="'.name'"]
INFO       [PD:4  MD:6 ]	......BinaryOperatorGrammar                       	OneOf.match OUT     	    	[match=<MatchResult 0/2: ''>, seg="'.name'"]
DEBUG      [PD:4  MD:6 ]	......ColumnReferenceSegment                      	Ref.match OUT       	    	[match=<MatchResult 0/2: ''>, seg="'.name'"]
INFO       [PD:4  MD:5 ]	.....ColumnReferenceSegment                       	OneOf.match OUT     	    	[match=<MatchResult 0/2: ''>, seg="'.name'"]
DEBUG      [PD:4  MD:5 ]	.....ColumnReferenceSegment                       	NonCo.match OUT     	    	[match=<MatchResult 0/2: ''>, seg="'.name'"]
INFO       [PD:4  MD:5 ]	.....SingleIdentifierGrammar                      	OneOf.match PRN     	    	[ns=2, ps=0, ms=0, pruned=[], opts=[<Ref: NakedIdentifierSegment>, <Ref: QuotedIdentifierSegment>]]
DEBUG      [PD:4  MD:6 ]	......SingleIdentifierGrammar                     	Ref.match OUT       	++  	[match=<MatchResult 1/1: 'tbl'>, seg="'tbl'"]
INFO       [PD:4  MD:5 ]	.....SingleIdentifierGrammar                      	OneOf.match OUT     	++  	[match=<MatchResult 1/1: 'tbl'>, seg="'tbl'"]
DEBUG      [PD:4  MD:5 ]	.....ColumnReferenceSegment                       	Ref.match OUT       	++  	[match=<MatchResult 1/1: 'tbl'>, seg="'tbl'"]
DEBUG      [PD:4  MD:5 ]	.....ColumnReferenceSegment                       	Delim._look_ahead_match IN	    	[ls=1, seg='name']
DEBUG      [PD:4  MD:5 ]	.....ColumnReferenceSegment                       	Delim._look_ahead_match SI	    	[mq=[], sb=['NAME']]
INFO       [PD:4  MD:5 ]	.....ColumnReferenceSegment                       	OneOf.match PRN     	    	[ns=1, ps=10, ms=0, pruned=[<Ref: OnKeywordSegment>, <Ref: AsKeywordSegment>, <Ref: UsingKeywordSegment>, <Ref: CommaSegment>, <Ref: CastOperatorSegment>, <Ref: StartSquareBracketSegment>, <Ref: StartBracketSegment>, <Ref: ColonSegment>, <Ref: DelimiterSegment>, <class 'sqlfluff.core.parser.segments.base.BracketedSegment'>], opts=[<Ref: BinaryOperatorGrammar>]]
INFO       [PD:4  MD:6 ]	......BinaryOperatorGrammar                       	OneOf.match PRN     	    	[ns=1, ps=3, ms=0, pruned=[<Ref: ArithmeticBinaryOperatorGrammar>, <Ref: StringBinaryOperatorGrammar>, <Ref: BooleanBinaryOperatorGrammar>], opts=[<Ref: ComparisonOperatorGrammar>]]
INFO       [PD:4  MD:7 ]	.......ComparisonOperatorGrammar                  	OneOf.match PRN     	    	[ns=1, ps=7, ms=0, pruned=[<Ref: EqualsSegment>, <Ref: GreaterThanSegment>, <Ref: LessThanSegment>, <Ref: GreaterThanOrEqualToSegment>, <Ref: LessThanOrEqualToSegment>, <Ref: NotEqualToSegment_a>, <Ref: NotEqualToSegment_b>], opts=[<Ref: LikeOperatorSegment>]]
DEBUG      [PD:4  MD:8 ]	........ComparisonOperatorGrammar                 	Ref.match OUT       	    	[match=<MatchResult 0/1: ''>, seg="'name'"]
INFO       [PD:4  MD:7 ]	.......ComparisonOperatorGrammar                  	OneOf.match OUT     	    	[match=<MatchResult 0/1: ''>, seg="'name'"]
DEBUG      [PD:4  MD:7 ]	.......BinaryOperatorGrammar                      	Ref.match OUT       	    	[match=<MatchResult 0/1: ''>, seg="'name'"]
INFO       [PD:4  MD:6 ]	......BinaryOperatorGrammar                       	OneOf.match OUT     	    	[match=<MatchResult 0/1: ''>, seg="'name'"]
DEBUG      [PD:4  MD:6 ]	......ColumnReferenceSegment                      	Ref.match OUT       	    	[match=<MatchResult 0/1: ''>, seg="'name'"]
INFO       [PD:4  MD:5 ]	.....ColumnReferenceSegment                       	OneOf.match OUT     	    	[match=<MatchResult 0/1: ''>, seg="'name'"]
DEBUG      [PD:4  MD:5 ]	.....ColumnReferenceSegment                       	NonCo.match OUT     	    	[match=<MatchResult 0/1: ''>, seg="'name'"]
INFO       [PD:4  MD:5 ]	.....SingleIdentifierGrammar                      	OneOf.match PRN     	    	[ns=2, ps=0, ms=0, pruned=[], opts=[<Ref: NakedIdentifierSegment>, <Ref: QuotedIdentifierSegment>]]
DEBUG      [PD:4  MD:6 ]	......SingleIdentifierGrammar                     	Ref.match OUT       	++  	[match=<MatchResult 1/1: 'name'>, seg="'name'"]
INFO       [PD:4  MD:5 ]	.....SingleIdentifierGrammar                      	OneOf.match OUT     	++  	[match=<MatchResult 1/1: 'name'>, seg="'name'"]
DEBUG      [PD:4  MD:5 ]	.....ColumnReferenceSegment                       	Ref.match OUT       	++  	[match=<MatchResult 1/1: 'name'>, seg="'name'"]
INFO       [PD:4  MD:4 ]	....ColumnReferenceSegment                        	Delim.match OUT     	++  	[match=<MatchResult 3/3: 'tbl.name'>, seg="'tbl.name'"]
DEBUG      [PD:4  MD:3 ]	...ColumnReferenceSegment                         	Colum.match OUT     	++  	[match=<MatchResult 1/1: 'tbl.name'>, seg="'tbl.name'"]
DEBUG      [PD:4  MD:3 ]	...BaseExpressionElementGrammar                   	Ref.match OUT       	++  	[match=<MatchResult 1/1: 'tbl.name'>, seg="'tbl.name'"]
INFO       [PD:4  MD:2 ]	..BaseExpressionElementGrammar                    	OneOf.match OUT     	++  	[match=<MatchResult 1/1: 'tbl.name'>, seg="'tbl.name'"]
DEBUG      [PD:4  MD:2 ]	..SelectClauseElementSegment                      	Ref.match OUT       	++  	[match=<MatchResult 1/1: 'tbl.name'>, seg="'tbl.name'"]
INFO       [PD:4  MD:1 ]	.SelectClauseElementSegment                       	Seque.match OUT     	++  	[match=<MatchResult 1/1: 'tbl.name'>, seg="'tbl.name'"]
INFO       [PD:4  MD:0 ]	SelectClauseElementSegment                        	OneOf.match OUT     	++  	[match=<MatchResult 1/1: 'tbl.name'>, seg="'tbl.name'"]
DEBUG      SelectClauseElementSegment.parse: Done Parse. Plotting Recursion. Recurse=True
DEBUG      ###
#
# Beginning Parse Depth 5: SelectClauseElementSegment
#
###
Initial Structure:
[L:  2, P:  5]      |select_clause_element:
[L:  2, P:  5]      |    column_reference:
[L:  2, P:  5]      |        identifier:                                           'tbl'
[L:  2, P:  8]      |        dot:                                                  '.'
[L:  2, P:  9]      |        identifier:                                           'name'

INFO       [PD:5] Skipping expansion of <ColumnReferenceSegment: ([L:  2, P:  5])>...
INFO       [PD:4] Skipping expansion of <SymbolSegment: ([L:  2, P: 13]) ','>...
INFO       [PD:4] Skipping expansion of <NewlineSegment: ([L:  2, P: 14]) '\n'>...
INFO       [PD:4] Skipping expansion of <WhitespaceSegment: ([L:  3, P:  1]) '    '>...
INFO       
###
#
# Parse Depth 4. Expanding: SelectClauseElementSegment: 'b.value'
#
###
INFO       [PD:4  MD:0 ]	SelectClauseElementSegment                        	OneOf.match PRN     	    	[ns=2, ps=0, ms=0, pruned=[], opts=[<Ref: WildcardExpressionSegment>, <Sequence: [<Ref: BaseExpressionElementGrammar>, <Ref: AliasExpressionSegment [opt]>]>]]
INFO       [PD:4  MD:5 ]	.....WildcardIdentifierSegment                    	AnyNu.match PRN     	    	[ns=1, ps=0, ms=0, pruned=[], opts=[<Sequence: [<Ref: SingleIdentifierGrammar>, <Ref: DotSegment>]>]]
INFO       [PD:4  MD:7 ]	.......SingleIdentifierGrammar                    	OneOf.match PRN     	    	[ns=2, ps=0, ms=0, pruned=[], opts=[<Ref: NakedIdentifierSegment>, <Ref: QuotedIdentifierSegment>]]
DEBUG      [PD:4  MD:8 ]	........SingleIdentifierGrammar                   	Ref.match OUT       	+   	[match=<MatchResult 1/3: 'b'>, seg="'b.value'"]
DEBUG      [PD:4  MD:8 ]	........SingleIdentifierGrammar                   	Ref.match OUT       	    	[match=<MatchResult 0/3: ''>, seg="'b.value'"]
INFO       [PD:4  MD:7 ]	.......SingleIdentifierGrammar                    	OneOf.match OUT     	+   	[match=<MatchResult 1/3: 'b'>, seg="'b.value'"]
DEBUG      [PD:4  MD:7 ]	.......WildcardIdentifierSegment                  	Ref.match OUT       	+   	[match=<MatchResult 1/3: 'b'>, seg="'b.value'"]
DEBUG      [PD:4  MD:7 ]	.......WildcardIdentifierSegment                  	Ref.match OUT       	+   	[match=<MatchResult 1/2: '.'>, seg="'.value'"]
INFO       [PD:4  MD:6 ]	......WildcardIdentifierSegment                   	Seque.match OUT     	+   	[match=<MatchResult 2/3: 'b.'>, seg="'b.value'"]
INFO       [PD:4  MD:5 ]	.....WildcardIdentifierSegment                    	AnyNu.match PRN     	    	[ns=1, ps=0, ms=0, pruned=[], opts=[<Sequence: [<Ref: SingleIdentifierGrammar>, <Ref: DotSegment>]>]]
INFO       [PD:4  MD:7 ]	.......SingleIdentifierGrammar                    	OneOf.match PRN     	    	[ns=2, ps=0, ms=0, pruned=[], opts=[<Ref: NakedIdentifierSegment>, <Ref: QuotedIdentifierSegment>]]
DEBUG      [PD:4  MD:8 ]	........SingleIdentifierGrammar                   	Ref.match OUT       	++  	[match=<MatchResult 1/1: 'value'>, seg="'value'"]
INFO       [PD:4  MD:7 ]	.......SingleIdentifierGrammar                    	OneOf.match OUT     	++  	[match=<MatchResult 1/1: 'value'>, seg="'value'"]
DEBUG      [PD:4  MD:7 ]	.......WildcardIdentifierSegment                  	Ref.match OUT       	++  	[match=<MatchResult 1/1: 'value'>, seg="'value'"]
INFO       [PD:4  MD:6 ]	......WildcardIdentifierSegment                   	Seque.match OUT     	    	[match=<MatchResult 0/1: ''>, seg="'value'"]
INFO       [PD:4  MD:5 ]	.....WildcardIdentifierSegment                    	AnyNu.match OUT     	+   	[match=<MatchResult 2/3: 'b.'>, seg="'b.value'"]
DEBUG      [PD:4  MD:5 ]	.....WildcardIdentifierSegment                    	Ref.match OUT       	    	[match=<MatchResult 0/1: ''>, seg="'value'"]
INFO       [PD:4  MD:4 ]	....WildcardIdentifierSegment                     	Seque.match OUT     	    	[match=<MatchResult 0/3: ''>, seg="'b.value'"]
DEBUG      [PD:4  MD:3 ]	...WildcardIdentifierSegment                      	Wildc.match OUT     	    	[match=<MatchResult 0/3: ''>, seg="'b.value'"]
DEBUG      [PD:4  MD:3 ]	...WildcardExpressionSegment                      	Ref.match OUT       	    	[match=<MatchResult 0/3: ''>, seg="'b.value'"]
INFO       [PD:4  MD:2 ]	..WildcardExpressionSegment                       	Seque.match OUT     	    	[match=<MatchResult 0/3: ''>, seg="'b.value'"]
DEBUG      [PD:4  MD:1 ]	.WildcardExpressionSegment                        	Wildc.match OUT     	    	[match=<MatchResult 0/3: ''>, seg="'b.value'"]
DEBUG      [PD:4  MD:1 ]	.SelectClauseElementSegment                       	Ref.match OUT       	    	[match=<MatchResult 0/3: ''>, seg="'b.value'"]
INFO       [PD:4  MD:2 ]	..BaseExpressionElementGrammar                    	OneOf.match PRN     	    	[ns=5, ps=1, ms=0, pruned=[<Ref: IntervalExpressionSegment>], opts=[<Ref: LiteralGrammar>, <Ref: BareFunctionSegment>, <Ref: FunctionSegment>, <Ref: ColumnReferenceSegment>, <Ref: ExpressionSegment>]]
INFO       [PD:4  MD:3 ]	...LiteralGrammar                                 	OneOf.match PRN     	    	[ns=2, ps=4, ms=0, pruned=[<Ref: BooleanLiteralGrammar>, <Ref: QualifiedNumericLiteralSegment>, <Ref: NullLiteralSegment>, <Ref: DateTimeLiteralGrammar>], opts=[<Ref: QuotedLiteralSegment>, <Ref: NumericLiteralSegment>]]
DEBUG      [PD:4  MD:4 ]	....LiteralGrammar                                	Ref.match OUT       	    	[match=<MatchResult 0/3: ''>, seg="'b.value'"]
DEBUG      [PD:4  MD:4 ]	....LiteralGrammar                                	Ref.match OUT       	    	[match=<MatchResult 0/3: ''>, seg="'b.value'"]
INFO       [PD:4  MD:3 ]	...LiteralGrammar                                 	OneOf.match OUT     	    	[match=<MatchResult 0/3: ''>, seg="'b.value'"]
DEBUG      [PD:4  MD:3 ]	...BaseExpressionElementGrammar                   	Ref.match OUT       	    	[match=<MatchResult 0/3: ''>, seg="'b.value'"]
DEBUG      [PD:4  MD:3 ]	...BaseExpressionElementGrammar                   	Ref.match OUT       	    	[match=<MatchResult 0/3: ''>, seg="'b.value'"]
INFO       [PD:4  MD:4 ]	....FunctionSegment                               	OneOf.match PRN     	    	[ns=1, ps=1, ms=0, pruned=[<Sequence: [<Sequence: [<Ref: DateAddFunctionNameSeg...]>], opts=[<Sequence: [<Sequence: [<AnyNumberOf: [<Ref: Functio..., <Ref: PostFunctionGrammar [opt]>]>]]
DEBUG      [PD:4  MD:10]	..........DateAddFunctionNameSegment              	Ref.match OUT       	    	[match=<MatchResult 0/3: ''>, seg="'b.value'"]
INFO       [PD:4  MD:9 ]	.........DateAddFunctionNameSegment               	Seque.match OUT     	    	[match=<MatchResult 0/3: ''>, seg="'b.value'"]
DEBUG      [PD:4  MD:8 ]	........DateAddFunctionNameSegment                	DateA.match OUT     	    	[match=<MatchResult 0/3: ''>, seg="'b.value'"]
DEBUG      [PD:4  MD:8 ]	........FunctionSegment                           	Ref.match OUT       	    	[match=<MatchResult 0/3: ''>, seg="'b.value'"]
INFO       [PD:4  MD:7 ]	.......FunctionSegment                            	AnyNu.match PRN     	    	[ns=1, ps=0, ms=0, pruned=[], opts=[<Ref: FunctionNameSegment>]]
INFO       [PD:4  MD:10]	..........FunctionNameSegment                     	AnyNu.match PRN     	    	[ns=1, ps=0, ms=0, pruned=[], opts=[<Sequence: [<Ref: SingleIdentifierGrammar>, <Ref: DotSegment>]>]]
INFO       [PD:4  MD:12]	............SingleIdentifierGrammar               	OneOf.match PRN     	    	[ns=2, ps=0, ms=0, pruned=[], opts=[<Ref: NakedIdentifierSegment>, <Ref: QuotedIdentifierSegment>]]
DEBUG      [PD:4  MD:13]	.............SingleIdentifierGrammar              	Ref.match OUT       	+   	[match=<MatchResult 1/3: 'b'>, seg="'b.value'"]
DEBUG      [PD:4  MD:13]	.............SingleIdentifierGrammar              	Ref.match OUT       	    	[match=<MatchResult 0/3: ''>, seg="'b.value'"]
INFO       [PD:4  MD:12]	............SingleIdentifierGrammar               	OneOf.match OUT     	+   	[match=<MatchResult 1/3: 'b'>, seg="'b.value'"]
DEBUG      [PD:4  MD:12]	............FunctionNameSegment                   	Ref.match OUT       	+   	[match=<MatchResult 1/3: 'b'>, seg="'b.value'"]
DEBUG      [PD:4  MD:12]	............FunctionNameSegment                   	Ref.match OUT       	+   	[match=<MatchResult 1/2: '.'>, seg="'.value'"]
INFO       [PD:4  MD:11]	...........FunctionNameSegment                    	Seque.match OUT     	+   	[match=<MatchResult 2/3: 'b.'>, seg="'b.value'"]
INFO       [PD:4  MD:10]	..........FunctionNameSegment                     	AnyNu.match PRN     	    	[ns=1, ps=0, ms=0, pruned=[], opts=[<Sequence: [<Ref: SingleIdentifierGrammar>, <Ref: DotSegment>]>]]
INFO       [PD:4  MD:12]	............SingleIdentifierGrammar               	OneOf.match PRN     	    	[ns=2, ps=0, ms=0, pruned=[], opts=[<Ref: NakedIdentifierSegment>, <Ref: QuotedIdentifierSegment>]]
DEBUG      [PD:4  MD:13]	.............SingleIdentifierGrammar              	Ref.match OUT       	++  	[match=<MatchResult 1/1: 'value'>, seg="'value'"]
INFO       [PD:4  MD:12]	............SingleIdentifierGrammar               	OneOf.match OUT     	++  	[match=<MatchResult 1/1: 'value'>, seg="'value'"]
DEBUG      [PD:4  MD:12]	............FunctionNameSegment                   	Ref.match OUT       	++  	[match=<MatchResult 1/1: 'value'>, seg="'value'"]
INFO       [PD:4  MD:11]	...........FunctionNameSegment                    	Seque.match OUT     	    	[match=<MatchResult 0/1: ''>, seg="'value'"]
INFO       [PD:4  MD:10]	..........FunctionNameSegment                     	AnyNu.match OUT     	+   	[match=<MatchResult 2/3: 'b.'>, seg="'b.value'"]
INFO       [PD:4  MD:10]	..........FunctionNameSegment                     	OneOf.match PRN     	    	[ns=2, ps=0, ms=0, pruned=[], opts=[<Ref: FunctionNameIdentifierSegment>, <Ref: QuotedIdentifierSegment>]]
DEBUG      [PD:4  MD:11]	...........FunctionNameSegment                    	Ref.match OUT       	++  	[match=<MatchResult 1/1: 'value'>, seg="'value'"]
INFO       [PD:4  MD:10]	..........FunctionNameSegment                     	OneOf.match OUT     	++  	[match=<MatchResult 1/1: 'value'>, seg="'value'"]
INFO       [PD:4  MD:9 ]	.........FunctionNameSegment                      	Seque.match OUT     	++  	[match=<MatchResult 3/3: 'b.value'>, seg="'b.value'"]
DEBUG      [PD:4  MD:8 ]	........FunctionNameSegment                       	Funct.match OUT     	++  	[match=<MatchResult 1/1: 'b.value'>, seg="'b.value'"]
DEBUG      [PD:4  MD:8 ]	........FunctionSegment                           	Ref.match OUT       	++  	[match=<MatchResult 1/1: 'b.value'>, seg="'b.value'"]
INFO       [PD:4  MD:7 ]	.......FunctionSegment                            	AnyNu.match OUT     	++  	[match=<MatchResult 1/1: 'b.value'>, seg="'b.value'"]
INFO       [PD:4  MD:6 ]	......FunctionSegment                             	Seque.match OUT     	    	[match=<MatchResult 0/3: ''>, seg="'b.value'"]
INFO       [PD:4  MD:5 ]	.....FunctionSegment                              	Seque.match OUT     	    	[match=<MatchResult 0/3: ''>, seg="'b.value'"]
INFO       [PD:4  MD:4 ]	....FunctionSegment                               	OneOf.match OUT     	    	[match=<MatchResult 0/3: ''>, seg="'b.value'"]
DEBUG      [PD:4  MD:3 ]	...FunctionSegment                                	Funct.match OUT     	    	[match=<MatchResult 0/3: ''>, seg="'b.value'"]
DEBUG      [PD:4  MD:3 ]	...BaseExpressionElementGrammar                   	Ref.match OUT       	    	[match=<MatchResult 0/3: ''>, seg="'b.value'"]
DEBUG      [PD:4  MD:5 ]	.....ColumnReferenceSegment                       	Delim._look_ahead_match IN	    	[ls=3, seg='b.value']
DEBUG      [PD:4  MD:5 ]	.....ColumnReferenceSegment                       	Delim._look_ahead_match SI	    	[mq=[(<OneOf: [<Ref: DotSegment>, <Sequence: [<Ref: DotSegment>, <Ref: Dot...]>, 1, '.'), (<OneOf: [<Ref: DotSegment>, <Sequence: [<Ref: DotSegment>, <Ref: Dot...]>, 1, '.')], sb=['B', '.', 'VALUE']]
INFO       [PD:4  MD:5 ]	.....ColumnReferenceSegment                       	OneOf.match PRN     	    	[ns=0, ps=0, ms=2, pruned=[], opts=[<Ref: DotSegment>, <Sequence: [<Ref: DotSegment>, <Ref: DotSegment>]>]]
DEBUG      [PD:4  MD:6 ]	......ColumnReferenceSegment                      	Ref.match OUT       	+   	[match=<MatchResult 1/2: '.'>, seg="'.value'"]
DEBUG      [PD:4  MD:7 ]	.......ColumnReferenceSegment                     	Ref.match OUT       	+   	[match=<MatchResult 1/2: '.'>, seg="'.value'"]
DEBUG      [PD:4  MD:7 ]	.......ColumnReferenceSegment                     	Ref.match OUT       	    	[match=<MatchResult 0/1: ''>, seg="'value'"]
INFO       [PD:4  MD:6 ]	......ColumnReferenceSegment                      	Seque.match OUT     	    	[match=<MatchResult 0/2: ''>, seg="'.value'"]
INFO       [PD:4  MD:5 ]	.....ColumnReferenceSegment                       	OneOf.match OUT     	+   	[match=<MatchResult 1/2: '.'>, seg="'.value'"]
INFO       [PD:4  MD:5 ]	.....ColumnReferenceSegment                       	OneOf.match PRN     	    	[ns=0, ps=0, ms=2, pruned=[], opts=[<Ref: DotSegment>, <Sequence: [<Ref: DotSegment>, <Ref: DotSegment>]>]]
DEBUG      [PD:4  MD:6 ]	......ColumnReferenceSegment                      	Ref.match OUT       	+   	[match=<MatchResult 1/2: '.'>, seg="'.value'"]
DEBUG      [PD:4  MD:7 ]	.......ColumnReferenceSegment                     	Ref.match OUT       	+   	[match=<MatchResult 1/2: '.'>, seg="'.value'"]
DEBUG      [PD:4  MD:7 ]	.......ColumnReferenceSegment                     	Ref.match OUT       	    	[match=<MatchResult 0/1: ''>, seg="'value'"]
INFO       [PD:4  MD:6 ]	......ColumnReferenceSegment                      	Seque.match OUT     	    	[match=<MatchResult 0/2: ''>, seg="'.value'"]
INFO       [PD:4  MD:5 ]	.....ColumnReferenceSegment                       	OneOf.match OUT     	+   	[match=<MatchResult 1/2: '.'>, seg="'.value'"]
INFO       [PD:4  MD:5 ]	.....ColumnReferenceSegment                       	OneOf.match PRN     	    	[ns=1, ps=10, ms=0, pruned=[<Ref: OnKeywordSegment>, <Ref: AsKeywordSegment>, <Ref: UsingKeywordSegment>, <Ref: CommaSegment>, <Ref: CastOperatorSegment>, <Ref: StartSquareBracketSegment>, <Ref: StartBracketSegment>, <Ref: ColonSegment>, <Ref: DelimiterSegment>, <class 'sqlfluff.core.parser.segments.base.BracketedSegment'>], opts=[<Ref: BinaryOperatorGrammar>]]
INFO       [PD:4  MD:6 ]	......BinaryOperatorGrammar                       	OneOf.match PRN     	    	[ns=1, ps=3, ms=0, pruned=[<Ref: ArithmeticBinaryOperatorGrammar>, <Ref: StringBinaryOperatorGrammar>, <Ref: BooleanBinaryOperatorGrammar>], opts=[<Ref: ComparisonOperatorGrammar>]]
INFO       [PD:4  MD:7 ]	.......ComparisonOperatorGrammar                  	OneOf.match PRN     	    	[ns=1, ps=7, ms=0, pruned=[<Ref: EqualsSegment>, <Ref: GreaterThanSegment>, <Ref: LessThanSegment>, <Ref: GreaterThanOrEqualToSegment>, <Ref: LessThanOrEqualToSegment>, <Ref: NotEqualToSegment_a>, <Ref: NotEqualToSegment_b>], opts=[<Ref: LikeOperatorSegment>]]
DEBUG      [PD:4  MD:8 ]	........ComparisonOperatorGrammar                 	Ref.match OUT       	    	[match=<MatchResult 0/3: ''>, seg="'b.value'"]
INFO       [PD:4  MD:7 ]	.......ComparisonOperatorGrammar                  	OneOf.match OUT     	    	[match=<MatchResult 0/3: ''>, seg="'b.value'"]
DEBUG      [PD:4  MD:7 ]	.......BinaryOperatorGrammar                      	Ref.match OUT       	    	[match=<MatchResult 0/3: ''>, seg="'b.value'"]
INFO       [PD:4  MD:6 ]	......BinaryOperatorGrammar                       	OneOf.match OUT     	    	[match=<MatchResult 0/3: ''>, seg="'b.value'"]
DEBUG      [PD:4  MD:6 ]	......ColumnReferenceSegment                      	Ref.match OUT       	    	[match=<MatchResult 0/3: ''>, seg="'b.value'"]
INFO       [PD:4  MD:5 ]	.....ColumnReferenceSegment                       	OneOf.match OUT     	    	[match=<MatchResult 0/3: ''>, seg="'b.value'"]
DEBUG      [PD:4  MD:5 ]	.....ColumnReferenceSegment                       	NonCo.match OUT     	    	[match=<MatchResult 0/3: ''>, seg="'b.value'"]
INFO       [PD:4  MD:5 ]	.....ColumnReferenceSegment                       	OneOf.match PRN     	    	[ns=1, ps=10, ms=0, pruned=[<Ref: OnKeywordSegment>, <Ref: AsKeywordSegment>, <Ref: UsingKeywordSegment>, <Ref: CommaSegment>, <Ref: CastOperatorSegment>, <Ref: StartSquareBracketSegment>, <Ref: StartBracketSegment>, <Ref: ColonSegment>, <Ref: DelimiterSegment>, <class 'sqlfluff.core.parser.segments.base.BracketedSegment'>], opts=[<Ref: BinaryOperatorGrammar>]]
INFO       [PD:4  MD:6 ]	......BinaryOperatorGrammar                       	OneOf.match PRN     	    	[ns=1, ps=3, ms=0, pruned=[<Ref: ArithmeticBinaryOperatorGrammar>, <Ref: StringBinaryOperatorGrammar>, <Ref: BooleanBinaryOperatorGrammar>], opts=[<Ref: ComparisonOperatorGrammar>]]
INFO       [PD:4  MD:7 ]	.......ComparisonOperatorGrammar                  	OneOf.match PRN     	    	[ns=1, ps=7, ms=0, pruned=[<Ref: EqualsSegment>, <Ref: GreaterThanSegment>, <Ref: LessThanSegment>, <Ref: GreaterThanOrEqualToSegment>, <Ref: LessThanOrEqualToSegment>, <Ref: NotEqualToSegment_a>, <Ref: NotEqualToSegment_b>], opts=[<Ref: LikeOperatorSegment>]]
DEBUG      [PD:4  MD:8 ]	........ComparisonOperatorGrammar                 	Ref.match OUT       	    	[match=<MatchResult 0/2: ''>, seg="'.value'"]
INFO       [PD:4  MD:7 ]	.......ComparisonOperatorGrammar                  	OneOf.match OUT     	    	[match=<MatchResult 0/2: ''>, seg="'.value'"]
DEBUG      [PD:4  MD:7 ]	.......BinaryOperatorGrammar                      	Ref.match OUT       	    	[match=<MatchResult 0/2: ''>, seg="'.value'"]
INFO       [PD:4  MD:6 ]	......BinaryOperatorGrammar                       	OneOf.match OUT     	    	[match=<MatchResult 0/2: ''>, seg="'.value'"]
DEBUG      [PD:4  MD:6 ]	......ColumnReferenceSegment                      	Ref.match OUT       	    	[match=<MatchResult 0/2: ''>, seg="'.value'"]
INFO       [PD:4  MD:5 ]	.....ColumnReferenceSegment                       	OneOf.match OUT     	    	[match=<MatchResult 0/2: ''>, seg="'.value'"]
DEBUG      [PD:4  MD:5 ]	.....ColumnReferenceSegment                       	NonCo.match OUT     	    	[match=<MatchResult 0/2: ''>, seg="'.value'"]
INFO       [PD:4  MD:5 ]	.....SingleIdentifierGrammar                      	OneOf.match PRN     	    	[ns=2, ps=0, ms=0, pruned=[], opts=[<Ref: NakedIdentifierSegment>, <Ref: QuotedIdentifierSegment>]]
DEBUG      [PD:4  MD:6 ]	......SingleIdentifierGrammar                     	Ref.match OUT       	++  	[match=<MatchResult 1/1: 'b'>, seg="'b'"]
INFO       [PD:4  MD:5 ]	.....SingleIdentifierGrammar                      	OneOf.match OUT     	++  	[match=<MatchResult 1/1: 'b'>, seg="'b'"]
DEBUG      [PD:4  MD:5 ]	.....ColumnReferenceSegment                       	Ref.match OUT       	++  	[match=<MatchResult 1/1: 'b'>, seg="'b'"]
DEBUG      [PD:4  MD:5 ]	.....ColumnReferenceSegment                       	Delim._look_ahead_match IN	    	[ls=1, seg='value']
DEBUG      [PD:4  MD:5 ]	.....ColumnReferenceSegment                       	Delim._look_ahead_match SI	    	[mq=[], sb=['VALUE']]
INFO       [PD:4  MD:5 ]	.....ColumnReferenceSegment                       	OneOf.match PRN     	    	[ns=1, ps=10, ms=0, pruned=[<Ref: OnKeywordSegment>, <Ref: AsKeywordSegment>, <Ref: UsingKeywordSegment>, <Ref: CommaSegment>, <Ref: CastOperatorSegment>, <Ref: StartSquareBracketSegment>, <Ref: StartBracketSegment>, <Ref: ColonSegment>, <Ref: DelimiterSegment>, <class 'sqlfluff.core.parser.segments.base.BracketedSegment'>], opts=[<Ref: BinaryOperatorGrammar>]]
INFO       [PD:4  MD:6 ]	......BinaryOperatorGrammar                       	OneOf.match PRN     	    	[ns=1, ps=3, ms=0, pruned=[<Ref: ArithmeticBinaryOperatorGrammar>, <Ref: StringBinaryOperatorGrammar>, <Ref: BooleanBinaryOperatorGrammar>], opts=[<Ref: ComparisonOperatorGrammar>]]
INFO       [PD:4  MD:7 ]	.......ComparisonOperatorGrammar                  	OneOf.match PRN     	    	[ns=1, ps=7, ms=0, pruned=[<Ref: EqualsSegment>, <Ref: GreaterThanSegment>, <Ref: LessThanSegment>, <Ref: GreaterThanOrEqualToSegment>, <Ref: LessThanOrEqualToSegment>, <Ref: NotEqualToSegment_a>, <Ref: NotEqualToSegment_b>], opts=[<Ref: LikeOperatorSegment>]]
DEBUG      [PD:4  MD:8 ]	........ComparisonOperatorGrammar                 	Ref.match OUT       	    	[match=<MatchResult 0/1: ''>, seg="'value'"]
INFO       [PD:4  MD:7 ]	.......ComparisonOperatorGrammar                  	OneOf.match OUT     	    	[match=<MatchResult 0/1: ''>, seg="'value'"]
DEBUG      [PD:4  MD:7 ]	.......BinaryOperatorGrammar                      	Ref.match OUT       	    	[match=<MatchResult 0/1: ''>, seg="'value'"]
INFO       [PD:4  MD:6 ]	......BinaryOperatorGrammar                       	OneOf.match OUT     	    	[match=<MatchResult 0/1: ''>, seg="'value'"]
DEBUG      [PD:4  MD:6 ]	......ColumnReferenceSegment                      	Ref.match OUT       	    	[match=<MatchResult 0/1: ''>, seg="'value'"]
INFO       [PD:4  MD:5 ]	.....ColumnReferenceSegment                       	OneOf.match OUT     	    	[match=<MatchResult 0/1: ''>, seg="'value'"]
DEBUG      [PD:4  MD:5 ]	.....ColumnReferenceSegment                       	NonCo.match OUT     	    	[match=<MatchResult 0/1: ''>, seg="'value'"]
INFO       [PD:4  MD:5 ]	.....SingleIdentifierGrammar                      	OneOf.match PRN     	    	[ns=2, ps=0, ms=0, pruned=[], opts=[<Ref: NakedIdentifierSegment>, <Ref: QuotedIdentifierSegment>]]
DEBUG      [PD:4  MD:6 ]	......SingleIdentifierGrammar                     	Ref.match OUT       	++  	[match=<MatchResult 1/1: 'value'>, seg="'value'"]
INFO       [PD:4  MD:5 ]	.....SingleIdentifierGrammar                      	OneOf.match OUT     	++  	[match=<MatchResult 1/1: 'value'>, seg="'value'"]
DEBUG      [PD:4  MD:5 ]	.....ColumnReferenceSegment                       	Ref.match OUT       	++  	[match=<MatchResult 1/1: 'value'>, seg="'value'"]
INFO       [PD:4  MD:4 ]	....ColumnReferenceSegment                        	Delim.match OUT     	++  	[match=<MatchResult 3/3: 'b.value'>, seg="'b.value'"]
DEBUG      [PD:4  MD:3 ]	...ColumnReferenceSegment                         	Colum.match OUT     	++  	[match=<MatchResult 1/1: 'b.value'>, seg="'b.value'"]
DEBUG      [PD:4  MD:3 ]	...BaseExpressionElementGrammar                   	Ref.match OUT       	++  	[match=<MatchResult 1/1: 'b.value'>, seg="'b.value'"]
INFO       [PD:4  MD:2 ]	..BaseExpressionElementGrammar                    	OneOf.match OUT     	++  	[match=<MatchResult 1/1: 'b.value'>, seg="'b.value'"]
DEBUG      [PD:4  MD:2 ]	..SelectClauseElementSegment                      	Ref.match OUT       	++  	[match=<MatchResult 1/1: 'b.value'>, seg="'b.value'"]
INFO       [PD:4  MD:1 ]	.SelectClauseElementSegment                       	Seque.match OUT     	++  	[match=<MatchResult 1/1: 'b.value'>, seg="'b.value'"]
INFO       [PD:4  MD:0 ]	SelectClauseElementSegment                        	OneOf.match OUT     	++  	[match=<MatchResult 1/1: 'b.value'>, seg="'b.value'"]
DEBUG      SelectClauseElementSegment.parse: Done Parse. Plotting Recursion. Recurse=True
DEBUG      ###
#
# Beginning Parse Depth 5: SelectClauseElementSegment
#
###
Initial Structure:
[L:  3, P:  5]      |select_clause_element:
[L:  3, P:  5]      |    column_reference:
[L:  3, P:  5]      |        identifier:                                           'b'
[L:  3, P:  6]      |        dot:                                                  '.'
[L:  3, P:  7]      |        identifier:                                           'value'

INFO       [PD:5] Skipping expansion of <ColumnReferenceSegment: ([L:  3, P:  5])>...
INFO       [PD:4] Skipping expansion of <SymbolSegment: ([L:  3, P: 12]) ','>...
INFO       [PD:4] Skipping expansion of <NewlineSegment: ([L:  3, P: 13]) '\n'>...
INFO       [PD:4] Skipping expansion of <WhitespaceSegment: ([L:  4, P:  1]) '    '>...
INFO       [PD:4] Skipping expansion of <CommentSegment: ([L:  4, P:  5]) '/*'>...
INFO       [PD:4] Skipping expansion of <NewlineSegment: ([L:  4, P:  7]) '\n'>...
INFO       [PD:4] Skipping expansion of <WhitespaceSegment: ([L:  5, P:  1]) '    '>...
INFO       [PD:4] Skipping expansion of <CommentSegment: ([L:  5, P:  5]) 'This is a block comment'>...
INFO       [PD:4] Skipping expansion of <NewlineSegment: ([L:  5, P: 28]) '\n'>...
INFO       [PD:4] Skipping expansion of <WhitespaceSegment: ([L:  6, P:  1]) '    '>...
INFO       [PD:4] Skipping expansion of <CommentSegment: ([L:  6, P:  5]) '*/'>...
INFO       [PD:4] Skipping expansion of <NewlineSegment: ([L:  6, P:  7]) '\n'>...
INFO       [PD:4] Skipping expansion of <WhitespaceSegment: ([L:  7, P:  1]) '    '>...
INFO       
###
#
# Parse Depth 4. Expanding: SelectClauseElementSegment: 'd.something'
#
###
INFO       [PD:4  MD:0 ]	SelectClauseElementSegment                        	OneOf.match PRN     	    	[ns=2, ps=0, ms=0, pruned=[], opts=[<Ref: WildcardExpressionSegment>, <Sequence: [<Ref: BaseExpressionElementGrammar>, <Ref: AliasExpressionSegment [opt]>]>]]
INFO       [PD:4  MD:5 ]	.....WildcardIdentifierSegment                    	AnyNu.match PRN     	    	[ns=1, ps=0, ms=0, pruned=[], opts=[<Sequence: [<Ref: SingleIdentifierGrammar>, <Ref: DotSegment>]>]]
INFO       [PD:4  MD:7 ]	.......SingleIdentifierGrammar                    	OneOf.match PRN     	    	[ns=2, ps=0, ms=0, pruned=[], opts=[<Ref: NakedIdentifierSegment>, <Ref: QuotedIdentifierSegment>]]
DEBUG      [PD:4  MD:8 ]	........SingleIdentifierGrammar                   	Ref.match OUT       	+   	[match=<MatchResult 1/3: 'd'>, seg="'d.something'"]
DEBUG      [PD:4  MD:8 ]	........SingleIdentifierGrammar                   	Ref.match OUT       	    	[match=<MatchResult 0/3: ''>, seg="'d.something'"]
INFO       [PD:4  MD:7 ]	.......SingleIdentifierGrammar                    	OneOf.match OUT     	+   	[match=<MatchResult 1/3: 'd'>, seg="'d.something'"]
DEBUG      [PD:4  MD:7 ]	.......WildcardIdentifierSegment                  	Ref.match OUT       	+   	[match=<MatchResult 1/3: 'd'>, seg="'d.something'"]
DEBUG      [PD:4  MD:7 ]	.......WildcardIdentifierSegment                  	Ref.match OUT       	+   	[match=<MatchResult 1/2: '.'>, seg="'.something'"]
INFO       [PD:4  MD:6 ]	......WildcardIdentifierSegment                   	Seque.match OUT     	+   	[match=<MatchResult 2/3: 'd.'>, seg="'d.something'"]
INFO       [PD:4  MD:5 ]	.....WildcardIdentifierSegment                    	AnyNu.match PRN     	    	[ns=1, ps=0, ms=0, pruned=[], opts=[<Sequence: [<Ref: SingleIdentifierGrammar>, <Ref: DotSegment>]>]]
INFO       [PD:4  MD:7 ]	.......SingleIdentifierGrammar                    	OneOf.match PRN     	    	[ns=2, ps=0, ms=0, pruned=[], opts=[<Ref: NakedIdentifierSegment>, <Ref: QuotedIdentifierSegment>]]
DEBUG      [PD:4  MD:8 ]	........SingleIdentifierGrammar                   	Ref.match OUT       	++  	[match=<MatchResult 1/1: 'something'>, seg="'something'"]
INFO       [PD:4  MD:7 ]	.......SingleIdentifierGrammar                    	OneOf.match OUT     	++  	[match=<MatchResult 1/1: 'something'>, seg="'something'"]
DEBUG      [PD:4  MD:7 ]	.......WildcardIdentifierSegment                  	Ref.match OUT       	++  	[match=<MatchResult 1/1: 'something'>, seg="'something'"]
INFO       [PD:4  MD:6 ]	......WildcardIdentifierSegment                   	Seque.match OUT     	    	[match=<MatchResult 0/1: ''>, seg="'something'"]
INFO       [PD:4  MD:5 ]	.....WildcardIdentifierSegment                    	AnyNu.match OUT     	+   	[match=<MatchResult 2/3: 'd.'>, seg="'d.something'"]
DEBUG      [PD:4  MD:5 ]	.....WildcardIdentifierSegment                    	Ref.match OUT       	    	[match=<MatchResult 0/1: ''>, seg="'something'"]
INFO       [PD:4  MD:4 ]	....WildcardIdentifierSegment                     	Seque.match OUT     	    	[match=<MatchResult 0/3: ''>, seg="'d.something'"]
DEBUG      [PD:4  MD:3 ]	...WildcardIdentifierSegment                      	Wildc.match OUT     	    	[match=<MatchResult 0/3: ''>, seg="'d.something'"]
DEBUG      [PD:4  MD:3 ]	...WildcardExpressionSegment                      	Ref.match OUT       	    	[match=<MatchResult 0/3: ''>, seg="'d.something'"]
INFO       [PD:4  MD:2 ]	..WildcardExpressionSegment                       	Seque.match OUT     	    	[match=<MatchResult 0/3: ''>, seg="'d.something'"]
DEBUG      [PD:4  MD:1 ]	.WildcardExpressionSegment                        	Wildc.match OUT     	    	[match=<MatchResult 0/3: ''>, seg="'d.something'"]
DEBUG      [PD:4  MD:1 ]	.SelectClauseElementSegment                       	Ref.match OUT       	    	[match=<MatchResult 0/3: ''>, seg="'d.something'"]
INFO       [PD:4  MD:2 ]	..BaseExpressionElementGrammar                    	OneOf.match PRN     	    	[ns=5, ps=1, ms=0, pruned=[<Ref: IntervalExpressionSegment>], opts=[<Ref: LiteralGrammar>, <Ref: BareFunctionSegment>, <Ref: FunctionSegment>, <Ref: ColumnReferenceSegment>, <Ref: ExpressionSegment>]]
INFO       [PD:4  MD:3 ]	...LiteralGrammar                                 	OneOf.match PRN     	    	[ns=2, ps=4, ms=0, pruned=[<Ref: BooleanLiteralGrammar>, <Ref: QualifiedNumericLiteralSegment>, <Ref: NullLiteralSegment>, <Ref: DateTimeLiteralGrammar>], opts=[<Ref: QuotedLiteralSegment>, <Ref: NumericLiteralSegment>]]
DEBUG      [PD:4  MD:4 ]	....LiteralGrammar                                	Ref.match OUT       	    	[match=<MatchResult 0/3: ''>, seg="'d.something'"]
DEBUG      [PD:4  MD:4 ]	....LiteralGrammar                                	Ref.match OUT       	    	[match=<MatchResult 0/3: ''>, seg="'d.something'"]
INFO       [PD:4  MD:3 ]	...LiteralGrammar                                 	OneOf.match OUT     	    	[match=<MatchResult 0/3: ''>, seg="'d.something'"]
DEBUG      [PD:4  MD:3 ]	...BaseExpressionElementGrammar                   	Ref.match OUT       	    	[match=<MatchResult 0/3: ''>, seg="'d.something'"]
DEBUG      [PD:4  MD:3 ]	...BaseExpressionElementGrammar                   	Ref.match OUT       	    	[match=<MatchResult 0/3: ''>, seg="'d.something'"]
INFO       [PD:4  MD:4 ]	....FunctionSegment                               	OneOf.match PRN     	    	[ns=1, ps=1, ms=0, pruned=[<Sequence: [<Sequence: [<Ref: DateAddFunctionNameSeg...]>], opts=[<Sequence: [<Sequence: [<AnyNumberOf: [<Ref: Functio..., <Ref: PostFunctionGrammar [opt]>]>]]
DEBUG      [PD:4  MD:10]	..........DateAddFunctionNameSegment              	Ref.match OUT       	    	[match=<MatchResult 0/3: ''>, seg="'d.something'"]
INFO       [PD:4  MD:9 ]	.........DateAddFunctionNameSegment               	Seque.match OUT     	    	[match=<MatchResult 0/3: ''>, seg="'d.something'"]
DEBUG      [PD:4  MD:8 ]	........DateAddFunctionNameSegment                	DateA.match OUT     	    	[match=<MatchResult 0/3: ''>, seg="'d.something'"]
DEBUG      [PD:4  MD:8 ]	........FunctionSegment                           	Ref.match OUT       	    	[match=<MatchResult 0/3: ''>, seg="'d.something'"]
INFO       [PD:4  MD:7 ]	.......FunctionSegment                            	AnyNu.match PRN     	    	[ns=1, ps=0, ms=0, pruned=[], opts=[<Ref: FunctionNameSegment>]]
INFO       [PD:4  MD:10]	..........FunctionNameSegment                     	AnyNu.match PRN     	    	[ns=1, ps=0, ms=0, pruned=[], opts=[<Sequence: [<Ref: SingleIdentifierGrammar>, <Ref: DotSegment>]>]]
INFO       [PD:4  MD:12]	............SingleIdentifierGrammar               	OneOf.match PRN     	    	[ns=2, ps=0, ms=0, pruned=[], opts=[<Ref: NakedIdentifierSegment>, <Ref: QuotedIdentifierSegment>]]
DEBUG      [PD:4  MD:13]	.............SingleIdentifierGrammar              	Ref.match OUT       	+   	[match=<MatchResult 1/3: 'd'>, seg="'d.something'"]
DEBUG      [PD:4  MD:13]	.............SingleIdentifierGrammar              	Ref.match OUT       	    	[match=<MatchResult 0/3: ''>, seg="'d.something'"]
INFO       [PD:4  MD:12]	............SingleIdentifierGrammar               	OneOf.match OUT     	+   	[match=<MatchResult 1/3: 'd'>, seg="'d.something'"]
DEBUG      [PD:4  MD:12]	............FunctionNameSegment                   	Ref.match OUT       	+   	[match=<MatchResult 1/3: 'd'>, seg="'d.something'"]
DEBUG      [PD:4  MD:12]	............FunctionNameSegment                   	Ref.match OUT       	+   	[match=<MatchResult 1/2: '.'>, seg="'.something'"]
INFO       [PD:4  MD:11]	...........FunctionNameSegment                    	Seque.match OUT     	+   	[match=<MatchResult 2/3: 'd.'>, seg="'d.something'"]
INFO       [PD:4  MD:10]	..........FunctionNameSegment                     	AnyNu.match PRN     	    	[ns=1, ps=0, ms=0, pruned=[], opts=[<Sequence: [<Ref: SingleIdentifierGrammar>, <Ref: DotSegment>]>]]
INFO       [PD:4  MD:12]	............SingleIdentifierGrammar               	OneOf.match PRN     	    	[ns=2, ps=0, ms=0, pruned=[], opts=[<Ref: NakedIdentifierSegment>, <Ref: QuotedIdentifierSegment>]]
DEBUG      [PD:4  MD:13]	.............SingleIdentifierGrammar              	Ref.match OUT       	++  	[match=<MatchResult 1/1: 'something'>, seg="'something'"]
INFO       [PD:4  MD:12]	............SingleIdentifierGrammar               	OneOf.match OUT     	++  	[match=<MatchResult 1/1: 'something'>, seg="'something'"]
DEBUG      [PD:4  MD:12]	............FunctionNameSegment                   	Ref.match OUT       	++  	[match=<MatchResult 1/1: 'something'>, seg="'something'"]
INFO       [PD:4  MD:11]	...........FunctionNameSegment                    	Seque.match OUT     	    	[match=<MatchResult 0/1: ''>, seg="'something'"]
INFO       [PD:4  MD:10]	..........FunctionNameSegment                     	AnyNu.match OUT     	+   	[match=<MatchResult 2/3: 'd.'>, seg="'d.something'"]
INFO       [PD:4  MD:10]	..........FunctionNameSegment                     	OneOf.match PRN     	    	[ns=2, ps=0, ms=0, pruned=[], opts=[<Ref: FunctionNameIdentifierSegment>, <Ref: QuotedIdentifierSegment>]]
DEBUG      [PD:4  MD:11]	...........FunctionNameSegment                    	Ref.match OUT       	++  	[match=<MatchResult 1/1: 'something'>, seg="'something'"]
INFO       [PD:4  MD:10]	..........FunctionNameSegment                     	OneOf.match OUT     	++  	[match=<MatchResult 1/1: 'something'>, seg="'something'"]
INFO       [PD:4  MD:9 ]	.........FunctionNameSegment                      	Seque.match OUT     	++  	[match=<MatchResult 3/3: 'd.something'>, seg="'d.something'"]
DEBUG      [PD:4  MD:8 ]	........FunctionNameSegment                       	Funct.match OUT     	++  	[match=<MatchResult 1/1: 'd.something'>, seg="'d.something'"]
DEBUG      [PD:4  MD:8 ]	........FunctionSegment                           	Ref.match OUT       	++  	[match=<MatchResult 1/1: 'd.something'>, seg="'d.something'"]
INFO       [PD:4  MD:7 ]	.......FunctionSegment                            	AnyNu.match OUT     	++  	[match=<MatchResult 1/1: 'd.something'>, seg="'d.something'"]
INFO       [PD:4  MD:6 ]	......FunctionSegment                             	Seque.match OUT     	    	[match=<MatchResult 0/3: ''>, seg="'d.something'"]
INFO       [PD:4  MD:5 ]	.....FunctionSegment                              	Seque.match OUT     	    	[match=<MatchResult 0/3: ''>, seg="'d.something'"]
INFO       [PD:4  MD:4 ]	....FunctionSegment                               	OneOf.match OUT     	    	[match=<MatchResult 0/3: ''>, seg="'d.something'"]
DEBUG      [PD:4  MD:3 ]	...FunctionSegment                                	Funct.match OUT     	    	[match=<MatchResult 0/3: ''>, seg="'d.something'"]
DEBUG      [PD:4  MD:3 ]	...BaseExpressionElementGrammar                   	Ref.match OUT       	    	[match=<MatchResult 0/3: ''>, seg="'d.something'"]
DEBUG      [PD:4  MD:5 ]	.....ColumnReferenceSegment                       	Delim._look_ahead_match IN	    	[ls=3, seg='d.something']
DEBUG      [PD:4  MD:5 ]	.....ColumnReferenceSegment                       	Delim._look_ahead_match SI	    	[mq=[(<OneOf: [<Ref: DotSegment>, <Sequence: [<Ref: DotSegment>, <Ref: Dot...]>, 1, '.'), (<OneOf: [<Ref: DotSegment>, <Sequence: [<Ref: DotSegment>, <Ref: Dot...]>, 1, '.')], sb=['D', '.', 'SOMETHING']]
INFO       [PD:4  MD:5 ]	.....ColumnReferenceSegment                       	OneOf.match PRN     	    	[ns=0, ps=0, ms=2, pruned=[], opts=[<Ref: DotSegment>, <Sequence: [<Ref: DotSegment>, <Ref: DotSegment>]>]]
DEBUG      [PD:4  MD:6 ]	......ColumnReferenceSegment                      	Ref.match OUT       	+   	[match=<MatchResult 1/2: '.'>, seg="'.something'"]
DEBUG      [PD:4  MD:7 ]	.......ColumnReferenceSegment                     	Ref.match OUT       	+   	[match=<MatchResult 1/2: '.'>, seg="'.something'"]
DEBUG      [PD:4  MD:7 ]	.......ColumnReferenceSegment                     	Ref.match OUT       	    	[match=<MatchResult 0/1: ''>, seg="'something'"]
INFO       [PD:4  MD:6 ]	......ColumnReferenceSegment                      	Seque.match OUT     	    	[match=<MatchResult 0/2: ''>, seg="'.something'"]
INFO       [PD:4  MD:5 ]	.....ColumnReferenceSegment                       	OneOf.match OUT     	+   	[match=<MatchResult 1/2: '.'>, seg="'.something'"]
INFO       [PD:4  MD:5 ]	.....ColumnReferenceSegment                       	OneOf.match PRN     	    	[ns=0, ps=0, ms=2, pruned=[], opts=[<Ref: DotSegment>, <Sequence: [<Ref: DotSegment>, <Ref: DotSegment>]>]]
DEBUG      [PD:4  MD:6 ]	......ColumnReferenceSegment                      	Ref.match OUT       	+   	[match=<MatchResult 1/2: '.'>, seg="'.something'"]
DEBUG      [PD:4  MD:7 ]	.......ColumnReferenceSegment                     	Ref.match OUT       	+   	[match=<MatchResult 1/2: '.'>, seg="'.something'"]
DEBUG      [PD:4  MD:7 ]	.......ColumnReferenceSegment                     	Ref.match OUT       	    	[match=<MatchResult 0/1: ''>, seg="'something'"]
INFO       [PD:4  MD:6 ]	......ColumnReferenceSegment                      	Seque.match OUT     	    	[match=<MatchResult 0/2: ''>, seg="'.something'"]
INFO       [PD:4  MD:5 ]	.....ColumnReferenceSegment                       	OneOf.match OUT     	+   	[match=<MatchResult 1/2: '.'>, seg="'.something'"]
INFO       [PD:4  MD:5 ]	.....ColumnReferenceSegment                       	OneOf.match PRN     	    	[ns=1, ps=10, ms=0, pruned=[<Ref: OnKeywordSegment>, <Ref: AsKeywordSegment>, <Ref: UsingKeywordSegment>, <Ref: CommaSegment>, <Ref: CastOperatorSegment>, <Ref: StartSquareBracketSegment>, <Ref: StartBracketSegment>, <Ref: ColonSegment>, <Ref: DelimiterSegment>, <class 'sqlfluff.core.parser.segments.base.BracketedSegment'>], opts=[<Ref: BinaryOperatorGrammar>]]
INFO       [PD:4  MD:6 ]	......BinaryOperatorGrammar                       	OneOf.match PRN     	    	[ns=1, ps=3, ms=0, pruned=[<Ref: ArithmeticBinaryOperatorGrammar>, <Ref: StringBinaryOperatorGrammar>, <Ref: BooleanBinaryOperatorGrammar>], opts=[<Ref: ComparisonOperatorGrammar>]]
INFO       [PD:4  MD:7 ]	.......ComparisonOperatorGrammar                  	OneOf.match PRN     	    	[ns=1, ps=7, ms=0, pruned=[<Ref: EqualsSegment>, <Ref: GreaterThanSegment>, <Ref: LessThanSegment>, <Ref: GreaterThanOrEqualToSegment>, <Ref: LessThanOrEqualToSegment>, <Ref: NotEqualToSegment_a>, <Ref: NotEqualToSegment_b>], opts=[<Ref: LikeOperatorSegment>]]
DEBUG      [PD:4  MD:8 ]	........ComparisonOperatorGrammar                 	Ref.match OUT       	    	[match=<MatchResult 0/3: ''>, seg="'d.something'"]
INFO       [PD:4  MD:7 ]	.......ComparisonOperatorGrammar                  	OneOf.match OUT     	    	[match=<MatchResult 0/3: ''>, seg="'d.something'"]
DEBUG      [PD:4  MD:7 ]	.......BinaryOperatorGrammar                      	Ref.match OUT       	    	[match=<MatchResult 0/3: ''>, seg="'d.something'"]
INFO       [PD:4  MD:6 ]	......BinaryOperatorGrammar                       	OneOf.match OUT     	    	[match=<MatchResult 0/3: ''>, seg="'d.something'"]
DEBUG      [PD:4  MD:6 ]	......ColumnReferenceSegment                      	Ref.match OUT       	    	[match=<MatchResult 0/3: ''>, seg="'d.something'"]
INFO       [PD:4  MD:5 ]	.....ColumnReferenceSegment                       	OneOf.match OUT     	    	[match=<MatchResult 0/3: ''>, seg="'d.something'"]
DEBUG      [PD:4  MD:5 ]	.....ColumnReferenceSegment                       	NonCo.match OUT     	    	[match=<MatchResult 0/3: ''>, seg="'d.something'"]
INFO       [PD:4  MD:5 ]	.....ColumnReferenceSegment                       	OneOf.match PRN     	    	[ns=1, ps=10, ms=0, pruned=[<Ref: OnKeywordSegment>, <Ref: AsKeywordSegment>, <Ref: UsingKeywordSegment>, <Ref: CommaSegment>, <Ref: CastOperatorSegment>, <Ref: StartSquareBracketSegment>, <Ref: StartBracketSegment>, <Ref: ColonSegment>, <Ref: DelimiterSegment>, <class 'sqlfluff.core.parser.segments.base.BracketedSegment'>], opts=[<Ref: BinaryOperatorGrammar>]]
INFO       [PD:4  MD:6 ]	......BinaryOperatorGrammar                       	OneOf.match PRN     	    	[ns=1, ps=3, ms=0, pruned=[<Ref: ArithmeticBinaryOperatorGrammar>, <Ref: StringBinaryOperatorGrammar>, <Ref: BooleanBinaryOperatorGrammar>], opts=[<Ref: ComparisonOperatorGrammar>]]
INFO       [PD:4  MD:7 ]	.......ComparisonOperatorGrammar                  	OneOf.match PRN     	    	[ns=1, ps=7, ms=0, pruned=[<Ref: EqualsSegment>, <Ref: GreaterThanSegment>, <Ref: LessThanSegment>, <Ref: GreaterThanOrEqualToSegment>, <Ref: LessThanOrEqualToSegment>, <Ref: NotEqualToSegment_a>, <Ref: NotEqualToSegment_b>], opts=[<Ref: LikeOperatorSegment>]]
DEBUG      [PD:4  MD:8 ]	........ComparisonOperatorGrammar                 	Ref.match OUT       	    	[match=<MatchResult 0/2: ''>, seg="'.something'"]
INFO       [PD:4  MD:7 ]	.......ComparisonOperatorGrammar                  	OneOf.match OUT     	    	[match=<MatchResult 0/2: ''>, seg="'.something'"]
DEBUG      [PD:4  MD:7 ]	.......BinaryOperatorGrammar                      	Ref.match OUT       	    	[match=<MatchResult 0/2: ''>, seg="'.something'"]
INFO       [PD:4  MD:6 ]	......BinaryOperatorGrammar                       	OneOf.match OUT     	    	[match=<MatchResult 0/2: ''>, seg="'.something'"]
DEBUG      [PD:4  MD:6 ]	......ColumnReferenceSegment                      	Ref.match OUT       	    	[match=<MatchResult 0/2: ''>, seg="'.something'"]
INFO       [PD:4  MD:5 ]	.....ColumnReferenceSegment                       	OneOf.match OUT     	    	[match=<MatchResult 0/2: ''>, seg="'.something'"]
DEBUG      [PD:4  MD:5 ]	.....ColumnReferenceSegment                       	NonCo.match OUT     	    	[match=<MatchResult 0/2: ''>, seg="'.something'"]
INFO       [PD:4  MD:5 ]	.....SingleIdentifierGrammar                      	OneOf.match PRN     	    	[ns=2, ps=0, ms=0, pruned=[], opts=[<Ref: NakedIdentifierSegment>, <Ref: QuotedIdentifierSegment>]]
DEBUG      [PD:4  MD:6 ]	......SingleIdentifierGrammar                     	Ref.match OUT       	++  	[match=<MatchResult 1/1: 'd'>, seg="'d'"]
INFO       [PD:4  MD:5 ]	.....SingleIdentifierGrammar                      	OneOf.match OUT     	++  	[match=<MatchResult 1/1: 'd'>, seg="'d'"]
DEBUG      [PD:4  MD:5 ]	.....ColumnReferenceSegment                       	Ref.match OUT       	++  	[match=<MatchResult 1/1: 'd'>, seg="'d'"]
DEBUG      [PD:4  MD:5 ]	.....ColumnReferenceSegment                       	Delim._look_ahead_match IN	    	[ls=1, seg='something']
DEBUG      [PD:4  MD:5 ]	.....ColumnReferenceSegment                       	Delim._look_ahead_match SI	    	[mq=[], sb=['SOMETHING']]
INFO       [PD:4  MD:5 ]	.....ColumnReferenceSegment                       	OneOf.match PRN     	    	[ns=1, ps=10, ms=0, pruned=[<Ref: OnKeywordSegment>, <Ref: AsKeywordSegment>, <Ref: UsingKeywordSegment>, <Ref: CommaSegment>, <Ref: CastOperatorSegment>, <Ref: StartSquareBracketSegment>, <Ref: StartBracketSegment>, <Ref: ColonSegment>, <Ref: DelimiterSegment>, <class 'sqlfluff.core.parser.segments.base.BracketedSegment'>], opts=[<Ref: BinaryOperatorGrammar>]]
INFO       [PD:4  MD:6 ]	......BinaryOperatorGrammar                       	OneOf.match PRN     	    	[ns=1, ps=3, ms=0, pruned=[<Ref: ArithmeticBinaryOperatorGrammar>, <Ref: StringBinaryOperatorGrammar>, <Ref: BooleanBinaryOperatorGrammar>], opts=[<Ref: ComparisonOperatorGrammar>]]
INFO       [PD:4  MD:7 ]	.......ComparisonOperatorGrammar                  	OneOf.match PRN     	    	[ns=1, ps=7, ms=0, pruned=[<Ref: EqualsSegment>, <Ref: GreaterThanSegment>, <Ref: LessThanSegment>, <Ref: GreaterThanOrEqualToSegment>, <Ref: LessThanOrEqualToSegment>, <Ref: NotEqualToSegment_a>, <Ref: NotEqualToSegment_b>], opts=[<Ref: LikeOperatorSegment>]]
DEBUG      [PD:4  MD:8 ]	........ComparisonOperatorGrammar                 	Ref.match OUT       	    	[match=<MatchResult 0/1: ''>, seg="'something'"]
INFO       [PD:4  MD:7 ]	.......ComparisonOperatorGrammar                  	OneOf.match OUT     	    	[match=<MatchResult 0/1: ''>, seg="'something'"]
DEBUG      [PD:4  MD:7 ]	.......BinaryOperatorGrammar                      	Ref.match OUT       	    	[match=<MatchResult 0/1: ''>, seg="'something'"]
INFO       [PD:4  MD:6 ]	......BinaryOperatorGrammar                       	OneOf.match OUT     	    	[match=<MatchResult 0/1: ''>, seg="'something'"]
DEBUG      [PD:4  MD:6 ]	......ColumnReferenceSegment                      	Ref.match OUT       	    	[match=<MatchResult 0/1: ''>, seg="'something'"]
INFO       [PD:4  MD:5 ]	.....ColumnReferenceSegment                       	OneOf.match OUT     	    	[match=<MatchResult 0/1: ''>, seg="'something'"]
DEBUG      [PD:4  MD:5 ]	.....ColumnReferenceSegment                       	NonCo.match OUT     	    	[match=<MatchResult 0/1: ''>, seg="'something'"]
INFO       [PD:4  MD:5 ]	.....SingleIdentifierGrammar                      	OneOf.match PRN     	    	[ns=2, ps=0, ms=0, pruned=[], opts=[<Ref: NakedIdentifierSegment>, <Ref: QuotedIdentifierSegment>]]
DEBUG      [PD:4  MD:6 ]	......SingleIdentifierGrammar                     	Ref.match OUT       	++  	[match=<MatchResult 1/1: 'something'>, seg="'something'"]
INFO       [PD:4  MD:5 ]	.....SingleIdentifierGrammar                      	OneOf.match OUT     	++  	[match=<MatchResult 1/1: 'something'>, seg="'something'"]
DEBUG      [PD:4  MD:5 ]	.....ColumnReferenceSegment                       	Ref.match OUT       	++  	[match=<MatchResult 1/1: 'something'>, seg="'something'"]
INFO       [PD:4  MD:4 ]	....ColumnReferenceSegment                        	Delim.match OUT     	++  	[match=<MatchResult 3/3: 'd.something'>, seg="'d.something'"]
DEBUG      [PD:4  MD:3 ]	...ColumnReferenceSegment                         	Colum.match OUT     	++  	[match=<MatchResult 1/1: 'd.something'>, seg="'d.something'"]
DEBUG      [PD:4  MD:3 ]	...BaseExpressionElementGrammar                   	Ref.match OUT       	++  	[match=<MatchResult 1/1: 'd.something'>, seg="'d.something'"]
INFO       [PD:4  MD:2 ]	..BaseExpressionElementGrammar                    	OneOf.match OUT     	++  	[match=<MatchResult 1/1: 'd.something'>, seg="'d.something'"]
DEBUG      [PD:4  MD:2 ]	..SelectClauseElementSegment                      	Ref.match OUT       	++  	[match=<MatchResult 1/1: 'd.something'>, seg="'d.something'"]
INFO       [PD:4  MD:1 ]	.SelectClauseElementSegment                       	Seque.match OUT     	++  	[match=<MatchResult 1/1: 'd.something'>, seg="'d.something'"]
INFO       [PD:4  MD:0 ]	SelectClauseElementSegment                        	OneOf.match OUT     	++  	[match=<MatchResult 1/1: 'd.something'>, seg="'d.something'"]
DEBUG      SelectClauseElementSegment.parse: Done Parse. Plotting Recursion. Recurse=True
DEBUG      ###
#
# Beginning Parse Depth 5: SelectClauseElementSegment
#
###
Initial Structure:
[L:  7, P:  5]      |select_clause_element:
[L:  7, P:  5]      |    column_reference:
[L:  7, P:  5]      |        identifier:                                           'd'
[L:  7, P:  6]      |        dot:                                                  '.'
[L:  7, P:  7]      |        identifier:                                           'something'

INFO       [PD:5] Skipping expansion of <ColumnReferenceSegment: ([L:  7, P:  5])>...
INFO       [PD:4] Skipping expansion of <SymbolSegment: ([L:  7, P: 16]) ','>...
INFO       [PD:4] Skipping expansion of <WhitespaceSegment: ([L:  7, P: 17]) '    '>...
INFO       [PD:4] Skipping expansion of <CommentSegment: ([L:  7, P: 21]) '-- Which a comment after it'>...
INFO       [PD:4] Skipping expansion of <NewlineSegment: ([L:  7, P: 48]) '\n'>...
INFO       [PD:4] Skipping expansion of <WhitespaceSegment: ([L:  8, P:  1]) '    '>...
INFO       
###
#
# Parse Depth 4. Expanding: SelectClauseElementSegment: 'tbl.foo'
#
###
INFO       [PD:4  MD:0 ]	SelectClauseElementSegment                        	OneOf.match PRN     	    	[ns=2, ps=0, ms=0, pruned=[], opts=[<Ref: WildcardExpressionSegment>, <Sequence: [<Ref: BaseExpressionElementGrammar>, <Ref: AliasExpressionSegment [opt]>]>]]
INFO       [PD:4  MD:5 ]	.....WildcardIdentifierSegment                    	AnyNu.match PRN     	    	[ns=1, ps=0, ms=0, pruned=[], opts=[<Sequence: [<Ref: SingleIdentifierGrammar>, <Ref: DotSegment>]>]]
INFO       [PD:4  MD:7 ]	.......SingleIdentifierGrammar                    	OneOf.match PRN     	    	[ns=2, ps=0, ms=0, pruned=[], opts=[<Ref: NakedIdentifierSegment>, <Ref: QuotedIdentifierSegment>]]
DEBUG      [PD:4  MD:8 ]	........SingleIdentifierGrammar                   	Ref.match OUT       	+   	[match=<MatchResult 1/3: 'tbl'>, seg="'tbl.foo'"]
DEBUG      [PD:4  MD:8 ]	........SingleIdentifierGrammar                   	Ref.match OUT       	    	[match=<MatchResult 0/3: ''>, seg="'tbl.foo'"]
INFO       [PD:4  MD:7 ]	.......SingleIdentifierGrammar                    	OneOf.match OUT     	+   	[match=<MatchResult 1/3: 'tbl'>, seg="'tbl.foo'"]
DEBUG      [PD:4  MD:7 ]	.......WildcardIdentifierSegment                  	Ref.match OUT       	+   	[match=<MatchResult 1/3: 'tbl'>, seg="'tbl.foo'"]
DEBUG      [PD:4  MD:7 ]	.......WildcardIdentifierSegment                  	Ref.match OUT       	+   	[match=<MatchResult 1/2: '.'>, seg="'.foo'"]
INFO       [PD:4  MD:6 ]	......WildcardIdentifierSegment                   	Seque.match OUT     	+   	[match=<MatchResult 2/3: 'tbl.'>, seg="'tbl.foo'"]
INFO       [PD:4  MD:5 ]	.....WildcardIdentifierSegment                    	AnyNu.match PRN     	    	[ns=1, ps=0, ms=0, pruned=[], opts=[<Sequence: [<Ref: SingleIdentifierGrammar>, <Ref: DotSegment>]>]]
INFO       [PD:4  MD:7 ]	.......SingleIdentifierGrammar                    	OneOf.match PRN     	    	[ns=2, ps=0, ms=0, pruned=[], opts=[<Ref: NakedIdentifierSegment>, <Ref: QuotedIdentifierSegment>]]
DEBUG      [PD:4  MD:8 ]	........SingleIdentifierGrammar                   	Ref.match OUT       	++  	[match=<MatchResult 1/1: 'foo'>, seg="'foo'"]
INFO       [PD:4  MD:7 ]	.......SingleIdentifierGrammar                    	OneOf.match OUT     	++  	[match=<MatchResult 1/1: 'foo'>, seg="'foo'"]
DEBUG      [PD:4  MD:7 ]	.......WildcardIdentifierSegment                  	Ref.match OUT       	++  	[match=<MatchResult 1/1: 'foo'>, seg="'foo'"]
INFO       [PD:4  MD:6 ]	......WildcardIdentifierSegment                   	Seque.match OUT     	    	[match=<MatchResult 0/1: ''>, seg="'foo'"]
INFO       [PD:4  MD:5 ]	.....WildcardIdentifierSegment                    	AnyNu.match OUT     	+   	[match=<MatchResult 2/3: 'tbl.'>, seg="'tbl.foo'"]
DEBUG      [PD:4  MD:5 ]	.....WildcardIdentifierSegment                    	Ref.match OUT       	    	[match=<MatchResult 0/1: ''>, seg="'foo'"]
INFO       [PD:4  MD:4 ]	....WildcardIdentifierSegment                     	Seque.match OUT     	    	[match=<MatchResult 0/3: ''>, seg="'tbl.foo'"]
DEBUG      [PD:4  MD:3 ]	...WildcardIdentifierSegment                      	Wildc.match OUT     	    	[match=<MatchResult 0/3: ''>, seg="'tbl.foo'"]
DEBUG      [PD:4  MD:3 ]	...WildcardExpressionSegment                      	Ref.match OUT       	    	[match=<MatchResult 0/3: ''>, seg="'tbl.foo'"]
INFO       [PD:4  MD:2 ]	..WildcardExpressionSegment                       	Seque.match OUT     	    	[match=<MatchResult 0/3: ''>, seg="'tbl.foo'"]
DEBUG      [PD:4  MD:1 ]	.WildcardExpressionSegment                        	Wildc.match OUT     	    	[match=<MatchResult 0/3: ''>, seg="'tbl.foo'"]
DEBUG      [PD:4  MD:1 ]	.SelectClauseElementSegment                       	Ref.match OUT       	    	[match=<MatchResult 0/3: ''>, seg="'tbl.foo'"]
INFO       [PD:4  MD:2 ]	..BaseExpressionElementGrammar                    	OneOf.match PRN     	    	[ns=5, ps=1, ms=0, pruned=[<Ref: IntervalExpressionSegment>], opts=[<Ref: LiteralGrammar>, <Ref: BareFunctionSegment>, <Ref: FunctionSegment>, <Ref: ColumnReferenceSegment>, <Ref: ExpressionSegment>]]
INFO       [PD:4  MD:3 ]	...LiteralGrammar                                 	OneOf.match PRN     	    	[ns=2, ps=4, ms=0, pruned=[<Ref: BooleanLiteralGrammar>, <Ref: QualifiedNumericLiteralSegment>, <Ref: NullLiteralSegment>, <Ref: DateTimeLiteralGrammar>], opts=[<Ref: QuotedLiteralSegment>, <Ref: NumericLiteralSegment>]]
DEBUG      [PD:4  MD:4 ]	....LiteralGrammar                                	Ref.match OUT       	    	[match=<MatchResult 0/3: ''>, seg="'tbl.foo'"]
DEBUG      [PD:4  MD:4 ]	....LiteralGrammar                                	Ref.match OUT       	    	[match=<MatchResult 0/3: ''>, seg="'tbl.foo'"]
INFO       [PD:4  MD:3 ]	...LiteralGrammar                                 	OneOf.match OUT     	    	[match=<MatchResult 0/3: ''>, seg="'tbl.foo'"]
DEBUG      [PD:4  MD:3 ]	...BaseExpressionElementGrammar                   	Ref.match OUT       	    	[match=<MatchResult 0/3: ''>, seg="'tbl.foo'"]
DEBUG      [PD:4  MD:3 ]	...BaseExpressionElementGrammar                   	Ref.match OUT       	    	[match=<MatchResult 0/3: ''>, seg="'tbl.foo'"]
INFO       [PD:4  MD:4 ]	....FunctionSegment                               	OneOf.match PRN     	    	[ns=1, ps=1, ms=0, pruned=[<Sequence: [<Sequence: [<Ref: DateAddFunctionNameSeg...]>], opts=[<Sequence: [<Sequence: [<AnyNumberOf: [<Ref: Functio..., <Ref: PostFunctionGrammar [opt]>]>]]
DEBUG      [PD:4  MD:10]	..........DateAddFunctionNameSegment              	Ref.match OUT       	    	[match=<MatchResult 0/3: ''>, seg="'tbl.foo'"]
INFO       [PD:4  MD:9 ]	.........DateAddFunctionNameSegment               	Seque.match OUT     	    	[match=<MatchResult 0/3: ''>, seg="'tbl.foo'"]
DEBUG      [PD:4  MD:8 ]	........DateAddFunctionNameSegment                	DateA.match OUT     	    	[match=<MatchResult 0/3: ''>, seg="'tbl.foo'"]
DEBUG      [PD:4  MD:8 ]	........FunctionSegment                           	Ref.match OUT       	    	[match=<MatchResult 0/3: ''>, seg="'tbl.foo'"]
INFO       [PD:4  MD:7 ]	.......FunctionSegment                            	AnyNu.match PRN     	    	[ns=1, ps=0, ms=0, pruned=[], opts=[<Ref: FunctionNameSegment>]]
INFO       [PD:4  MD:10]	..........FunctionNameSegment                     	AnyNu.match PRN     	    	[ns=1, ps=0, ms=0, pruned=[], opts=[<Sequence: [<Ref: SingleIdentifierGrammar>, <Ref: DotSegment>]>]]
INFO       [PD:4  MD:12]	............SingleIdentifierGrammar               	OneOf.match PRN     	    	[ns=2, ps=0, ms=0, pruned=[], opts=[<Ref: NakedIdentifierSegment>, <Ref: QuotedIdentifierSegment>]]
DEBUG      [PD:4  MD:13]	.............SingleIdentifierGrammar              	Ref.match OUT       	+   	[match=<MatchResult 1/3: 'tbl'>, seg="'tbl.foo'"]
DEBUG      [PD:4  MD:13]	.............SingleIdentifierGrammar              	Ref.match OUT       	    	[match=<MatchResult 0/3: ''>, seg="'tbl.foo'"]
INFO       [PD:4  MD:12]	............SingleIdentifierGrammar               	OneOf.match OUT     	+   	[match=<MatchResult 1/3: 'tbl'>, seg="'tbl.foo'"]
DEBUG      [PD:4  MD:12]	............FunctionNameSegment                   	Ref.match OUT       	+   	[match=<MatchResult 1/3: 'tbl'>, seg="'tbl.foo'"]
DEBUG      [PD:4  MD:12]	............FunctionNameSegment                   	Ref.match OUT       	+   	[match=<MatchResult 1/2: '.'>, seg="'.foo'"]
INFO       [PD:4  MD:11]	...........FunctionNameSegment                    	Seque.match OUT     	+   	[match=<MatchResult 2/3: 'tbl.'>, seg="'tbl.foo'"]
INFO       [PD:4  MD:10]	..........FunctionNameSegment                     	AnyNu.match PRN     	    	[ns=1, ps=0, ms=0, pruned=[], opts=[<Sequence: [<Ref: SingleIdentifierGrammar>, <Ref: DotSegment>]>]]
INFO       [PD:4  MD:12]	............SingleIdentifierGrammar               	OneOf.match PRN     	    	[ns=2, ps=0, ms=0, pruned=[], opts=[<Ref: NakedIdentifierSegment>, <Ref: QuotedIdentifierSegment>]]
DEBUG      [PD:4  MD:13]	.............SingleIdentifierGrammar              	Ref.match OUT       	++  	[match=<MatchResult 1/1: 'foo'>, seg="'foo'"]
INFO       [PD:4  MD:12]	............SingleIdentifierGrammar               	OneOf.match OUT     	++  	[match=<MatchResult 1/1: 'foo'>, seg="'foo'"]
DEBUG      [PD:4  MD:12]	............FunctionNameSegment                   	Ref.match OUT       	++  	[match=<MatchResult 1/1: 'foo'>, seg="'foo'"]
INFO       [PD:4  MD:11]	...........FunctionNameSegment                    	Seque.match OUT     	    	[match=<MatchResult 0/1: ''>, seg="'foo'"]
INFO       [PD:4  MD:10]	..........FunctionNameSegment                     	AnyNu.match OUT     	+   	[match=<MatchResult 2/3: 'tbl.'>, seg="'tbl.foo'"]
INFO       [PD:4  MD:10]	..........FunctionNameSegment                     	OneOf.match PRN     	    	[ns=2, ps=0, ms=0, pruned=[], opts=[<Ref: FunctionNameIdentifierSegment>, <Ref: QuotedIdentifierSegment>]]
DEBUG      [PD:4  MD:11]	...........FunctionNameSegment                    	Ref.match OUT       	++  	[match=<MatchResult 1/1: 'foo'>, seg="'foo'"]
INFO       [PD:4  MD:10]	..........FunctionNameSegment                     	OneOf.match OUT     	++  	[match=<MatchResult 1/1: 'foo'>, seg="'foo'"]
INFO       [PD:4  MD:9 ]	.........FunctionNameSegment                      	Seque.match OUT     	++  	[match=<MatchResult 3/3: 'tbl.foo'>, seg="'tbl.foo'"]
DEBUG      [PD:4  MD:8 ]	........FunctionNameSegment                       	Funct.match OUT     	++  	[match=<MatchResult 1/1: 'tbl.foo'>, seg="'tbl.foo'"]
DEBUG      [PD:4  MD:8 ]	........FunctionSegment                           	Ref.match OUT       	++  	[match=<MatchResult 1/1: 'tbl.foo'>, seg="'tbl.foo'"]
INFO       [PD:4  MD:7 ]	.......FunctionSegment                            	AnyNu.match OUT     	++  	[match=<MatchResult 1/1: 'tbl.foo'>, seg="'tbl.foo'"]
INFO       [PD:4  MD:6 ]	......FunctionSegment                             	Seque.match OUT     	    	[match=<MatchResult 0/3: ''>, seg="'tbl.foo'"]
INFO       [PD:4  MD:5 ]	.....FunctionSegment                              	Seque.match OUT     	    	[match=<MatchResult 0/3: ''>, seg="'tbl.foo'"]
INFO       [PD:4  MD:4 ]	....FunctionSegment                               	OneOf.match OUT     	    	[match=<MatchResult 0/3: ''>, seg="'tbl.foo'"]
DEBUG      [PD:4  MD:3 ]	...FunctionSegment                                	Funct.match OUT     	    	[match=<MatchResult 0/3: ''>, seg="'tbl.foo'"]
DEBUG      [PD:4  MD:3 ]	...BaseExpressionElementGrammar                   	Ref.match OUT       	    	[match=<MatchResult 0/3: ''>, seg="'tbl.foo'"]
DEBUG      [PD:4  MD:5 ]	.....ColumnReferenceSegment                       	Delim._look_ahead_match IN	    	[ls=3, seg='tbl.foo']
DEBUG      [PD:4  MD:5 ]	.....ColumnReferenceSegment                       	Delim._look_ahead_match SI	    	[mq=[(<OneOf: [<Ref: DotSegment>, <Sequence: [<Ref: DotSegment>, <Ref: Dot...]>, 1, '.'), (<OneOf: [<Ref: DotSegment>, <Sequence: [<Ref: DotSegment>, <Ref: Dot...]>, 1, '.')], sb=['TBL', '.', 'FOO']]
INFO       [PD:4  MD:5 ]	.....ColumnReferenceSegment                       	OneOf.match PRN     	    	[ns=0, ps=0, ms=2, pruned=[], opts=[<Ref: DotSegment>, <Sequence: [<Ref: DotSegment>, <Ref: DotSegment>]>]]
DEBUG      [PD:4  MD:6 ]	......ColumnReferenceSegment                      	Ref.match OUT       	+   	[match=<MatchResult 1/2: '.'>, seg="'.foo'"]
DEBUG      [PD:4  MD:7 ]	.......ColumnReferenceSegment                     	Ref.match OUT       	+   	[match=<MatchResult 1/2: '.'>, seg="'.foo'"]
DEBUG      [PD:4  MD:7 ]	.......ColumnReferenceSegment                     	Ref.match OUT       	    	[match=<MatchResult 0/1: ''>, seg="'foo'"]
INFO       [PD:4  MD:6 ]	......ColumnReferenceSegment                      	Seque.match OUT     	    	[match=<MatchResult 0/2: ''>, seg="'.foo'"]
INFO       [PD:4  MD:5 ]	.....ColumnReferenceSegment                       	OneOf.match OUT     	+   	[match=<MatchResult 1/2: '.'>, seg="'.foo'"]
INFO       [PD:4  MD:5 ]	.....ColumnReferenceSegment                       	OneOf.match PRN     	    	[ns=0, ps=0, ms=2, pruned=[], opts=[<Ref: DotSegment>, <Sequence: [<Ref: DotSegment>, <Ref: DotSegment>]>]]
DEBUG      [PD:4  MD:6 ]	......ColumnReferenceSegment                      	Ref.match OUT       	+   	[match=<MatchResult 1/2: '.'>, seg="'.foo'"]
DEBUG      [PD:4  MD:7 ]	.......ColumnReferenceSegment                     	Ref.match OUT       	+   	[match=<MatchResult 1/2: '.'>, seg="'.foo'"]
DEBUG      [PD:4  MD:7 ]	.......ColumnReferenceSegment                     	Ref.match OUT       	    	[match=<MatchResult 0/1: ''>, seg="'foo'"]
INFO       [PD:4  MD:6 ]	......ColumnReferenceSegment                      	Seque.match OUT     	    	[match=<MatchResult 0/2: ''>, seg="'.foo'"]
INFO       [PD:4  MD:5 ]	.....ColumnReferenceSegment                       	OneOf.match OUT     	+   	[match=<MatchResult 1/2: '.'>, seg="'.foo'"]
INFO       [PD:4  MD:5 ]	.....ColumnReferenceSegment                       	OneOf.match PRN     	    	[ns=1, ps=10, ms=0, pruned=[<Ref: OnKeywordSegment>, <Ref: AsKeywordSegment>, <Ref: UsingKeywordSegment>, <Ref: CommaSegment>, <Ref: CastOperatorSegment>, <Ref: StartSquareBracketSegment>, <Ref: StartBracketSegment>, <Ref: ColonSegment>, <Ref: DelimiterSegment>, <class 'sqlfluff.core.parser.segments.base.BracketedSegment'>], opts=[<Ref: BinaryOperatorGrammar>]]
INFO       [PD:4  MD:6 ]	......BinaryOperatorGrammar                       	OneOf.match PRN     	    	[ns=1, ps=3, ms=0, pruned=[<Ref: ArithmeticBinaryOperatorGrammar>, <Ref: StringBinaryOperatorGrammar>, <Ref: BooleanBinaryOperatorGrammar>], opts=[<Ref: ComparisonOperatorGrammar>]]
INFO       [PD:4  MD:7 ]	.......ComparisonOperatorGrammar                  	OneOf.match PRN     	    	[ns=1, ps=7, ms=0, pruned=[<Ref: EqualsSegment>, <Ref: GreaterThanSegment>, <Ref: LessThanSegment>, <Ref: GreaterThanOrEqualToSegment>, <Ref: LessThanOrEqualToSegment>, <Ref: NotEqualToSegment_a>, <Ref: NotEqualToSegment_b>], opts=[<Ref: LikeOperatorSegment>]]
DEBUG      [PD:4  MD:8 ]	........ComparisonOperatorGrammar                 	Ref.match OUT       	    	[match=<MatchResult 0/3: ''>, seg="'tbl.foo'"]
INFO       [PD:4  MD:7 ]	.......ComparisonOperatorGrammar                  	OneOf.match OUT     	    	[match=<MatchResult 0/3: ''>, seg="'tbl.foo'"]
DEBUG      [PD:4  MD:7 ]	.......BinaryOperatorGrammar                      	Ref.match OUT       	    	[match=<MatchResult 0/3: ''>, seg="'tbl.foo'"]
INFO       [PD:4  MD:6 ]	......BinaryOperatorGrammar                       	OneOf.match OUT     	    	[match=<MatchResult 0/3: ''>, seg="'tbl.foo'"]
DEBUG      [PD:4  MD:6 ]	......ColumnReferenceSegment                      	Ref.match OUT       	    	[match=<MatchResult 0/3: ''>, seg="'tbl.foo'"]
INFO       [PD:4  MD:5 ]	.....ColumnReferenceSegment                       	OneOf.match OUT     	    	[match=<MatchResult 0/3: ''>, seg="'tbl.foo'"]
DEBUG      [PD:4  MD:5 ]	.....ColumnReferenceSegment                       	NonCo.match OUT     	    	[match=<MatchResult 0/3: ''>, seg="'tbl.foo'"]
INFO       [PD:4  MD:5 ]	.....ColumnReferenceSegment                       	OneOf.match PRN     	    	[ns=1, ps=10, ms=0, pruned=[<Ref: OnKeywordSegment>, <Ref: AsKeywordSegment>, <Ref: UsingKeywordSegment>, <Ref: CommaSegment>, <Ref: CastOperatorSegment>, <Ref: StartSquareBracketSegment>, <Ref: StartBracketSegment>, <Ref: ColonSegment>, <Ref: DelimiterSegment>, <class 'sqlfluff.core.parser.segments.base.BracketedSegment'>], opts=[<Ref: BinaryOperatorGrammar>]]
INFO       [PD:4  MD:6 ]	......BinaryOperatorGrammar                       	OneOf.match PRN     	    	[ns=1, ps=3, ms=0, pruned=[<Ref: ArithmeticBinaryOperatorGrammar>, <Ref: StringBinaryOperatorGrammar>, <Ref: BooleanBinaryOperatorGrammar>], opts=[<Ref: ComparisonOperatorGrammar>]]
INFO       [PD:4  MD:7 ]	.......ComparisonOperatorGrammar                  	OneOf.match PRN     	    	[ns=1, ps=7, ms=0, pruned=[<Ref: EqualsSegment>, <Ref: GreaterThanSegment>, <Ref: LessThanSegment>, <Ref: GreaterThanOrEqualToSegment>, <Ref: LessThanOrEqualToSegment>, <Ref: NotEqualToSegment_a>, <Ref: NotEqualToSegment_b>], opts=[<Ref: LikeOperatorSegment>]]
DEBUG      [PD:4  MD:8 ]	........ComparisonOperatorGrammar                 	Ref.match OUT       	    	[match=<MatchResult 0/2: ''>, seg="'.foo'"]
INFO       [PD:4  MD:7 ]	.......ComparisonOperatorGrammar                  	OneOf.match OUT     	    	[match=<MatchResult 0/2: ''>, seg="'.foo'"]
DEBUG      [PD:4  MD:7 ]	.......BinaryOperatorGrammar                      	Ref.match OUT       	    	[match=<MatchResult 0/2: ''>, seg="'.foo'"]
INFO       [PD:4  MD:6 ]	......BinaryOperatorGrammar                       	OneOf.match OUT     	    	[match=<MatchResult 0/2: ''>, seg="'.foo'"]
DEBUG      [PD:4  MD:6 ]	......ColumnReferenceSegment                      	Ref.match OUT       	    	[match=<MatchResult 0/2: ''>, seg="'.foo'"]
INFO       [PD:4  MD:5 ]	.....ColumnReferenceSegment                       	OneOf.match OUT     	    	[match=<MatchResult 0/2: ''>, seg="'.foo'"]
DEBUG      [PD:4  MD:5 ]	.....ColumnReferenceSegment                       	NonCo.match OUT     	    	[match=<MatchResult 0/2: ''>, seg="'.foo'"]
INFO       [PD:4  MD:5 ]	.....SingleIdentifierGrammar                      	OneOf.match PRN     	    	[ns=2, ps=0, ms=0, pruned=[], opts=[<Ref: NakedIdentifierSegment>, <Ref: QuotedIdentifierSegment>]]
DEBUG      [PD:4  MD:6 ]	......SingleIdentifierGrammar                     	Ref.match OUT       	++  	[match=<MatchResult 1/1: 'tbl'>, seg="'tbl'"]
INFO       [PD:4  MD:5 ]	.....SingleIdentifierGrammar                      	OneOf.match OUT     	++  	[match=<MatchResult 1/1: 'tbl'>, seg="'tbl'"]
DEBUG      [PD:4  MD:5 ]	.....ColumnReferenceSegment                       	Ref.match OUT       	++  	[match=<MatchResult 1/1: 'tbl'>, seg="'tbl'"]
DEBUG      [PD:4  MD:5 ]	.....ColumnReferenceSegment                       	Delim._look_ahead_match IN	    	[ls=1, seg='foo']
DEBUG      [PD:4  MD:5 ]	.....ColumnReferenceSegment                       	Delim._look_ahead_match SI	    	[mq=[], sb=['FOO']]
INFO       [PD:4  MD:5 ]	.....ColumnReferenceSegment                       	OneOf.match PRN     	    	[ns=1, ps=10, ms=0, pruned=[<Ref: OnKeywordSegment>, <Ref: AsKeywordSegment>, <Ref: UsingKeywordSegment>, <Ref: CommaSegment>, <Ref: CastOperatorSegment>, <Ref: StartSquareBracketSegment>, <Ref: StartBracketSegment>, <Ref: ColonSegment>, <Ref: DelimiterSegment>, <class 'sqlfluff.core.parser.segments.base.BracketedSegment'>], opts=[<Ref: BinaryOperatorGrammar>]]
INFO       [PD:4  MD:6 ]	......BinaryOperatorGrammar                       	OneOf.match PRN     	    	[ns=1, ps=3, ms=0, pruned=[<Ref: ArithmeticBinaryOperatorGrammar>, <Ref: StringBinaryOperatorGrammar>, <Ref: BooleanBinaryOperatorGrammar>], opts=[<Ref: ComparisonOperatorGrammar>]]
INFO       [PD:4  MD:7 ]	.......ComparisonOperatorGrammar                  	OneOf.match PRN     	    	[ns=1, ps=7, ms=0, pruned=[<Ref: EqualsSegment>, <Ref: GreaterThanSegment>, <Ref: LessThanSegment>, <Ref: GreaterThanOrEqualToSegment>, <Ref: LessThanOrEqualToSegment>, <Ref: NotEqualToSegment_a>, <Ref: NotEqualToSegment_b>], opts=[<Ref: LikeOperatorSegment>]]
DEBUG      [PD:4  MD:8 ]	........ComparisonOperatorGrammar                 	Ref.match OUT       	    	[match=<MatchResult 0/1: ''>, seg="'foo'"]
INFO       [PD:4  MD:7 ]	.......ComparisonOperatorGrammar                  	OneOf.match OUT     	    	[match=<MatchResult 0/1: ''>, seg="'foo'"]
DEBUG      [PD:4  MD:7 ]	.......BinaryOperatorGrammar                      	Ref.match OUT       	    	[match=<MatchResult 0/1: ''>, seg="'foo'"]
INFO       [PD:4  MD:6 ]	......BinaryOperatorGrammar                       	OneOf.match OUT     	    	[match=<MatchResult 0/1: ''>, seg="'foo'"]
DEBUG      [PD:4  MD:6 ]	......ColumnReferenceSegment                      	Ref.match OUT       	    	[match=<MatchResult 0/1: ''>, seg="'foo'"]
INFO       [PD:4  MD:5 ]	.....ColumnReferenceSegment                       	OneOf.match OUT     	    	[match=<MatchResult 0/1: ''>, seg="'foo'"]
DEBUG      [PD:4  MD:5 ]	.....ColumnReferenceSegment                       	NonCo.match OUT     	    	[match=<MatchResult 0/1: ''>, seg="'foo'"]
INFO       [PD:4  MD:5 ]	.....SingleIdentifierGrammar                      	OneOf.match PRN     	    	[ns=2, ps=0, ms=0, pruned=[], opts=[<Ref: NakedIdentifierSegment>, <Ref: QuotedIdentifierSegment>]]
DEBUG      [PD:4  MD:6 ]	......SingleIdentifierGrammar                     	Ref.match OUT       	++  	[match=<MatchResult 1/1: 'foo'>, seg="'foo'"]
INFO       [PD:4  MD:5 ]	.....SingleIdentifierGrammar                      	OneOf.match OUT     	++  	[match=<MatchResult 1/1: 'foo'>, seg="'foo'"]
DEBUG      [PD:4  MD:5 ]	.....ColumnReferenceSegment                       	Ref.match OUT       	++  	[match=<MatchResult 1/1: 'foo'>, seg="'foo'"]
INFO       [PD:4  MD:4 ]	....ColumnReferenceSegment                        	Delim.match OUT     	++  	[match=<MatchResult 3/3: 'tbl.foo'>, seg="'tbl.foo'"]
DEBUG      [PD:4  MD:3 ]	...ColumnReferenceSegment                         	Colum.match OUT     	++  	[match=<MatchResult 1/1: 'tbl.foo'>, seg="'tbl.foo'"]
DEBUG      [PD:4  MD:3 ]	...BaseExpressionElementGrammar                   	Ref.match OUT       	++  	[match=<MatchResult 1/1: 'tbl.foo'>, seg="'tbl.foo'"]
INFO       [PD:4  MD:2 ]	..BaseExpressionElementGrammar                    	OneOf.match OUT     	++  	[match=<MatchResult 1/1: 'tbl.foo'>, seg="'tbl.foo'"]
DEBUG      [PD:4  MD:2 ]	..SelectClauseElementSegment                      	Ref.match OUT       	++  	[match=<MatchResult 1/1: 'tbl.foo'>, seg="'tbl.foo'"]
INFO       [PD:4  MD:1 ]	.SelectClauseElementSegment                       	Seque.match OUT     	++  	[match=<MatchResult 1/1: 'tbl.foo'>, seg="'tbl.foo'"]
INFO       [PD:4  MD:0 ]	SelectClauseElementSegment                        	OneOf.match OUT     	++  	[match=<MatchResult 1/1: 'tbl.foo'>, seg="'tbl.foo'"]
DEBUG      SelectClauseElementSegment.parse: Done Parse. Plotting Recursion. Recurse=True
DEBUG      ###
#
# Beginning Parse Depth 5: SelectClauseElementSegment
#
###
Initial Structure:
[L:  8, P:  5]      |select_clause_element:
[L:  8, P:  5]      |    column_reference:
[L:  8, P:  5]      |        identifier:                                           'tbl'
[L:  8, P:  8]      |        dot:                                                  '.'
[L:  8, P:  9]      |        identifier:                                           'foo'

INFO       [PD:5] Skipping expansion of <ColumnReferenceSegment: ([L:  8, P:  5])>...
INFO       [PD:4] Skipping expansion of <SymbolSegment: ([L:  8, P: 12]) ','>...
INFO       [PD:4] Skipping expansion of <NewlineSegment: ([L:  8, P: 13]) '\n'>...
INFO       [PD:4] Skipping expansion of <WhitespaceSegment: ([L:  9, P:  1]) '    '>...
INFO       
###
#
# Parse Depth 4. Expanding: SelectClauseElementSegment: 'c.val + b.val / -2 AS a_calculation'
#
###
INFO       [PD:4  MD:0 ]	SelectClauseElementSegment                        	OneOf.match PRN     	    	[ns=2, ps=0, ms=0, pruned=[], opts=[<Ref: WildcardExpressionSegment>, <Sequence: [<Ref: BaseExpressionElementGrammar>, <Ref: AliasExpressionSegment [opt]>]>]]
INFO       [PD:4  MD:5 ]	.....WildcardIdentifierSegment                    	AnyNu.match PRN     	    	[ns=1, ps=0, ms=0, pruned=[], opts=[<Sequence: [<Ref: SingleIdentifierGrammar>, <Ref: DotSegment>]>]]
INFO       [PD:4  MD:7 ]	.......SingleIdentifierGrammar                    	OneOf.match PRN     	    	[ns=2, ps=0, ms=0, pruned=[], opts=[<Ref: NakedIdentifierSegment>, <Ref: QuotedIdentifierSegment>]]
DEBUG      [PD:4  MD:8 ]	........SingleIdentifierGrammar                   	Ref.match OUT       	+   	[match=<MatchResult 1/18: 'c'>, seg="'c.val + b.val / -2 A...'"]
DEBUG      [PD:4  MD:8 ]	........SingleIdentifierGrammar                   	Ref.match OUT       	    	[match=<MatchResult 0/18: ''>, seg="'c.val + b.val / -2 A...'"]
INFO       [PD:4  MD:7 ]	.......SingleIdentifierGrammar                    	OneOf.match OUT     	+   	[match=<MatchResult 1/18: 'c'>, seg="'c.val + b.val / -2 A...'"]
DEBUG      [PD:4  MD:7 ]	.......WildcardIdentifierSegment                  	Ref.match OUT       	+   	[match=<MatchResult 1/18: 'c'>, seg="'c.val + b.val / -2 A...'"]
DEBUG      [PD:4  MD:7 ]	.......WildcardIdentifierSegment                  	Ref.match OUT       	+   	[match=<MatchResult 1/17: '.'>, seg="'.val + b.val / -2 AS...'"]
INFO       [PD:4  MD:6 ]	......WildcardIdentifierSegment                   	Seque.match OUT     	+   	[match=<MatchResult 2/18: 'c.'>, seg="'c.val + b.val / -2 A...'"]
INFO       [PD:4  MD:5 ]	.....WildcardIdentifierSegment                    	AnyNu.match PRN     	    	[ns=1, ps=0, ms=0, pruned=[], opts=[<Sequence: [<Ref: SingleIdentifierGrammar>, <Ref: DotSegment>]>]]
INFO       [PD:4  MD:7 ]	.......SingleIdentifierGrammar                    	OneOf.match PRN     	    	[ns=2, ps=0, ms=0, pruned=[], opts=[<Ref: NakedIdentifierSegment>, <Ref: QuotedIdentifierSegment>]]
DEBUG      [PD:4  MD:8 ]	........SingleIdentifierGrammar                   	Ref.match OUT       	+   	[match=<MatchResult 1/16: 'val'>, seg="'val + b.val / -2 AS ...'"]
DEBUG      [PD:4  MD:8 ]	........SingleIdentifierGrammar                   	Ref.match OUT       	    	[match=<MatchResult 0/16: ''>, seg="'val + b.val / -2 AS ...'"]
INFO       [PD:4  MD:7 ]	.......SingleIdentifierGrammar                    	OneOf.match OUT     	+   	[match=<MatchResult 1/16: 'val'>, seg="'val + b.val / -2 AS ...'"]
DEBUG      [PD:4  MD:7 ]	.......WildcardIdentifierSegment                  	Ref.match OUT       	+   	[match=<MatchResult 1/16: 'val'>, seg="'val + b.val / -2 AS ...'"]
DEBUG      [PD:4  MD:7 ]	.......WildcardIdentifierSegment                  	Ref.match OUT       	    	[match=<MatchResult 0/14: ''>, seg="'+ b.val / -2 AS a_ca...'"]
INFO       [PD:4  MD:6 ]	......WildcardIdentifierSegment                   	Seque.match OUT     	    	[match=<MatchResult 0/16: ''>, seg="'val + b.val / -2 AS ...'"]
INFO       [PD:4  MD:5 ]	.....WildcardIdentifierSegment                    	AnyNu.match OUT     	+   	[match=<MatchResult 2/18: 'c.'>, seg="'c.val + b.val / -2 A...'"]
DEBUG      [PD:4  MD:5 ]	.....WildcardIdentifierSegment                    	Ref.match OUT       	    	[match=<MatchResult 0/16: ''>, seg="'val + b.val / -2 AS ...'"]
INFO       [PD:4  MD:4 ]	....WildcardIdentifierSegment                     	Seque.match OUT     	    	[match=<MatchResult 0/18: ''>, seg="'c.val + b.val / -2 A...'"]
DEBUG      [PD:4  MD:3 ]	...WildcardIdentifierSegment                      	Wildc.match OUT     	    	[match=<MatchResult 0/18: ''>, seg="'c.val + b.val / -2 A...'"]
DEBUG      [PD:4  MD:3 ]	...WildcardExpressionSegment                      	Ref.match OUT       	    	[match=<MatchResult 0/18: ''>, seg="'c.val + b.val / -2 A...'"]
INFO       [PD:4  MD:2 ]	..WildcardExpressionSegment                       	Seque.match OUT     	    	[match=<MatchResult 0/18: ''>, seg="'c.val + b.val / -2 A...'"]
DEBUG      [PD:4  MD:1 ]	.WildcardExpressionSegment                        	Wildc.match OUT     	    	[match=<MatchResult 0/18: ''>, seg="'c.val + b.val / -2 A...'"]
DEBUG      [PD:4  MD:1 ]	.SelectClauseElementSegment                       	Ref.match OUT       	    	[match=<MatchResult 0/18: ''>, seg="'c.val + b.val / -2 A...'"]
INFO       [PD:4  MD:2 ]	..BaseExpressionElementGrammar                    	OneOf.match PRN     	    	[ns=5, ps=1, ms=0, pruned=[<Ref: IntervalExpressionSegment>], opts=[<Ref: LiteralGrammar>, <Ref: BareFunctionSegment>, <Ref: FunctionSegment>, <Ref: ColumnReferenceSegment>, <Ref: ExpressionSegment>]]
INFO       [PD:4  MD:3 ]	...LiteralGrammar                                 	OneOf.match PRN     	    	[ns=2, ps=4, ms=0, pruned=[<Ref: BooleanLiteralGrammar>, <Ref: QualifiedNumericLiteralSegment>, <Ref: NullLiteralSegment>, <Ref: DateTimeLiteralGrammar>], opts=[<Ref: QuotedLiteralSegment>, <Ref: NumericLiteralSegment>]]
DEBUG      [PD:4  MD:4 ]	....LiteralGrammar                                	Ref.match OUT       	    	[match=<MatchResult 0/18: ''>, seg="'c.val + b.val / -2 A...'"]
DEBUG      [PD:4  MD:4 ]	....LiteralGrammar                                	Ref.match OUT       	    	[match=<MatchResult 0/18: ''>, seg="'c.val + b.val / -2 A...'"]
INFO       [PD:4  MD:3 ]	...LiteralGrammar                                 	OneOf.match OUT     	    	[match=<MatchResult 0/18: ''>, seg="'c.val + b.val / -2 A...'"]
DEBUG      [PD:4  MD:3 ]	...BaseExpressionElementGrammar                   	Ref.match OUT       	    	[match=<MatchResult 0/18: ''>, seg="'c.val + b.val / -2 A...'"]
DEBUG      [PD:4  MD:3 ]	...BaseExpressionElementGrammar                   	Ref.match OUT       	    	[match=<MatchResult 0/18: ''>, seg="'c.val + b.val / -2 A...'"]
INFO       [PD:4  MD:4 ]	....FunctionSegment                               	OneOf.match PRN     	    	[ns=1, ps=1, ms=0, pruned=[<Sequence: [<Sequence: [<Ref: DateAddFunctionNameSeg...]>], opts=[<Sequence: [<Sequence: [<AnyNumberOf: [<Ref: Functio..., <Ref: PostFunctionGrammar [opt]>]>]]
DEBUG      [PD:4  MD:10]	..........DateAddFunctionNameSegment              	Ref.match OUT       	    	[match=<MatchResult 0/18: ''>, seg="'c.val + b.val / -2 A...'"]
INFO       [PD:4  MD:9 ]	.........DateAddFunctionNameSegment               	Seque.match OUT     	    	[match=<MatchResult 0/18: ''>, seg="'c.val + b.val / -2 A...'"]
DEBUG      [PD:4  MD:8 ]	........DateAddFunctionNameSegment                	DateA.match OUT     	    	[match=<MatchResult 0/18: ''>, seg="'c.val + b.val / -2 A...'"]
DEBUG      [PD:4  MD:8 ]	........FunctionSegment                           	Ref.match OUT       	    	[match=<MatchResult 0/18: ''>, seg="'c.val + b.val / -2 A...'"]
INFO       [PD:4  MD:7 ]	.......FunctionSegment                            	AnyNu.match PRN     	    	[ns=1, ps=0, ms=0, pruned=[], opts=[<Ref: FunctionNameSegment>]]
INFO       [PD:4  MD:10]	..........FunctionNameSegment                     	AnyNu.match PRN     	    	[ns=1, ps=0, ms=0, pruned=[], opts=[<Sequence: [<Ref: SingleIdentifierGrammar>, <Ref: DotSegment>]>]]
INFO       [PD:4  MD:12]	............SingleIdentifierGrammar               	OneOf.match PRN     	    	[ns=2, ps=0, ms=0, pruned=[], opts=[<Ref: NakedIdentifierSegment>, <Ref: QuotedIdentifierSegment>]]
DEBUG      [PD:4  MD:13]	.............SingleIdentifierGrammar              	Ref.match OUT       	+   	[match=<MatchResult 1/18: 'c'>, seg="'c.val + b.val / -2 A...'"]
DEBUG      [PD:4  MD:13]	.............SingleIdentifierGrammar              	Ref.match OUT       	    	[match=<MatchResult 0/18: ''>, seg="'c.val + b.val / -2 A...'"]
INFO       [PD:4  MD:12]	............SingleIdentifierGrammar               	OneOf.match OUT     	+   	[match=<MatchResult 1/18: 'c'>, seg="'c.val + b.val / -2 A...'"]
DEBUG      [PD:4  MD:12]	............FunctionNameSegment                   	Ref.match OUT       	+   	[match=<MatchResult 1/18: 'c'>, seg="'c.val + b.val / -2 A...'"]
DEBUG      [PD:4  MD:12]	............FunctionNameSegment                   	Ref.match OUT       	+   	[match=<MatchResult 1/17: '.'>, seg="'.val + b.val / -2 AS...'"]
INFO       [PD:4  MD:11]	...........FunctionNameSegment                    	Seque.match OUT     	+   	[match=<MatchResult 2/18: 'c.'>, seg="'c.val + b.val / -2 A...'"]
INFO       [PD:4  MD:10]	..........FunctionNameSegment                     	AnyNu.match PRN     	    	[ns=1, ps=0, ms=0, pruned=[], opts=[<Sequence: [<Ref: SingleIdentifierGrammar>, <Ref: DotSegment>]>]]
INFO       [PD:4  MD:12]	............SingleIdentifierGrammar               	OneOf.match PRN     	    	[ns=2, ps=0, ms=0, pruned=[], opts=[<Ref: NakedIdentifierSegment>, <Ref: QuotedIdentifierSegment>]]
DEBUG      [PD:4  MD:13]	.............SingleIdentifierGrammar              	Ref.match OUT       	+   	[match=<MatchResult 1/16: 'val'>, seg="'val + b.val / -2 AS ...'"]
DEBUG      [PD:4  MD:13]	.............SingleIdentifierGrammar              	Ref.match OUT       	    	[match=<MatchResult 0/16: ''>, seg="'val + b.val / -2 AS ...'"]
INFO       [PD:4  MD:12]	............SingleIdentifierGrammar               	OneOf.match OUT     	+   	[match=<MatchResult 1/16: 'val'>, seg="'val + b.val / -2 AS ...'"]
DEBUG      [PD:4  MD:12]	............FunctionNameSegment                   	Ref.match OUT       	+   	[match=<MatchResult 1/16: 'val'>, seg="'val + b.val / -2 AS ...'"]
DEBUG      [PD:4  MD:12]	............FunctionNameSegment                   	Ref.match OUT       	    	[match=<MatchResult 0/14: ''>, seg="'+ b.val / -2 AS a_ca...'"]
INFO       [PD:4  MD:11]	...........FunctionNameSegment                    	Seque.match OUT     	    	[match=<MatchResult 0/16: ''>, seg="'val + b.val / -2 AS ...'"]
INFO       [PD:4  MD:10]	..........FunctionNameSegment                     	AnyNu.match OUT     	+   	[match=<MatchResult 2/18: 'c.'>, seg="'c.val + b.val / -2 A...'"]
INFO       [PD:4  MD:10]	..........FunctionNameSegment                     	OneOf.match PRN     	    	[ns=2, ps=0, ms=0, pruned=[], opts=[<Ref: FunctionNameIdentifierSegment>, <Ref: QuotedIdentifierSegment>]]
DEBUG      [PD:4  MD:11]	...........FunctionNameSegment                    	Ref.match OUT       	+   	[match=<MatchResult 1/16: 'val'>, seg="'val + b.val / -2 AS ...'"]
DEBUG      [PD:4  MD:11]	...........FunctionNameSegment                    	Ref.match OUT       	    	[match=<MatchResult 0/16: ''>, seg="'val + b.val / -2 AS ...'"]
INFO       [PD:4  MD:10]	..........FunctionNameSegment                     	OneOf.match OUT     	+   	[match=<MatchResult 1/16: 'val'>, seg="'val + b.val / -2 AS ...'"]
INFO       [PD:4  MD:9 ]	.........FunctionNameSegment                      	Seque.match OUT     	+   	[match=<MatchResult 3/18: 'c.val'>, seg="'c.val + b.val / -2 A...'"]
DEBUG      [PD:4  MD:8 ]	........FunctionNameSegment                       	Funct.match OUT     	+   	[match=<MatchResult 1/16: 'c.val'>, seg="'c.val + b.val / -2 A...'"]
DEBUG      [PD:4  MD:8 ]	........FunctionSegment                           	Ref.match OUT       	+   	[match=<MatchResult 1/16: 'c.val'>, seg="'c.val + b.val / -2 A...'"]
INFO       [PD:4  MD:7 ]	.......FunctionSegment                            	AnyNu.match OUT     	+   	[match=<MatchResult 1/16: 'c.val'>, seg="'c.val + b.val / -2 A...'"]
INFO       [PD:4  MD:7 ]	.......FunctionSegment                            	Brack.match OUT     	    	[match=<MatchResult 0/14: ''>, seg="'+ b.val / -2 AS a_ca...'"]
INFO       [PD:4  MD:6 ]	......FunctionSegment                             	Seque.match OUT     	    	[match=<MatchResult 0/18: ''>, seg="'c.val + b.val / -2 A...'"]
INFO       [PD:4  MD:5 ]	.....FunctionSegment                              	Seque.match OUT     	    	[match=<MatchResult 0/18: ''>, seg="'c.val + b.val / -2 A...'"]
INFO       [PD:4  MD:4 ]	....FunctionSegment                               	OneOf.match OUT     	    	[match=<MatchResult 0/18: ''>, seg="'c.val + b.val / -2 A...'"]
DEBUG      [PD:4  MD:3 ]	...FunctionSegment                                	Funct.match OUT     	    	[match=<MatchResult 0/18: ''>, seg="'c.val + b.val / -2 A...'"]
DEBUG      [PD:4  MD:3 ]	...BaseExpressionElementGrammar                   	Ref.match OUT       	    	[match=<MatchResult 0/18: ''>, seg="'c.val + b.val / -2 A...'"]
DEBUG      [PD:4  MD:5 ]	.....ColumnReferenceSegment                       	Delim._look_ahead_match IN	    	[ls=18, seg='c.val + b.val / -2 A...']
DEBUG      [PD:4  MD:5 ]	.....ColumnReferenceSegment                       	Delim._look_ahead_match SI	    	[mq=[(<OneOf: [<Ref: DotSegment>, <Sequence: [<Ref: DotSegment>, <Ref: Dot...]>, 1, '.'), (<OneOf: [<Ref: DotSegment>, <Sequence: [<Ref: DotSegment>, <Ref: Dot...]>, 1, '.'), (<OneOf: [<Ref: DotSegment>, <Sequence: [<Ref: DotSegment>, <Ref: Dot...]>, 7, '.'), (<OneOf: [<Ref: DotSegment>, <Sequence: [<Ref: DotSegment>, <Ref: Dot...]>, 7, '.')], sb=['C', '.', 'VAL', '', '+', '', 'B', '.', 'VAL', '', '/', '', '-', '2', '', 'AS', '', 'A_CALCULATION']]
INFO       [PD:4  MD:5 ]	.....ColumnReferenceSegment                       	OneOf.match PRN     	    	[ns=0, ps=0, ms=2, pruned=[], opts=[<Ref: DotSegment>, <Sequence: [<Ref: DotSegment>, <Ref: DotSegment>]>]]
DEBUG      [PD:4  MD:6 ]	......ColumnReferenceSegment                      	Ref.match OUT       	+   	[match=<MatchResult 1/11: '.'>, seg="'.val / -2 AS a_calcu...'"]
DEBUG      [PD:4  MD:7 ]	.......ColumnReferenceSegment                     	Ref.match OUT       	+   	[match=<MatchResult 1/11: '.'>, seg="'.val / -2 AS a_calcu...'"]
DEBUG      [PD:4  MD:7 ]	.......ColumnReferenceSegment                     	Ref.match OUT       	    	[match=<MatchResult 0/10: ''>, seg="'val / -2 AS a_calcul...'"]
INFO       [PD:4  MD:6 ]	......ColumnReferenceSegment                      	Seque.match OUT     	    	[match=<MatchResult 0/11: ''>, seg="'.val / -2 AS a_calcu...'"]
INFO       [PD:4  MD:5 ]	.....ColumnReferenceSegment                       	OneOf.match OUT     	+   	[match=<MatchResult 1/11: '.'>, seg="'.val / -2 AS a_calcu...'"]
INFO       [PD:4  MD:5 ]	.....ColumnReferenceSegment                       	OneOf.match PRN     	    	[ns=0, ps=0, ms=2, pruned=[], opts=[<Ref: DotSegment>, <Sequence: [<Ref: DotSegment>, <Ref: DotSegment>]>]]
DEBUG      [PD:4  MD:6 ]	......ColumnReferenceSegment                      	Ref.match OUT       	+   	[match=<MatchResult 1/11: '.'>, seg="'.val / -2 AS a_calcu...'"]
DEBUG      [PD:4  MD:7 ]	.......ColumnReferenceSegment                     	Ref.match OUT       	+   	[match=<MatchResult 1/11: '.'>, seg="'.val / -2 AS a_calcu...'"]
DEBUG      [PD:4  MD:7 ]	.......ColumnReferenceSegment                     	Ref.match OUT       	    	[match=<MatchResult 0/10: ''>, seg="'val / -2 AS a_calcul...'"]
INFO       [PD:4  MD:6 ]	......ColumnReferenceSegment                      	Seque.match OUT     	    	[match=<MatchResult 0/11: ''>, seg="'.val / -2 AS a_calcu...'"]
INFO       [PD:4  MD:5 ]	.....ColumnReferenceSegment                       	OneOf.match OUT     	+   	[match=<MatchResult 1/11: '.'>, seg="'.val / -2 AS a_calcu...'"]
INFO       [PD:4  MD:5 ]	.....ColumnReferenceSegment                       	OneOf.match PRN     	    	[ns=0, ps=0, ms=2, pruned=[], opts=[<Ref: DotSegment>, <Sequence: [<Ref: DotSegment>, <Ref: DotSegment>]>]]
DEBUG      [PD:4  MD:6 ]	......ColumnReferenceSegment                      	Ref.match OUT       	+   	[match=<MatchResult 1/17: '.'>, seg="'.val + b.val / -2 AS...'"]
DEBUG      [PD:4  MD:7 ]	.......ColumnReferenceSegment                     	Ref.match OUT       	+   	[match=<MatchResult 1/17: '.'>, seg="'.val + b.val / -2 AS...'"]
DEBUG      [PD:4  MD:7 ]	.......ColumnReferenceSegment                     	Ref.match OUT       	    	[match=<MatchResult 0/16: ''>, seg="'val + b.val / -2 AS ...'"]
INFO       [PD:4  MD:6 ]	......ColumnReferenceSegment                      	Seque.match OUT     	    	[match=<MatchResult 0/17: ''>, seg="'.val + b.val / -2 AS...'"]
INFO       [PD:4  MD:5 ]	.....ColumnReferenceSegment                       	OneOf.match OUT     	+   	[match=<MatchResult 1/17: '.'>, seg="'.val + b.val / -2 AS...'"]
INFO       [PD:4  MD:5 ]	.....ColumnReferenceSegment                       	OneOf.match PRN     	    	[ns=0, ps=0, ms=2, pruned=[], opts=[<Ref: DotSegment>, <Sequence: [<Ref: DotSegment>, <Ref: DotSegment>]>]]
DEBUG      [PD:4  MD:6 ]	......ColumnReferenceSegment                      	Ref.match OUT       	+   	[match=<MatchResult 1/17: '.'>, seg="'.val + b.val / -2 AS...'"]
DEBUG      [PD:4  MD:7 ]	.......ColumnReferenceSegment                     	Ref.match OUT       	+   	[match=<MatchResult 1/17: '.'>, seg="'.val + b.val / -2 AS...'"]
DEBUG      [PD:4  MD:7 ]	.......ColumnReferenceSegment                     	Ref.match OUT       	    	[match=<MatchResult 0/16: ''>, seg="'val + b.val / -2 AS ...'"]
INFO       [PD:4  MD:6 ]	......ColumnReferenceSegment                      	Seque.match OUT     	    	[match=<MatchResult 0/17: ''>, seg="'.val + b.val / -2 AS...'"]
INFO       [PD:4  MD:5 ]	.....ColumnReferenceSegment                       	OneOf.match OUT     	+   	[match=<MatchResult 1/17: '.'>, seg="'.val + b.val / -2 AS...'"]
INFO       [PD:4  MD:5 ]	.....ColumnReferenceSegment                       	OneOf.match PRN     	    	[ns=1, ps=10, ms=0, pruned=[<Ref: OnKeywordSegment>, <Ref: AsKeywordSegment>, <Ref: UsingKeywordSegment>, <Ref: CommaSegment>, <Ref: CastOperatorSegment>, <Ref: StartSquareBracketSegment>, <Ref: StartBracketSegment>, <Ref: ColonSegment>, <Ref: DelimiterSegment>, <class 'sqlfluff.core.parser.segments.base.BracketedSegment'>], opts=[<Ref: BinaryOperatorGrammar>]]
INFO       [PD:4  MD:6 ]	......BinaryOperatorGrammar                       	OneOf.match PRN     	    	[ns=1, ps=3, ms=0, pruned=[<Ref: ArithmeticBinaryOperatorGrammar>, <Ref: StringBinaryOperatorGrammar>, <Ref: BooleanBinaryOperatorGrammar>], opts=[<Ref: ComparisonOperatorGrammar>]]
INFO       [PD:4  MD:7 ]	.......ComparisonOperatorGrammar                  	OneOf.match PRN     	    	[ns=1, ps=7, ms=0, pruned=[<Ref: EqualsSegment>, <Ref: GreaterThanSegment>, <Ref: LessThanSegment>, <Ref: GreaterThanOrEqualToSegment>, <Ref: LessThanOrEqualToSegment>, <Ref: NotEqualToSegment_a>, <Ref: NotEqualToSegment_b>], opts=[<Ref: LikeOperatorSegment>]]
DEBUG      [PD:4  MD:8 ]	........ComparisonOperatorGrammar                 	Ref.match OUT       	    	[match=<MatchResult 0/18: ''>, seg="'c.val + b.val / -2 A...'"]
INFO       [PD:4  MD:7 ]	.......ComparisonOperatorGrammar                  	OneOf.match OUT     	    	[match=<MatchResult 0/18: ''>, seg="'c.val + b.val / -2 A...'"]
DEBUG      [PD:4  MD:7 ]	.......BinaryOperatorGrammar                      	Ref.match OUT       	    	[match=<MatchResult 0/18: ''>, seg="'c.val + b.val / -2 A...'"]
INFO       [PD:4  MD:6 ]	......BinaryOperatorGrammar                       	OneOf.match OUT     	    	[match=<MatchResult 0/18: ''>, seg="'c.val + b.val / -2 A...'"]
DEBUG      [PD:4  MD:6 ]	......ColumnReferenceSegment                      	Ref.match OUT       	    	[match=<MatchResult 0/18: ''>, seg="'c.val + b.val / -2 A...'"]
INFO       [PD:4  MD:5 ]	.....ColumnReferenceSegment                       	OneOf.match OUT     	    	[match=<MatchResult 0/18: ''>, seg="'c.val + b.val / -2 A...'"]
DEBUG      [PD:4  MD:5 ]	.....ColumnReferenceSegment                       	NonCo.match OUT     	    	[match=<MatchResult 0/18: ''>, seg="'c.val + b.val / -2 A...'"]
INFO       [PD:4  MD:5 ]	.....ColumnReferenceSegment                       	OneOf.match PRN     	    	[ns=1, ps=10, ms=0, pruned=[<Ref: OnKeywordSegment>, <Ref: AsKeywordSegment>, <Ref: UsingKeywordSegment>, <Ref: CommaSegment>, <Ref: CastOperatorSegment>, <Ref: StartSquareBracketSegment>, <Ref: StartBracketSegment>, <Ref: ColonSegment>, <Ref: DelimiterSegment>, <class 'sqlfluff.core.parser.segments.base.BracketedSegment'>], opts=[<Ref: BinaryOperatorGrammar>]]
INFO       [PD:4  MD:6 ]	......BinaryOperatorGrammar                       	OneOf.match PRN     	    	[ns=1, ps=3, ms=0, pruned=[<Ref: ArithmeticBinaryOperatorGrammar>, <Ref: StringBinaryOperatorGrammar>, <Ref: BooleanBinaryOperatorGrammar>], opts=[<Ref: ComparisonOperatorGrammar>]]
INFO       [PD:4  MD:7 ]	.......ComparisonOperatorGrammar                  	OneOf.match PRN     	    	[ns=1, ps=7, ms=0, pruned=[<Ref: EqualsSegment>, <Ref: GreaterThanSegment>, <Ref: LessThanSegment>, <Ref: GreaterThanOrEqualToSegment>, <Ref: LessThanOrEqualToSegment>, <Ref: NotEqualToSegment_a>, <Ref: NotEqualToSegment_b>], opts=[<Ref: LikeOperatorSegment>]]
DEBUG      [PD:4  MD:8 ]	........ComparisonOperatorGrammar                 	Ref.match OUT       	    	[match=<MatchResult 0/17: ''>, seg="'.val + b.val / -2 AS...'"]
INFO       [PD:4  MD:7 ]	.......ComparisonOperatorGrammar                  	OneOf.match OUT     	    	[match=<MatchResult 0/17: ''>, seg="'.val + b.val / -2 AS...'"]
DEBUG      [PD:4  MD:7 ]	.......BinaryOperatorGrammar                      	Ref.match OUT       	    	[match=<MatchResult 0/17: ''>, seg="'.val + b.val / -2 AS...'"]
INFO       [PD:4  MD:6 ]	......BinaryOperatorGrammar                       	OneOf.match OUT     	    	[match=<MatchResult 0/17: ''>, seg="'.val + b.val / -2 AS...'"]
DEBUG      [PD:4  MD:6 ]	......ColumnReferenceSegment                      	Ref.match OUT       	    	[match=<MatchResult 0/17: ''>, seg="'.val + b.val / -2 AS...'"]
INFO       [PD:4  MD:5 ]	.....ColumnReferenceSegment                       	OneOf.match OUT     	    	[match=<MatchResult 0/17: ''>, seg="'.val + b.val / -2 AS...'"]
DEBUG      [PD:4  MD:5 ]	.....ColumnReferenceSegment                       	NonCo.match OUT     	    	[match=<MatchResult 0/17: ''>, seg="'.val + b.val / -2 AS...'"]
INFO       [PD:4  MD:5 ]	.....SingleIdentifierGrammar                      	OneOf.match PRN     	    	[ns=2, ps=0, ms=0, pruned=[], opts=[<Ref: NakedIdentifierSegment>, <Ref: QuotedIdentifierSegment>]]
DEBUG      [PD:4  MD:6 ]	......SingleIdentifierGrammar                     	Ref.match OUT       	++  	[match=<MatchResult 1/1: 'c'>, seg="'c'"]
INFO       [PD:4  MD:5 ]	.....SingleIdentifierGrammar                      	OneOf.match OUT     	++  	[match=<MatchResult 1/1: 'c'>, seg="'c'"]
DEBUG      [PD:4  MD:5 ]	.....ColumnReferenceSegment                       	Ref.match OUT       	++  	[match=<MatchResult 1/1: 'c'>, seg="'c'"]
DEBUG      [PD:4  MD:5 ]	.....ColumnReferenceSegment                       	Delim._look_ahead_match IN	    	[ls=16, seg='val + b.val / -2 AS ...']
DEBUG      [PD:4  MD:5 ]	.....ColumnReferenceSegment                       	Delim._look_ahead_match SI	    	[mq=[(<OneOf: [<Ref: DotSegment>, <Sequence: [<Ref: DotSegment>, <Ref: Dot...]>, 5, '.'), (<OneOf: [<Ref: DotSegment>, <Sequence: [<Ref: DotSegment>, <Ref: Dot...]>, 5, '.')], sb=['VAL', '', '+', '', 'B', '.', 'VAL', '', '/', '', '-', '2', '', 'AS', '', 'A_CALCULATION']]
INFO       [PD:4  MD:5 ]	.....ColumnReferenceSegment                       	OneOf.match PRN     	    	[ns=0, ps=0, ms=2, pruned=[], opts=[<Ref: DotSegment>, <Sequence: [<Ref: DotSegment>, <Ref: DotSegment>]>]]
DEBUG      [PD:4  MD:6 ]	......ColumnReferenceSegment                      	Ref.match OUT       	+   	[match=<MatchResult 1/11: '.'>, seg="'.val / -2 AS a_calcu...'"]
DEBUG      [PD:4  MD:7 ]	.......ColumnReferenceSegment                     	Ref.match OUT       	+   	[match=<MatchResult 1/11: '.'>, seg="'.val / -2 AS a_calcu...'"]
DEBUG      [PD:4  MD:7 ]	.......ColumnReferenceSegment                     	Ref.match OUT       	    	[match=<MatchResult 0/10: ''>, seg="'val / -2 AS a_calcul...'"]
INFO       [PD:4  MD:6 ]	......ColumnReferenceSegment                      	Seque.match OUT     	    	[match=<MatchResult 0/11: ''>, seg="'.val / -2 AS a_calcu...'"]
INFO       [PD:4  MD:5 ]	.....ColumnReferenceSegment                       	OneOf.match OUT     	+   	[match=<MatchResult 1/11: '.'>, seg="'.val / -2 AS a_calcu...'"]
INFO       [PD:4  MD:5 ]	.....ColumnReferenceSegment                       	OneOf.match PRN     	    	[ns=0, ps=0, ms=2, pruned=[], opts=[<Ref: DotSegment>, <Sequence: [<Ref: DotSegment>, <Ref: DotSegment>]>]]
DEBUG      [PD:4  MD:6 ]	......ColumnReferenceSegment                      	Ref.match OUT       	+   	[match=<MatchResult 1/11: '.'>, seg="'.val / -2 AS a_calcu...'"]
DEBUG      [PD:4  MD:7 ]	.......ColumnReferenceSegment                     	Ref.match OUT       	+   	[match=<MatchResult 1/11: '.'>, seg="'.val / -2 AS a_calcu...'"]
DEBUG      [PD:4  MD:7 ]	.......ColumnReferenceSegment                     	Ref.match OUT       	    	[match=<MatchResult 0/10: ''>, seg="'val / -2 AS a_calcul...'"]
INFO       [PD:4  MD:6 ]	......ColumnReferenceSegment                      	Seque.match OUT     	    	[match=<MatchResult 0/11: ''>, seg="'.val / -2 AS a_calcu...'"]
INFO       [PD:4  MD:5 ]	.....ColumnReferenceSegment                       	OneOf.match OUT     	+   	[match=<MatchResult 1/11: '.'>, seg="'.val / -2 AS a_calcu...'"]
INFO       [PD:4  MD:5 ]	.....ColumnReferenceSegment                       	OneOf.match PRN     	    	[ns=1, ps=10, ms=0, pruned=[<Ref: OnKeywordSegment>, <Ref: AsKeywordSegment>, <Ref: UsingKeywordSegment>, <Ref: CommaSegment>, <Ref: CastOperatorSegment>, <Ref: StartSquareBracketSegment>, <Ref: StartBracketSegment>, <Ref: ColonSegment>, <Ref: DelimiterSegment>, <class 'sqlfluff.core.parser.segments.base.BracketedSegment'>], opts=[<Ref: BinaryOperatorGrammar>]]
INFO       [PD:4  MD:6 ]	......BinaryOperatorGrammar                       	OneOf.match PRN     	    	[ns=1, ps=3, ms=0, pruned=[<Ref: ArithmeticBinaryOperatorGrammar>, <Ref: StringBinaryOperatorGrammar>, <Ref: BooleanBinaryOperatorGrammar>], opts=[<Ref: ComparisonOperatorGrammar>]]
INFO       [PD:4  MD:7 ]	.......ComparisonOperatorGrammar                  	OneOf.match PRN     	    	[ns=1, ps=7, ms=0, pruned=[<Ref: EqualsSegment>, <Ref: GreaterThanSegment>, <Ref: LessThanSegment>, <Ref: GreaterThanOrEqualToSegment>, <Ref: LessThanOrEqualToSegment>, <Ref: NotEqualToSegment_a>, <Ref: NotEqualToSegment_b>], opts=[<Ref: LikeOperatorSegment>]]
DEBUG      [PD:4  MD:8 ]	........ComparisonOperatorGrammar                 	Ref.match OUT       	    	[match=<MatchResult 0/16: ''>, seg="'val + b.val / -2 AS ...'"]
INFO       [PD:4  MD:7 ]	.......ComparisonOperatorGrammar                  	OneOf.match OUT     	    	[match=<MatchResult 0/16: ''>, seg="'val + b.val / -2 AS ...'"]
DEBUG      [PD:4  MD:7 ]	.......BinaryOperatorGrammar                      	Ref.match OUT       	    	[match=<MatchResult 0/16: ''>, seg="'val + b.val / -2 AS ...'"]
INFO       [PD:4  MD:6 ]	......BinaryOperatorGrammar                       	OneOf.match OUT     	    	[match=<MatchResult 0/16: ''>, seg="'val + b.val / -2 AS ...'"]
DEBUG      [PD:4  MD:6 ]	......ColumnReferenceSegment                      	Ref.match OUT       	    	[match=<MatchResult 0/16: ''>, seg="'val + b.val / -2 AS ...'"]
INFO       [PD:4  MD:5 ]	.....ColumnReferenceSegment                       	OneOf.match OUT     	    	[match=<MatchResult 0/16: ''>, seg="'val + b.val / -2 AS ...'"]
DEBUG      [PD:4  MD:5 ]	.....ColumnReferenceSegment                       	NonCo.match OUT     	    	[match=<MatchResult 0/16: ''>, seg="'val + b.val / -2 AS ...'"]
INFO       [PD:4  MD:5 ]	.....ColumnReferenceSegment                       	OneOf.match PRN     	    	[ns=1, ps=10, ms=0, pruned=[<Ref: OnKeywordSegment>, <Ref: AsKeywordSegment>, <Ref: UsingKeywordSegment>, <Ref: CommaSegment>, <Ref: CastOperatorSegment>, <Ref: StartSquareBracketSegment>, <Ref: StartBracketSegment>, <Ref: ColonSegment>, <Ref: DelimiterSegment>, <class 'sqlfluff.core.parser.segments.base.BracketedSegment'>], opts=[<Ref: BinaryOperatorGrammar>]]
INFO       [PD:4  MD:6 ]	......BinaryOperatorGrammar                       	OneOf.match PRN     	    	[ns=1, ps=2, ms=1, pruned=[<Ref: StringBinaryOperatorGrammar>, <Ref: BooleanBinaryOperatorGrammar>], opts=[<Ref: ArithmeticBinaryOperatorGrammar>, <Ref: ComparisonOperatorGrammar>]]
INFO       [PD:4  MD:7 ]	.......ArithmeticBinaryOperatorGrammar            	OneOf.match PRN     	    	[ns=0, ps=9, ms=1, pruned=[<Ref: MinusSegment>, <Ref: DivideSegment>, <Ref: MultiplySegment>, <Ref: ModuloSegment>, <Ref: BitwiseAndSegment>, <Ref: BitwiseOrSegment>, <Ref: BitwiseXorSegment>, <Ref: BitwiseLShiftSegment>, <Ref: BitwiseRShiftSegment>], opts=[<Ref: PlusSegment>]]
DEBUG      [PD:4  MD:8 ]	........ArithmeticBinaryOperatorGrammar           	Ref.match OUT       	    	[match=<MatchResult 0/15: ''>, seg="' + b.val / -2 AS a_c...'"]
INFO       [PD:4  MD:7 ]	.......ArithmeticBinaryOperatorGrammar            	OneOf.match OUT     	    	[match=<MatchResult 0/15: ''>, seg="' + b.val / -2 AS a_c...'"]
DEBUG      [PD:4  MD:7 ]	.......BinaryOperatorGrammar                      	Ref.match OUT       	    	[match=<MatchResult 0/15: ''>, seg="' + b.val / -2 AS a_c...'"]
INFO       [PD:4  MD:7 ]	.......ComparisonOperatorGrammar                  	OneOf.match PRN     	    	[ns=1, ps=7, ms=0, pruned=[<Ref: EqualsSegment>, <Ref: GreaterThanSegment>, <Ref: LessThanSegment>, <Ref: GreaterThanOrEqualToSegment>, <Ref: LessThanOrEqualToSegment>, <Ref: NotEqualToSegment_a>, <Ref: NotEqualToSegment_b>], opts=[<Ref: LikeOperatorSegment>]]
DEBUG      [PD:4  MD:8 ]	........ComparisonOperatorGrammar                 	Ref.match OUT       	    	[match=<MatchResult 0/15: ''>, seg="' + b.val / -2 AS a_c...'"]
INFO       [PD:4  MD:7 ]	.......ComparisonOperatorGrammar                  	OneOf.match OUT     	    	[match=<MatchResult 0/15: ''>, seg="' + b.val / -2 AS a_c...'"]
DEBUG      [PD:4  MD:7 ]	.......BinaryOperatorGrammar                      	Ref.match OUT       	    	[match=<MatchResult 0/15: ''>, seg="' + b.val / -2 AS a_c...'"]
INFO       [PD:4  MD:6 ]	......BinaryOperatorGrammar                       	OneOf.match OUT     	    	[match=<MatchResult 0/15: ''>, seg="' + b.val / -2 AS a_c...'"]
DEBUG      [PD:4  MD:6 ]	......ColumnReferenceSegment                      	Ref.match OUT       	    	[match=<MatchResult 0/15: ''>, seg="' + b.val / -2 AS a_c...'"]
INFO       [PD:4  MD:5 ]	.....ColumnReferenceSegment                       	OneOf.match OUT     	    	[match=<MatchResult 0/15: ''>, seg="' + b.val / -2 AS a_c...'"]
DEBUG      [PD:4  MD:5 ]	.....ColumnReferenceSegment                       	NonCo.match OUT     	+   	[match=<MatchResult 1/15: ' '>, seg="' + b.val / -2 AS a_c...'"]
INFO       [PD:4  MD:5 ]	.....SingleIdentifierGrammar                      	OneOf.match PRN     	    	[ns=2, ps=0, ms=0, pruned=[], opts=[<Ref: NakedIdentifierSegment>, <Ref: QuotedIdentifierSegment>]]
DEBUG      [PD:4  MD:6 ]	......SingleIdentifierGrammar                     	Ref.match OUT       	++  	[match=<MatchResult 1/1: 'val'>, seg="'val'"]
INFO       [PD:4  MD:5 ]	.....SingleIdentifierGrammar                      	OneOf.match OUT     	++  	[match=<MatchResult 1/1: 'val'>, seg="'val'"]
DEBUG      [PD:4  MD:5 ]	.....ColumnReferenceSegment                       	Ref.match OUT       	++  	[match=<MatchResult 1/1: 'val'>, seg="'val'"]
INFO       [PD:4  MD:4 ]	....ColumnReferenceSegment                        	Delim.match OUT     	+   	[match=<MatchResult 3/18: 'c.val'>, seg="'c.val + b.val / -2 A...'"]
DEBUG      [PD:4  MD:3 ]	...ColumnReferenceSegment                         	Colum.match OUT     	+   	[match=<MatchResult 1/16: 'c.val'>, seg="'c.val + b.val / -2 A...'"]
DEBUG      [PD:4  MD:3 ]	...BaseExpressionElementGrammar                   	Ref.match OUT       	+   	[match=<MatchResult 1/16: 'c.val'>, seg="'c.val + b.val / -2 A...'"]
INFO       [PD:4  MD:5 ]	.....Expression_A_Grammar                         	OneOf.match PRN     	    	[ns=1, ps=1, ms=0, pruned=[<Sequence: [<OneOf: [<Ref: PositiveSegment>, <Ref: N..., <Ref: Expression_C_Grammar>]>], opts=[<Ref: Expression_C_Grammar>]]
INFO       [PD:4  MD:6 ]	......Expression_C_Grammar                        	OneOf.match PRN     	    	[ns=1, ps=2, ms=0, pruned=[<Sequence: [<Ref: ExistsKeywordSegment>, <Bracketed: [<Ref: SelectStatementSegmen...]>, <Ref: CaseExpressionSegment>], opts=[<Ref: Expression_D_Grammar>]]
INFO       [PD:4  MD:8 ]	........Expression_D_Grammar                      	OneOf.match PRN     	    	[ns=6, ps=3, ms=0, pruned=[<Bracketed: [<OneOf: [<Ref: ExpressionSegment>, <Ref:...]>, <Ref: SelectStatementSegment>, <Ref: IntervalExpressionSegment>], opts=[<Ref: BareFunctionSegment>, <Ref: FunctionSegment>, <Ref: LiteralGrammar>, <Ref: ColumnReferenceSegment>, <Sequence: [<Ref: SimpleArrayTypeGrammar [opt]>, <Ref: ArrayLiteralSegment>]>, <Sequence: [<Ref: DatatypeSegment>, <OneOf: [<Ref: QuotedLiteralSegment>, <R...]>]]
DEBUG      [PD:4  MD:9 ]	.........Expression_D_Grammar                     	Ref.match OUT       	    	[match=<MatchResult 0/18: ''>, seg="'c.val + b.val / -2 A...'"]
INFO       [PD:4  MD:10]	..........FunctionSegment                         	OneOf.match PRN     	    	[ns=1, ps=1, ms=0, pruned=[<Sequence: [<Sequence: [<Ref: DateAddFunctionNameSeg...]>], opts=[<Sequence: [<Sequence: [<AnyNumberOf: [<Ref: Functio..., <Ref: PostFunctionGrammar [opt]>]>]]
DEBUG      [PD:4  MD:16]	................DateAddFunctionNameSegment        	Ref.match OUT       	    	[match=<MatchResult 0/18: ''>, seg="'c.val + b.val / -2 A...'"]
INFO       [PD:4  MD:15]	...............DateAddFunctionNameSegment         	Seque.match OUT     	    	[match=<MatchResult 0/18: ''>, seg="'c.val + b.val / -2 A...'"]
DEBUG      [PD:4  MD:14]	..............DateAddFunctionNameSegment          	DateA.match OUT     	    	[match=<MatchResult 0/18: ''>, seg="'c.val + b.val / -2 A...'"]
DEBUG      [PD:4  MD:14]	..............FunctionSegment                     	Ref.match OUT       	    	[match=<MatchResult 0/18: ''>, seg="'c.val + b.val / -2 A...'"]
INFO       [PD:4  MD:13]	.............FunctionSegment                      	AnyNu.match PRN     	    	[ns=1, ps=0, ms=0, pruned=[], opts=[<Ref: FunctionNameSegment>]]
INFO       [PD:4  MD:16]	................FunctionNameSegment               	AnyNu.match PRN     	    	[ns=1, ps=0, ms=0, pruned=[], opts=[<Sequence: [<Ref: SingleIdentifierGrammar>, <Ref: DotSegment>]>]]
INFO       [PD:4  MD:18]	..................SingleIdentifierGrammar         	OneOf.match PRN     	    	[ns=2, ps=0, ms=0, pruned=[], opts=[<Ref: NakedIdentifierSegment>, <Ref: QuotedIdentifierSegment>]]
DEBUG      [PD:4  MD:19]	...................SingleIdentifierGrammar        	Ref.match OUT       	+   	[match=<MatchResult 1/18: 'c'>, seg="'c.val + b.val / -2 A...'"]
DEBUG      [PD:4  MD:19]	...................SingleIdentifierGrammar        	Ref.match OUT       	    	[match=<MatchResult 0/18: ''>, seg="'c.val + b.val / -2 A...'"]
INFO       [PD:4  MD:18]	..................SingleIdentifierGrammar         	OneOf.match OUT     	+   	[match=<MatchResult 1/18: 'c'>, seg="'c.val + b.val / -2 A...'"]
DEBUG      [PD:4  MD:18]	..................FunctionNameSegment             	Ref.match OUT       	+   	[match=<MatchResult 1/18: 'c'>, seg="'c.val + b.val / -2 A...'"]
DEBUG      [PD:4  MD:18]	..................FunctionNameSegment             	Ref.match OUT       	+   	[match=<MatchResult 1/17: '.'>, seg="'.val + b.val / -2 AS...'"]
INFO       [PD:4  MD:17]	.................FunctionNameSegment              	Seque.match OUT     	+   	[match=<MatchResult 2/18: 'c.'>, seg="'c.val + b.val / -2 A...'"]
INFO       [PD:4  MD:16]	................FunctionNameSegment               	AnyNu.match PRN     	    	[ns=1, ps=0, ms=0, pruned=[], opts=[<Sequence: [<Ref: SingleIdentifierGrammar>, <Ref: DotSegment>]>]]
INFO       [PD:4  MD:18]	..................SingleIdentifierGrammar         	OneOf.match PRN     	    	[ns=2, ps=0, ms=0, pruned=[], opts=[<Ref: NakedIdentifierSegment>, <Ref: QuotedIdentifierSegment>]]
DEBUG      [PD:4  MD:19]	...................SingleIdentifierGrammar        	Ref.match OUT       	+   	[match=<MatchResult 1/16: 'val'>, seg="'val + b.val / -2 AS ...'"]
DEBUG      [PD:4  MD:19]	...................SingleIdentifierGrammar        	Ref.match OUT       	    	[match=<MatchResult 0/16: ''>, seg="'val + b.val / -2 AS ...'"]
INFO       [PD:4  MD:18]	..................SingleIdentifierGrammar         	OneOf.match OUT     	+   	[match=<MatchResult 1/16: 'val'>, seg="'val + b.val / -2 AS ...'"]
DEBUG      [PD:4  MD:18]	..................FunctionNameSegment             	Ref.match OUT       	+   	[match=<MatchResult 1/16: 'val'>, seg="'val + b.val / -2 AS ...'"]
DEBUG      [PD:4  MD:18]	..................FunctionNameSegment             	Ref.match OUT       	    	[match=<MatchResult 0/14: ''>, seg="'+ b.val / -2 AS a_ca...'"]
INFO       [PD:4  MD:17]	.................FunctionNameSegment              	Seque.match OUT     	    	[match=<MatchResult 0/16: ''>, seg="'val + b.val / -2 AS ...'"]
INFO       [PD:4  MD:16]	................FunctionNameSegment               	AnyNu.match OUT     	+   	[match=<MatchResult 2/18: 'c.'>, seg="'c.val + b.val / -2 A...'"]
INFO       [PD:4  MD:16]	................FunctionNameSegment               	OneOf.match PRN     	    	[ns=2, ps=0, ms=0, pruned=[], opts=[<Ref: FunctionNameIdentifierSegment>, <Ref: QuotedIdentifierSegment>]]
DEBUG      [PD:4  MD:17]	.................FunctionNameSegment              	Ref.match OUT       	+   	[match=<MatchResult 1/16: 'val'>, seg="'val + b.val / -2 AS ...'"]
DEBUG      [PD:4  MD:17]	.................FunctionNameSegment              	Ref.match OUT       	    	[match=<MatchResult 0/16: ''>, seg="'val + b.val / -2 AS ...'"]
INFO       [PD:4  MD:16]	................FunctionNameSegment               	OneOf.match OUT     	+   	[match=<MatchResult 1/16: 'val'>, seg="'val + b.val / -2 AS ...'"]
INFO       [PD:4  MD:15]	...............FunctionNameSegment                	Seque.match OUT     	+   	[match=<MatchResult 3/18: 'c.val'>, seg="'c.val + b.val / -2 A...'"]
DEBUG      [PD:4  MD:14]	..............FunctionNameSegment                 	Funct.match OUT     	+   	[match=<MatchResult 1/16: 'c.val'>, seg="'c.val + b.val / -2 A...'"]
DEBUG      [PD:4  MD:14]	..............FunctionSegment                     	Ref.match OUT       	+   	[match=<MatchResult 1/16: 'c.val'>, seg="'c.val + b.val / -2 A...'"]
INFO       [PD:4  MD:13]	.............FunctionSegment                      	AnyNu.match OUT     	+   	[match=<MatchResult 1/16: 'c.val'>, seg="'c.val + b.val / -2 A...'"]
INFO       [PD:4  MD:13]	.............FunctionSegment                      	Brack.match OUT     	    	[match=<MatchResult 0/14: ''>, seg="'+ b.val / -2 AS a_ca...'"]
INFO       [PD:4  MD:12]	............FunctionSegment                       	Seque.match OUT     	    	[match=<MatchResult 0/18: ''>, seg="'c.val + b.val / -2 A...'"]
INFO       [PD:4  MD:11]	...........FunctionSegment                        	Seque.match OUT     	    	[match=<MatchResult 0/18: ''>, seg="'c.val + b.val / -2 A...'"]
INFO       [PD:4  MD:10]	..........FunctionSegment                         	OneOf.match OUT     	    	[match=<MatchResult 0/18: ''>, seg="'c.val + b.val / -2 A...'"]
DEBUG      [PD:4  MD:9 ]	.........FunctionSegment                          	Funct.match OUT     	    	[match=<MatchResult 0/18: ''>, seg="'c.val + b.val / -2 A...'"]
DEBUG      [PD:4  MD:9 ]	.........Expression_D_Grammar                     	Ref.match OUT       	    	[match=<MatchResult 0/18: ''>, seg="'c.val + b.val / -2 A...'"]
INFO       [PD:4  MD:9 ]	.........LiteralGrammar                           	OneOf.match PRN     	    	[ns=2, ps=4, ms=0, pruned=[<Ref: BooleanLiteralGrammar>, <Ref: QualifiedNumericLiteralSegment>, <Ref: NullLiteralSegment>, <Ref: DateTimeLiteralGrammar>], opts=[<Ref: QuotedLiteralSegment>, <Ref: NumericLiteralSegment>]]
DEBUG      [PD:4  MD:10]	..........LiteralGrammar                          	Ref.match OUT       	    	[match=<MatchResult 0/18: ''>, seg="'c.val + b.val / -2 A...'"]
DEBUG      [PD:4  MD:10]	..........LiteralGrammar                          	Ref.match OUT       	    	[match=<MatchResult 0/18: ''>, seg="'c.val + b.val / -2 A...'"]
INFO       [PD:4  MD:9 ]	.........LiteralGrammar                           	OneOf.match OUT     	    	[match=<MatchResult 0/18: ''>, seg="'c.val + b.val / -2 A...'"]
DEBUG      [PD:4  MD:9 ]	.........Expression_D_Grammar                     	Ref.match OUT       	    	[match=<MatchResult 0/18: ''>, seg="'c.val + b.val / -2 A...'"]
DEBUG      [PD:4  MD:11]	...........ColumnReferenceSegment                 	Delim._look_ahead_match IN	    	[ls=18, seg='c.val + b.val / -2 A...']
DEBUG      [PD:4  MD:11]	...........ColumnReferenceSegment                 	Delim._look_ahead_match SI	    	[mq=[(<OneOf: [<Ref: DotSegment>, <Sequence: [<Ref: DotSegment>, <Ref: Dot...]>, 1, '.'), (<OneOf: [<Ref: DotSegment>, <Sequence: [<Ref: DotSegment>, <Ref: Dot...]>, 1, '.'), (<OneOf: [<Ref: DotSegment>, <Sequence: [<Ref: DotSegment>, <Ref: Dot...]>, 7, '.'), (<OneOf: [<Ref: DotSegment>, <Sequence: [<Ref: DotSegment>, <Ref: Dot...]>, 7, '.')], sb=['C', '.', 'VAL', '', '+', '', 'B', '.', 'VAL', '', '/', '', '-', '2', '', 'AS', '', 'A_CALCULATION']]
INFO       [PD:4  MD:11]	...........ColumnReferenceSegment                 	OneOf.match PRN     	    	[ns=0, ps=0, ms=2, pruned=[], opts=[<Ref: DotSegment>, <Sequence: [<Ref: DotSegment>, <Ref: DotSegment>]>]]
DEBUG      [PD:4  MD:12]	............ColumnReferenceSegment                	Ref.match OUT       	+   	[match=<MatchResult 1/11: '.'>, seg="'.val / -2 AS a_calcu...'"]
DEBUG      [PD:4  MD:13]	.............ColumnReferenceSegment               	Ref.match OUT       	+   	[match=<MatchResult 1/11: '.'>, seg="'.val / -2 AS a_calcu...'"]
DEBUG      [PD:4  MD:13]	.............ColumnReferenceSegment               	Ref.match OUT       	    	[match=<MatchResult 0/10: ''>, seg="'val / -2 AS a_calcul...'"]
INFO       [PD:4  MD:12]	............ColumnReferenceSegment                	Seque.match OUT     	    	[match=<MatchResult 0/11: ''>, seg="'.val / -2 AS a_calcu...'"]
INFO       [PD:4  MD:11]	...........ColumnReferenceSegment                 	OneOf.match OUT     	+   	[match=<MatchResult 1/11: '.'>, seg="'.val / -2 AS a_calcu...'"]
INFO       [PD:4  MD:11]	...........ColumnReferenceSegment                 	OneOf.match PRN     	    	[ns=0, ps=0, ms=2, pruned=[], opts=[<Ref: DotSegment>, <Sequence: [<Ref: DotSegment>, <Ref: DotSegment>]>]]
DEBUG      [PD:4  MD:12]	............ColumnReferenceSegment                	Ref.match OUT       	+   	[match=<MatchResult 1/11: '.'>, seg="'.val / -2 AS a_calcu...'"]
DEBUG      [PD:4  MD:13]	.............ColumnReferenceSegment               	Ref.match OUT       	+   	[match=<MatchResult 1/11: '.'>, seg="'.val / -2 AS a_calcu...'"]
DEBUG      [PD:4  MD:13]	.............ColumnReferenceSegment               	Ref.match OUT       	    	[match=<MatchResult 0/10: ''>, seg="'val / -2 AS a_calcul...'"]
INFO       [PD:4  MD:12]	............ColumnReferenceSegment                	Seque.match OUT     	    	[match=<MatchResult 0/11: ''>, seg="'.val / -2 AS a_calcu...'"]
INFO       [PD:4  MD:11]	...........ColumnReferenceSegment                 	OneOf.match OUT     	+   	[match=<MatchResult 1/11: '.'>, seg="'.val / -2 AS a_calcu...'"]
INFO       [PD:4  MD:11]	...........ColumnReferenceSegment                 	OneOf.match PRN     	    	[ns=0, ps=0, ms=2, pruned=[], opts=[<Ref: DotSegment>, <Sequence: [<Ref: DotSegment>, <Ref: DotSegment>]>]]
DEBUG      [PD:4  MD:12]	............ColumnReferenceSegment                	Ref.match OUT       	+   	[match=<MatchResult 1/17: '.'>, seg="'.val + b.val / -2 AS...'"]
DEBUG      [PD:4  MD:13]	.............ColumnReferenceSegment               	Ref.match OUT       	+   	[match=<MatchResult 1/17: '.'>, seg="'.val + b.val / -2 AS...'"]
DEBUG      [PD:4  MD:13]	.............ColumnReferenceSegment               	Ref.match OUT       	    	[match=<MatchResult 0/16: ''>, seg="'val + b.val / -2 AS ...'"]
INFO       [PD:4  MD:12]	............ColumnReferenceSegment                	Seque.match OUT     	    	[match=<MatchResult 0/17: ''>, seg="'.val + b.val / -2 AS...'"]
INFO       [PD:4  MD:11]	...........ColumnReferenceSegment                 	OneOf.match OUT     	+   	[match=<MatchResult 1/17: '.'>, seg="'.val + b.val / -2 AS...'"]
INFO       [PD:4  MD:11]	...........ColumnReferenceSegment                 	OneOf.match PRN     	    	[ns=0, ps=0, ms=2, pruned=[], opts=[<Ref: DotSegment>, <Sequence: [<Ref: DotSegment>, <Ref: DotSegment>]>]]
DEBUG      [PD:4  MD:12]	............ColumnReferenceSegment                	Ref.match OUT       	+   	[match=<MatchResult 1/17: '.'>, seg="'.val + b.val / -2 AS...'"]
DEBUG      [PD:4  MD:13]	.............ColumnReferenceSegment               	Ref.match OUT       	+   	[match=<MatchResult 1/17: '.'>, seg="'.val + b.val / -2 AS...'"]
DEBUG      [PD:4  MD:13]	.............ColumnReferenceSegment               	Ref.match OUT       	    	[match=<MatchResult 0/16: ''>, seg="'val + b.val / -2 AS ...'"]
INFO       [PD:4  MD:12]	............ColumnReferenceSegment                	Seque.match OUT     	    	[match=<MatchResult 0/17: ''>, seg="'.val + b.val / -2 AS...'"]
INFO       [PD:4  MD:11]	...........ColumnReferenceSegment                 	OneOf.match OUT     	+   	[match=<MatchResult 1/17: '.'>, seg="'.val + b.val / -2 AS...'"]
INFO       [PD:4  MD:11]	...........ColumnReferenceSegment                 	OneOf.match PRN     	    	[ns=1, ps=10, ms=0, pruned=[<Ref: OnKeywordSegment>, <Ref: AsKeywordSegment>, <Ref: UsingKeywordSegment>, <Ref: CommaSegment>, <Ref: CastOperatorSegment>, <Ref: StartSquareBracketSegment>, <Ref: StartBracketSegment>, <Ref: ColonSegment>, <Ref: DelimiterSegment>, <class 'sqlfluff.core.parser.segments.base.BracketedSegment'>], opts=[<Ref: BinaryOperatorGrammar>]]
INFO       [PD:4  MD:12]	............BinaryOperatorGrammar                 	OneOf.match PRN     	    	[ns=1, ps=3, ms=0, pruned=[<Ref: ArithmeticBinaryOperatorGrammar>, <Ref: StringBinaryOperatorGrammar>, <Ref: BooleanBinaryOperatorGrammar>], opts=[<Ref: ComparisonOperatorGrammar>]]
INFO       [PD:4  MD:13]	.............ComparisonOperatorGrammar            	OneOf.match PRN     	    	[ns=1, ps=7, ms=0, pruned=[<Ref: EqualsSegment>, <Ref: GreaterThanSegment>, <Ref: LessThanSegment>, <Ref: GreaterThanOrEqualToSegment>, <Ref: LessThanOrEqualToSegment>, <Ref: NotEqualToSegment_a>, <Ref: NotEqualToSegment_b>], opts=[<Ref: LikeOperatorSegment>]]
DEBUG      [PD:4  MD:14]	..............ComparisonOperatorGrammar           	Ref.match OUT       	    	[match=<MatchResult 0/18: ''>, seg="'c.val + b.val / -2 A...'"]
INFO       [PD:4  MD:13]	.............ComparisonOperatorGrammar            	OneOf.match OUT     	    	[match=<MatchResult 0/18: ''>, seg="'c.val + b.val / -2 A...'"]
DEBUG      [PD:4  MD:13]	.............BinaryOperatorGrammar                	Ref.match OUT       	    	[match=<MatchResult 0/18: ''>, seg="'c.val + b.val / -2 A...'"]
INFO       [PD:4  MD:12]	............BinaryOperatorGrammar                 	OneOf.match OUT     	    	[match=<MatchResult 0/18: ''>, seg="'c.val + b.val / -2 A...'"]
DEBUG      [PD:4  MD:12]	............ColumnReferenceSegment                	Ref.match OUT       	    	[match=<MatchResult 0/18: ''>, seg="'c.val + b.val / -2 A...'"]
INFO       [PD:4  MD:11]	...........ColumnReferenceSegment                 	OneOf.match OUT     	    	[match=<MatchResult 0/18: ''>, seg="'c.val + b.val / -2 A...'"]
DEBUG      [PD:4  MD:11]	...........ColumnReferenceSegment                 	NonCo.match OUT     	    	[match=<MatchResult 0/18: ''>, seg="'c.val + b.val / -2 A...'"]
INFO       [PD:4  MD:11]	...........ColumnReferenceSegment                 	OneOf.match PRN     	    	[ns=1, ps=10, ms=0, pruned=[<Ref: OnKeywordSegment>, <Ref: AsKeywordSegment>, <Ref: UsingKeywordSegment>, <Ref: CommaSegment>, <Ref: CastOperatorSegment>, <Ref: StartSquareBracketSegment>, <Ref: StartBracketSegment>, <Ref: ColonSegment>, <Ref: DelimiterSegment>, <class 'sqlfluff.core.parser.segments.base.BracketedSegment'>], opts=[<Ref: BinaryOperatorGrammar>]]
INFO       [PD:4  MD:12]	............BinaryOperatorGrammar                 	OneOf.match PRN     	    	[ns=1, ps=3, ms=0, pruned=[<Ref: ArithmeticBinaryOperatorGrammar>, <Ref: StringBinaryOperatorGrammar>, <Ref: BooleanBinaryOperatorGrammar>], opts=[<Ref: ComparisonOperatorGrammar>]]
INFO       [PD:4  MD:13]	.............ComparisonOperatorGrammar            	OneOf.match PRN     	    	[ns=1, ps=7, ms=0, pruned=[<Ref: EqualsSegment>, <Ref: GreaterThanSegment>, <Ref: LessThanSegment>, <Ref: GreaterThanOrEqualToSegment>, <Ref: LessThanOrEqualToSegment>, <Ref: NotEqualToSegment_a>, <Ref: NotEqualToSegment_b>], opts=[<Ref: LikeOperatorSegment>]]
DEBUG      [PD:4  MD:14]	..............ComparisonOperatorGrammar           	Ref.match OUT       	    	[match=<MatchResult 0/17: ''>, seg="'.val + b.val / -2 AS...'"]
INFO       [PD:4  MD:13]	.............ComparisonOperatorGrammar            	OneOf.match OUT     	    	[match=<MatchResult 0/17: ''>, seg="'.val + b.val / -2 AS...'"]
DEBUG      [PD:4  MD:13]	.............BinaryOperatorGrammar                	Ref.match OUT       	    	[match=<MatchResult 0/17: ''>, seg="'.val + b.val / -2 AS...'"]
INFO       [PD:4  MD:12]	............BinaryOperatorGrammar                 	OneOf.match OUT     	    	[match=<MatchResult 0/17: ''>, seg="'.val + b.val / -2 AS...'"]
DEBUG      [PD:4  MD:12]	............ColumnReferenceSegment                	Ref.match OUT       	    	[match=<MatchResult 0/17: ''>, seg="'.val + b.val / -2 AS...'"]
INFO       [PD:4  MD:11]	...........ColumnReferenceSegment                 	OneOf.match OUT     	    	[match=<MatchResult 0/17: ''>, seg="'.val + b.val / -2 AS...'"]
DEBUG      [PD:4  MD:11]	...........ColumnReferenceSegment                 	NonCo.match OUT     	    	[match=<MatchResult 0/17: ''>, seg="'.val + b.val / -2 AS...'"]
INFO       [PD:4  MD:11]	...........SingleIdentifierGrammar                	OneOf.match PRN     	    	[ns=2, ps=0, ms=0, pruned=[], opts=[<Ref: NakedIdentifierSegment>, <Ref: QuotedIdentifierSegment>]]
DEBUG      [PD:4  MD:12]	............SingleIdentifierGrammar               	Ref.match OUT       	++  	[match=<MatchResult 1/1: 'c'>, seg="'c'"]
INFO       [PD:4  MD:11]	...........SingleIdentifierGrammar                	OneOf.match OUT     	++  	[match=<MatchResult 1/1: 'c'>, seg="'c'"]
DEBUG      [PD:4  MD:11]	...........ColumnReferenceSegment                 	Ref.match OUT       	++  	[match=<MatchResult 1/1: 'c'>, seg="'c'"]
DEBUG      [PD:4  MD:11]	...........ColumnReferenceSegment                 	Delim._look_ahead_match IN	    	[ls=16, seg='val + b.val / -2 AS ...']
DEBUG      [PD:4  MD:11]	...........ColumnReferenceSegment                 	Delim._look_ahead_match SI	    	[mq=[(<OneOf: [<Ref: DotSegment>, <Sequence: [<Ref: DotSegment>, <Ref: Dot...]>, 5, '.'), (<OneOf: [<Ref: DotSegment>, <Sequence: [<Ref: DotSegment>, <Ref: Dot...]>, 5, '.')], sb=['VAL', '', '+', '', 'B', '.', 'VAL', '', '/', '', '-', '2', '', 'AS', '', 'A_CALCULATION']]
INFO       [PD:4  MD:11]	...........ColumnReferenceSegment                 	OneOf.match PRN     	    	[ns=0, ps=0, ms=2, pruned=[], opts=[<Ref: DotSegment>, <Sequence: [<Ref: DotSegment>, <Ref: DotSegment>]>]]
DEBUG      [PD:4  MD:12]	............ColumnReferenceSegment                	Ref.match OUT       	+   	[match=<MatchResult 1/11: '.'>, seg="'.val / -2 AS a_calcu...'"]
DEBUG      [PD:4  MD:13]	.............ColumnReferenceSegment               	Ref.match OUT       	+   	[match=<MatchResult 1/11: '.'>, seg="'.val / -2 AS a_calcu...'"]
DEBUG      [PD:4  MD:13]	.............ColumnReferenceSegment               	Ref.match OUT       	    	[match=<MatchResult 0/10: ''>, seg="'val / -2 AS a_calcul...'"]
INFO       [PD:4  MD:12]	............ColumnReferenceSegment                	Seque.match OUT     	    	[match=<MatchResult 0/11: ''>, seg="'.val / -2 AS a_calcu...'"]
INFO       [PD:4  MD:11]	...........ColumnReferenceSegment                 	OneOf.match OUT     	+   	[match=<MatchResult 1/11: '.'>, seg="'.val / -2 AS a_calcu...'"]
INFO       [PD:4  MD:11]	...........ColumnReferenceSegment                 	OneOf.match PRN     	    	[ns=0, ps=0, ms=2, pruned=[], opts=[<Ref: DotSegment>, <Sequence: [<Ref: DotSegment>, <Ref: DotSegment>]>]]
DEBUG      [PD:4  MD:12]	............ColumnReferenceSegment                	Ref.match OUT       	+   	[match=<MatchResult 1/11: '.'>, seg="'.val / -2 AS a_calcu...'"]
DEBUG      [PD:4  MD:13]	.............ColumnReferenceSegment               	Ref.match OUT       	+   	[match=<MatchResult 1/11: '.'>, seg="'.val / -2 AS a_calcu...'"]
DEBUG      [PD:4  MD:13]	.............ColumnReferenceSegment               	Ref.match OUT       	    	[match=<MatchResult 0/10: ''>, seg="'val / -2 AS a_calcul...'"]
INFO       [PD:4  MD:12]	............ColumnReferenceSegment                	Seque.match OUT     	    	[match=<MatchResult 0/11: ''>, seg="'.val / -2 AS a_calcu...'"]
INFO       [PD:4  MD:11]	...........ColumnReferenceSegment                 	OneOf.match OUT     	+   	[match=<MatchResult 1/11: '.'>, seg="'.val / -2 AS a_calcu...'"]
INFO       [PD:4  MD:11]	...........ColumnReferenceSegment                 	OneOf.match PRN     	    	[ns=1, ps=10, ms=0, pruned=[<Ref: OnKeywordSegment>, <Ref: AsKeywordSegment>, <Ref: UsingKeywordSegment>, <Ref: CommaSegment>, <Ref: CastOperatorSegment>, <Ref: StartSquareBracketSegment>, <Ref: StartBracketSegment>, <Ref: ColonSegment>, <Ref: DelimiterSegment>, <class 'sqlfluff.core.parser.segments.base.BracketedSegment'>], opts=[<Ref: BinaryOperatorGrammar>]]
INFO       [PD:4  MD:12]	............BinaryOperatorGrammar                 	OneOf.match PRN     	    	[ns=1, ps=3, ms=0, pruned=[<Ref: ArithmeticBinaryOperatorGrammar>, <Ref: StringBinaryOperatorGrammar>, <Ref: BooleanBinaryOperatorGrammar>], opts=[<Ref: ComparisonOperatorGrammar>]]
INFO       [PD:4  MD:13]	.............ComparisonOperatorGrammar            	OneOf.match PRN     	    	[ns=1, ps=7, ms=0, pruned=[<Ref: EqualsSegment>, <Ref: GreaterThanSegment>, <Ref: LessThanSegment>, <Ref: GreaterThanOrEqualToSegment>, <Ref: LessThanOrEqualToSegment>, <Ref: NotEqualToSegment_a>, <Ref: NotEqualToSegment_b>], opts=[<Ref: LikeOperatorSegment>]]
DEBUG      [PD:4  MD:14]	..............ComparisonOperatorGrammar           	Ref.match OUT       	    	[match=<MatchResult 0/16: ''>, seg="'val + b.val / -2 AS ...'"]
INFO       [PD:4  MD:13]	.............ComparisonOperatorGrammar            	OneOf.match OUT     	    	[match=<MatchResult 0/16: ''>, seg="'val + b.val / -2 AS ...'"]
DEBUG      [PD:4  MD:13]	.............BinaryOperatorGrammar                	Ref.match OUT       	    	[match=<MatchResult 0/16: ''>, seg="'val + b.val / -2 AS ...'"]
INFO       [PD:4  MD:12]	............BinaryOperatorGrammar                 	OneOf.match OUT     	    	[match=<MatchResult 0/16: ''>, seg="'val + b.val / -2 AS ...'"]
DEBUG      [PD:4  MD:12]	............ColumnReferenceSegment                	Ref.match OUT       	    	[match=<MatchResult 0/16: ''>, seg="'val + b.val / -2 AS ...'"]
INFO       [PD:4  MD:11]	...........ColumnReferenceSegment                 	OneOf.match OUT     	    	[match=<MatchResult 0/16: ''>, seg="'val + b.val / -2 AS ...'"]
DEBUG      [PD:4  MD:11]	...........ColumnReferenceSegment                 	NonCo.match OUT     	    	[match=<MatchResult 0/16: ''>, seg="'val + b.val / -2 AS ...'"]
INFO       [PD:4  MD:11]	...........ColumnReferenceSegment                 	OneOf.match PRN     	    	[ns=1, ps=10, ms=0, pruned=[<Ref: OnKeywordSegment>, <Ref: AsKeywordSegment>, <Ref: UsingKeywordSegment>, <Ref: CommaSegment>, <Ref: CastOperatorSegment>, <Ref: StartSquareBracketSegment>, <Ref: StartBracketSegment>, <Ref: ColonSegment>, <Ref: DelimiterSegment>, <class 'sqlfluff.core.parser.segments.base.BracketedSegment'>], opts=[<Ref: BinaryOperatorGrammar>]]
INFO       [PD:4  MD:12]	............BinaryOperatorGrammar                 	OneOf.match PRN     	    	[ns=1, ps=2, ms=1, pruned=[<Ref: StringBinaryOperatorGrammar>, <Ref: BooleanBinaryOperatorGrammar>], opts=[<Ref: ArithmeticBinaryOperatorGrammar>, <Ref: ComparisonOperatorGrammar>]]
INFO       [PD:4  MD:13]	.............ArithmeticBinaryOperatorGrammar      	OneOf.match PRN     	    	[ns=0, ps=9, ms=1, pruned=[<Ref: MinusSegment>, <Ref: DivideSegment>, <Ref: MultiplySegment>, <Ref: ModuloSegment>, <Ref: BitwiseAndSegment>, <Ref: BitwiseOrSegment>, <Ref: BitwiseXorSegment>, <Ref: BitwiseLShiftSegment>, <Ref: BitwiseRShiftSegment>], opts=[<Ref: PlusSegment>]]
DEBUG      [PD:4  MD:14]	..............ArithmeticBinaryOperatorGrammar     	Ref.match OUT       	    	[match=<MatchResult 0/15: ''>, seg="' + b.val / -2 AS a_c...'"]
INFO       [PD:4  MD:13]	.............ArithmeticBinaryOperatorGrammar      	OneOf.match OUT     	    	[match=<MatchResult 0/15: ''>, seg="' + b.val / -2 AS a_c...'"]
DEBUG      [PD:4  MD:13]	.............BinaryOperatorGrammar                	Ref.match OUT       	    	[match=<MatchResult 0/15: ''>, seg="' + b.val / -2 AS a_c...'"]
INFO       [PD:4  MD:13]	.............ComparisonOperatorGrammar            	OneOf.match PRN     	    	[ns=1, ps=7, ms=0, pruned=[<Ref: EqualsSegment>, <Ref: GreaterThanSegment>, <Ref: LessThanSegment>, <Ref: GreaterThanOrEqualToSegment>, <Ref: LessThanOrEqualToSegment>, <Ref: NotEqualToSegment_a>, <Ref: NotEqualToSegment_b>], opts=[<Ref: LikeOperatorSegment>]]
DEBUG      [PD:4  MD:14]	..............ComparisonOperatorGrammar           	Ref.match OUT       	    	[match=<MatchResult 0/15: ''>, seg="' + b.val / -2 AS a_c...'"]
INFO       [PD:4  MD:13]	.............ComparisonOperatorGrammar            	OneOf.match OUT     	    	[match=<MatchResult 0/15: ''>, seg="' + b.val / -2 AS a_c...'"]
DEBUG      [PD:4  MD:13]	.............BinaryOperatorGrammar                	Ref.match OUT       	    	[match=<MatchResult 0/15: ''>, seg="' + b.val / -2 AS a_c...'"]
INFO       [PD:4  MD:12]	............BinaryOperatorGrammar                 	OneOf.match OUT     	    	[match=<MatchResult 0/15: ''>, seg="' + b.val / -2 AS a_c...'"]
DEBUG      [PD:4  MD:12]	............ColumnReferenceSegment                	Ref.match OUT       	    	[match=<MatchResult 0/15: ''>, seg="' + b.val / -2 AS a_c...'"]
INFO       [PD:4  MD:11]	...........ColumnReferenceSegment                 	OneOf.match OUT     	    	[match=<MatchResult 0/15: ''>, seg="' + b.val / -2 AS a_c...'"]
DEBUG      [PD:4  MD:11]	...........ColumnReferenceSegment                 	NonCo.match OUT     	+   	[match=<MatchResult 1/15: ' '>, seg="' + b.val / -2 AS a_c...'"]
INFO       [PD:4  MD:11]	...........SingleIdentifierGrammar                	OneOf.match PRN     	    	[ns=2, ps=0, ms=0, pruned=[], opts=[<Ref: NakedIdentifierSegment>, <Ref: QuotedIdentifierSegment>]]
DEBUG      [PD:4  MD:12]	............SingleIdentifierGrammar               	Ref.match OUT       	++  	[match=<MatchResult 1/1: 'val'>, seg="'val'"]
INFO       [PD:4  MD:11]	...........SingleIdentifierGrammar                	OneOf.match OUT     	++  	[match=<MatchResult 1/1: 'val'>, seg="'val'"]
DEBUG      [PD:4  MD:11]	...........ColumnReferenceSegment                 	Ref.match OUT       	++  	[match=<MatchResult 1/1: 'val'>, seg="'val'"]
INFO       [PD:4  MD:10]	..........ColumnReferenceSegment                  	Delim.match OUT     	+   	[match=<MatchResult 3/18: 'c.val'>, seg="'c.val + b.val / -2 A...'"]
DEBUG      [PD:4  MD:9 ]	.........ColumnReferenceSegment                   	Colum.match OUT     	+   	[match=<MatchResult 1/16: 'c.val'>, seg="'c.val + b.val / -2 A...'"]
DEBUG      [PD:4  MD:9 ]	.........Expression_D_Grammar                     	Ref.match OUT       	+   	[match=<MatchResult 1/16: 'c.val'>, seg="'c.val + b.val / -2 A...'"]
DEBUG      [PD:4  MD:10]	..........Expression_D_Grammar                    	Ref.match OUT       	    	[match=<MatchResult 0/18: ''>, seg="'c.val + b.val / -2 A...'"]
INFO       [PD:4  MD:11]	...........ArrayLiteralSegment                    	Brack.match OUT     	    	[match=<MatchResult 0/18: ''>, seg="'c.val + b.val / -2 A...'"]
DEBUG      [PD:4  MD:10]	..........ArrayLiteralSegment                     	Array.match OUT     	    	[match=<MatchResult 0/18: ''>, seg="'c.val + b.val / -2 A...'"]
DEBUG      [PD:4  MD:10]	..........Expression_D_Grammar                    	Ref.match OUT       	    	[match=<MatchResult 0/18: ''>, seg="'c.val + b.val / -2 A...'"]
INFO       [PD:4  MD:9 ]	.........Expression_D_Grammar                     	Seque.match OUT     	    	[match=<MatchResult 0/18: ''>, seg="'c.val + b.val / -2 A...'"]
INFO       [PD:4  MD:11]	...........DatatypeSegment                        	OneOf.match PRN     	    	[ns=1, ps=2, ms=0, pruned=[<Sequence: [<OneOf: [<Ref: TimeKeywordSegment>, <Ref..., <Bracketed: [<Ref: NumericLiteralSegment..., <Sequence:...]>, <Sequence: [<Ref: DoubleKeywordSegment>, <Ref: PrecisionKeywordSegment>]>], opts=[<Sequence: [<OneOf: [<Sequence: [<OneOf: [<Ref: Char..., <Bracketed: [<OneOf: [<Delimited: [<Ref:..., <Ref: Char...]>]]
INFO       [PD:4  MD:13]	.............DatatypeSegment                      	OneOf.match PRN     	    	[ns=1, ps=1, ms=0, pruned=[<Sequence: [<OneOf: [<Ref: CharacterKeywordSegment>,..., <OneOf: [<Ref: VaryingKeywordSegment>, <...]>], opts=[<Sequence: [<Sequence: [<Ref: SingleIdentifierGramma..., <Ref: DatatypeIdentifierSegment>]>]]
INFO       [PD:4  MD:16]	................SingleIdentifierGrammar           	OneOf.match PRN     	    	[ns=2, ps=0, ms=0, pruned=[], opts=[<Ref: NakedIdentifierSegment>, <Ref: QuotedIdentifierSegment>]]
DEBUG      [PD:4  MD:17]	.................SingleIdentifierGrammar          	Ref.match OUT       	+   	[match=<MatchResult 1/18: 'c'>, seg="'c.val + b.val / -2 A...'"]
DEBUG      [PD:4  MD:17]	.................SingleIdentifierGrammar          	Ref.match OUT       	    	[match=<MatchResult 0/18: ''>, seg="'c.val + b.val / -2 A...'"]
INFO       [PD:4  MD:16]	................SingleIdentifierGrammar           	OneOf.match OUT     	+   	[match=<MatchResult 1/18: 'c'>, seg="'c.val + b.val / -2 A...'"]
DEBUG      [PD:4  MD:16]	................DatatypeSegment                   	Ref.match OUT       	+   	[match=<MatchResult 1/18: 'c'>, seg="'c.val + b.val / -2 A...'"]
DEBUG      [PD:4  MD:16]	................DatatypeSegment                   	Ref.match OUT       	+   	[match=<MatchResult 1/17: '.'>, seg="'.val + b.val / -2 AS...'"]
INFO       [PD:4  MD:15]	...............DatatypeSegment                    	Seque.match OUT     	+   	[match=<MatchResult 2/18: 'c.'>, seg="'c.val + b.val / -2 A...'"]
DEBUG      [PD:4  MD:15]	...............DatatypeSegment                    	Ref.match OUT       	+   	[match=<MatchResult 1/16: 'val'>, seg="'val + b.val / -2 AS ...'"]
INFO       [PD:4  MD:14]	..............DatatypeSegment                     	Seque.match OUT     	+   	[match=<MatchResult 3/18: 'c.val'>, seg="'c.val + b.val / -2 A...'"]
INFO       [PD:4  MD:13]	.............DatatypeSegment                      	OneOf.match OUT     	+   	[match=<MatchResult 3/18: 'c.val'>, seg="'c.val + b.val / -2 A...'"]
INFO       [PD:4  MD:13]	.............DatatypeSegment                      	Brack.match OUT     	    	[match=<MatchResult 0/14: ''>, seg="'+ b.val / -2 AS a_ca...'"]
DEBUG      [PD:4  MD:13]	.............DatatypeSegment                      	Ref.match OUT       	    	[match=<MatchResult 0/14: ''>, seg="'+ b.val / -2 AS a_ca...'"]
INFO       [PD:4  MD:12]	............DatatypeSegment                       	Seque.match OUT     	+   	[match=<MatchResult 3/18: 'c.val'>, seg="'c.val + b.val / -2 A...'"]
INFO       [PD:4  MD:11]	...........DatatypeSegment                        	OneOf.match OUT     	+   	[match=<MatchResult 3/18: 'c.val'>, seg="'c.val + b.val / -2 A...'"]
DEBUG      [PD:4  MD:10]	..........DatatypeSegment                         	Datat.match OUT     	+   	[match=<MatchResult 1/16: 'c.val'>, seg="'c.val + b.val / -2 A...'"]
DEBUG      [PD:4  MD:10]	..........Expression_D_Grammar                    	Ref.match OUT       	+   	[match=<MatchResult 1/16: 'c.val'>, seg="'c.val + b.val / -2 A...'"]
INFO       [PD:4  MD:10]	..........Expression_D_Grammar                    	OneOf.match PRN     	    	[ns=2, ps=3, ms=0, pruned=[<Ref: BooleanLiteralGrammar>, <Ref: NullLiteralSegment>, <Ref: DateTimeLiteralGrammar>], opts=[<Ref: QuotedLiteralSegment>, <Ref: NumericLiteralSegment>]]
DEBUG      [PD:4  MD:11]	...........Expression_D_Grammar                   	Ref.match OUT       	    	[match=<MatchResult 0/14: ''>, seg="'+ b.val / -2 AS a_ca...'"]
DEBUG      [PD:4  MD:11]	...........Expression_D_Grammar                   	Ref.match OUT       	    	[match=<MatchResult 0/14: ''>, seg="'+ b.val / -2 AS a_ca...'"]
INFO       [PD:4  MD:10]	..........Expression_D_Grammar                    	OneOf.match OUT     	    	[match=<MatchResult 0/14: ''>, seg="'+ b.val / -2 AS a_ca...'"]
INFO       [PD:4  MD:9 ]	.........Expression_D_Grammar                     	Seque.match OUT     	    	[match=<MatchResult 0/18: ''>, seg="'c.val + b.val / -2 A...'"]
INFO       [PD:4  MD:8 ]	........Expression_D_Grammar                      	OneOf.match OUT     	+   	[match=<MatchResult 1/16: 'c.val'>, seg="'c.val + b.val / -2 A...'"]
INFO       [PD:4  MD:8 ]	........Accessor_Grammar                          	AnyNu.match PRN     	    	[ns=0, ps=1, ms=0, pruned=[<Ref: ArrayAccessorSegment>], opts='ALL']
INFO       [PD:4  MD:8 ]	........Accessor_Grammar                          	AnyNu.match OUT     	    	[match=<MatchResult 0/14: ''>, seg="'+ b.val / -2 AS a_ca...'"]
DEBUG      [PD:4  MD:8 ]	........Expression_D_Grammar                      	Ref.match OUT       	    	[match=<MatchResult 0/14: ''>, seg="'+ b.val / -2 AS a_ca...'"]
INFO       [PD:4  MD:8 ]	........Expression_D_Grammar                      	AnyNu.match PRN     	    	[ns=0, ps=1, ms=0, pruned=[<Ref: ShorthandCastSegment>], opts='ALL']
INFO       [PD:4  MD:8 ]	........Expression_D_Grammar                      	AnyNu.match OUT     	    	[match=<MatchResult 0/14: ''>, seg="'+ b.val / -2 AS a_ca...'"]
INFO       [PD:4  MD:7 ]	.......Expression_D_Grammar                       	Seque.match OUT     	+   	[match=<MatchResult 1/16: 'c.val'>, seg="'c.val + b.val / -2 A...'"]
DEBUG      [PD:4  MD:7 ]	.......Expression_C_Grammar                       	Ref.match OUT       	+   	[match=<MatchResult 1/16: 'c.val'>, seg="'c.val + b.val / -2 A...'"]
INFO       [PD:4  MD:6 ]	......Expression_C_Grammar                        	OneOf.match OUT     	+   	[match=<MatchResult 1/16: 'c.val'>, seg="'c.val + b.val / -2 A...'"]
DEBUG      [PD:4  MD:6 ]	......Expression_A_Grammar                        	Ref.match OUT       	+   	[match=<MatchResult 1/16: 'c.val'>, seg="'c.val + b.val / -2 A...'"]
INFO       [PD:4  MD:5 ]	.....Expression_A_Grammar                         	OneOf.match OUT     	+   	[match=<MatchResult 1/16: 'c.val'>, seg="'c.val + b.val / -2 A...'"]
INFO       [PD:4  MD:5 ]	.....Expression_A_Grammar                         	AnyNu.match PRN     	    	[ns=1, ps=0, ms=0, pruned=[], opts=[<OneOf: [<Sequence: [<OneOf: [<Sequence: [<Ref: N..., <Sequence: [<Ref: NotKeywordSegment [opt..., <Sequence:...]>]]
INFO       [PD:4  MD:6 ]	......Expression_A_Grammar                        	OneOf.match PRN     	    	[ns=3, ps=5, ms=0, pruned=[<Sequence: [<Ref: NotKeywordSegment [opt]>, <Ref: InKeywordSegment>, <Bracketed: [<OneOf: [<Delimited: [<Ref:...]>, <Sequence: [<Ref: NotKeywordSegment [opt]>, <Ref: InKeywordSegment>, <Ref: FunctionSegment>]>, <Sequence: [<Ref: IsKeywordSegment>, <Ref: NotKeywordSegment [opt]>, <Ref: IsClauseGrammar>]>, <Sequence: [<Ref: NotKeywordSegment>, <Ref: Expression_C_Grammar>]>, <Sequence: [<Ref: NotKeywordSegment [opt]>, <Ref: BetweenKeywordSegment>, <Ref: Expression_C_Grammar>, <AnyNumbe...]>], opts=[<Sequence: [<OneOf: [<Sequence: [<Ref: NotKeywordSeg..., <Ref: Expression_C_Grammar>, <Sequence: [<Ref: EscapeKe...]>, <Ref: IsNullGrammar>, <Ref: NotNullGrammar>]]
INFO       [PD:4  MD:8 ]	........Expression_A_Grammar                      	OneOf.match PRN     	    	[ns=1, ps=1, ms=0, pruned=[<Sequence: [<Ref: NotKeywordSegment [opt]>, <Ref: LikeGrammar>]>], opts=[<Sequence: [<Ref: BinaryOperatorGrammar>, <Ref: NotKeywordSegment [opt]>]>]]
INFO       [PD:4  MD:10]	..........BinaryOperatorGrammar                   	OneOf.match PRN     	    	[ns=1, ps=2, ms=1, pruned=[<Ref: StringBinaryOperatorGrammar>, <Ref: BooleanBinaryOperatorGrammar>], opts=[<Ref: ArithmeticBinaryOperatorGrammar>, <Ref: ComparisonOperatorGrammar>]]
INFO       [PD:4  MD:11]	...........ArithmeticBinaryOperatorGrammar        	OneOf.match PRN     	    	[ns=0, ps=9, ms=1, pruned=[<Ref: MinusSegment>, <Ref: DivideSegment>, <Ref: MultiplySegment>, <Ref: ModuloSegment>, <Ref: BitwiseAndSegment>, <Ref: BitwiseOrSegment>, <Ref: BitwiseXorSegment>, <Ref: BitwiseLShiftSegment>, <Ref: BitwiseRShiftSegment>], opts=[<Ref: PlusSegment>]]
DEBUG      [PD:4  MD:12]	............ArithmeticBinaryOperatorGrammar       	Ref.match OUT       	+   	[match=<MatchResult 1/14: '+'>, seg="'+ b.val / -2 AS a_ca...'"]
INFO       [PD:4  MD:11]	...........ArithmeticBinaryOperatorGrammar        	OneOf.match OUT     	+   	[match=<MatchResult 1/14: '+'>, seg="'+ b.val / -2 AS a_ca...'"]
DEBUG      [PD:4  MD:11]	...........BinaryOperatorGrammar                  	Ref.match OUT       	+   	[match=<MatchResult 1/14: '+'>, seg="'+ b.val / -2 AS a_ca...'"]
INFO       [PD:4  MD:11]	...........ComparisonOperatorGrammar              	OneOf.match PRN     	    	[ns=1, ps=7, ms=0, pruned=[<Ref: EqualsSegment>, <Ref: GreaterThanSegment>, <Ref: LessThanSegment>, <Ref: GreaterThanOrEqualToSegment>, <Ref: LessThanOrEqualToSegment>, <Ref: NotEqualToSegment_a>, <Ref: NotEqualToSegment_b>], opts=[<Ref: LikeOperatorSegment>]]
DEBUG      [PD:4  MD:12]	............ComparisonOperatorGrammar             	Ref.match OUT       	    	[match=<MatchResult 0/14: ''>, seg="'+ b.val / -2 AS a_ca...'"]
INFO       [PD:4  MD:11]	...........ComparisonOperatorGrammar              	OneOf.match OUT     	    	[match=<MatchResult 0/14: ''>, seg="'+ b.val / -2 AS a_ca...'"]
DEBUG      [PD:4  MD:11]	...........BinaryOperatorGrammar                  	Ref.match OUT       	    	[match=<MatchResult 0/14: ''>, seg="'+ b.val / -2 AS a_ca...'"]
INFO       [PD:4  MD:10]	..........BinaryOperatorGrammar                   	OneOf.match OUT     	+   	[match=<MatchResult 1/14: '+'>, seg="'+ b.val / -2 AS a_ca...'"]
DEBUG      [PD:4  MD:10]	..........Expression_A_Grammar                    	Ref.match OUT       	+   	[match=<MatchResult 1/14: '+'>, seg="'+ b.val / -2 AS a_ca...'"]
DEBUG      [PD:4  MD:10]	..........Expression_A_Grammar                    	Ref.match OUT       	    	[match=<MatchResult 0/12: ''>, seg="'b.val / -2 AS a_calc...'"]
INFO       [PD:4  MD:9 ]	.........Expression_A_Grammar                     	Seque.match OUT     	+   	[match=<MatchResult 1/14: '+'>, seg="'+ b.val / -2 AS a_ca...'"]
INFO       [PD:4  MD:8 ]	........Expression_A_Grammar                      	OneOf.match OUT     	+   	[match=<MatchResult 1/14: '+'>, seg="'+ b.val / -2 AS a_ca...'"]
INFO       [PD:4  MD:8 ]	........Expression_C_Grammar                      	OneOf.match PRN     	    	[ns=1, ps=2, ms=0, pruned=[<Sequence: [<Ref: ExistsKeywordSegment>, <Bracketed: [<Ref: SelectStatementSegmen...]>, <Ref: CaseExpressionSegment>], opts=[<Ref: Expression_D_Grammar>]]
INFO       [PD:4  MD:10]	..........Expression_D_Grammar                    	OneOf.match PRN     	    	[ns=6, ps=3, ms=0, pruned=[<Bracketed: [<OneOf: [<Ref: ExpressionSegment>, <Ref:...]>, <Ref: SelectStatementSegment>, <Ref: IntervalExpressionSegment>], opts=[<Ref: BareFunctionSegment>, <Ref: FunctionSegment>, <Ref: LiteralGrammar>, <Ref: ColumnReferenceSegment>, <Sequence: [<Ref: SimpleArrayTypeGrammar [opt]>, <Ref: ArrayLiteralSegment>]>, <Sequence: [<Ref: DatatypeSegment>, <OneOf: [<Ref: QuotedLiteralSegment>, <R...]>]]
DEBUG      [PD:4  MD:11]	...........Expression_D_Grammar                   	Ref.match OUT       	    	[match=<MatchResult 0/12: ''>, seg="'b.val / -2 AS a_calc...'"]
INFO       [PD:4  MD:12]	............FunctionSegment                       	OneOf.match PRN     	    	[ns=1, ps=1, ms=0, pruned=[<Sequence: [<Sequence: [<Ref: DateAddFunctionNameSeg...]>], opts=[<Sequence: [<Sequence: [<AnyNumberOf: [<Ref: Functio..., <Ref: PostFunctionGrammar [opt]>]>]]
DEBUG      [PD:4  MD:18]	..................DateAddFunctionNameSegment      	Ref.match OUT       	    	[match=<MatchResult 0/12: ''>, seg="'b.val / -2 AS a_calc...'"]
INFO       [PD:4  MD:17]	.................DateAddFunctionNameSegment       	Seque.match OUT     	    	[match=<MatchResult 0/12: ''>, seg="'b.val / -2 AS a_calc...'"]
DEBUG      [PD:4  MD:16]	................DateAddFunctionNameSegment        	DateA.match OUT     	    	[match=<MatchResult 0/12: ''>, seg="'b.val / -2 AS a_calc...'"]
DEBUG      [PD:4  MD:16]	................FunctionSegment                   	Ref.match OUT       	    	[match=<MatchResult 0/12: ''>, seg="'b.val / -2 AS a_calc...'"]
INFO       [PD:4  MD:15]	...............FunctionSegment                    	AnyNu.match PRN     	    	[ns=1, ps=0, ms=0, pruned=[], opts=[<Ref: FunctionNameSegment>]]
INFO       [PD:4  MD:18]	..................FunctionNameSegment             	AnyNu.match PRN     	    	[ns=1, ps=0, ms=0, pruned=[], opts=[<Sequence: [<Ref: SingleIdentifierGrammar>, <Ref: DotSegment>]>]]
INFO       [PD:4  MD:20]	....................SingleIdentifierGrammar       	OneOf.match PRN     	    	[ns=2, ps=0, ms=0, pruned=[], opts=[<Ref: NakedIdentifierSegment>, <Ref: QuotedIdentifierSegment>]]
DEBUG      [PD:4  MD:21]	.....................SingleIdentifierGrammar      	Ref.match OUT       	+   	[match=<MatchResult 1/12: 'b'>, seg="'b.val / -2 AS a_calc...'"]
DEBUG      [PD:4  MD:21]	.....................SingleIdentifierGrammar      	Ref.match OUT       	    	[match=<MatchResult 0/12: ''>, seg="'b.val / -2 AS a_calc...'"]
INFO       [PD:4  MD:20]	....................SingleIdentifierGrammar       	OneOf.match OUT     	+   	[match=<MatchResult 1/12: 'b'>, seg="'b.val / -2 AS a_calc...'"]
DEBUG      [PD:4  MD:20]	....................FunctionNameSegment           	Ref.match OUT       	+   	[match=<MatchResult 1/12: 'b'>, seg="'b.val / -2 AS a_calc...'"]
DEBUG      [PD:4  MD:20]	....................FunctionNameSegment           	Ref.match OUT       	+   	[match=<MatchResult 1/11: '.'>, seg="'.val / -2 AS a_calcu...'"]
INFO       [PD:4  MD:19]	...................FunctionNameSegment            	Seque.match OUT     	+   	[match=<MatchResult 2/12: 'b.'>, seg="'b.val / -2 AS a_calc...'"]
INFO       [PD:4  MD:18]	..................FunctionNameSegment             	AnyNu.match PRN     	    	[ns=1, ps=0, ms=0, pruned=[], opts=[<Sequence: [<Ref: SingleIdentifierGrammar>, <Ref: DotSegment>]>]]
INFO       [PD:4  MD:20]	....................SingleIdentifierGrammar       	OneOf.match PRN     	    	[ns=2, ps=0, ms=0, pruned=[], opts=[<Ref: NakedIdentifierSegment>, <Ref: QuotedIdentifierSegment>]]
DEBUG      [PD:4  MD:21]	.....................SingleIdentifierGrammar      	Ref.match OUT       	+   	[match=<MatchResult 1/10: 'val'>, seg="'val / -2 AS a_calcul...'"]
DEBUG      [PD:4  MD:21]	.....................SingleIdentifierGrammar      	Ref.match OUT       	    	[match=<MatchResult 0/10: ''>, seg="'val / -2 AS a_calcul...'"]
INFO       [PD:4  MD:20]	....................SingleIdentifierGrammar       	OneOf.match OUT     	+   	[match=<MatchResult 1/10: 'val'>, seg="'val / -2 AS a_calcul...'"]
DEBUG      [PD:4  MD:20]	....................FunctionNameSegment           	Ref.match OUT       	+   	[match=<MatchResult 1/10: 'val'>, seg="'val / -2 AS a_calcul...'"]
DEBUG      [PD:4  MD:20]	....................FunctionNameSegment           	Ref.match OUT       	    	[match=<MatchResult 0/8: ''>, seg="'/ -2 AS a_calculatio...'"]
INFO       [PD:4  MD:19]	...................FunctionNameSegment            	Seque.match OUT     	    	[match=<MatchResult 0/10: ''>, seg="'val / -2 AS a_calcul...'"]
INFO       [PD:4  MD:18]	..................FunctionNameSegment             	AnyNu.match OUT     	+   	[match=<MatchResult 2/12: 'b.'>, seg="'b.val / -2 AS a_calc...'"]
INFO       [PD:4  MD:18]	..................FunctionNameSegment             	OneOf.match PRN     	    	[ns=2, ps=0, ms=0, pruned=[], opts=[<Ref: FunctionNameIdentifierSegment>, <Ref: QuotedIdentifierSegment>]]
DEBUG      [PD:4  MD:19]	...................FunctionNameSegment            	Ref.match OUT       	+   	[match=<MatchResult 1/10: 'val'>, seg="'val / -2 AS a_calcul...'"]
DEBUG      [PD:4  MD:19]	...................FunctionNameSegment            	Ref.match OUT       	    	[match=<MatchResult 0/10: ''>, seg="'val / -2 AS a_calcul...'"]
INFO       [PD:4  MD:18]	..................FunctionNameSegment             	OneOf.match OUT     	+   	[match=<MatchResult 1/10: 'val'>, seg="'val / -2 AS a_calcul...'"]
INFO       [PD:4  MD:17]	.................FunctionNameSegment              	Seque.match OUT     	+   	[match=<MatchResult 3/12: 'b.val'>, seg="'b.val / -2 AS a_calc...'"]
DEBUG      [PD:4  MD:16]	................FunctionNameSegment               	Funct.match OUT     	+   	[match=<MatchResult 1/10: 'b.val'>, seg="'b.val / -2 AS a_calc...'"]
DEBUG      [PD:4  MD:16]	................FunctionSegment                   	Ref.match OUT       	+   	[match=<MatchResult 1/10: 'b.val'>, seg="'b.val / -2 AS a_calc...'"]
INFO       [PD:4  MD:15]	...............FunctionSegment                    	AnyNu.match OUT     	+   	[match=<MatchResult 1/10: 'b.val'>, seg="'b.val / -2 AS a_calc...'"]
INFO       [PD:4  MD:15]	...............FunctionSegment                    	Brack.match OUT     	    	[match=<MatchResult 0/8: ''>, seg="'/ -2 AS a_calculatio...'"]
INFO       [PD:4  MD:14]	..............FunctionSegment                     	Seque.match OUT     	    	[match=<MatchResult 0/12: ''>, seg="'b.val / -2 AS a_calc...'"]
INFO       [PD:4  MD:13]	.............FunctionSegment                      	Seque.match OUT     	    	[match=<MatchResult 0/12: ''>, seg="'b.val / -2 AS a_calc...'"]
INFO       [PD:4  MD:12]	............FunctionSegment                       	OneOf.match OUT     	    	[match=<MatchResult 0/12: ''>, seg="'b.val / -2 AS a_calc...'"]
DEBUG      [PD:4  MD:11]	...........FunctionSegment                        	Funct.match OUT     	    	[match=<MatchResult 0/12: ''>, seg="'b.val / -2 AS a_calc...'"]
DEBUG      [PD:4  MD:11]	...........Expression_D_Grammar                   	Ref.match OUT       	    	[match=<MatchResult 0/12: ''>, seg="'b.val / -2 AS a_calc...'"]
INFO       [PD:4  MD:11]	...........LiteralGrammar                         	OneOf.match PRN     	    	[ns=2, ps=4, ms=0, pruned=[<Ref: BooleanLiteralGrammar>, <Ref: QualifiedNumericLiteralSegment>, <Ref: NullLiteralSegment>, <Ref: DateTimeLiteralGrammar>], opts=[<Ref: QuotedLiteralSegment>, <Ref: NumericLiteralSegment>]]
DEBUG      [PD:4  MD:12]	............LiteralGrammar                        	Ref.match OUT       	    	[match=<MatchResult 0/12: ''>, seg="'b.val / -2 AS a_calc...'"]
DEBUG      [PD:4  MD:12]	............LiteralGrammar                        	Ref.match OUT       	    	[match=<MatchResult 0/12: ''>, seg="'b.val / -2 AS a_calc...'"]
INFO       [PD:4  MD:11]	...........LiteralGrammar                         	OneOf.match OUT     	    	[match=<MatchResult 0/12: ''>, seg="'b.val / -2 AS a_calc...'"]
DEBUG      [PD:4  MD:11]	...........Expression_D_Grammar                   	Ref.match OUT       	    	[match=<MatchResult 0/12: ''>, seg="'b.val / -2 AS a_calc...'"]
DEBUG      [PD:4  MD:13]	.............ColumnReferenceSegment               	Delim._look_ahead_match IN	    	[ls=12, seg='b.val / -2 AS a_calc...']
DEBUG      [PD:4  MD:13]	.............ColumnReferenceSegment               	Delim._look_ahead_match SI	    	[mq=[(<OneOf: [<Ref: DotSegment>, <Sequence: [<Ref: DotSegment>, <Ref: Dot...]>, 1, '.'), (<OneOf: [<Ref: DotSegment>, <Sequence: [<Ref: DotSegment>, <Ref: Dot...]>, 1, '.')], sb=['B', '.', 'VAL', '', '/', '', '-', '2', '', 'AS', '', 'A_CALCULATION']]
INFO       [PD:4  MD:13]	.............ColumnReferenceSegment               	OneOf.match PRN     	    	[ns=0, ps=0, ms=2, pruned=[], opts=[<Ref: DotSegment>, <Sequence: [<Ref: DotSegment>, <Ref: DotSegment>]>]]
DEBUG      [PD:4  MD:14]	..............ColumnReferenceSegment              	Ref.match OUT       	+   	[match=<MatchResult 1/11: '.'>, seg="'.val / -2 AS a_calcu...'"]
DEBUG      [PD:4  MD:15]	...............ColumnReferenceSegment             	Ref.match OUT       	+   	[match=<MatchResult 1/11: '.'>, seg="'.val / -2 AS a_calcu...'"]
DEBUG      [PD:4  MD:15]	...............ColumnReferenceSegment             	Ref.match OUT       	    	[match=<MatchResult 0/10: ''>, seg="'val / -2 AS a_calcul...'"]
INFO       [PD:4  MD:14]	..............ColumnReferenceSegment              	Seque.match OUT     	    	[match=<MatchResult 0/11: ''>, seg="'.val / -2 AS a_calcu...'"]
INFO       [PD:4  MD:13]	.............ColumnReferenceSegment               	OneOf.match OUT     	+   	[match=<MatchResult 1/11: '.'>, seg="'.val / -2 AS a_calcu...'"]
INFO       [PD:4  MD:13]	.............ColumnReferenceSegment               	OneOf.match PRN     	    	[ns=0, ps=0, ms=2, pruned=[], opts=[<Ref: DotSegment>, <Sequence: [<Ref: DotSegment>, <Ref: DotSegment>]>]]
DEBUG      [PD:4  MD:14]	..............ColumnReferenceSegment              	Ref.match OUT       	+   	[match=<MatchResult 1/11: '.'>, seg="'.val / -2 AS a_calcu...'"]
DEBUG      [PD:4  MD:15]	...............ColumnReferenceSegment             	Ref.match OUT       	+   	[match=<MatchResult 1/11: '.'>, seg="'.val / -2 AS a_calcu...'"]
DEBUG      [PD:4  MD:15]	...............ColumnReferenceSegment             	Ref.match OUT       	    	[match=<MatchResult 0/10: ''>, seg="'val / -2 AS a_calcul...'"]
INFO       [PD:4  MD:14]	..............ColumnReferenceSegment              	Seque.match OUT     	    	[match=<MatchResult 0/11: ''>, seg="'.val / -2 AS a_calcu...'"]
INFO       [PD:4  MD:13]	.............ColumnReferenceSegment               	OneOf.match OUT     	+   	[match=<MatchResult 1/11: '.'>, seg="'.val / -2 AS a_calcu...'"]
INFO       [PD:4  MD:13]	.............ColumnReferenceSegment               	OneOf.match PRN     	    	[ns=1, ps=10, ms=0, pruned=[<Ref: OnKeywordSegment>, <Ref: AsKeywordSegment>, <Ref: UsingKeywordSegment>, <Ref: CommaSegment>, <Ref: CastOperatorSegment>, <Ref: StartSquareBracketSegment>, <Ref: StartBracketSegment>, <Ref: ColonSegment>, <Ref: DelimiterSegment>, <class 'sqlfluff.core.parser.segments.base.BracketedSegment'>], opts=[<Ref: BinaryOperatorGrammar>]]
INFO       [PD:4  MD:14]	..............BinaryOperatorGrammar               	OneOf.match PRN     	    	[ns=1, ps=3, ms=0, pruned=[<Ref: ArithmeticBinaryOperatorGrammar>, <Ref: StringBinaryOperatorGrammar>, <Ref: BooleanBinaryOperatorGrammar>], opts=[<Ref: ComparisonOperatorGrammar>]]
INFO       [PD:4  MD:15]	...............ComparisonOperatorGrammar          	OneOf.match PRN     	    	[ns=1, ps=7, ms=0, pruned=[<Ref: EqualsSegment>, <Ref: GreaterThanSegment>, <Ref: LessThanSegment>, <Ref: GreaterThanOrEqualToSegment>, <Ref: LessThanOrEqualToSegment>, <Ref: NotEqualToSegment_a>, <Ref: NotEqualToSegment_b>], opts=[<Ref: LikeOperatorSegment>]]
DEBUG      [PD:4  MD:16]	................ComparisonOperatorGrammar         	Ref.match OUT       	    	[match=<MatchResult 0/12: ''>, seg="'b.val / -2 AS a_calc...'"]
INFO       [PD:4  MD:15]	...............ComparisonOperatorGrammar          	OneOf.match OUT     	    	[match=<MatchResult 0/12: ''>, seg="'b.val / -2 AS a_calc...'"]
DEBUG      [PD:4  MD:15]	...............BinaryOperatorGrammar              	Ref.match OUT       	    	[match=<MatchResult 0/12: ''>, seg="'b.val / -2 AS a_calc...'"]
INFO       [PD:4  MD:14]	..............BinaryOperatorGrammar               	OneOf.match OUT     	    	[match=<MatchResult 0/12: ''>, seg="'b.val / -2 AS a_calc...'"]
DEBUG      [PD:4  MD:14]	..............ColumnReferenceSegment              	Ref.match OUT       	    	[match=<MatchResult 0/12: ''>, seg="'b.val / -2 AS a_calc...'"]
INFO       [PD:4  MD:13]	.............ColumnReferenceSegment               	OneOf.match OUT     	    	[match=<MatchResult 0/12: ''>, seg="'b.val / -2 AS a_calc...'"]
DEBUG      [PD:4  MD:13]	.............ColumnReferenceSegment               	NonCo.match OUT     	    	[match=<MatchResult 0/12: ''>, seg="'b.val / -2 AS a_calc...'"]
INFO       [PD:4  MD:13]	.............ColumnReferenceSegment               	OneOf.match PRN     	    	[ns=1, ps=10, ms=0, pruned=[<Ref: OnKeywordSegment>, <Ref: AsKeywordSegment>, <Ref: UsingKeywordSegment>, <Ref: CommaSegment>, <Ref: CastOperatorSegment>, <Ref: StartSquareBracketSegment>, <Ref: StartBracketSegment>, <Ref: ColonSegment>, <Ref: DelimiterSegment>, <class 'sqlfluff.core.parser.segments.base.BracketedSegment'>], opts=[<Ref: BinaryOperatorGrammar>]]
INFO       [PD:4  MD:14]	..............BinaryOperatorGrammar               	OneOf.match PRN     	    	[ns=1, ps=3, ms=0, pruned=[<Ref: ArithmeticBinaryOperatorGrammar>, <Ref: StringBinaryOperatorGrammar>, <Ref: BooleanBinaryOperatorGrammar>], opts=[<Ref: ComparisonOperatorGrammar>]]
INFO       [PD:4  MD:15]	...............ComparisonOperatorGrammar          	OneOf.match PRN     	    	[ns=1, ps=7, ms=0, pruned=[<Ref: EqualsSegment>, <Ref: GreaterThanSegment>, <Ref: LessThanSegment>, <Ref: GreaterThanOrEqualToSegment>, <Ref: LessThanOrEqualToSegment>, <Ref: NotEqualToSegment_a>, <Ref: NotEqualToSegment_b>], opts=[<Ref: LikeOperatorSegment>]]
DEBUG      [PD:4  MD:16]	................ComparisonOperatorGrammar         	Ref.match OUT       	    	[match=<MatchResult 0/11: ''>, seg="'.val / -2 AS a_calcu...'"]
INFO       [PD:4  MD:15]	...............ComparisonOperatorGrammar          	OneOf.match OUT     	    	[match=<MatchResult 0/11: ''>, seg="'.val / -2 AS a_calcu...'"]
DEBUG      [PD:4  MD:15]	...............BinaryOperatorGrammar              	Ref.match OUT       	    	[match=<MatchResult 0/11: ''>, seg="'.val / -2 AS a_calcu...'"]
INFO       [PD:4  MD:14]	..............BinaryOperatorGrammar               	OneOf.match OUT     	    	[match=<MatchResult 0/11: ''>, seg="'.val / -2 AS a_calcu...'"]
DEBUG      [PD:4  MD:14]	..............ColumnReferenceSegment              	Ref.match OUT       	    	[match=<MatchResult 0/11: ''>, seg="'.val / -2 AS a_calcu...'"]
INFO       [PD:4  MD:13]	.............ColumnReferenceSegment               	OneOf.match OUT     	    	[match=<MatchResult 0/11: ''>, seg="'.val / -2 AS a_calcu...'"]
DEBUG      [PD:4  MD:13]	.............ColumnReferenceSegment               	NonCo.match OUT     	    	[match=<MatchResult 0/11: ''>, seg="'.val / -2 AS a_calcu...'"]
INFO       [PD:4  MD:13]	.............SingleIdentifierGrammar              	OneOf.match PRN     	    	[ns=2, ps=0, ms=0, pruned=[], opts=[<Ref: NakedIdentifierSegment>, <Ref: QuotedIdentifierSegment>]]
DEBUG      [PD:4  MD:14]	..............SingleIdentifierGrammar             	Ref.match OUT       	++  	[match=<MatchResult 1/1: 'b'>, seg="'b'"]
INFO       [PD:4  MD:13]	.............SingleIdentifierGrammar              	OneOf.match OUT     	++  	[match=<MatchResult 1/1: 'b'>, seg="'b'"]
DEBUG      [PD:4  MD:13]	.............ColumnReferenceSegment               	Ref.match OUT       	++  	[match=<MatchResult 1/1: 'b'>, seg="'b'"]
DEBUG      [PD:4  MD:13]	.............ColumnReferenceSegment               	Delim._look_ahead_match IN	    	[ls=10, seg='val / -2 AS a_calcul...']
DEBUG      [PD:4  MD:13]	.............ColumnReferenceSegment               	Delim._look_ahead_match SI	    	[mq=[], sb=['VAL', '', '/', '', '-', '2', '', 'AS', '', 'A_CALCULATION']]
INFO       [PD:4  MD:13]	.............ColumnReferenceSegment               	OneOf.match PRN     	    	[ns=1, ps=10, ms=0, pruned=[<Ref: OnKeywordSegment>, <Ref: AsKeywordSegment>, <Ref: UsingKeywordSegment>, <Ref: CommaSegment>, <Ref: CastOperatorSegment>, <Ref: StartSquareBracketSegment>, <Ref: StartBracketSegment>, <Ref: ColonSegment>, <Ref: DelimiterSegment>, <class 'sqlfluff.core.parser.segments.base.BracketedSegment'>], opts=[<Ref: BinaryOperatorGrammar>]]
INFO       [PD:4  MD:14]	..............BinaryOperatorGrammar               	OneOf.match PRN     	    	[ns=1, ps=3, ms=0, pruned=[<Ref: ArithmeticBinaryOperatorGrammar>, <Ref: StringBinaryOperatorGrammar>, <Ref: BooleanBinaryOperatorGrammar>], opts=[<Ref: ComparisonOperatorGrammar>]]
INFO       [PD:4  MD:15]	...............ComparisonOperatorGrammar          	OneOf.match PRN     	    	[ns=1, ps=7, ms=0, pruned=[<Ref: EqualsSegment>, <Ref: GreaterThanSegment>, <Ref: LessThanSegment>, <Ref: GreaterThanOrEqualToSegment>, <Ref: LessThanOrEqualToSegment>, <Ref: NotEqualToSegment_a>, <Ref: NotEqualToSegment_b>], opts=[<Ref: LikeOperatorSegment>]]
DEBUG      [PD:4  MD:16]	................ComparisonOperatorGrammar         	Ref.match OUT       	    	[match=<MatchResult 0/10: ''>, seg="'val / -2 AS a_calcul...'"]
INFO       [PD:4  MD:15]	...............ComparisonOperatorGrammar          	OneOf.match OUT     	    	[match=<MatchResult 0/10: ''>, seg="'val / -2 AS a_calcul...'"]
DEBUG      [PD:4  MD:15]	...............BinaryOperatorGrammar              	Ref.match OUT       	    	[match=<MatchResult 0/10: ''>, seg="'val / -2 AS a_calcul...'"]
INFO       [PD:4  MD:14]	..............BinaryOperatorGrammar               	OneOf.match OUT     	    	[match=<MatchResult 0/10: ''>, seg="'val / -2 AS a_calcul...'"]
DEBUG      [PD:4  MD:14]	..............ColumnReferenceSegment              	Ref.match OUT       	    	[match=<MatchResult 0/10: ''>, seg="'val / -2 AS a_calcul...'"]
INFO       [PD:4  MD:13]	.............ColumnReferenceSegment               	OneOf.match OUT     	    	[match=<MatchResult 0/10: ''>, seg="'val / -2 AS a_calcul...'"]
DEBUG      [PD:4  MD:13]	.............ColumnReferenceSegment               	NonCo.match OUT     	    	[match=<MatchResult 0/10: ''>, seg="'val / -2 AS a_calcul...'"]
INFO       [PD:4  MD:13]	.............ColumnReferenceSegment               	OneOf.match PRN     	    	[ns=1, ps=10, ms=0, pruned=[<Ref: OnKeywordSegment>, <Ref: AsKeywordSegment>, <Ref: UsingKeywordSegment>, <Ref: CommaSegment>, <Ref: CastOperatorSegment>, <Ref: StartSquareBracketSegment>, <Ref: StartBracketSegment>, <Ref: ColonSegment>, <Ref: DelimiterSegment>, <class 'sqlfluff.core.parser.segments.base.BracketedSegment'>], opts=[<Ref: BinaryOperatorGrammar>]]
INFO       [PD:4  MD:14]	..............BinaryOperatorGrammar               	OneOf.match PRN     	    	[ns=1, ps=2, ms=1, pruned=[<Ref: StringBinaryOperatorGrammar>, <Ref: BooleanBinaryOperatorGrammar>], opts=[<Ref: ArithmeticBinaryOperatorGrammar>, <Ref: ComparisonOperatorGrammar>]]
INFO       [PD:4  MD:15]	...............ArithmeticBinaryOperatorGrammar    	OneOf.match PRN     	    	[ns=0, ps=9, ms=1, pruned=[<Ref: PlusSegment>, <Ref: MinusSegment>, <Ref: MultiplySegment>, <Ref: ModuloSegment>, <Ref: BitwiseAndSegment>, <Ref: BitwiseOrSegment>, <Ref: BitwiseXorSegment>, <Ref: BitwiseLShiftSegment>, <Ref: BitwiseRShiftSegment>], opts=[<Ref: DivideSegment>]]
DEBUG      [PD:4  MD:16]	................ArithmeticBinaryOperatorGrammar   	Ref.match OUT       	    	[match=<MatchResult 0/9: ''>, seg="' / -2 AS a_calculati...'"]
INFO       [PD:4  MD:15]	...............ArithmeticBinaryOperatorGrammar    	OneOf.match OUT     	    	[match=<MatchResult 0/9: ''>, seg="' / -2 AS a_calculati...'"]
DEBUG      [PD:4  MD:15]	...............BinaryOperatorGrammar              	Ref.match OUT       	    	[match=<MatchResult 0/9: ''>, seg="' / -2 AS a_calculati...'"]
INFO       [PD:4  MD:15]	...............ComparisonOperatorGrammar          	OneOf.match PRN     	    	[ns=1, ps=7, ms=0, pruned=[<Ref: EqualsSegment>, <Ref: GreaterThanSegment>, <Ref: LessThanSegment>, <Ref: GreaterThanOrEqualToSegment>, <Ref: LessThanOrEqualToSegment>, <Ref: NotEqualToSegment_a>, <Ref: NotEqualToSegment_b>], opts=[<Ref: LikeOperatorSegment>]]
DEBUG      [PD:4  MD:16]	................ComparisonOperatorGrammar         	Ref.match OUT       	    	[match=<MatchResult 0/9: ''>, seg="' / -2 AS a_calculati...'"]
INFO       [PD:4  MD:15]	...............ComparisonOperatorGrammar          	OneOf.match OUT     	    	[match=<MatchResult 0/9: ''>, seg="' / -2 AS a_calculati...'"]
DEBUG      [PD:4  MD:15]	...............BinaryOperatorGrammar              	Ref.match OUT       	    	[match=<MatchResult 0/9: ''>, seg="' / -2 AS a_calculati...'"]
INFO       [PD:4  MD:14]	..............BinaryOperatorGrammar               	OneOf.match OUT     	    	[match=<MatchResult 0/9: ''>, seg="' / -2 AS a_calculati...'"]
DEBUG      [PD:4  MD:14]	..............ColumnReferenceSegment              	Ref.match OUT       	    	[match=<MatchResult 0/9: ''>, seg="' / -2 AS a_calculati...'"]
INFO       [PD:4  MD:13]	.............ColumnReferenceSegment               	OneOf.match OUT     	    	[match=<MatchResult 0/9: ''>, seg="' / -2 AS a_calculati...'"]
DEBUG      [PD:4  MD:13]	.............ColumnReferenceSegment               	NonCo.match OUT     	+   	[match=<MatchResult 1/9: ' '>, seg="' / -2 AS a_calculati...'"]
INFO       [PD:4  MD:13]	.............SingleIdentifierGrammar              	OneOf.match PRN     	    	[ns=2, ps=0, ms=0, pruned=[], opts=[<Ref: NakedIdentifierSegment>, <Ref: QuotedIdentifierSegment>]]
DEBUG      [PD:4  MD:14]	..............SingleIdentifierGrammar             	Ref.match OUT       	++  	[match=<MatchResult 1/1: 'val'>, seg="'val'"]
INFO       [PD:4  MD:13]	.............SingleIdentifierGrammar              	OneOf.match OUT     	++  	[match=<MatchResult 1/1: 'val'>, seg="'val'"]
DEBUG      [PD:4  MD:13]	.............ColumnReferenceSegment               	Ref.match OUT       	++  	[match=<MatchResult 1/1: 'val'>, seg="'val'"]
INFO       [PD:4  MD:12]	............ColumnReferenceSegment                	Delim.match OUT     	+   	[match=<MatchResult 3/12: 'b.val'>, seg="'b.val / -2 AS a_calc...'"]
DEBUG      [PD:4  MD:11]	...........ColumnReferenceSegment                 	Colum.match OUT     	+   	[match=<MatchResult 1/10: 'b.val'>, seg="'b.val / -2 AS a_calc...'"]
DEBUG      [PD:4  MD:11]	...........Expression_D_Grammar                   	Ref.match OUT       	+   	[match=<MatchResult 1/10: 'b.val'>, seg="'b.val / -2 AS a_calc...'"]
DEBUG      [PD:4  MD:12]	............Expression_D_Grammar                  	Ref.match OUT       	    	[match=<MatchResult 0/12: ''>, seg="'b.val / -2 AS a_calc...'"]
INFO       [PD:4  MD:13]	.............ArrayLiteralSegment                  	Brack.match OUT     	    	[match=<MatchResult 0/12: ''>, seg="'b.val / -2 AS a_calc...'"]
DEBUG      [PD:4  MD:12]	............ArrayLiteralSegment                   	Array.match OUT     	    	[match=<MatchResult 0/12: ''>, seg="'b.val / -2 AS a_calc...'"]
DEBUG      [PD:4  MD:12]	............Expression_D_Grammar                  	Ref.match OUT       	    	[match=<MatchResult 0/12: ''>, seg="'b.val / -2 AS a_calc...'"]
INFO       [PD:4  MD:11]	...........Expression_D_Grammar                   	Seque.match OUT     	    	[match=<MatchResult 0/12: ''>, seg="'b.val / -2 AS a_calc...'"]
INFO       [PD:4  MD:13]	.............DatatypeSegment                      	OneOf.match PRN     	    	[ns=1, ps=2, ms=0, pruned=[<Sequence: [<OneOf: [<Ref: TimeKeywordSegment>, <Ref..., <Bracketed: [<Ref: NumericLiteralSegment..., <Sequence:...]>, <Sequence: [<Ref: DoubleKeywordSegment>, <Ref: PrecisionKeywordSegment>]>], opts=[<Sequence: [<OneOf: [<Sequence: [<OneOf: [<Ref: Char..., <Bracketed: [<OneOf: [<Delimited: [<Ref:..., <Ref: Char...]>]]
INFO       [PD:4  MD:15]	...............DatatypeSegment                    	OneOf.match PRN     	    	[ns=1, ps=1, ms=0, pruned=[<Sequence: [<OneOf: [<Ref: CharacterKeywordSegment>,..., <OneOf: [<Ref: VaryingKeywordSegment>, <...]>], opts=[<Sequence: [<Sequence: [<Ref: SingleIdentifierGramma..., <Ref: DatatypeIdentifierSegment>]>]]
INFO       [PD:4  MD:18]	..................SingleIdentifierGrammar         	OneOf.match PRN     	    	[ns=2, ps=0, ms=0, pruned=[], opts=[<Ref: NakedIdentifierSegment>, <Ref: QuotedIdentifierSegment>]]
DEBUG      [PD:4  MD:19]	...................SingleIdentifierGrammar        	Ref.match OUT       	+   	[match=<MatchResult 1/12: 'b'>, seg="'b.val / -2 AS a_calc...'"]
DEBUG      [PD:4  MD:19]	...................SingleIdentifierGrammar        	Ref.match OUT       	    	[match=<MatchResult 0/12: ''>, seg="'b.val / -2 AS a_calc...'"]
INFO       [PD:4  MD:18]	..................SingleIdentifierGrammar         	OneOf.match OUT     	+   	[match=<MatchResult 1/12: 'b'>, seg="'b.val / -2 AS a_calc...'"]
DEBUG      [PD:4  MD:18]	..................DatatypeSegment                 	Ref.match OUT       	+   	[match=<MatchResult 1/12: 'b'>, seg="'b.val / -2 AS a_calc...'"]
DEBUG      [PD:4  MD:18]	..................DatatypeSegment                 	Ref.match OUT       	+   	[match=<MatchResult 1/11: '.'>, seg="'.val / -2 AS a_calcu...'"]
INFO       [PD:4  MD:17]	.................DatatypeSegment                  	Seque.match OUT     	+   	[match=<MatchResult 2/12: 'b.'>, seg="'b.val / -2 AS a_calc...'"]
DEBUG      [PD:4  MD:17]	.................DatatypeSegment                  	Ref.match OUT       	+   	[match=<MatchResult 1/10: 'val'>, seg="'val / -2 AS a_calcul...'"]
INFO       [PD:4  MD:16]	................DatatypeSegment                   	Seque.match OUT     	+   	[match=<MatchResult 3/12: 'b.val'>, seg="'b.val / -2 AS a_calc...'"]
INFO       [PD:4  MD:15]	...............DatatypeSegment                    	OneOf.match OUT     	+   	[match=<MatchResult 3/12: 'b.val'>, seg="'b.val / -2 AS a_calc...'"]
INFO       [PD:4  MD:15]	...............DatatypeSegment                    	Brack.match OUT     	    	[match=<MatchResult 0/8: ''>, seg="'/ -2 AS a_calculatio...'"]
DEBUG      [PD:4  MD:15]	...............DatatypeSegment                    	Ref.match OUT       	    	[match=<MatchResult 0/8: ''>, seg="'/ -2 AS a_calculatio...'"]
INFO       [PD:4  MD:14]	..............DatatypeSegment                     	Seque.match OUT     	+   	[match=<MatchResult 3/12: 'b.val'>, seg="'b.val / -2 AS a_calc...'"]
INFO       [PD:4  MD:13]	.............DatatypeSegment                      	OneOf.match OUT     	+   	[match=<MatchResult 3/12: 'b.val'>, seg="'b.val / -2 AS a_calc...'"]
DEBUG      [PD:4  MD:12]	............DatatypeSegment                       	Datat.match OUT     	+   	[match=<MatchResult 1/10: 'b.val'>, seg="'b.val / -2 AS a_calc...'"]
DEBUG      [PD:4  MD:12]	............Expression_D_Grammar                  	Ref.match OUT       	+   	[match=<MatchResult 1/10: 'b.val'>, seg="'b.val / -2 AS a_calc...'"]
INFO       [PD:4  MD:12]	............Expression_D_Grammar                  	OneOf.match PRN     	    	[ns=2, ps=3, ms=0, pruned=[<Ref: BooleanLiteralGrammar>, <Ref: NullLiteralSegment>, <Ref: DateTimeLiteralGrammar>], opts=[<Ref: QuotedLiteralSegment>, <Ref: NumericLiteralSegment>]]
DEBUG      [PD:4  MD:13]	.............Expression_D_Grammar                 	Ref.match OUT       	    	[match=<MatchResult 0/8: ''>, seg="'/ -2 AS a_calculatio...'"]
DEBUG      [PD:4  MD:13]	.............Expression_D_Grammar                 	Ref.match OUT       	    	[match=<MatchResult 0/8: ''>, seg="'/ -2 AS a_calculatio...'"]
INFO       [PD:4  MD:12]	............Expression_D_Grammar                  	OneOf.match OUT     	    	[match=<MatchResult 0/8: ''>, seg="'/ -2 AS a_calculatio...'"]
INFO       [PD:4  MD:11]	...........Expression_D_Grammar                   	Seque.match OUT     	    	[match=<MatchResult 0/12: ''>, seg="'b.val / -2 AS a_calc...'"]
INFO       [PD:4  MD:10]	..........Expression_D_Grammar                    	OneOf.match OUT     	+   	[match=<MatchResult 1/10: 'b.val'>, seg="'b.val / -2 AS a_calc...'"]
INFO       [PD:4  MD:10]	..........Accessor_Grammar                        	AnyNu.match PRN     	    	[ns=0, ps=1, ms=0, pruned=[<Ref: ArrayAccessorSegment>], opts='ALL']
INFO       [PD:4  MD:10]	..........Accessor_Grammar                        	AnyNu.match OUT     	    	[match=<MatchResult 0/8: ''>, seg="'/ -2 AS a_calculatio...'"]
DEBUG      [PD:4  MD:10]	..........Expression_D_Grammar                    	Ref.match OUT       	    	[match=<MatchResult 0/8: ''>, seg="'/ -2 AS a_calculatio...'"]
INFO       [PD:4  MD:10]	..........Expression_D_Grammar                    	AnyNu.match PRN     	    	[ns=0, ps=1, ms=0, pruned=[<Ref: ShorthandCastSegment>], opts='ALL']
INFO       [PD:4  MD:10]	..........Expression_D_Grammar                    	AnyNu.match OUT     	    	[match=<MatchResult 0/8: ''>, seg="'/ -2 AS a_calculatio...'"]
INFO       [PD:4  MD:9 ]	.........Expression_D_Grammar                     	Seque.match OUT     	+   	[match=<MatchResult 1/10: 'b.val'>, seg="'b.val / -2 AS a_calc...'"]
DEBUG      [PD:4  MD:9 ]	.........Expression_C_Grammar                     	Ref.match OUT       	+   	[match=<MatchResult 1/10: 'b.val'>, seg="'b.val / -2 AS a_calc...'"]
INFO       [PD:4  MD:8 ]	........Expression_C_Grammar                      	OneOf.match OUT     	+   	[match=<MatchResult 1/10: 'b.val'>, seg="'b.val / -2 AS a_calc...'"]
DEBUG      [PD:4  MD:8 ]	........Expression_A_Grammar                      	Ref.match OUT       	+   	[match=<MatchResult 1/10: 'b.val'>, seg="'b.val / -2 AS a_calc...'"]
DEBUG      [PD:4  MD:9 ]	.........Expression_A_Grammar                     	Ref.match OUT       	    	[match=<MatchResult 0/8: ''>, seg="'/ -2 AS a_calculatio...'"]
INFO       [PD:4  MD:8 ]	........Expression_A_Grammar                      	Seque.match OUT     	    	[match=<MatchResult 0/8: ''>, seg="'/ -2 AS a_calculatio...'"]
INFO       [PD:4  MD:7 ]	.......Expression_A_Grammar                       	Seque.match OUT     	+   	[match=<MatchResult 3/12: '+ b.val'>, seg="'+ b.val / -2 AS a_ca...'"]
DEBUG      [PD:4  MD:7 ]	.......Expression_A_Grammar                       	Ref.match OUT       	    	[match=<MatchResult 0/14: ''>, seg="'+ b.val / -2 AS a_ca...'"]
DEBUG      [PD:4  MD:7 ]	.......Expression_A_Grammar                       	Ref.match OUT       	    	[match=<MatchResult 0/14: ''>, seg="'+ b.val / -2 AS a_ca...'"]
INFO       [PD:4  MD:6 ]	......Expression_A_Grammar                        	OneOf.match OUT     	+   	[match=<MatchResult 3/12: '+ b.val'>, seg="'+ b.val / -2 AS a_ca...'"]
INFO       [PD:4  MD:5 ]	.....Expression_A_Grammar                         	AnyNu.match PRN     	    	[ns=1, ps=0, ms=0, pruned=[], opts=[<OneOf: [<Sequence: [<OneOf: [<Sequence: [<Ref: N..., <Sequence: [<Ref: NotKeywordSegment [opt..., <Sequence:...]>]]
INFO       [PD:4  MD:6 ]	......Expression_A_Grammar                        	OneOf.match PRN     	    	[ns=3, ps=5, ms=0, pruned=[<Sequence: [<Ref: NotKeywordSegment [opt]>, <Ref: InKeywordSegment>, <Bracketed: [<OneOf: [<Delimited: [<Ref:...]>, <Sequence: [<Ref: NotKeywordSegment [opt]>, <Ref: InKeywordSegment>, <Ref: FunctionSegment>]>, <Sequence: [<Ref: IsKeywordSegment>, <Ref: NotKeywordSegment [opt]>, <Ref: IsClauseGrammar>]>, <Sequence: [<Ref: NotKeywordSegment>, <Ref: Expression_C_Grammar>]>, <Sequence: [<Ref: NotKeywordSegment [opt]>, <Ref: BetweenKeywordSegment>, <Ref: Expression_C_Grammar>, <AnyNumbe...]>], opts=[<Sequence: [<OneOf: [<Sequence: [<Ref: NotKeywordSeg..., <Ref: Expression_C_Grammar>, <Sequence: [<Ref: EscapeKe...]>, <Ref: IsNullGrammar>, <Ref: NotNullGrammar>]]
INFO       [PD:4  MD:8 ]	........Expression_A_Grammar                      	OneOf.match PRN     	    	[ns=1, ps=1, ms=0, pruned=[<Sequence: [<Ref: NotKeywordSegment [opt]>, <Ref: LikeGrammar>]>], opts=[<Sequence: [<Ref: BinaryOperatorGrammar>, <Ref: NotKeywordSegment [opt]>]>]]
INFO       [PD:4  MD:10]	..........BinaryOperatorGrammar                   	OneOf.match PRN     	    	[ns=1, ps=2, ms=1, pruned=[<Ref: StringBinaryOperatorGrammar>, <Ref: BooleanBinaryOperatorGrammar>], opts=[<Ref: ArithmeticBinaryOperatorGrammar>, <Ref: ComparisonOperatorGrammar>]]
INFO       [PD:4  MD:11]	...........ArithmeticBinaryOperatorGrammar        	OneOf.match PRN     	    	[ns=0, ps=9, ms=1, pruned=[<Ref: PlusSegment>, <Ref: MinusSegment>, <Ref: MultiplySegment>, <Ref: ModuloSegment>, <Ref: BitwiseAndSegment>, <Ref: BitwiseOrSegment>, <Ref: BitwiseXorSegment>, <Ref: BitwiseLShiftSegment>, <Ref: BitwiseRShiftSegment>], opts=[<Ref: DivideSegment>]]
DEBUG      [PD:4  MD:12]	............ArithmeticBinaryOperatorGrammar       	Ref.match OUT       	+   	[match=<MatchResult 1/8: '/'>, seg="'/ -2 AS a_calculatio...'"]
INFO       [PD:4  MD:11]	...........ArithmeticBinaryOperatorGrammar        	OneOf.match OUT     	+   	[match=<MatchResult 1/8: '/'>, seg="'/ -2 AS a_calculatio...'"]
DEBUG      [PD:4  MD:11]	...........BinaryOperatorGrammar                  	Ref.match OUT       	+   	[match=<MatchResult 1/8: '/'>, seg="'/ -2 AS a_calculatio...'"]
INFO       [PD:4  MD:11]	...........ComparisonOperatorGrammar              	OneOf.match PRN     	    	[ns=1, ps=7, ms=0, pruned=[<Ref: EqualsSegment>, <Ref: GreaterThanSegment>, <Ref: LessThanSegment>, <Ref: GreaterThanOrEqualToSegment>, <Ref: LessThanOrEqualToSegment>, <Ref: NotEqualToSegment_a>, <Ref: NotEqualToSegment_b>], opts=[<Ref: LikeOperatorSegment>]]
DEBUG      [PD:4  MD:12]	............ComparisonOperatorGrammar             	Ref.match OUT       	    	[match=<MatchResult 0/8: ''>, seg="'/ -2 AS a_calculatio...'"]
INFO       [PD:4  MD:11]	...........ComparisonOperatorGrammar              	OneOf.match OUT     	    	[match=<MatchResult 0/8: ''>, seg="'/ -2 AS a_calculatio...'"]
DEBUG      [PD:4  MD:11]	...........BinaryOperatorGrammar                  	Ref.match OUT       	    	[match=<MatchResult 0/8: ''>, seg="'/ -2 AS a_calculatio...'"]
INFO       [PD:4  MD:10]	..........BinaryOperatorGrammar                   	OneOf.match OUT     	+   	[match=<MatchResult 1/8: '/'>, seg="'/ -2 AS a_calculatio...'"]
DEBUG      [PD:4  MD:10]	..........Expression_A_Grammar                    	Ref.match OUT       	+   	[match=<MatchResult 1/8: '/'>, seg="'/ -2 AS a_calculatio...'"]
DEBUG      [PD:4  MD:10]	..........Expression_A_Grammar                    	Ref.match OUT       	    	[match=<MatchResult 0/6: ''>, seg="'-2 AS a_calculation'"]
INFO       [PD:4  MD:9 ]	.........Expression_A_Grammar                     	Seque.match OUT     	+   	[match=<MatchResult 1/8: '/'>, seg="'/ -2 AS a_calculatio...'"]
INFO       [PD:4  MD:8 ]	........Expression_A_Grammar                      	OneOf.match OUT     	+   	[match=<MatchResult 1/8: '/'>, seg="'/ -2 AS a_calculatio...'"]
INFO       [PD:4  MD:8 ]	........Expression_C_Grammar                      	OneOf.match PRN     	    	[ns=1, ps=2, ms=0, pruned=[<Sequence: [<Ref: ExistsKeywordSegment>, <Bracketed: [<Ref: SelectStatementSegmen...]>, <Ref: CaseExpressionSegment>], opts=[<Ref: Expression_D_Grammar>]]
INFO       [PD:4  MD:10]	..........Expression_D_Grammar                    	OneOf.match PRN     	    	[ns=6, ps=3, ms=0, pruned=[<Bracketed: [<OneOf: [<Ref: ExpressionSegment>, <Ref:...]>, <Ref: SelectStatementSegment>, <Ref: IntervalExpressionSegment>], opts=[<Ref: BareFunctionSegment>, <Ref: FunctionSegment>, <Ref: LiteralGrammar>, <Ref: ColumnReferenceSegment>, <Sequence: [<Ref: SimpleArrayTypeGrammar [opt]>, <Ref: ArrayLiteralSegment>]>, <Sequence: [<Ref: DatatypeSegment>, <OneOf: [<Ref: QuotedLiteralSegment>, <R...]>]]
DEBUG      [PD:4  MD:11]	...........Expression_D_Grammar                   	Ref.match OUT       	    	[match=<MatchResult 0/6: ''>, seg="'-2 AS a_calculation'"]
INFO       [PD:4  MD:12]	............FunctionSegment                       	OneOf.match PRN     	    	[ns=1, ps=1, ms=0, pruned=[<Sequence: [<Sequence: [<Ref: DateAddFunctionNameSeg...]>], opts=[<Sequence: [<Sequence: [<AnyNumberOf: [<Ref: Functio..., <Ref: PostFunctionGrammar [opt]>]>]]
DEBUG      [PD:4  MD:18]	..................DateAddFunctionNameSegment      	Ref.match OUT       	    	[match=<MatchResult 0/6: ''>, seg="'-2 AS a_calculation'"]
INFO       [PD:4  MD:17]	.................DateAddFunctionNameSegment       	Seque.match OUT     	    	[match=<MatchResult 0/6: ''>, seg="'-2 AS a_calculation'"]
DEBUG      [PD:4  MD:16]	................DateAddFunctionNameSegment        	DateA.match OUT     	    	[match=<MatchResult 0/6: ''>, seg="'-2 AS a_calculation'"]
DEBUG      [PD:4  MD:16]	................FunctionSegment                   	Ref.match OUT       	    	[match=<MatchResult 0/6: ''>, seg="'-2 AS a_calculation'"]
INFO       [PD:4  MD:15]	...............FunctionSegment                    	AnyNu.match PRN     	    	[ns=1, ps=0, ms=0, pruned=[], opts=[<Ref: FunctionNameSegment>]]
INFO       [PD:4  MD:18]	..................FunctionNameSegment             	AnyNu.match PRN     	    	[ns=1, ps=0, ms=0, pruned=[], opts=[<Sequence: [<Ref: SingleIdentifierGrammar>, <Ref: DotSegment>]>]]
INFO       [PD:4  MD:20]	....................SingleIdentifierGrammar       	OneOf.match PRN     	    	[ns=2, ps=0, ms=0, pruned=[], opts=[<Ref: NakedIdentifierSegment>, <Ref: QuotedIdentifierSegment>]]
DEBUG      [PD:4  MD:21]	.....................SingleIdentifierGrammar      	Ref.match OUT       	    	[match=<MatchResult 0/6: ''>, seg="'-2 AS a_calculation'"]
DEBUG      [PD:4  MD:21]	.....................SingleIdentifierGrammar      	Ref.match OUT       	    	[match=<MatchResult 0/6: ''>, seg="'-2 AS a_calculation'"]
INFO       [PD:4  MD:20]	....................SingleIdentifierGrammar       	OneOf.match OUT     	    	[match=<MatchResult 0/6: ''>, seg="'-2 AS a_calculation'"]
DEBUG      [PD:4  MD:20]	....................FunctionNameSegment           	Ref.match OUT       	    	[match=<MatchResult 0/6: ''>, seg="'-2 AS a_calculation'"]
INFO       [PD:4  MD:19]	...................FunctionNameSegment            	Seque.match OUT     	    	[match=<MatchResult 0/6: ''>, seg="'-2 AS a_calculation'"]
INFO       [PD:4  MD:18]	..................FunctionNameSegment             	AnyNu.match OUT     	    	[match=<MatchResult 0/6: ''>, seg="'-2 AS a_calculation'"]
INFO       [PD:4  MD:18]	..................FunctionNameSegment             	OneOf.match PRN     	    	[ns=2, ps=0, ms=0, pruned=[], opts=[<Ref: FunctionNameIdentifierSegment>, <Ref: QuotedIdentifierSegment>]]
DEBUG      [PD:4  MD:19]	...................FunctionNameSegment            	Ref.match OUT       	    	[match=<MatchResult 0/6: ''>, seg="'-2 AS a_calculation'"]
DEBUG      [PD:4  MD:19]	...................FunctionNameSegment            	Ref.match OUT       	    	[match=<MatchResult 0/6: ''>, seg="'-2 AS a_calculation'"]
INFO       [PD:4  MD:18]	..................FunctionNameSegment             	OneOf.match OUT     	    	[match=<MatchResult 0/6: ''>, seg="'-2 AS a_calculation'"]
INFO       [PD:4  MD:17]	.................FunctionNameSegment              	Seque.match OUT     	    	[match=<MatchResult 0/6: ''>, seg="'-2 AS a_calculation'"]
DEBUG      [PD:4  MD:16]	................FunctionNameSegment               	Funct.match OUT     	    	[match=<MatchResult 0/6: ''>, seg="'-2 AS a_calculation'"]
DEBUG      [PD:4  MD:16]	................FunctionSegment                   	Ref.match OUT       	    	[match=<MatchResult 0/6: ''>, seg="'-2 AS a_calculation'"]
INFO       [PD:4  MD:15]	...............FunctionSegment                    	AnyNu.match OUT     	    	[match=<MatchResult 0/6: ''>, seg="'-2 AS a_calculation'"]
INFO       [PD:4  MD:14]	..............FunctionSegment                     	Seque.match OUT     	    	[match=<MatchResult 0/6: ''>, seg="'-2 AS a_calculation'"]
INFO       [PD:4  MD:13]	.............FunctionSegment                      	Seque.match OUT     	    	[match=<MatchResult 0/6: ''>, seg="'-2 AS a_calculation'"]
INFO       [PD:4  MD:12]	............FunctionSegment                       	OneOf.match OUT     	    	[match=<MatchResult 0/6: ''>, seg="'-2 AS a_calculation'"]
DEBUG      [PD:4  MD:11]	...........FunctionSegment                        	Funct.match OUT     	    	[match=<MatchResult 0/6: ''>, seg="'-2 AS a_calculation'"]
DEBUG      [PD:4  MD:11]	...........Expression_D_Grammar                   	Ref.match OUT       	    	[match=<MatchResult 0/6: ''>, seg="'-2 AS a_calculation'"]
INFO       [PD:4  MD:11]	...........LiteralGrammar                         	OneOf.match PRN     	    	[ns=2, ps=3, ms=1, pruned=[<Ref: BooleanLiteralGrammar>, <Ref: NullLiteralSegment>, <Ref: DateTimeLiteralGrammar>], opts=[<Ref: QuotedLiteralSegment>, <Ref: NumericLiteralSegment>, <Ref: QualifiedNumericLiteralSegment>]]
DEBUG      [PD:4  MD:12]	............LiteralGrammar                        	Ref.match OUT       	    	[match=<MatchResult 0/6: ''>, seg="'-2 AS a_calculation'"]
DEBUG      [PD:4  MD:12]	............LiteralGrammar                        	Ref.match OUT       	    	[match=<MatchResult 0/6: ''>, seg="'-2 AS a_calculation'"]
INFO       [PD:4  MD:14]	..............QualifiedNumericLiteralSegment      	OneOf.match PRN     	    	[ns=0, ps=1, ms=1, pruned=[<Ref: PlusSegment>], opts=[<Ref: MinusSegment>]]
DEBUG      [PD:4  MD:15]	...............QualifiedNumericLiteralSegment     	Ref.match OUT       	+   	[match=<MatchResult 1/6: '-'>, seg="'-2 AS a_calculation'"]
INFO       [PD:4  MD:14]	..............QualifiedNumericLiteralSegment      	OneOf.match OUT     	+   	[match=<MatchResult 1/6: '-'>, seg="'-2 AS a_calculation'"]
DEBUG      [PD:4  MD:14]	..............QualifiedNumericLiteralSegment      	Ref.match OUT       	+   	[match=<MatchResult 1/5: '2'>, seg="'2 AS a_calculation'"]
INFO       [PD:4  MD:13]	.............QualifiedNumericLiteralSegment       	Seque.match OUT     	+   	[match=<MatchResult 2/6: '-2'>, seg="'-2 AS a_calculation'"]
DEBUG      [PD:4  MD:12]	............QualifiedNumericLiteralSegment        	Quali.match OUT     	+   	[match=<MatchResult 1/5: '-2'>, seg="'-2 AS a_calculation'"]
DEBUG      [PD:4  MD:12]	............LiteralGrammar                        	Ref.match OUT       	+   	[match=<MatchResult 1/5: '-2'>, seg="'-2 AS a_calculation'"]
INFO       [PD:4  MD:11]	...........LiteralGrammar                         	OneOf.match OUT     	+   	[match=<MatchResult 1/5: '-2'>, seg="'-2 AS a_calculation'"]
DEBUG      [PD:4  MD:11]	...........Expression_D_Grammar                   	Ref.match OUT       	+   	[match=<MatchResult 1/5: '-2'>, seg="'-2 AS a_calculation'"]
DEBUG      [PD:4  MD:13]	.............ColumnReferenceSegment               	Delim._look_ahead_match IN	    	[ls=6, seg='-2 AS a_calculation']
DEBUG      [PD:4  MD:13]	.............ColumnReferenceSegment               	Delim._look_ahead_match SI	    	[mq=[], sb=['-', '2', '', 'AS', '', 'A_CALCULATION']]
INFO       [PD:4  MD:13]	.............ColumnReferenceSegment               	OneOf.match PRN     	    	[ns=1, ps=10, ms=0, pruned=[<Ref: OnKeywordSegment>, <Ref: AsKeywordSegment>, <Ref: UsingKeywordSegment>, <Ref: CommaSegment>, <Ref: CastOperatorSegment>, <Ref: StartSquareBracketSegment>, <Ref: StartBracketSegment>, <Ref: ColonSegment>, <Ref: DelimiterSegment>, <class 'sqlfluff.core.parser.segments.base.BracketedSegment'>], opts=[<Ref: BinaryOperatorGrammar>]]
INFO       [PD:4  MD:14]	..............BinaryOperatorGrammar               	OneOf.match PRN     	    	[ns=1, ps=2, ms=1, pruned=[<Ref: StringBinaryOperatorGrammar>, <Ref: BooleanBinaryOperatorGrammar>], opts=[<Ref: ArithmeticBinaryOperatorGrammar>, <Ref: ComparisonOperatorGrammar>]]
INFO       [PD:4  MD:15]	...............ArithmeticBinaryOperatorGrammar    	OneOf.match PRN     	    	[ns=0, ps=9, ms=1, pruned=[<Ref: PlusSegment>, <Ref: DivideSegment>, <Ref: MultiplySegment>, <Ref: ModuloSegment>, <Ref: BitwiseAndSegment>, <Ref: BitwiseOrSegment>, <Ref: BitwiseXorSegment>, <Ref: BitwiseLShiftSegment>, <Ref: BitwiseRShiftSegment>], opts=[<Ref: MinusSegment>]]
DEBUG      [PD:4  MD:16]	................ArithmeticBinaryOperatorGrammar   	Ref.match OUT       	+   	[match=<MatchResult 1/6: '-'>, seg="'-2 AS a_calculation'"]
INFO       [PD:4  MD:15]	...............ArithmeticBinaryOperatorGrammar    	OneOf.match OUT     	+   	[match=<MatchResult 1/6: '-'>, seg="'-2 AS a_calculation'"]
DEBUG      [PD:4  MD:15]	...............BinaryOperatorGrammar              	Ref.match OUT       	+   	[match=<MatchResult 1/6: '-'>, seg="'-2 AS a_calculation'"]
INFO       [PD:4  MD:15]	...............ComparisonOperatorGrammar          	OneOf.match PRN     	    	[ns=1, ps=7, ms=0, pruned=[<Ref: EqualsSegment>, <Ref: GreaterThanSegment>, <Ref: LessThanSegment>, <Ref: GreaterThanOrEqualToSegment>, <Ref: LessThanOrEqualToSegment>, <Ref: NotEqualToSegment_a>, <Ref: NotEqualToSegment_b>], opts=[<Ref: LikeOperatorSegment>]]
DEBUG      [PD:4  MD:16]	................ComparisonOperatorGrammar         	Ref.match OUT       	    	[match=<MatchResult 0/6: ''>, seg="'-2 AS a_calculation'"]
INFO       [PD:4  MD:15]	...............ComparisonOperatorGrammar          	OneOf.match OUT     	    	[match=<MatchResult 0/6: ''>, seg="'-2 AS a_calculation'"]
DEBUG      [PD:4  MD:15]	...............BinaryOperatorGrammar              	Ref.match OUT       	    	[match=<MatchResult 0/6: ''>, seg="'-2 AS a_calculation'"]
INFO       [PD:4  MD:14]	..............BinaryOperatorGrammar               	OneOf.match OUT     	+   	[match=<MatchResult 1/6: '-'>, seg="'-2 AS a_calculation'"]
DEBUG      [PD:4  MD:14]	..............ColumnReferenceSegment              	Ref.match OUT       	+   	[match=<MatchResult 1/6: '-'>, seg="'-2 AS a_calculation'"]
INFO       [PD:4  MD:13]	.............ColumnReferenceSegment               	OneOf.match OUT     	+   	[match=<MatchResult 1/6: '-'>, seg="'-2 AS a_calculation'"]
DEBUG      [PD:4  MD:13]	.............ColumnReferenceSegment               	NonCo.match OUT     	    	[match=<MatchResult 0/6: ''>, seg="'-2 AS a_calculation'"]
INFO       [PD:4  MD:12]	............ColumnReferenceSegment                	Delim.match OUT     	    	[match=<MatchResult 0/6: ''>, seg="'-2 AS a_calculation'"]
DEBUG      [PD:4  MD:11]	...........ColumnReferenceSegment                 	Colum.match OUT     	    	[match=<MatchResult 0/6: ''>, seg="'-2 AS a_calculation'"]
DEBUG      [PD:4  MD:11]	...........Expression_D_Grammar                   	Ref.match OUT       	    	[match=<MatchResult 0/6: ''>, seg="'-2 AS a_calculation'"]
DEBUG      [PD:4  MD:12]	............Expression_D_Grammar                  	Ref.match OUT       	    	[match=<MatchResult 0/6: ''>, seg="'-2 AS a_calculation'"]
INFO       [PD:4  MD:13]	.............ArrayLiteralSegment                  	Brack.match OUT     	    	[match=<MatchResult 0/6: ''>, seg="'-2 AS a_calculation'"]
DEBUG      [PD:4  MD:12]	............ArrayLiteralSegment                   	Array.match OUT     	    	[match=<MatchResult 0/6: ''>, seg="'-2 AS a_calculation'"]
DEBUG      [PD:4  MD:12]	............Expression_D_Grammar                  	Ref.match OUT       	    	[match=<MatchResult 0/6: ''>, seg="'-2 AS a_calculation'"]
INFO       [PD:4  MD:11]	...........Expression_D_Grammar                   	Seque.match OUT     	    	[match=<MatchResult 0/6: ''>, seg="'-2 AS a_calculation'"]
INFO       [PD:4  MD:13]	.............DatatypeSegment                      	OneOf.match PRN     	    	[ns=1, ps=2, ms=0, pruned=[<Sequence: [<OneOf: [<Ref: TimeKeywordSegment>, <Ref..., <Bracketed: [<Ref: NumericLiteralSegment..., <Sequence:...]>, <Sequence: [<Ref: DoubleKeywordSegment>, <Ref: PrecisionKeywordSegment>]>], opts=[<Sequence: [<OneOf: [<Sequence: [<OneOf: [<Ref: Char..., <Bracketed: [<OneOf: [<Delimited: [<Ref:..., <Ref: Char...]>]]
INFO       [PD:4  MD:15]	...............DatatypeSegment                    	OneOf.match PRN     	    	[ns=1, ps=1, ms=0, pruned=[<Sequence: [<OneOf: [<Ref: CharacterKeywordSegment>,..., <OneOf: [<Ref: VaryingKeywordSegment>, <...]>], opts=[<Sequence: [<Sequence: [<Ref: SingleIdentifierGramma..., <Ref: DatatypeIdentifierSegment>]>]]
INFO       [PD:4  MD:18]	..................SingleIdentifierGrammar         	OneOf.match PRN     	    	[ns=2, ps=0, ms=0, pruned=[], opts=[<Ref: NakedIdentifierSegment>, <Ref: QuotedIdentifierSegment>]]
DEBUG      [PD:4  MD:19]	...................SingleIdentifierGrammar        	Ref.match OUT       	    	[match=<MatchResult 0/6: ''>, seg="'-2 AS a_calculation'"]
DEBUG      [PD:4  MD:19]	...................SingleIdentifierGrammar        	Ref.match OUT       	    	[match=<MatchResult 0/6: ''>, seg="'-2 AS a_calculation'"]
INFO       [PD:4  MD:18]	..................SingleIdentifierGrammar         	OneOf.match OUT     	    	[match=<MatchResult 0/6: ''>, seg="'-2 AS a_calculation'"]
DEBUG      [PD:4  MD:18]	..................DatatypeSegment                 	Ref.match OUT       	    	[match=<MatchResult 0/6: ''>, seg="'-2 AS a_calculation'"]
INFO       [PD:4  MD:17]	.................DatatypeSegment                  	Seque.match OUT     	    	[match=<MatchResult 0/6: ''>, seg="'-2 AS a_calculation'"]
DEBUG      [PD:4  MD:17]	.................DatatypeSegment                  	Ref.match OUT       	    	[match=<MatchResult 0/6: ''>, seg="'-2 AS a_calculation'"]
INFO       [PD:4  MD:16]	................DatatypeSegment                   	Seque.match OUT     	    	[match=<MatchResult 0/6: ''>, seg="'-2 AS a_calculation'"]
INFO       [PD:4  MD:15]	...............DatatypeSegment                    	OneOf.match OUT     	    	[match=<MatchResult 0/6: ''>, seg="'-2 AS a_calculation'"]
INFO       [PD:4  MD:14]	..............DatatypeSegment                     	Seque.match OUT     	    	[match=<MatchResult 0/6: ''>, seg="'-2 AS a_calculation'"]
INFO       [PD:4  MD:13]	.............DatatypeSegment                      	OneOf.match OUT     	    	[match=<MatchResult 0/6: ''>, seg="'-2 AS a_calculation'"]
DEBUG      [PD:4  MD:12]	............DatatypeSegment                       	Datat.match OUT     	    	[match=<MatchResult 0/6: ''>, seg="'-2 AS a_calculation'"]
DEBUG      [PD:4  MD:12]	............Expression_D_Grammar                  	Ref.match OUT       	    	[match=<MatchResult 0/6: ''>, seg="'-2 AS a_calculation'"]
INFO       [PD:4  MD:11]	...........Expression_D_Grammar                   	Seque.match OUT     	    	[match=<MatchResult 0/6: ''>, seg="'-2 AS a_calculation'"]
INFO       [PD:4  MD:10]	..........Expression_D_Grammar                    	OneOf.match OUT     	+   	[match=<MatchResult 1/5: '-2'>, seg="'-2 AS a_calculation'"]
INFO       [PD:4  MD:10]	..........Accessor_Grammar                        	AnyNu.match PRN     	    	[ns=0, ps=1, ms=0, pruned=[<Ref: ArrayAccessorSegment>], opts='ALL']
INFO       [PD:4  MD:10]	..........Accessor_Grammar                        	AnyNu.match OUT     	    	[match=<MatchResult 0/3: ''>, seg="'AS a_calculation'"]
DEBUG      [PD:4  MD:10]	..........Expression_D_Grammar                    	Ref.match OUT       	    	[match=<MatchResult 0/3: ''>, seg="'AS a_calculation'"]
INFO       [PD:4  MD:10]	..........Expression_D_Grammar                    	AnyNu.match PRN     	    	[ns=0, ps=1, ms=0, pruned=[<Ref: ShorthandCastSegment>], opts='ALL']
INFO       [PD:4  MD:10]	..........Expression_D_Grammar                    	AnyNu.match OUT     	    	[match=<MatchResult 0/3: ''>, seg="'AS a_calculation'"]
INFO       [PD:4  MD:9 ]	.........Expression_D_Grammar                     	Seque.match OUT     	+   	[match=<MatchResult 1/5: '-2'>, seg="'-2 AS a_calculation'"]
DEBUG      [PD:4  MD:9 ]	.........Expression_C_Grammar                     	Ref.match OUT       	+   	[match=<MatchResult 1/5: '-2'>, seg="'-2 AS a_calculation'"]
INFO       [PD:4  MD:8 ]	........Expression_C_Grammar                      	OneOf.match OUT     	+   	[match=<MatchResult 1/5: '-2'>, seg="'-2 AS a_calculation'"]
DEBUG      [PD:4  MD:8 ]	........Expression_A_Grammar                      	Ref.match OUT       	+   	[match=<MatchResult 1/5: '-2'>, seg="'-2 AS a_calculation'"]
DEBUG      [PD:4  MD:9 ]	.........Expression_A_Grammar                     	Ref.match OUT       	    	[match=<MatchResult 0/3: ''>, seg="'AS a_calculation'"]
INFO       [PD:4  MD:8 ]	........Expression_A_Grammar                      	Seque.match OUT     	    	[match=<MatchResult 0/3: ''>, seg="'AS a_calculation'"]
INFO       [PD:4  MD:7 ]	.......Expression_A_Grammar                       	Seque.match OUT     	+   	[match=<MatchResult 3/7: '/ -2'>, seg="'/ -2 AS a_calculatio...'"]
DEBUG      [PD:4  MD:7 ]	.......Expression_A_Grammar                       	Ref.match OUT       	    	[match=<MatchResult 0/8: ''>, seg="'/ -2 AS a_calculatio...'"]
DEBUG      [PD:4  MD:7 ]	.......Expression_A_Grammar                       	Ref.match OUT       	    	[match=<MatchResult 0/8: ''>, seg="'/ -2 AS a_calculatio...'"]
INFO       [PD:4  MD:6 ]	......Expression_A_Grammar                        	OneOf.match OUT     	+   	[match=<MatchResult 3/7: '/ -2'>, seg="'/ -2 AS a_calculatio...'"]
INFO       [PD:4  MD:5 ]	.....Expression_A_Grammar                         	AnyNu.match PRN     	    	[ns=1, ps=0, ms=0, pruned=[], opts=[<OneOf: [<Sequence: [<OneOf: [<Sequence: [<Ref: N..., <Sequence: [<Ref: NotKeywordSegment [opt..., <Sequence:...]>]]
INFO       [PD:4  MD:6 ]	......Expression_A_Grammar                        	OneOf.match PRN     	    	[ns=3, ps=5, ms=0, pruned=[<Sequence: [<Ref: NotKeywordSegment [opt]>, <Ref: InKeywordSegment>, <Bracketed: [<OneOf: [<Delimited: [<Ref:...]>, <Sequence: [<Ref: NotKeywordSegment [opt]>, <Ref: InKeywordSegment>, <Ref: FunctionSegment>]>, <Sequence: [<Ref: IsKeywordSegment>, <Ref: NotKeywordSegment [opt]>, <Ref: IsClauseGrammar>]>, <Sequence: [<Ref: NotKeywordSegment>, <Ref: Expression_C_Grammar>]>, <Sequence: [<Ref: NotKeywordSegment [opt]>, <Ref: BetweenKeywordSegment>, <Ref: Expression_C_Grammar>, <AnyNumbe...]>], opts=[<Sequence: [<OneOf: [<Sequence: [<Ref: NotKeywordSeg..., <Ref: Expression_C_Grammar>, <Sequence: [<Ref: EscapeKe...]>, <Ref: IsNullGrammar>, <Ref: NotNullGrammar>]]
INFO       [PD:4  MD:8 ]	........Expression_A_Grammar                      	OneOf.match PRN     	    	[ns=1, ps=1, ms=0, pruned=[<Sequence: [<Ref: NotKeywordSegment [opt]>, <Ref: LikeGrammar>]>], opts=[<Sequence: [<Ref: BinaryOperatorGrammar>, <Ref: NotKeywordSegment [opt]>]>]]
INFO       [PD:4  MD:10]	..........BinaryOperatorGrammar                   	OneOf.match PRN     	    	[ns=1, ps=3, ms=0, pruned=[<Ref: ArithmeticBinaryOperatorGrammar>, <Ref: StringBinaryOperatorGrammar>, <Ref: BooleanBinaryOperatorGrammar>], opts=[<Ref: ComparisonOperatorGrammar>]]
INFO       [PD:4  MD:11]	...........ComparisonOperatorGrammar              	OneOf.match PRN     	    	[ns=1, ps=7, ms=0, pruned=[<Ref: EqualsSegment>, <Ref: GreaterThanSegment>, <Ref: LessThanSegment>, <Ref: GreaterThanOrEqualToSegment>, <Ref: LessThanOrEqualToSegment>, <Ref: NotEqualToSegment_a>, <Ref: NotEqualToSegment_b>], opts=[<Ref: LikeOperatorSegment>]]
DEBUG      [PD:4  MD:12]	............ComparisonOperatorGrammar             	Ref.match OUT       	    	[match=<MatchResult 0/3: ''>, seg="'AS a_calculation'"]
INFO       [PD:4  MD:11]	...........ComparisonOperatorGrammar              	OneOf.match OUT     	    	[match=<MatchResult 0/3: ''>, seg="'AS a_calculation'"]
DEBUG      [PD:4  MD:11]	...........BinaryOperatorGrammar                  	Ref.match OUT       	    	[match=<MatchResult 0/3: ''>, seg="'AS a_calculation'"]
INFO       [PD:4  MD:10]	..........BinaryOperatorGrammar                   	OneOf.match OUT     	    	[match=<MatchResult 0/3: ''>, seg="'AS a_calculation'"]
DEBUG      [PD:4  MD:10]	..........Expression_A_Grammar                    	Ref.match OUT       	    	[match=<MatchResult 0/3: ''>, seg="'AS a_calculation'"]
INFO       [PD:4  MD:9 ]	.........Expression_A_Grammar                     	Seque.match OUT     	    	[match=<MatchResult 0/3: ''>, seg="'AS a_calculation'"]
INFO       [PD:4  MD:8 ]	........Expression_A_Grammar                      	OneOf.match OUT     	    	[match=<MatchResult 0/3: ''>, seg="'AS a_calculation'"]
INFO       [PD:4  MD:7 ]	.......Expression_A_Grammar                       	Seque.match OUT     	    	[match=<MatchResult 0/3: ''>, seg="'AS a_calculation'"]
DEBUG      [PD:4  MD:7 ]	.......Expression_A_Grammar                       	Ref.match OUT       	    	[match=<MatchResult 0/3: ''>, seg="'AS a_calculation'"]
DEBUG      [PD:4  MD:7 ]	.......Expression_A_Grammar                       	Ref.match OUT       	    	[match=<MatchResult 0/3: ''>, seg="'AS a_calculation'"]
INFO       [PD:4  MD:6 ]	......Expression_A_Grammar                        	OneOf.match OUT     	    	[match=<MatchResult 0/3: ''>, seg="'AS a_calculation'"]
INFO       [PD:4  MD:5 ]	.....Expression_A_Grammar                         	AnyNu.match OUT     	+   	[match=<MatchResult 7/11: '+ b.val / -2'>, seg="'+ b.val / -2 AS a_ca...'"]
INFO       [PD:4  MD:4 ]	....Expression_A_Grammar                          	Seque.match OUT     	+   	[match=<MatchResult 9/13: 'c.val + b.val / -2'>, seg="'c.val + b.val / -2 A...'"]
DEBUG      [PD:4  MD:4 ]	....ExpressionSegment                             	Ref.match OUT       	+   	[match=<MatchResult 9/13: 'c.val + b.val / -2'>, seg="'c.val + b.val / -2 A...'"]
DEBUG      [PD:4  MD:3 ]	...ExpressionSegment                              	Expre.match OUT     	+   	[match=<MatchResult 1/5: 'c.val + b.val / -2'>, seg="'c.val + b.val / -2 A...'"]
DEBUG      [PD:4  MD:3 ]	...BaseExpressionElementGrammar                   	Ref.match OUT       	+   	[match=<MatchResult 1/5: 'c.val + b.val / -2'>, seg="'c.val + b.val / -2 A...'"]
INFO       [PD:4  MD:2 ]	..BaseExpressionElementGrammar                    	OneOf.match OUT     	+   	[match=<MatchResult 1/5: 'c.val + b.val / -2'>, seg="'c.val + b.val / -2 A...'"]
DEBUG      [PD:4  MD:2 ]	..SelectClauseElementSegment                      	Ref.match OUT       	+   	[match=<MatchResult 1/5: 'c.val + b.val / -2'>, seg="'c.val + b.val / -2 A...'"]
DEBUG      [PD:4  MD:4 ]	....AliasExpressionSegment                        	Ref.match OUT       	+   	[match=<MatchResult 1/3: 'AS'>, seg="'AS a_calculation'"]
INFO       [PD:4  MD:4 ]	....AliasExpressionSegment                        	OneOf.match PRN     	    	[ns=2, ps=0, ms=0, pruned=[], opts=[<Sequence: [<Ref: SingleIdentifierGrammar>, <Bracketed: [<Ref: SingleIdentifierListS...]>, <Ref: QuotedLiteralSegment>]]
INFO       [PD:4  MD:6 ]	......SingleIdentifierGrammar                     	OneOf.match PRN     	    	[ns=2, ps=0, ms=0, pruned=[], opts=[<Ref: NakedIdentifierSegment>, <Ref: QuotedIdentifierSegment>]]
DEBUG      [PD:4  MD:7 ]	.......SingleIdentifierGrammar                    	Ref.match OUT       	++  	[match=<MatchResult 1/1: 'a_calculation'>, seg="'a_calculation'"]
INFO       [PD:4  MD:6 ]	......SingleIdentifierGrammar                     	OneOf.match OUT     	++  	[match=<MatchResult 1/1: 'a_calculation'>, seg="'a_calculation'"]
DEBUG      [PD:4  MD:6 ]	......AliasExpressionSegment                      	Ref.match OUT       	++  	[match=<MatchResult 1/1: 'a_calculation'>, seg="'a_calculation'"]
INFO       [PD:4  MD:5 ]	.....AliasExpressionSegment                       	Seque.match OUT     	++  	[match=<MatchResult 1/1: 'a_calculation'>, seg="'a_calculation'"]
INFO       [PD:4  MD:4 ]	....AliasExpressionSegment                        	OneOf.match OUT     	++  	[match=<MatchResult 1/1: 'a_calculation'>, seg="'a_calculation'"]
INFO       [PD:4  MD:3 ]	...AliasExpressionSegment                         	Seque.match OUT     	++  	[match=<MatchResult 3/3: 'AS a_calculation'>, seg="'AS a_calculation'"]
DEBUG      [PD:4  MD:2 ]	..AliasExpressionSegment                          	Alias.match OUT     	++  	[match=<MatchResult 1/1: 'AS a_calculation'>, seg="'AS a_calculation'"]
DEBUG      [PD:4  MD:2 ]	..SelectClauseElementSegment                      	Ref.match OUT       	++  	[match=<MatchResult 1/1: 'AS a_calculation'>, seg="'AS a_calculation'"]
INFO       [PD:4  MD:1 ]	.SelectClauseElementSegment                       	Seque.match OUT     	++  	[match=<MatchResult 3/3: 'c.val + b.val /...S a_calculation'>, seg="'c.val + b.val / -2 A...'"]
INFO       [PD:4  MD:0 ]	SelectClauseElementSegment                        	OneOf.match OUT     	++  	[match=<MatchResult 3/3: 'c.val + b.val /...S a_calculation'>, seg="'c.val + b.val / -2 A...'"]
DEBUG      SelectClauseElementSegment.parse: Done Parse. Plotting Recursion. Recurse=True
DEBUG      ###
#
# Beginning Parse Depth 5: SelectClauseElementSegment
#
###
Initial Structure:
[L:  9, P:  5]      |select_clause_element:
[L:  9, P:  5]      |    expression:
[L:  9, P:  5]      |        column_reference:
[L:  9, P:  5]      |            identifier:                                       'c'
[L:  9, P:  6]      |            dot:                                              '.'
[L:  9, P:  7]      |            identifier:                                       'val'
[L:  9, P: 10]      |        whitespace:                                           ' '
[L:  9, P: 11]      |        binary_operator:                                      '+'
[L:  9, P: 12]      |        whitespace:                                           ' '
[L:  9, P: 13]      |        column_reference:
[L:  9, P: 13]      |            identifier:                                       'b'
[L:  9, P: 14]      |            dot:                                              '.'
[L:  9, P: 15]      |            identifier:                                       'val'
[L:  9, P: 18]      |        whitespace:                                           ' '
[L:  9, P: 19]      |        binary_operator:                                      '/'
[L:  9, P: 20]      |        whitespace:                                           ' '
[L:  9, P: 21]      |        numeric_literal:
[L:  9, P: 21]      |            binary_operator:                                  '-'
[L:  9, P: 22]      |            literal:                                          '2'
[L:  9, P: 23]      |    whitespace:                                               ' '
[L:  9, P: 24]      |    alias_expression:
[L:  9, P: 24]      |        keyword:                                              'AS'
[L:  9, P: 26]      |        whitespace:                                           ' '
[L:  9, P: 27]      |        identifier:                                           'a_calculation'

INFO       [PD:5] Skipping expansion of <ExpressionSegment: ([L:  9, P:  5])>...
INFO       [PD:5] Skipping expansion of <WhitespaceSegment: ([L:  9, P: 23]) ' '>...
INFO       [PD:5] Skipping expansion of <AliasExpressionSegment: ([L:  9, P: 24])>...
INFO       [PD:3] Skipping expansion of <NewlineSegment: ([L:  9, P: 40]) '\n'>...
INFO       [PD:3] Skipping expansion of <Dedent: ([L: 10, P:  1]) ''>...
INFO       
###
#
# Parse Depth 3. Expanding: FromClauseSegment: 'FROM tbl\nINNER JOIN b ON (tbl.common_id ...'
#
###
DEBUG      [PD:3  MD:1 ]	.FromClauseSegment                                	Ref.match OUT       	+   	[match=<MatchResult 1/31: 'FROM'>, seg="'FROM tbl\\nINNER JOIN ...'"]
DEBUG      [PD:3  MD:2 ]	..FromClauseSegment                               	Delim._look_ahead_match IN	    	[ls=29, seg='tbl\nINNER JOIN b ON ...']
DEBUG      [PD:3  MD:2 ]	..FromClauseSegment                               	Delim._look_ahead_match SI	    	[mq=[], sb=['TBL', '', 'INNER', '', 'JOIN', '', 'B', '', 'ON', '', '(TBL.COMMON_ID', '', 'JOIN', '', 'C', '', 'ON', '', '(TBL.ID', '', 'LEFT', '', 'JOIN', '', 'D', '', 'ON', '', '(TBL.ID']]
DEBUG      [PD:3  MD:2 ]	..FromClauseSegment                               	Delim._look_ahead_match SC	    	[bsm=None]
INFO       [PD:3  MD:4 ]	....FromExpressionSegment                         	OneOf.match PRN     	    	[ns=1, ps=1, ms=0, pruned=[<Ref: MLTableExpressionSegment>], opts=[<Ref: FromExpressionElementSegment>]]
DEBUG      [PD:3  MD:7 ]	.......FromExpressionElementSegment               	Ref.match OUT       	    	[match=<MatchResult 0/29: ''>, seg="'tbl\\nINNER JOIN b ON ...'"]
INFO       [PD:3  MD:7 ]	.......FromExpressionElementSegment               	Optio.match PRN     	    	[ns=1, ps=1, ms=0, pruned=[<Bracketed: [<Ref: TableExpressionSegment>]>], opts=[<Ref: TableExpressionSegment>]]
INFO       [PD:3  MD:9 ]	.........TableExpressionSegment                   	OneOf.match PRN     	    	[ns=3, ps=1, ms=0, pruned=[<Bracketed: [<Ref: SelectableGrammar>]>], opts=[<Ref: BareFunctionSegment>, <Ref: FunctionSegment>, <Ref: TableReferenceSegment>]]
DEBUG      [PD:3  MD:10]	..........TableExpressionSegment                  	Ref.match OUT       	    	[match=<MatchResult 0/29: ''>, seg="'tbl\\nINNER JOIN b ON ...'"]
INFO       [PD:3  MD:11]	...........FunctionSegment                        	OneOf.match PRN     	    	[ns=1, ps=1, ms=0, pruned=[<Sequence: [<Sequence: [<Ref: DateAddFunctionNameSeg...]>], opts=[<Sequence: [<Sequence: [<AnyNumberOf: [<Ref: Functio..., <Ref: PostFunctionGrammar [opt]>]>]]
DEBUG      [PD:3  MD:17]	.................DateAddFunctionNameSegment       	Ref.match OUT       	    	[match=<MatchResult 0/29: ''>, seg="'tbl\\nINNER JOIN b ON ...'"]
INFO       [PD:3  MD:16]	................DateAddFunctionNameSegment        	Seque.match OUT     	    	[match=<MatchResult 0/29: ''>, seg="'tbl\\nINNER JOIN b ON ...'"]
DEBUG      [PD:3  MD:15]	...............DateAddFunctionNameSegment         	DateA.match OUT     	    	[match=<MatchResult 0/29: ''>, seg="'tbl\\nINNER JOIN b ON ...'"]
DEBUG      [PD:3  MD:15]	...............FunctionSegment                    	Ref.match OUT       	    	[match=<MatchResult 0/29: ''>, seg="'tbl\\nINNER JOIN b ON ...'"]
INFO       [PD:3  MD:14]	..............FunctionSegment                     	AnyNu.match PRN     	    	[ns=1, ps=0, ms=0, pruned=[], opts=[<Ref: FunctionNameSegment>]]
INFO       [PD:3  MD:17]	.................FunctionNameSegment              	AnyNu.match PRN     	    	[ns=1, ps=0, ms=0, pruned=[], opts=[<Sequence: [<Ref: SingleIdentifierGrammar>, <Ref: DotSegment>]>]]
INFO       [PD:3  MD:19]	...................SingleIdentifierGrammar        	OneOf.match PRN     	    	[ns=2, ps=0, ms=0, pruned=[], opts=[<Ref: NakedIdentifierSegment>, <Ref: QuotedIdentifierSegment>]]
DEBUG      [PD:3  MD:20]	....................SingleIdentifierGrammar       	Ref.match OUT       	+   	[match=<MatchResult 1/29: 'tbl'>, seg="'tbl\\nINNER JOIN b ON ...'"]
DEBUG      [PD:3  MD:20]	....................SingleIdentifierGrammar       	Ref.match OUT       	    	[match=<MatchResult 0/29: ''>, seg="'tbl\\nINNER JOIN b ON ...'"]
INFO       [PD:3  MD:19]	...................SingleIdentifierGrammar        	OneOf.match OUT     	+   	[match=<MatchResult 1/29: 'tbl'>, seg="'tbl\\nINNER JOIN b ON ...'"]
DEBUG      [PD:3  MD:19]	...................FunctionNameSegment            	Ref.match OUT       	+   	[match=<MatchResult 1/29: 'tbl'>, seg="'tbl\\nINNER JOIN b ON ...'"]
DEBUG      [PD:3  MD:19]	...................FunctionNameSegment            	Ref.match OUT       	    	[match=<MatchResult 0/27: ''>, seg="'INNER JOIN b ON (tbl...'"]
INFO       [PD:3  MD:18]	..................FunctionNameSegment             	Seque.match OUT     	    	[match=<MatchResult 0/29: ''>, seg="'tbl\\nINNER JOIN b ON ...'"]
INFO       [PD:3  MD:17]	.................FunctionNameSegment              	AnyNu.match OUT     	    	[match=<MatchResult 0/29: ''>, seg="'tbl\\nINNER JOIN b ON ...'"]
INFO       [PD:3  MD:17]	.................FunctionNameSegment              	OneOf.match PRN     	    	[ns=2, ps=0, ms=0, pruned=[], opts=[<Ref: FunctionNameIdentifierSegment>, <Ref: QuotedIdentifierSegment>]]
DEBUG      [PD:3  MD:18]	..................FunctionNameSegment             	Ref.match OUT       	+   	[match=<MatchResult 1/29: 'tbl'>, seg="'tbl\\nINNER JOIN b ON ...'"]
DEBUG      [PD:3  MD:18]	..................FunctionNameSegment             	Ref.match OUT       	    	[match=<MatchResult 0/29: ''>, seg="'tbl\\nINNER JOIN b ON ...'"]
INFO       [PD:3  MD:17]	.................FunctionNameSegment              	OneOf.match OUT     	+   	[match=<MatchResult 1/29: 'tbl'>, seg="'tbl\\nINNER JOIN b ON ...'"]
INFO       [PD:3  MD:16]	................FunctionNameSegment               	Seque.match OUT     	+   	[match=<MatchResult 1/29: 'tbl'>, seg="'tbl\\nINNER JOIN b ON ...'"]
DEBUG      [PD:3  MD:15]	...............FunctionNameSegment                	Funct.match OUT     	+   	[match=<MatchResult 1/29: 'tbl'>, seg="'tbl\\nINNER JOIN b ON ...'"]
DEBUG      [PD:3  MD:15]	...............FunctionSegment                    	Ref.match OUT       	+   	[match=<MatchResult 1/29: 'tbl'>, seg="'tbl\\nINNER JOIN b ON ...'"]
INFO       [PD:3  MD:14]	..............FunctionSegment                     	AnyNu.match OUT     	+   	[match=<MatchResult 1/29: 'tbl'>, seg="'tbl\\nINNER JOIN b ON ...'"]
INFO       [PD:3  MD:14]	..............FunctionSegment                     	Brack.match OUT     	    	[match=<MatchResult 0/27: ''>, seg="'INNER JOIN b ON (tbl...'"]
INFO       [PD:3  MD:13]	.............FunctionSegment                      	Seque.match OUT     	    	[match=<MatchResult 0/29: ''>, seg="'tbl\\nINNER JOIN b ON ...'"]
INFO       [PD:3  MD:12]	............FunctionSegment                       	Seque.match OUT     	    	[match=<MatchResult 0/29: ''>, seg="'tbl\\nINNER JOIN b ON ...'"]
INFO       [PD:3  MD:11]	...........FunctionSegment                        	OneOf.match OUT     	    	[match=<MatchResult 0/29: ''>, seg="'tbl\\nINNER JOIN b ON ...'"]
DEBUG      [PD:3  MD:10]	..........FunctionSegment                         	Funct.match OUT     	    	[match=<MatchResult 0/29: ''>, seg="'tbl\\nINNER JOIN b ON ...'"]
DEBUG      [PD:3  MD:10]	..........TableExpressionSegment                  	Ref.match OUT       	    	[match=<MatchResult 0/29: ''>, seg="'tbl\\nINNER JOIN b ON ...'"]
DEBUG      [PD:3  MD:12]	............TableReferenceSegment                 	Delim._look_ahead_match IN	    	[ls=29, seg='tbl\nINNER JOIN b ON ...']
DEBUG      [PD:3  MD:12]	............TableReferenceSegment                 	Delim._look_ahead_match SI	    	[mq=[], sb=['TBL', '', 'INNER', '', 'JOIN', '', 'B', '', 'ON', '', '(TBL.COMMON_ID', '', 'JOIN', '', 'C', '', 'ON', '', '(TBL.ID', '', 'LEFT', '', 'JOIN', '', 'D', '', 'ON', '', '(TBL.ID']]
INFO       [PD:3  MD:12]	............TableReferenceSegment                 	OneOf.match PRN     	    	[ns=1, ps=10, ms=0, pruned=[<Ref: OnKeywordSegment>, <Ref: AsKeywordSegment>, <Ref: UsingKeywordSegment>, <Ref: CommaSegment>, <Ref: CastOperatorSegment>, <Ref: StartSquareBracketSegment>, <Ref: StartBracketSegment>, <Ref: ColonSegment>, <Ref: DelimiterSegment>, <class 'sqlfluff.core.parser.segments.base.BracketedSegment'>], opts=[<Ref: BinaryOperatorGrammar>]]
INFO       [PD:3  MD:13]	.............BinaryOperatorGrammar                	OneOf.match PRN     	    	[ns=1, ps=3, ms=0, pruned=[<Ref: ArithmeticBinaryOperatorGrammar>, <Ref: StringBinaryOperatorGrammar>, <Ref: BooleanBinaryOperatorGrammar>], opts=[<Ref: ComparisonOperatorGrammar>]]
INFO       [PD:3  MD:14]	..............ComparisonOperatorGrammar           	OneOf.match PRN     	    	[ns=1, ps=7, ms=0, pruned=[<Ref: EqualsSegment>, <Ref: GreaterThanSegment>, <Ref: LessThanSegment>, <Ref: GreaterThanOrEqualToSegment>, <Ref: LessThanOrEqualToSegment>, <Ref: NotEqualToSegment_a>, <Ref: NotEqualToSegment_b>], opts=[<Ref: LikeOperatorSegment>]]
DEBUG      [PD:3  MD:15]	...............ComparisonOperatorGrammar          	Ref.match OUT       	    	[match=<MatchResult 0/29: ''>, seg="'tbl\\nINNER JOIN b ON ...'"]
INFO       [PD:3  MD:14]	..............ComparisonOperatorGrammar           	OneOf.match OUT     	    	[match=<MatchResult 0/29: ''>, seg="'tbl\\nINNER JOIN b ON ...'"]
DEBUG      [PD:3  MD:14]	..............BinaryOperatorGrammar               	Ref.match OUT       	    	[match=<MatchResult 0/29: ''>, seg="'tbl\\nINNER JOIN b ON ...'"]
INFO       [PD:3  MD:13]	.............BinaryOperatorGrammar                	OneOf.match OUT     	    	[match=<MatchResult 0/29: ''>, seg="'tbl\\nINNER JOIN b ON ...'"]
DEBUG      [PD:3  MD:13]	.............TableReferenceSegment                	Ref.match OUT       	    	[match=<MatchResult 0/29: ''>, seg="'tbl\\nINNER JOIN b ON ...'"]
INFO       [PD:3  MD:12]	............TableReferenceSegment                 	OneOf.match OUT     	    	[match=<MatchResult 0/29: ''>, seg="'tbl\\nINNER JOIN b ON ...'"]
DEBUG      [PD:3  MD:12]	............TableReferenceSegment                 	NonCo.match OUT     	    	[match=<MatchResult 0/29: ''>, seg="'tbl\\nINNER JOIN b ON ...'"]
INFO       [PD:3  MD:12]	............TableReferenceSegment                 	OneOf.match PRN     	    	[ns=1, ps=10, ms=0, pruned=[<Ref: OnKeywordSegment>, <Ref: AsKeywordSegment>, <Ref: UsingKeywordSegment>, <Ref: CommaSegment>, <Ref: CastOperatorSegment>, <Ref: StartSquareBracketSegment>, <Ref: StartBracketSegment>, <Ref: ColonSegment>, <Ref: DelimiterSegment>, <class 'sqlfluff.core.parser.segments.base.BracketedSegment'>], opts=[<Ref: BinaryOperatorGrammar>]]
INFO       [PD:3  MD:13]	.............BinaryOperatorGrammar                	OneOf.match PRN     	    	[ns=1, ps=3, ms=0, pruned=[<Ref: ArithmeticBinaryOperatorGrammar>, <Ref: StringBinaryOperatorGrammar>, <Ref: BooleanBinaryOperatorGrammar>], opts=[<Ref: ComparisonOperatorGrammar>]]
INFO       [PD:3  MD:14]	..............ComparisonOperatorGrammar           	OneOf.match PRN     	    	[ns=1, ps=7, ms=0, pruned=[<Ref: EqualsSegment>, <Ref: GreaterThanSegment>, <Ref: LessThanSegment>, <Ref: GreaterThanOrEqualToSegment>, <Ref: LessThanOrEqualToSegment>, <Ref: NotEqualToSegment_a>, <Ref: NotEqualToSegment_b>], opts=[<Ref: LikeOperatorSegment>]]
DEBUG      [PD:3  MD:15]	...............ComparisonOperatorGrammar          	Ref.match OUT       	    	[match=<MatchResult 0/28: ''>, seg="'\\nINNER JOIN b ON (tb...'"]
INFO       [PD:3  MD:14]	..............ComparisonOperatorGrammar           	OneOf.match OUT     	    	[match=<MatchResult 0/28: ''>, seg="'\\nINNER JOIN b ON (tb...'"]
DEBUG      [PD:3  MD:14]	..............BinaryOperatorGrammar               	Ref.match OUT       	    	[match=<MatchResult 0/28: ''>, seg="'\\nINNER JOIN b ON (tb...'"]
INFO       [PD:3  MD:13]	.............BinaryOperatorGrammar                	OneOf.match OUT     	    	[match=<MatchResult 0/28: ''>, seg="'\\nINNER JOIN b ON (tb...'"]
DEBUG      [PD:3  MD:13]	.............TableReferenceSegment                	Ref.match OUT       	    	[match=<MatchResult 0/28: ''>, seg="'\\nINNER JOIN b ON (tb...'"]
INFO       [PD:3  MD:12]	............TableReferenceSegment                 	OneOf.match OUT     	    	[match=<MatchResult 0/28: ''>, seg="'\\nINNER JOIN b ON (tb...'"]
DEBUG      [PD:3  MD:12]	............TableReferenceSegment                 	NonCo.match OUT     	+   	[match=<MatchResult 1/28: '\n'>, seg="'\\nINNER JOIN b ON (tb...'"]
INFO       [PD:3  MD:12]	............SingleIdentifierGrammar               	OneOf.match PRN     	    	[ns=2, ps=0, ms=0, pruned=[], opts=[<Ref: NakedIdentifierSegment>, <Ref: QuotedIdentifierSegment>]]
DEBUG      [PD:3  MD:13]	.............SingleIdentifierGrammar              	Ref.match OUT       	++  	[match=<MatchResult 1/1: 'tbl'>, seg="'tbl'"]
INFO       [PD:3  MD:12]	............SingleIdentifierGrammar               	OneOf.match OUT     	++  	[match=<MatchResult 1/1: 'tbl'>, seg="'tbl'"]
DEBUG      [PD:3  MD:12]	............TableReferenceSegment                 	Ref.match OUT       	++  	[match=<MatchResult 1/1: 'tbl'>, seg="'tbl'"]
INFO       [PD:3  MD:11]	...........TableReferenceSegment                  	Delim.match OUT     	+   	[match=<MatchResult 1/29: 'tbl'>, seg="'tbl\\nINNER JOIN b ON ...'"]
DEBUG      [PD:3  MD:10]	..........TableReferenceSegment                   	Table.match OUT     	+   	[match=<MatchResult 1/29: 'tbl'>, seg="'tbl\\nINNER JOIN b ON ...'"]
DEBUG      [PD:3  MD:10]	..........TableExpressionSegment                  	Ref.match OUT       	+   	[match=<MatchResult 1/29: 'tbl'>, seg="'tbl\\nINNER JOIN b ON ...'"]
INFO       [PD:3  MD:9 ]	.........TableExpressionSegment                   	OneOf.match OUT     	+   	[match=<MatchResult 1/29: 'tbl'>, seg="'tbl\\nINNER JOIN b ON ...'"]
DEBUG      [PD:3  MD:8 ]	........TableExpressionSegment                    	Table.match OUT     	+   	[match=<MatchResult 1/29: 'tbl'>, seg="'tbl\\nINNER JOIN b ON ...'"]
DEBUG      [PD:3  MD:8 ]	........FromExpressionElementSegment              	Ref.match OUT       	+   	[match=<MatchResult 1/29: 'tbl'>, seg="'tbl\\nINNER JOIN b ON ...'"]
INFO       [PD:3  MD:7 ]	.......FromExpressionElementSegment               	Optio.match OUT     	+   	[match=<MatchResult 1/29: 'tbl'>, seg="'tbl\\nINNER JOIN b ON ...'"]
DEBUG      [PD:3  MD:8 ]	........FromExpressionElementSegment              	Ref.match OUT       	    	[match=<MatchResult 0/27: ''>, seg="'INNER JOIN b ON (tbl...'"]
INFO       [PD:3  MD:7 ]	.......FromExpressionElementSegment               	Seque.match OUT     	    	[match=<MatchResult 0/27: ''>, seg="'INNER JOIN b ON (tbl...'"]
DEBUG      [PD:3  MD:9 ]	.........AliasExpressionSegment                   	Ref.match OUT       	    	[match=<MatchResult 0/27: ''>, seg="'INNER JOIN b ON (tbl...'"]
INFO       [PD:3  MD:9 ]	.........AliasExpressionSegment                   	OneOf.match PRN     	    	[ns=2, ps=0, ms=0, pruned=[], opts=[<Sequence: [<Ref: SingleIdentifierGrammar>, <Bracketed: [<Ref: SingleIdentifierListS...]>, <Ref: QuotedLiteralSegment>]]
INFO       [PD:3  MD:11]	...........SingleIdentifierGrammar                	OneOf.match PRN     	    	[ns=2, ps=0, ms=0, pruned=[], opts=[<Ref: NakedIdentifierSegment>, <Ref: QuotedIdentifierSegment>]]
DEBUG      [PD:3  MD:12]	............SingleIdentifierGrammar               	Ref.match OUT       	    	[match=<MatchResult 0/27: ''>, seg="'INNER JOIN b ON (tbl...'"]
DEBUG      [PD:3  MD:12]	............SingleIdentifierGrammar               	Ref.match OUT       	    	[match=<MatchResult 0/27: ''>, seg="'INNER JOIN b ON (tbl...'"]
INFO       [PD:3  MD:11]	...........SingleIdentifierGrammar                	OneOf.match OUT     	    	[match=<MatchResult 0/27: ''>, seg="'INNER JOIN b ON (tbl...'"]
DEBUG      [PD:3  MD:11]	...........AliasExpressionSegment                 	Ref.match OUT       	    	[match=<MatchResult 0/27: ''>, seg="'INNER JOIN b ON (tbl...'"]
INFO       [PD:3  MD:10]	..........AliasExpressionSegment                  	Seque.match OUT     	    	[match=<MatchResult 0/27: ''>, seg="'INNER JOIN b ON (tbl...'"]
DEBUG      [PD:3  MD:10]	..........AliasExpressionSegment                  	Ref.match OUT       	    	[match=<MatchResult 0/27: ''>, seg="'INNER JOIN b ON (tbl...'"]
INFO       [PD:3  MD:9 ]	.........AliasExpressionSegment                   	OneOf.match OUT     	    	[match=<MatchResult 0/27: ''>, seg="'INNER JOIN b ON (tbl...'"]
INFO       [PD:3  MD:8 ]	........AliasExpressionSegment                    	Seque.match OUT     	    	[match=<MatchResult 0/27: ''>, seg="'INNER JOIN b ON (tbl...'"]
DEBUG      [PD:3  MD:7 ]	.......AliasExpressionSegment                     	Alias.match OUT     	    	[match=<MatchResult 0/27: ''>, seg="'INNER JOIN b ON (tbl...'"]
DEBUG      [PD:3  MD:7 ]	.......FromExpressionElementSegment               	Ref.match OUT       	    	[match=<MatchResult 0/27: ''>, seg="'INNER JOIN b ON (tbl...'"]
DEBUG      [PD:3  MD:7 ]	.......FromExpressionElementSegment               	Ref.match OUT       	    	[match=<MatchResult 0/27: ''>, seg="'INNER JOIN b ON (tbl...'"]
INFO       [PD:3  MD:6 ]	......FromExpressionElementSegment                	Seque.match OUT     	+   	[match=<MatchResult 1/29: 'tbl'>, seg="'tbl\\nINNER JOIN b ON ...'"]
DEBUG      [PD:3  MD:5 ]	.....FromExpressionElementSegment                 	FromE.match OUT     	+   	[match=<MatchResult 1/29: 'tbl'>, seg="'tbl\\nINNER JOIN b ON ...'"]
DEBUG      [PD:3  MD:5 ]	.....FromExpressionSegment                        	Ref.match OUT       	+   	[match=<MatchResult 1/29: 'tbl'>, seg="'tbl\\nINNER JOIN b ON ...'"]
INFO       [PD:3  MD:4 ]	....FromExpressionSegment                         	OneOf.match OUT     	+   	[match=<MatchResult 1/29: 'tbl'>, seg="'tbl\\nINNER JOIN b ON ...'"]
INFO       [PD:3  MD:4 ]	....FromExpressionSegment                         	Condi.match OUT     	+   	[match=<MatchResult 1/28: ''>, seg="'INNER JOIN b ON (tbl...'"]
INFO       [PD:3  MD:4 ]	....FromExpressionSegment                         	AnyNu.match PRN     	    	[ns=1, ps=0, ms=1, pruned=[], opts=[<Ref: JoinClauseSegment>, <Ref: JoinLikeClauseGrammar>]]
INFO       [PD:3  MD:7 ]	.......JoinClauseSegment                          	OneOf.match PRN     	    	[ns=0, ps=2, ms=1, pruned=[<Ref: CrossKeywordSegment>, <Sequence: [<OneOf: [<Ref: FullKeywordSegment>, <Ref..., <Ref: OuterKeywordSegment [opt]>]>], opts=[<Ref: InnerKeywordSegment>]]
DEBUG      [PD:3  MD:8 ]	........JoinClauseSegment                         	Ref.match OUT       	+   	[match=<MatchResult 1/27: 'INNER'>, seg="'INNER JOIN b ON (tbl...'"]
INFO       [PD:3  MD:7 ]	.......JoinClauseSegment                          	OneOf.match OUT     	+   	[match=<MatchResult 1/27: 'INNER'>, seg="'INNER JOIN b ON (tbl...'"]
DEBUG      [PD:3  MD:8 ]	........JoinKeywords                              	Ref.match OUT       	+   	[match=<MatchResult 1/25: 'JOIN'>, seg="'JOIN b ON (tbl.commo...'"]
INFO       [PD:3  MD:7 ]	.......JoinKeywords                               	Seque.match OUT     	+   	[match=<MatchResult 1/25: 'JOIN'>, seg="'JOIN b ON (tbl.commo...'"]
DEBUG      [PD:3  MD:7 ]	.......JoinClauseSegment                          	Ref.match OUT       	+   	[match=<MatchResult 1/25: 'JOIN'>, seg="'JOIN b ON (tbl.commo...'"]
DEBUG      [PD:3  MD:10]	..........FromExpressionElementSegment            	Ref.match OUT       	    	[match=<MatchResult 0/23: ''>, seg="'b ON (tbl.common_id ...'"]
INFO       [PD:3  MD:10]	..........FromExpressionElementSegment            	Optio.match PRN     	    	[ns=1, ps=1, ms=0, pruned=[<Bracketed: [<Ref: TableExpressionSegment>]>], opts=[<Ref: TableExpressionSegment>]]
INFO       [PD:3  MD:12]	............TableExpressionSegment                	OneOf.match PRN     	    	[ns=3, ps=1, ms=0, pruned=[<Bracketed: [<Ref: SelectableGrammar>]>], opts=[<Ref: BareFunctionSegment>, <Ref: FunctionSegment>, <Ref: TableReferenceSegment>]]
DEBUG      [PD:3  MD:13]	.............TableExpressionSegment               	Ref.match OUT       	    	[match=<MatchResult 0/23: ''>, seg="'b ON (tbl.common_id ...'"]
INFO       [PD:3  MD:14]	..............FunctionSegment                     	OneOf.match PRN     	    	[ns=1, ps=1, ms=0, pruned=[<Sequence: [<Sequence: [<Ref: DateAddFunctionNameSeg...]>], opts=[<Sequence: [<Sequence: [<AnyNumberOf: [<Ref: Functio..., <Ref: PostFunctionGrammar [opt]>]>]]
DEBUG      [PD:3  MD:20]	....................DateAddFunctionNameSegment    	Ref.match OUT       	    	[match=<MatchResult 0/23: ''>, seg="'b ON (tbl.common_id ...'"]
INFO       [PD:3  MD:19]	...................DateAddFunctionNameSegment     	Seque.match OUT     	    	[match=<MatchResult 0/23: ''>, seg="'b ON (tbl.common_id ...'"]
DEBUG      [PD:3  MD:18]	..................DateAddFunctionNameSegment      	DateA.match OUT     	    	[match=<MatchResult 0/23: ''>, seg="'b ON (tbl.common_id ...'"]
DEBUG      [PD:3  MD:18]	..................FunctionSegment                 	Ref.match OUT       	    	[match=<MatchResult 0/23: ''>, seg="'b ON (tbl.common_id ...'"]
INFO       [PD:3  MD:17]	.................FunctionSegment                  	AnyNu.match PRN     	    	[ns=1, ps=0, ms=0, pruned=[], opts=[<Ref: FunctionNameSegment>]]
INFO       [PD:3  MD:20]	....................FunctionNameSegment           	AnyNu.match PRN     	    	[ns=1, ps=0, ms=0, pruned=[], opts=[<Sequence: [<Ref: SingleIdentifierGrammar>, <Ref: DotSegment>]>]]
INFO       [PD:3  MD:22]	......................SingleIdentifierGrammar     	OneOf.match PRN     	    	[ns=2, ps=0, ms=0, pruned=[], opts=[<Ref: NakedIdentifierSegment>, <Ref: QuotedIdentifierSegment>]]
DEBUG      [PD:3  MD:23]	.......................SingleIdentifierGrammar    	Ref.match OUT       	+   	[match=<MatchResult 1/23: 'b'>, seg="'b ON (tbl.common_id ...'"]
DEBUG      [PD:3  MD:23]	.......................SingleIdentifierGrammar    	Ref.match OUT       	    	[match=<MatchResult 0/23: ''>, seg="'b ON (tbl.common_id ...'"]
INFO       [PD:3  MD:22]	......................SingleIdentifierGrammar     	OneOf.match OUT     	+   	[match=<MatchResult 1/23: 'b'>, seg="'b ON (tbl.common_id ...'"]
DEBUG      [PD:3  MD:22]	......................FunctionNameSegment         	Ref.match OUT       	+   	[match=<MatchResult 1/23: 'b'>, seg="'b ON (tbl.common_id ...'"]
DEBUG      [PD:3  MD:22]	......................FunctionNameSegment         	Ref.match OUT       	    	[match=<MatchResult 0/21: ''>, seg="'ON (tbl.common_id = ...'"]
INFO       [PD:3  MD:21]	.....................FunctionNameSegment          	Seque.match OUT     	    	[match=<MatchResult 0/23: ''>, seg="'b ON (tbl.common_id ...'"]
INFO       [PD:3  MD:20]	....................FunctionNameSegment           	AnyNu.match OUT     	    	[match=<MatchResult 0/23: ''>, seg="'b ON (tbl.common_id ...'"]
INFO       [PD:3  MD:20]	....................FunctionNameSegment           	OneOf.match PRN     	    	[ns=2, ps=0, ms=0, pruned=[], opts=[<Ref: FunctionNameIdentifierSegment>, <Ref: QuotedIdentifierSegment>]]
DEBUG      [PD:3  MD:21]	.....................FunctionNameSegment          	Ref.match OUT       	+   	[match=<MatchResult 1/23: 'b'>, seg="'b ON (tbl.common_id ...'"]
DEBUG      [PD:3  MD:21]	.....................FunctionNameSegment          	Ref.match OUT       	    	[match=<MatchResult 0/23: ''>, seg="'b ON (tbl.common_id ...'"]
INFO       [PD:3  MD:20]	....................FunctionNameSegment           	OneOf.match OUT     	+   	[match=<MatchResult 1/23: 'b'>, seg="'b ON (tbl.common_id ...'"]
INFO       [PD:3  MD:19]	...................FunctionNameSegment            	Seque.match OUT     	+   	[match=<MatchResult 1/23: 'b'>, seg="'b ON (tbl.common_id ...'"]
DEBUG      [PD:3  MD:18]	..................FunctionNameSegment             	Funct.match OUT     	+   	[match=<MatchResult 1/23: 'b'>, seg="'b ON (tbl.common_id ...'"]
DEBUG      [PD:3  MD:18]	..................FunctionSegment                 	Ref.match OUT       	+   	[match=<MatchResult 1/23: 'b'>, seg="'b ON (tbl.common_id ...'"]
INFO       [PD:3  MD:17]	.................FunctionSegment                  	AnyNu.match OUT     	+   	[match=<MatchResult 1/23: 'b'>, seg="'b ON (tbl.common_id ...'"]
INFO       [PD:3  MD:17]	.................FunctionSegment                  	Brack.match OUT     	    	[match=<MatchResult 0/21: ''>, seg="'ON (tbl.common_id = ...'"]
INFO       [PD:3  MD:16]	................FunctionSegment                   	Seque.match OUT     	    	[match=<MatchResult 0/23: ''>, seg="'b ON (tbl.common_id ...'"]
INFO       [PD:3  MD:15]	...............FunctionSegment                    	Seque.match OUT     	    	[match=<MatchResult 0/23: ''>, seg="'b ON (tbl.common_id ...'"]
INFO       [PD:3  MD:14]	..............FunctionSegment                     	OneOf.match OUT     	    	[match=<MatchResult 0/23: ''>, seg="'b ON (tbl.common_id ...'"]
DEBUG      [PD:3  MD:13]	.............FunctionSegment                      	Funct.match OUT     	    	[match=<MatchResult 0/23: ''>, seg="'b ON (tbl.common_id ...'"]
DEBUG      [PD:3  MD:13]	.............TableExpressionSegment               	Ref.match OUT       	    	[match=<MatchResult 0/23: ''>, seg="'b ON (tbl.common_id ...'"]
DEBUG      [PD:3  MD:15]	...............TableReferenceSegment              	Delim._look_ahead_match IN	    	[ls=23, seg='b ON (tbl.common_id ...']
DEBUG      [PD:3  MD:15]	...............TableReferenceSegment              	Delim._look_ahead_match SI	    	[mq=[], sb=['B', '', 'ON', '', '(TBL.COMMON_ID', '', 'JOIN', '', 'C', '', 'ON', '', '(TBL.ID', '', 'LEFT', '', 'JOIN', '', 'D', '', 'ON', '', '(TBL.ID']]
INFO       [PD:3  MD:15]	...............TableReferenceSegment              	OneOf.match PRN     	    	[ns=1, ps=10, ms=0, pruned=[<Ref: OnKeywordSegment>, <Ref: AsKeywordSegment>, <Ref: UsingKeywordSegment>, <Ref: CommaSegment>, <Ref: CastOperatorSegment>, <Ref: StartSquareBracketSegment>, <Ref: StartBracketSegment>, <Ref: ColonSegment>, <Ref: DelimiterSegment>, <class 'sqlfluff.core.parser.segments.base.BracketedSegment'>], opts=[<Ref: BinaryOperatorGrammar>]]
INFO       [PD:3  MD:16]	................BinaryOperatorGrammar             	OneOf.match PRN     	    	[ns=1, ps=3, ms=0, pruned=[<Ref: ArithmeticBinaryOperatorGrammar>, <Ref: StringBinaryOperatorGrammar>, <Ref: BooleanBinaryOperatorGrammar>], opts=[<Ref: ComparisonOperatorGrammar>]]
INFO       [PD:3  MD:17]	.................ComparisonOperatorGrammar        	OneOf.match PRN     	    	[ns=1, ps=7, ms=0, pruned=[<Ref: EqualsSegment>, <Ref: GreaterThanSegment>, <Ref: LessThanSegment>, <Ref: GreaterThanOrEqualToSegment>, <Ref: LessThanOrEqualToSegment>, <Ref: NotEqualToSegment_a>, <Ref: NotEqualToSegment_b>], opts=[<Ref: LikeOperatorSegment>]]
DEBUG      [PD:3  MD:18]	..................ComparisonOperatorGrammar       	Ref.match OUT       	    	[match=<MatchResult 0/23: ''>, seg="'b ON (tbl.common_id ...'"]
INFO       [PD:3  MD:17]	.................ComparisonOperatorGrammar        	OneOf.match OUT     	    	[match=<MatchResult 0/23: ''>, seg="'b ON (tbl.common_id ...'"]
DEBUG      [PD:3  MD:17]	.................BinaryOperatorGrammar            	Ref.match OUT       	    	[match=<MatchResult 0/23: ''>, seg="'b ON (tbl.common_id ...'"]
INFO       [PD:3  MD:16]	................BinaryOperatorGrammar             	OneOf.match OUT     	    	[match=<MatchResult 0/23: ''>, seg="'b ON (tbl.common_id ...'"]
DEBUG      [PD:3  MD:16]	................TableReferenceSegment             	Ref.match OUT       	    	[match=<MatchResult 0/23: ''>, seg="'b ON (tbl.common_id ...'"]
INFO       [PD:3  MD:15]	...............TableReferenceSegment              	OneOf.match OUT     	    	[match=<MatchResult 0/23: ''>, seg="'b ON (tbl.common_id ...'"]
DEBUG      [PD:3  MD:15]	...............TableReferenceSegment              	NonCo.match OUT     	    	[match=<MatchResult 0/23: ''>, seg="'b ON (tbl.common_id ...'"]
INFO       [PD:3  MD:15]	...............TableReferenceSegment              	OneOf.match PRN     	    	[ns=1, ps=9, ms=1, pruned=[<Ref: AsKeywordSegment>, <Ref: UsingKeywordSegment>, <Ref: CommaSegment>, <Ref: CastOperatorSegment>, <Ref: StartSquareBracketSegment>, <Ref: StartBracketSegment>, <Ref: ColonSegment>, <Ref: DelimiterSegment>, <class 'sqlfluff.core.parser.segments.base.BracketedSegment'>], opts=[<Ref: OnKeywordSegment>, <Ref: BinaryOperatorGrammar>]]
DEBUG      [PD:3  MD:16]	................TableReferenceSegment             	Ref.match OUT       	    	[match=<MatchResult 0/22: ''>, seg="' ON (tbl.common_id =...'"]
INFO       [PD:3  MD:16]	................BinaryOperatorGrammar             	OneOf.match PRN     	    	[ns=1, ps=3, ms=0, pruned=[<Ref: ArithmeticBinaryOperatorGrammar>, <Ref: StringBinaryOperatorGrammar>, <Ref: BooleanBinaryOperatorGrammar>], opts=[<Ref: ComparisonOperatorGrammar>]]
INFO       [PD:3  MD:17]	.................ComparisonOperatorGrammar        	OneOf.match PRN     	    	[ns=1, ps=7, ms=0, pruned=[<Ref: EqualsSegment>, <Ref: GreaterThanSegment>, <Ref: LessThanSegment>, <Ref: GreaterThanOrEqualToSegment>, <Ref: LessThanOrEqualToSegment>, <Ref: NotEqualToSegment_a>, <Ref: NotEqualToSegment_b>], opts=[<Ref: LikeOperatorSegment>]]
DEBUG      [PD:3  MD:18]	..................ComparisonOperatorGrammar       	Ref.match OUT       	    	[match=<MatchResult 0/22: ''>, seg="' ON (tbl.common_id =...'"]
INFO       [PD:3  MD:17]	.................ComparisonOperatorGrammar        	OneOf.match OUT     	    	[match=<MatchResult 0/22: ''>, seg="' ON (tbl.common_id =...'"]
DEBUG      [PD:3  MD:17]	.................BinaryOperatorGrammar            	Ref.match OUT       	    	[match=<MatchResult 0/22: ''>, seg="' ON (tbl.common_id =...'"]
INFO       [PD:3  MD:16]	................BinaryOperatorGrammar             	OneOf.match OUT     	    	[match=<MatchResult 0/22: ''>, seg="' ON (tbl.common_id =...'"]
DEBUG      [PD:3  MD:16]	................TableReferenceSegment             	Ref.match OUT       	    	[match=<MatchResult 0/22: ''>, seg="' ON (tbl.common_id =...'"]
INFO       [PD:3  MD:15]	...............TableReferenceSegment              	OneOf.match OUT     	    	[match=<MatchResult 0/22: ''>, seg="' ON (tbl.common_id =...'"]
DEBUG      [PD:3  MD:15]	...............TableReferenceSegment              	NonCo.match OUT     	+   	[match=<MatchResult 1/22: ' '>, seg="' ON (tbl.common_id =...'"]
INFO       [PD:3  MD:15]	...............SingleIdentifierGrammar            	OneOf.match PRN     	    	[ns=2, ps=0, ms=0, pruned=[], opts=[<Ref: NakedIdentifierSegment>, <Ref: QuotedIdentifierSegment>]]
DEBUG      [PD:3  MD:16]	................SingleIdentifierGrammar           	Ref.match OUT       	++  	[match=<MatchResult 1/1: 'b'>, seg="'b'"]
INFO       [PD:3  MD:15]	...............SingleIdentifierGrammar            	OneOf.match OUT     	++  	[match=<MatchResult 1/1: 'b'>, seg="'b'"]
DEBUG      [PD:3  MD:15]	...............TableReferenceSegment              	Ref.match OUT       	++  	[match=<MatchResult 1/1: 'b'>, seg="'b'"]
INFO       [PD:3  MD:14]	..............TableReferenceSegment               	Delim.match OUT     	+   	[match=<MatchResult 1/23: 'b'>, seg="'b ON (tbl.common_id ...'"]
DEBUG      [PD:3  MD:13]	.............TableReferenceSegment                	Table.match OUT     	+   	[match=<MatchResult 1/23: 'b'>, seg="'b ON (tbl.common_id ...'"]
DEBUG      [PD:3  MD:13]	.............TableExpressionSegment               	Ref.match OUT       	+   	[match=<MatchResult 1/23: 'b'>, seg="'b ON (tbl.common_id ...'"]
INFO       [PD:3  MD:12]	............TableExpressionSegment                	OneOf.match OUT     	+   	[match=<MatchResult 1/23: 'b'>, seg="'b ON (tbl.common_id ...'"]
DEBUG      [PD:3  MD:11]	...........TableExpressionSegment                 	Table.match OUT     	+   	[match=<MatchResult 1/23: 'b'>, seg="'b ON (tbl.common_id ...'"]
DEBUG      [PD:3  MD:11]	...........FromExpressionElementSegment           	Ref.match OUT       	+   	[match=<MatchResult 1/23: 'b'>, seg="'b ON (tbl.common_id ...'"]
INFO       [PD:3  MD:10]	..........FromExpressionElementSegment            	Optio.match OUT     	+   	[match=<MatchResult 1/23: 'b'>, seg="'b ON (tbl.common_id ...'"]
DEBUG      [PD:3  MD:11]	...........FromExpressionElementSegment           	Ref.match OUT       	    	[match=<MatchResult 0/21: ''>, seg="'ON (tbl.common_id = ...'"]
INFO       [PD:3  MD:10]	..........FromExpressionElementSegment            	Seque.match OUT     	    	[match=<MatchResult 0/21: ''>, seg="'ON (tbl.common_id = ...'"]
DEBUG      [PD:3  MD:12]	............AliasExpressionSegment                	Ref.match OUT       	    	[match=<MatchResult 0/21: ''>, seg="'ON (tbl.common_id = ...'"]
INFO       [PD:3  MD:12]	............AliasExpressionSegment                	OneOf.match PRN     	    	[ns=2, ps=0, ms=0, pruned=[], opts=[<Sequence: [<Ref: SingleIdentifierGrammar>, <Bracketed: [<Ref: SingleIdentifierListS...]>, <Ref: QuotedLiteralSegment>]]
INFO       [PD:3  MD:14]	..............SingleIdentifierGrammar             	OneOf.match PRN     	    	[ns=2, ps=0, ms=0, pruned=[], opts=[<Ref: NakedIdentifierSegment>, <Ref: QuotedIdentifierSegment>]]
DEBUG      [PD:3  MD:15]	...............SingleIdentifierGrammar            	Ref.match OUT       	    	[match=<MatchResult 0/21: ''>, seg="'ON (tbl.common_id = ...'"]
DEBUG      [PD:3  MD:15]	...............SingleIdentifierGrammar            	Ref.match OUT       	    	[match=<MatchResult 0/21: ''>, seg="'ON (tbl.common_id = ...'"]
INFO       [PD:3  MD:14]	..............SingleIdentifierGrammar             	OneOf.match OUT     	    	[match=<MatchResult 0/21: ''>, seg="'ON (tbl.common_id = ...'"]
DEBUG      [PD:3  MD:14]	..............AliasExpressionSegment              	Ref.match OUT       	    	[match=<MatchResult 0/21: ''>, seg="'ON (tbl.common_id = ...'"]
INFO       [PD:3  MD:13]	.............AliasExpressionSegment               	Seque.match OUT     	    	[match=<MatchResult 0/21: ''>, seg="'ON (tbl.common_id = ...'"]
DEBUG      [PD:3  MD:13]	.............AliasExpressionSegment               	Ref.match OUT       	    	[match=<MatchResult 0/21: ''>, seg="'ON (tbl.common_id = ...'"]
INFO       [PD:3  MD:12]	............AliasExpressionSegment                	OneOf.match OUT     	    	[match=<MatchResult 0/21: ''>, seg="'ON (tbl.common_id = ...'"]
INFO       [PD:3  MD:11]	...........AliasExpressionSegment                 	Seque.match OUT     	    	[match=<MatchResult 0/21: ''>, seg="'ON (tbl.common_id = ...'"]
DEBUG      [PD:3  MD:10]	..........AliasExpressionSegment                  	Alias.match OUT     	    	[match=<MatchResult 0/21: ''>, seg="'ON (tbl.common_id = ...'"]
DEBUG      [PD:3  MD:10]	..........FromExpressionElementSegment            	Ref.match OUT       	    	[match=<MatchResult 0/21: ''>, seg="'ON (tbl.common_id = ...'"]
DEBUG      [PD:3  MD:10]	..........FromExpressionElementSegment            	Ref.match OUT       	    	[match=<MatchResult 0/21: ''>, seg="'ON (tbl.common_id = ...'"]
INFO       [PD:3  MD:9 ]	.........FromExpressionElementSegment             	Seque.match OUT     	+   	[match=<MatchResult 1/23: 'b'>, seg="'b ON (tbl.common_id ...'"]
DEBUG      [PD:3  MD:8 ]	........FromExpressionElementSegment              	FromE.match OUT     	+   	[match=<MatchResult 1/23: 'b'>, seg="'b ON (tbl.common_id ...'"]
DEBUG      [PD:3  MD:8 ]	........JoinClauseSegment                         	Ref.match OUT       	+   	[match=<MatchResult 1/23: 'b'>, seg="'b ON (tbl.common_id ...'"]
INFO       [PD:3  MD:8 ]	........JoinClauseSegment                         	OneOf.match PRN     	    	[ns=0, ps=1, ms=1, pruned=[<Sequence: [<Ref: UsingKeywordSegment>, <class 'sqlfluff.core.parser.segments.me..., <Bracketed: [<Delimited: [<...]>], opts=[<Ref: JoinOnConditionSegment>]]
DEBUG      [PD:3  MD:11]	...........JoinOnConditionSegment                 	Ref.match OUT       	+   	[match=<MatchResult 1/21: 'ON'>, seg="'ON (tbl.common_id = ...'"]
INFO       [PD:3  MD:11]	...........JoinOnConditionSegment                 	Optio.match PRN     	    	[ns=1, ps=0, ms=1, pruned=[], opts=[<Bracketed: [<Ref: ExpressionSegment>]>, <Ref: ExpressionSegment>]]
INFO       [PD:3  MD:16]	................Expression_A_Grammar              	OneOf.match PRN     	    	[ns=1, ps=1, ms=0, pruned=[<Sequence: [<OneOf: [<Ref: PositiveSegment>, <Ref: N..., <Ref: Expression_C_Grammar>]>], opts=[<Ref: Expression_C_Grammar>]]
INFO       [PD:3  MD:17]	.................Expression_C_Grammar             	OneOf.match PRN     	    	[ns=1, ps=2, ms=0, pruned=[<Sequence: [<Ref: ExistsKeywordSegment>, <Bracketed: [<Ref: SelectStatementSegmen...]>, <Ref: CaseExpressionSegment>], opts=[<Ref: Expression_D_Grammar>]]
INFO       [PD:3  MD:19]	...................Expression_D_Grammar           	OneOf.match PRN     	    	[ns=6, ps=3, ms=0, pruned=[<Bracketed: [<OneOf: [<Ref: ExpressionSegment>, <Ref:...]>, <Ref: SelectStatementSegment>, <Ref: IntervalExpressionSegment>], opts=[<Ref: BareFunctionSegment>, <Ref: FunctionSegment>, <Ref: LiteralGrammar>, <Ref: ColumnReferenceSegment>, <Sequence: [<Ref: SimpleArrayTypeGrammar [opt]>, <Ref: ArrayLiteralSegment>]>, <Sequence: [<Ref: DatatypeSegment>, <OneOf: [<Ref: QuotedLiteralSegment>, <R...]>]]
DEBUG      [PD:3  MD:20]	....................Expression_D_Grammar          	Ref.match OUT       	    	[match=<MatchResult 0/9: ''>, seg="'tbl.common_id = b.co...'"]
INFO       [PD:3  MD:21]	.....................FunctionSegment              	OneOf.match PRN     	    	[ns=1, ps=1, ms=0, pruned=[<Sequence: [<Sequence: [<Ref: DateAddFunctionNameSeg...]>], opts=[<Sequence: [<Sequence: [<AnyNumberOf: [<Ref: Functio..., <Ref: PostFunctionGrammar [opt]>]>]]
DEBUG      [PD:3  MD:27]	...........................DateAddFunctionNameSegment	Ref.match OUT       	    	[match=<MatchResult 0/9: ''>, seg="'tbl.common_id = b.co...'"]
INFO       [PD:3  MD:26]	..........................DateAddFunctionNameSegment	Seque.match OUT     	    	[match=<MatchResult 0/9: ''>, seg="'tbl.common_id = b.co...'"]
DEBUG      [PD:3  MD:25]	.........................DateAddFunctionNameSegment	DateA.match OUT     	    	[match=<MatchResult 0/9: ''>, seg="'tbl.common_id = b.co...'"]
DEBUG      [PD:3  MD:25]	.........................FunctionSegment          	Ref.match OUT       	    	[match=<MatchResult 0/9: ''>, seg="'tbl.common_id = b.co...'"]
INFO       [PD:3  MD:24]	........................FunctionSegment           	AnyNu.match PRN     	    	[ns=1, ps=0, ms=0, pruned=[], opts=[<Ref: FunctionNameSegment>]]
INFO       [PD:3  MD:27]	...........................FunctionNameSegment    	AnyNu.match PRN     	    	[ns=1, ps=0, ms=0, pruned=[], opts=[<Sequence: [<Ref: SingleIdentifierGrammar>, <Ref: DotSegment>]>]]
INFO       [PD:3  MD:29]	.............................SingleIdentifierGrammar	OneOf.match PRN     	    	[ns=2, ps=0, ms=0, pruned=[], opts=[<Ref: NakedIdentifierSegment>, <Ref: QuotedIdentifierSegment>]]
DEBUG      [PD:3  MD:30]	..............................SingleIdentifierGrammar	Ref.match OUT       	+   	[match=<MatchResult 1/9: 'tbl'>, seg="'tbl.common_id = b.co...'"]
DEBUG      [PD:3  MD:30]	..............................SingleIdentifierGrammar	Ref.match OUT       	    	[match=<MatchResult 0/9: ''>, seg="'tbl.common_id = b.co...'"]
INFO       [PD:3  MD:29]	.............................SingleIdentifierGrammar	OneOf.match OUT     	+   	[match=<MatchResult 1/9: 'tbl'>, seg="'tbl.common_id = b.co...'"]
DEBUG      [PD:3  MD:29]	.............................FunctionNameSegment  	Ref.match OUT       	+   	[match=<MatchResult 1/9: 'tbl'>, seg="'tbl.common_id = b.co...'"]
DEBUG      [PD:3  MD:29]	.............................FunctionNameSegment  	Ref.match OUT       	+   	[match=<MatchResult 1/8: '.'>, seg="'.common_id = b.commo...'"]
INFO       [PD:3  MD:28]	............................FunctionNameSegment   	Seque.match OUT     	+   	[match=<MatchResult 2/9: 'tbl.'>, seg="'tbl.common_id = b.co...'"]
INFO       [PD:3  MD:27]	...........................FunctionNameSegment    	AnyNu.match PRN     	    	[ns=1, ps=0, ms=0, pruned=[], opts=[<Sequence: [<Ref: SingleIdentifierGrammar>, <Ref: DotSegment>]>]]
INFO       [PD:3  MD:29]	.............................SingleIdentifierGrammar	OneOf.match PRN     	    	[ns=2, ps=0, ms=0, pruned=[], opts=[<Ref: NakedIdentifierSegment>, <Ref: QuotedIdentifierSegment>]]
DEBUG      [PD:3  MD:30]	..............................SingleIdentifierGrammar	Ref.match OUT       	+   	[match=<MatchResult 1/7: 'common_id'>, seg="'common_id = b.common...'"]
DEBUG      [PD:3  MD:30]	..............................SingleIdentifierGrammar	Ref.match OUT       	    	[match=<MatchResult 0/7: ''>, seg="'common_id = b.common...'"]
INFO       [PD:3  MD:29]	.............................SingleIdentifierGrammar	OneOf.match OUT     	+   	[match=<MatchResult 1/7: 'common_id'>, seg="'common_id = b.common...'"]
DEBUG      [PD:3  MD:29]	.............................FunctionNameSegment  	Ref.match OUT       	+   	[match=<MatchResult 1/7: 'common_id'>, seg="'common_id = b.common...'"]
DEBUG      [PD:3  MD:29]	.............................FunctionNameSegment  	Ref.match OUT       	    	[match=<MatchResult 0/5: ''>, seg="'= b.common_id'"]
INFO       [PD:3  MD:28]	............................FunctionNameSegment   	Seque.match OUT     	    	[match=<MatchResult 0/7: ''>, seg="'common_id = b.common...'"]
INFO       [PD:3  MD:27]	...........................FunctionNameSegment    	AnyNu.match OUT     	+   	[match=<MatchResult 2/9: 'tbl.'>, seg="'tbl.common_id = b.co...'"]
INFO       [PD:3  MD:27]	...........................FunctionNameSegment    	OneOf.match PRN     	    	[ns=2, ps=0, ms=0, pruned=[], opts=[<Ref: FunctionNameIdentifierSegment>, <Ref: QuotedIdentifierSegment>]]
DEBUG      [PD:3  MD:28]	............................FunctionNameSegment   	Ref.match OUT       	+   	[match=<MatchResult 1/7: 'common_id'>, seg="'common_id = b.common...'"]
DEBUG      [PD:3  MD:28]	............................FunctionNameSegment   	Ref.match OUT       	    	[match=<MatchResult 0/7: ''>, seg="'common_id = b.common...'"]
INFO       [PD:3  MD:27]	...........................FunctionNameSegment    	OneOf.match OUT     	+   	[match=<MatchResult 1/7: 'common_id'>, seg="'common_id = b.common...'"]
INFO       [PD:3  MD:26]	..........................FunctionNameSegment     	Seque.match OUT     	+   	[match=<MatchResult 3/9: 'tbl.common_id'>, seg="'tbl.common_id = b.co...'"]
DEBUG      [PD:3  MD:25]	.........................FunctionNameSegment      	Funct.match OUT     	+   	[match=<MatchResult 1/7: 'tbl.common_id'>, seg="'tbl.common_id = b.co...'"]
DEBUG      [PD:3  MD:25]	.........................FunctionSegment          	Ref.match OUT       	+   	[match=<MatchResult 1/7: 'tbl.common_id'>, seg="'tbl.common_id = b.co...'"]
INFO       [PD:3  MD:24]	........................FunctionSegment           	AnyNu.match OUT     	+   	[match=<MatchResult 1/7: 'tbl.common_id'>, seg="'tbl.common_id = b.co...'"]
INFO       [PD:3  MD:24]	........................FunctionSegment           	Brack.match OUT     	    	[match=<MatchResult 0/5: ''>, seg="'= b.common_id'"]
INFO       [PD:3  MD:23]	.......................FunctionSegment            	Seque.match OUT     	    	[match=<MatchResult 0/9: ''>, seg="'tbl.common_id = b.co...'"]
INFO       [PD:3  MD:22]	......................FunctionSegment             	Seque.match OUT     	    	[match=<MatchResult 0/9: ''>, seg="'tbl.common_id = b.co...'"]
INFO       [PD:3  MD:21]	.....................FunctionSegment              	OneOf.match OUT     	    	[match=<MatchResult 0/9: ''>, seg="'tbl.common_id = b.co...'"]
DEBUG      [PD:3  MD:20]	....................FunctionSegment               	Funct.match OUT     	    	[match=<MatchResult 0/9: ''>, seg="'tbl.common_id = b.co...'"]
DEBUG      [PD:3  MD:20]	....................Expression_D_Grammar          	Ref.match OUT       	    	[match=<MatchResult 0/9: ''>, seg="'tbl.common_id = b.co...'"]
INFO       [PD:3  MD:20]	....................LiteralGrammar                	OneOf.match PRN     	    	[ns=2, ps=4, ms=0, pruned=[<Ref: BooleanLiteralGrammar>, <Ref: QualifiedNumericLiteralSegment>, <Ref: NullLiteralSegment>, <Ref: DateTimeLiteralGrammar>], opts=[<Ref: QuotedLiteralSegment>, <Ref: NumericLiteralSegment>]]
DEBUG      [PD:3  MD:21]	.....................LiteralGrammar               	Ref.match OUT       	    	[match=<MatchResult 0/9: ''>, seg="'tbl.common_id = b.co...'"]
DEBUG      [PD:3  MD:21]	.....................LiteralGrammar               	Ref.match OUT       	    	[match=<MatchResult 0/9: ''>, seg="'tbl.common_id = b.co...'"]
INFO       [PD:3  MD:20]	....................LiteralGrammar                	OneOf.match OUT     	    	[match=<MatchResult 0/9: ''>, seg="'tbl.common_id = b.co...'"]
DEBUG      [PD:3  MD:20]	....................Expression_D_Grammar          	Ref.match OUT       	    	[match=<MatchResult 0/9: ''>, seg="'tbl.common_id = b.co...'"]
DEBUG      [PD:3  MD:22]	......................ColumnReferenceSegment      	Delim._look_ahead_match IN	    	[ls=9, seg='tbl.common_id = b.co...']
DEBUG      [PD:3  MD:22]	......................ColumnReferenceSegment      	Delim._look_ahead_match SI	    	[mq=[(<OneOf: [<Ref: DotSegment>, <Sequence: [<Ref: DotSegment>, <Ref: Dot...]>, 1, '.'), (<OneOf: [<Ref: DotSegment>, <Sequence: [<Ref: DotSegment>, <Ref: Dot...]>, 1, '.'), (<OneOf: [<Ref: DotSegment>, <Sequence: [<Ref: DotSegment>, <Ref: Dot...]>, 7, '.'), (<OneOf: [<Ref: DotSegment>, <Sequence: [<Ref: DotSegment>, <Ref: Dot...]>, 7, '.')], sb=['TBL', '.', 'COMMON_ID', '', '=', '', 'B', '.', 'COMMON_ID']]
INFO       [PD:3  MD:22]	......................ColumnReferenceSegment      	OneOf.match PRN     	    	[ns=0, ps=0, ms=2, pruned=[], opts=[<Ref: DotSegment>, <Sequence: [<Ref: DotSegment>, <Ref: DotSegment>]>]]
DEBUG      [PD:3  MD:23]	.......................ColumnReferenceSegment     	Ref.match OUT       	+   	[match=<MatchResult 1/2: '.'>, seg="'.common_id'"]
DEBUG      [PD:3  MD:24]	........................ColumnReferenceSegment    	Ref.match OUT       	+   	[match=<MatchResult 1/2: '.'>, seg="'.common_id'"]
DEBUG      [PD:3  MD:24]	........................ColumnReferenceSegment    	Ref.match OUT       	    	[match=<MatchResult 0/1: ''>, seg="'common_id'"]
INFO       [PD:3  MD:23]	.......................ColumnReferenceSegment     	Seque.match OUT     	    	[match=<MatchResult 0/2: ''>, seg="'.common_id'"]
INFO       [PD:3  MD:22]	......................ColumnReferenceSegment      	OneOf.match OUT     	+   	[match=<MatchResult 1/2: '.'>, seg="'.common_id'"]
INFO       [PD:3  MD:22]	......................ColumnReferenceSegment      	OneOf.match PRN     	    	[ns=0, ps=0, ms=2, pruned=[], opts=[<Ref: DotSegment>, <Sequence: [<Ref: DotSegment>, <Ref: DotSegment>]>]]
DEBUG      [PD:3  MD:23]	.......................ColumnReferenceSegment     	Ref.match OUT       	+   	[match=<MatchResult 1/2: '.'>, seg="'.common_id'"]
DEBUG      [PD:3  MD:24]	........................ColumnReferenceSegment    	Ref.match OUT       	+   	[match=<MatchResult 1/2: '.'>, seg="'.common_id'"]
DEBUG      [PD:3  MD:24]	........................ColumnReferenceSegment    	Ref.match OUT       	    	[match=<MatchResult 0/1: ''>, seg="'common_id'"]
INFO       [PD:3  MD:23]	.......................ColumnReferenceSegment     	Seque.match OUT     	    	[match=<MatchResult 0/2: ''>, seg="'.common_id'"]
INFO       [PD:3  MD:22]	......................ColumnReferenceSegment      	OneOf.match OUT     	+   	[match=<MatchResult 1/2: '.'>, seg="'.common_id'"]
INFO       [PD:3  MD:22]	......................ColumnReferenceSegment      	OneOf.match PRN     	    	[ns=0, ps=0, ms=2, pruned=[], opts=[<Ref: DotSegment>, <Sequence: [<Ref: DotSegment>, <Ref: DotSegment>]>]]
DEBUG      [PD:3  MD:23]	.......................ColumnReferenceSegment     	Ref.match OUT       	+   	[match=<MatchResult 1/8: '.'>, seg="'.common_id = b.commo...'"]
DEBUG      [PD:3  MD:24]	........................ColumnReferenceSegment    	Ref.match OUT       	+   	[match=<MatchResult 1/8: '.'>, seg="'.common_id = b.commo...'"]
DEBUG      [PD:3  MD:24]	........................ColumnReferenceSegment    	Ref.match OUT       	    	[match=<MatchResult 0/7: ''>, seg="'common_id = b.common...'"]
INFO       [PD:3  MD:23]	.......................ColumnReferenceSegment     	Seque.match OUT     	    	[match=<MatchResult 0/8: ''>, seg="'.common_id = b.commo...'"]
INFO       [PD:3  MD:22]	......................ColumnReferenceSegment      	OneOf.match OUT     	+   	[match=<MatchResult 1/8: '.'>, seg="'.common_id = b.commo...'"]
INFO       [PD:3  MD:22]	......................ColumnReferenceSegment      	OneOf.match PRN     	    	[ns=0, ps=0, ms=2, pruned=[], opts=[<Ref: DotSegment>, <Sequence: [<Ref: DotSegment>, <Ref: DotSegment>]>]]
DEBUG      [PD:3  MD:23]	.......................ColumnReferenceSegment     	Ref.match OUT       	+   	[match=<MatchResult 1/8: '.'>, seg="'.common_id = b.commo...'"]
DEBUG      [PD:3  MD:24]	........................ColumnReferenceSegment    	Ref.match OUT       	+   	[match=<MatchResult 1/8: '.'>, seg="'.common_id = b.commo...'"]
DEBUG      [PD:3  MD:24]	........................ColumnReferenceSegment    	Ref.match OUT       	    	[match=<MatchResult 0/7: ''>, seg="'common_id = b.common...'"]
INFO       [PD:3  MD:23]	.......................ColumnReferenceSegment     	Seque.match OUT     	    	[match=<MatchResult 0/8: ''>, seg="'.common_id = b.commo...'"]
INFO       [PD:3  MD:22]	......................ColumnReferenceSegment      	OneOf.match OUT     	+   	[match=<MatchResult 1/8: '.'>, seg="'.common_id = b.commo...'"]
INFO       [PD:3  MD:22]	......................ColumnReferenceSegment      	OneOf.match PRN     	    	[ns=1, ps=10, ms=0, pruned=[<Ref: OnKeywordSegment>, <Ref: AsKeywordSegment>, <Ref: UsingKeywordSegment>, <Ref: CommaSegment>, <Ref: CastOperatorSegment>, <Ref: StartSquareBracketSegment>, <Ref: StartBracketSegment>, <Ref: ColonSegment>, <Ref: DelimiterSegment>, <class 'sqlfluff.core.parser.segments.base.BracketedSegment'>], opts=[<Ref: BinaryOperatorGrammar>]]
INFO       [PD:3  MD:23]	.......................BinaryOperatorGrammar      	OneOf.match PRN     	    	[ns=1, ps=3, ms=0, pruned=[<Ref: ArithmeticBinaryOperatorGrammar>, <Ref: StringBinaryOperatorGrammar>, <Ref: BooleanBinaryOperatorGrammar>], opts=[<Ref: ComparisonOperatorGrammar>]]
INFO       [PD:3  MD:24]	........................ComparisonOperatorGrammar 	OneOf.match PRN     	    	[ns=1, ps=7, ms=0, pruned=[<Ref: EqualsSegment>, <Ref: GreaterThanSegment>, <Ref: LessThanSegment>, <Ref: GreaterThanOrEqualToSegment>, <Ref: LessThanOrEqualToSegment>, <Ref: NotEqualToSegment_a>, <Ref: NotEqualToSegment_b>], opts=[<Ref: LikeOperatorSegment>]]
DEBUG      [PD:3  MD:25]	.........................ComparisonOperatorGrammar	Ref.match OUT       	    	[match=<MatchResult 0/9: ''>, seg="'tbl.common_id = b.co...'"]
INFO       [PD:3  MD:24]	........................ComparisonOperatorGrammar 	OneOf.match OUT     	    	[match=<MatchResult 0/9: ''>, seg="'tbl.common_id = b.co...'"]
DEBUG      [PD:3  MD:24]	........................BinaryOperatorGrammar     	Ref.match OUT       	    	[match=<MatchResult 0/9: ''>, seg="'tbl.common_id = b.co...'"]
INFO       [PD:3  MD:23]	.......................BinaryOperatorGrammar      	OneOf.match OUT     	    	[match=<MatchResult 0/9: ''>, seg="'tbl.common_id = b.co...'"]
DEBUG      [PD:3  MD:23]	.......................ColumnReferenceSegment     	Ref.match OUT       	    	[match=<MatchResult 0/9: ''>, seg="'tbl.common_id = b.co...'"]
INFO       [PD:3  MD:22]	......................ColumnReferenceSegment      	OneOf.match OUT     	    	[match=<MatchResult 0/9: ''>, seg="'tbl.common_id = b.co...'"]
DEBUG      [PD:3  MD:22]	......................ColumnReferenceSegment      	NonCo.match OUT     	    	[match=<MatchResult 0/9: ''>, seg="'tbl.common_id = b.co...'"]
INFO       [PD:3  MD:22]	......................ColumnReferenceSegment      	OneOf.match PRN     	    	[ns=1, ps=10, ms=0, pruned=[<Ref: OnKeywordSegment>, <Ref: AsKeywordSegment>, <Ref: UsingKeywordSegment>, <Ref: CommaSegment>, <Ref: CastOperatorSegment>, <Ref: StartSquareBracketSegment>, <Ref: StartBracketSegment>, <Ref: ColonSegment>, <Ref: DelimiterSegment>, <class 'sqlfluff.core.parser.segments.base.BracketedSegment'>], opts=[<Ref: BinaryOperatorGrammar>]]
INFO       [PD:3  MD:23]	.......................BinaryOperatorGrammar      	OneOf.match PRN     	    	[ns=1, ps=3, ms=0, pruned=[<Ref: ArithmeticBinaryOperatorGrammar>, <Ref: StringBinaryOperatorGrammar>, <Ref: BooleanBinaryOperatorGrammar>], opts=[<Ref: ComparisonOperatorGrammar>]]
INFO       [PD:3  MD:24]	........................ComparisonOperatorGrammar 	OneOf.match PRN     	    	[ns=1, ps=7, ms=0, pruned=[<Ref: EqualsSegment>, <Ref: GreaterThanSegment>, <Ref: LessThanSegment>, <Ref: GreaterThanOrEqualToSegment>, <Ref: LessThanOrEqualToSegment>, <Ref: NotEqualToSegment_a>, <Ref: NotEqualToSegment_b>], opts=[<Ref: LikeOperatorSegment>]]
DEBUG      [PD:3  MD:25]	.........................ComparisonOperatorGrammar	Ref.match OUT       	    	[match=<MatchResult 0/8: ''>, seg="'.common_id = b.commo...'"]
INFO       [PD:3  MD:24]	........................ComparisonOperatorGrammar 	OneOf.match OUT     	    	[match=<MatchResult 0/8: ''>, seg="'.common_id = b.commo...'"]
DEBUG      [PD:3  MD:24]	........................BinaryOperatorGrammar     	Ref.match OUT       	    	[match=<MatchResult 0/8: ''>, seg="'.common_id = b.commo...'"]
INFO       [PD:3  MD:23]	.......................BinaryOperatorGrammar      	OneOf.match OUT     	    	[match=<MatchResult 0/8: ''>, seg="'.common_id = b.commo...'"]
DEBUG      [PD:3  MD:23]	.......................ColumnReferenceSegment     	Ref.match OUT       	    	[match=<MatchResult 0/8: ''>, seg="'.common_id = b.commo...'"]
INFO       [PD:3  MD:22]	......................ColumnReferenceSegment      	OneOf.match OUT     	    	[match=<MatchResult 0/8: ''>, seg="'.common_id = b.commo...'"]
DEBUG      [PD:3  MD:22]	......................ColumnReferenceSegment      	NonCo.match OUT     	    	[match=<MatchResult 0/8: ''>, seg="'.common_id = b.commo...'"]
INFO       [PD:3  MD:22]	......................SingleIdentifierGrammar     	OneOf.match PRN     	    	[ns=2, ps=0, ms=0, pruned=[], opts=[<Ref: NakedIdentifierSegment>, <Ref: QuotedIdentifierSegment>]]
DEBUG      [PD:3  MD:23]	.......................SingleIdentifierGrammar    	Ref.match OUT       	++  	[match=<MatchResult 1/1: 'tbl'>, seg="'tbl'"]
INFO       [PD:3  MD:22]	......................SingleIdentifierGrammar     	OneOf.match OUT     	++  	[match=<MatchResult 1/1: 'tbl'>, seg="'tbl'"]
DEBUG      [PD:3  MD:22]	......................ColumnReferenceSegment      	Ref.match OUT       	++  	[match=<MatchResult 1/1: 'tbl'>, seg="'tbl'"]
DEBUG      [PD:3  MD:22]	......................ColumnReferenceSegment      	Delim._look_ahead_match IN	    	[ls=7, seg='common_id = b.common...']
DEBUG      [PD:3  MD:22]	......................ColumnReferenceSegment      	Delim._look_ahead_match SI	    	[mq=[(<OneOf: [<Ref: DotSegment>, <Sequence: [<Ref: DotSegment>, <Ref: Dot...]>, 5, '.'), (<OneOf: [<Ref: DotSegment>, <Sequence: [<Ref: DotSegment>, <Ref: Dot...]>, 5, '.')], sb=['COMMON_ID', '', '=', '', 'B', '.', 'COMMON_ID']]
INFO       [PD:3  MD:22]	......................ColumnReferenceSegment      	OneOf.match PRN     	    	[ns=0, ps=0, ms=2, pruned=[], opts=[<Ref: DotSegment>, <Sequence: [<Ref: DotSegment>, <Ref: DotSegment>]>]]
DEBUG      [PD:3  MD:23]	.......................ColumnReferenceSegment     	Ref.match OUT       	+   	[match=<MatchResult 1/2: '.'>, seg="'.common_id'"]
DEBUG      [PD:3  MD:24]	........................ColumnReferenceSegment    	Ref.match OUT       	+   	[match=<MatchResult 1/2: '.'>, seg="'.common_id'"]
DEBUG      [PD:3  MD:24]	........................ColumnReferenceSegment    	Ref.match OUT       	    	[match=<MatchResult 0/1: ''>, seg="'common_id'"]
INFO       [PD:3  MD:23]	.......................ColumnReferenceSegment     	Seque.match OUT     	    	[match=<MatchResult 0/2: ''>, seg="'.common_id'"]
INFO       [PD:3  MD:22]	......................ColumnReferenceSegment      	OneOf.match OUT     	+   	[match=<MatchResult 1/2: '.'>, seg="'.common_id'"]
INFO       [PD:3  MD:22]	......................ColumnReferenceSegment      	OneOf.match PRN     	    	[ns=0, ps=0, ms=2, pruned=[], opts=[<Ref: DotSegment>, <Sequence: [<Ref: DotSegment>, <Ref: DotSegment>]>]]
DEBUG      [PD:3  MD:23]	.......................ColumnReferenceSegment     	Ref.match OUT       	+   	[match=<MatchResult 1/2: '.'>, seg="'.common_id'"]
DEBUG      [PD:3  MD:24]	........................ColumnReferenceSegment    	Ref.match OUT       	+   	[match=<MatchResult 1/2: '.'>, seg="'.common_id'"]
DEBUG      [PD:3  MD:24]	........................ColumnReferenceSegment    	Ref.match OUT       	    	[match=<MatchResult 0/1: ''>, seg="'common_id'"]
INFO       [PD:3  MD:23]	.......................ColumnReferenceSegment     	Seque.match OUT     	    	[match=<MatchResult 0/2: ''>, seg="'.common_id'"]
INFO       [PD:3  MD:22]	......................ColumnReferenceSegment      	OneOf.match OUT     	+   	[match=<MatchResult 1/2: '.'>, seg="'.common_id'"]
INFO       [PD:3  MD:22]	......................ColumnReferenceSegment      	OneOf.match PRN     	    	[ns=1, ps=10, ms=0, pruned=[<Ref: OnKeywordSegment>, <Ref: AsKeywordSegment>, <Ref: UsingKeywordSegment>, <Ref: CommaSegment>, <Ref: CastOperatorSegment>, <Ref: StartSquareBracketSegment>, <Ref: StartBracketSegment>, <Ref: ColonSegment>, <Ref: DelimiterSegment>, <class 'sqlfluff.core.parser.segments.base.BracketedSegment'>], opts=[<Ref: BinaryOperatorGrammar>]]
INFO       [PD:3  MD:23]	.......................BinaryOperatorGrammar      	OneOf.match PRN     	    	[ns=1, ps=3, ms=0, pruned=[<Ref: ArithmeticBinaryOperatorGrammar>, <Ref: StringBinaryOperatorGrammar>, <Ref: BooleanBinaryOperatorGrammar>], opts=[<Ref: ComparisonOperatorGrammar>]]
INFO       [PD:3  MD:24]	........................ComparisonOperatorGrammar 	OneOf.match PRN     	    	[ns=1, ps=7, ms=0, pruned=[<Ref: EqualsSegment>, <Ref: GreaterThanSegment>, <Ref: LessThanSegment>, <Ref: GreaterThanOrEqualToSegment>, <Ref: LessThanOrEqualToSegment>, <Ref: NotEqualToSegment_a>, <Ref: NotEqualToSegment_b>], opts=[<Ref: LikeOperatorSegment>]]
DEBUG      [PD:3  MD:25]	.........................ComparisonOperatorGrammar	Ref.match OUT       	    	[match=<MatchResult 0/7: ''>, seg="'common_id = b.common...'"]
INFO       [PD:3  MD:24]	........................ComparisonOperatorGrammar 	OneOf.match OUT     	    	[match=<MatchResult 0/7: ''>, seg="'common_id = b.common...'"]
DEBUG      [PD:3  MD:24]	........................BinaryOperatorGrammar     	Ref.match OUT       	    	[match=<MatchResult 0/7: ''>, seg="'common_id = b.common...'"]
INFO       [PD:3  MD:23]	.......................BinaryOperatorGrammar      	OneOf.match OUT     	    	[match=<MatchResult 0/7: ''>, seg="'common_id = b.common...'"]
DEBUG      [PD:3  MD:23]	.......................ColumnReferenceSegment     	Ref.match OUT       	    	[match=<MatchResult 0/7: ''>, seg="'common_id = b.common...'"]
INFO       [PD:3  MD:22]	......................ColumnReferenceSegment      	OneOf.match OUT     	    	[match=<MatchResult 0/7: ''>, seg="'common_id = b.common...'"]
DEBUG      [PD:3  MD:22]	......................ColumnReferenceSegment      	NonCo.match OUT     	    	[match=<MatchResult 0/7: ''>, seg="'common_id = b.common...'"]
INFO       [PD:3  MD:22]	......................ColumnReferenceSegment      	OneOf.match PRN     	    	[ns=1, ps=10, ms=0, pruned=[<Ref: OnKeywordSegment>, <Ref: AsKeywordSegment>, <Ref: UsingKeywordSegment>, <Ref: CommaSegment>, <Ref: CastOperatorSegment>, <Ref: StartSquareBracketSegment>, <Ref: StartBracketSegment>, <Ref: ColonSegment>, <Ref: DelimiterSegment>, <class 'sqlfluff.core.parser.segments.base.BracketedSegment'>], opts=[<Ref: BinaryOperatorGrammar>]]
INFO       [PD:3  MD:23]	.......................BinaryOperatorGrammar      	OneOf.match PRN     	    	[ns=1, ps=3, ms=0, pruned=[<Ref: ArithmeticBinaryOperatorGrammar>, <Ref: StringBinaryOperatorGrammar>, <Ref: BooleanBinaryOperatorGrammar>], opts=[<Ref: ComparisonOperatorGrammar>]]
INFO       [PD:3  MD:24]	........................ComparisonOperatorGrammar 	OneOf.match PRN     	    	[ns=1, ps=6, ms=1, pruned=[<Ref: GreaterThanSegment>, <Ref: LessThanSegment>, <Ref: GreaterThanOrEqualToSegment>, <Ref: LessThanOrEqualToSegment>, <Ref: NotEqualToSegment_a>, <Ref: NotEqualToSegment_b>], opts=[<Ref: EqualsSegment>, <Ref: LikeOperatorSegment>]]
DEBUG      [PD:3  MD:25]	.........................ComparisonOperatorGrammar	Ref.match OUT       	    	[match=<MatchResult 0/6: ''>, seg="' = b.common_id'"]
DEBUG      [PD:3  MD:25]	.........................ComparisonOperatorGrammar	Ref.match OUT       	    	[match=<MatchResult 0/6: ''>, seg="' = b.common_id'"]
INFO       [PD:3  MD:24]	........................ComparisonOperatorGrammar 	OneOf.match OUT     	    	[match=<MatchResult 0/6: ''>, seg="' = b.common_id'"]
DEBUG      [PD:3  MD:24]	........................BinaryOperatorGrammar     	Ref.match OUT       	    	[match=<MatchResult 0/6: ''>, seg="' = b.common_id'"]
INFO       [PD:3  MD:23]	.......................BinaryOperatorGrammar      	OneOf.match OUT     	    	[match=<MatchResult 0/6: ''>, seg="' = b.common_id'"]
DEBUG      [PD:3  MD:23]	.......................ColumnReferenceSegment     	Ref.match OUT       	    	[match=<MatchResult 0/6: ''>, seg="' = b.common_id'"]
INFO       [PD:3  MD:22]	......................ColumnReferenceSegment      	OneOf.match OUT     	    	[match=<MatchResult 0/6: ''>, seg="' = b.common_id'"]
DEBUG      [PD:3  MD:22]	......................ColumnReferenceSegment      	NonCo.match OUT     	+   	[match=<MatchResult 1/6: ' '>, seg="' = b.common_id'"]
INFO       [PD:3  MD:22]	......................SingleIdentifierGrammar     	OneOf.match PRN     	    	[ns=2, ps=0, ms=0, pruned=[], opts=[<Ref: NakedIdentifierSegment>, <Ref: QuotedIdentifierSegment>]]
DEBUG      [PD:3  MD:23]	.......................SingleIdentifierGrammar    	Ref.match OUT       	++  	[match=<MatchResult 1/1: 'common_id'>, seg="'common_id'"]
INFO       [PD:3  MD:22]	......................SingleIdentifierGrammar     	OneOf.match OUT     	++  	[match=<MatchResult 1/1: 'common_id'>, seg="'common_id'"]
DEBUG      [PD:3  MD:22]	......................ColumnReferenceSegment      	Ref.match OUT       	++  	[match=<MatchResult 1/1: 'common_id'>, seg="'common_id'"]
INFO       [PD:3  MD:21]	.....................ColumnReferenceSegment       	Delim.match OUT     	+   	[match=<MatchResult 3/9: 'tbl.common_id'>, seg="'tbl.common_id = b.co...'"]
DEBUG      [PD:3  MD:20]	....................ColumnReferenceSegment        	Colum.match OUT     	+   	[match=<MatchResult 1/7: 'tbl.common_id'>, seg="'tbl.common_id = b.co...'"]
DEBUG      [PD:3  MD:20]	....................Expression_D_Grammar          	Ref.match OUT       	+   	[match=<MatchResult 1/7: 'tbl.common_id'>, seg="'tbl.common_id = b.co...'"]
DEBUG      [PD:3  MD:21]	.....................Expression_D_Grammar         	Ref.match OUT       	    	[match=<MatchResult 0/9: ''>, seg="'tbl.common_id = b.co...'"]
INFO       [PD:3  MD:22]	......................ArrayLiteralSegment         	Brack.match OUT     	    	[match=<MatchResult 0/9: ''>, seg="'tbl.common_id = b.co...'"]
DEBUG      [PD:3  MD:21]	.....................ArrayLiteralSegment          	Array.match OUT     	    	[match=<MatchResult 0/9: ''>, seg="'tbl.common_id = b.co...'"]
DEBUG      [PD:3  MD:21]	.....................Expression_D_Grammar         	Ref.match OUT       	    	[match=<MatchResult 0/9: ''>, seg="'tbl.common_id = b.co...'"]
INFO       [PD:3  MD:20]	....................Expression_D_Grammar          	Seque.match OUT     	    	[match=<MatchResult 0/9: ''>, seg="'tbl.common_id = b.co...'"]
INFO       [PD:3  MD:22]	......................DatatypeSegment             	OneOf.match PRN     	    	[ns=1, ps=2, ms=0, pruned=[<Sequence: [<OneOf: [<Ref: TimeKeywordSegment>, <Ref..., <Bracketed: [<Ref: NumericLiteralSegment..., <Sequence:...]>, <Sequence: [<Ref: DoubleKeywordSegment>, <Ref: PrecisionKeywordSegment>]>], opts=[<Sequence: [<OneOf: [<Sequence: [<OneOf: [<Ref: Char..., <Bracketed: [<OneOf: [<Delimited: [<Ref:..., <Ref: Char...]>]]
INFO       [PD:3  MD:24]	........................DatatypeSegment           	OneOf.match PRN     	    	[ns=1, ps=1, ms=0, pruned=[<Sequence: [<OneOf: [<Ref: CharacterKeywordSegment>,..., <OneOf: [<Ref: VaryingKeywordSegment>, <...]>], opts=[<Sequence: [<Sequence: [<Ref: SingleIdentifierGramma..., <Ref: DatatypeIdentifierSegment>]>]]
INFO       [PD:3  MD:27]	...........................SingleIdentifierGrammar	OneOf.match PRN     	    	[ns=2, ps=0, ms=0, pruned=[], opts=[<Ref: NakedIdentifierSegment>, <Ref: QuotedIdentifierSegment>]]
DEBUG      [PD:3  MD:28]	............................SingleIdentifierGrammar	Ref.match OUT       	+   	[match=<MatchResult 1/9: 'tbl'>, seg="'tbl.common_id = b.co...'"]
DEBUG      [PD:3  MD:28]	............................SingleIdentifierGrammar	Ref.match OUT       	    	[match=<MatchResult 0/9: ''>, seg="'tbl.common_id = b.co...'"]
INFO       [PD:3  MD:27]	...........................SingleIdentifierGrammar	OneOf.match OUT     	+   	[match=<MatchResult 1/9: 'tbl'>, seg="'tbl.common_id = b.co...'"]
DEBUG      [PD:3  MD:27]	...........................DatatypeSegment        	Ref.match OUT       	+   	[match=<MatchResult 1/9: 'tbl'>, seg="'tbl.common_id = b.co...'"]
DEBUG      [PD:3  MD:27]	...........................DatatypeSegment        	Ref.match OUT       	+   	[match=<MatchResult 1/8: '.'>, seg="'.common_id = b.commo...'"]
INFO       [PD:3  MD:26]	..........................DatatypeSegment         	Seque.match OUT     	+   	[match=<MatchResult 2/9: 'tbl.'>, seg="'tbl.common_id = b.co...'"]
DEBUG      [PD:3  MD:26]	..........................DatatypeSegment         	Ref.match OUT       	+   	[match=<MatchResult 1/7: 'common_id'>, seg="'common_id = b.common...'"]
INFO       [PD:3  MD:25]	.........................DatatypeSegment          	Seque.match OUT     	+   	[match=<MatchResult 3/9: 'tbl.common_id'>, seg="'tbl.common_id = b.co...'"]
INFO       [PD:3  MD:24]	........................DatatypeSegment           	OneOf.match OUT     	+   	[match=<MatchResult 3/9: 'tbl.common_id'>, seg="'tbl.common_id = b.co...'"]
INFO       [PD:3  MD:24]	........................DatatypeSegment           	Brack.match OUT     	    	[match=<MatchResult 0/5: ''>, seg="'= b.common_id'"]
DEBUG      [PD:3  MD:24]	........................DatatypeSegment           	Ref.match OUT       	    	[match=<MatchResult 0/5: ''>, seg="'= b.common_id'"]
INFO       [PD:3  MD:23]	.......................DatatypeSegment            	Seque.match OUT     	+   	[match=<MatchResult 3/9: 'tbl.common_id'>, seg="'tbl.common_id = b.co...'"]
INFO       [PD:3  MD:22]	......................DatatypeSegment             	OneOf.match OUT     	+   	[match=<MatchResult 3/9: 'tbl.common_id'>, seg="'tbl.common_id = b.co...'"]
DEBUG      [PD:3  MD:21]	.....................DatatypeSegment              	Datat.match OUT     	+   	[match=<MatchResult 1/7: 'tbl.common_id'>, seg="'tbl.common_id = b.co...'"]
DEBUG      [PD:3  MD:21]	.....................Expression_D_Grammar         	Ref.match OUT       	+   	[match=<MatchResult 1/7: 'tbl.common_id'>, seg="'tbl.common_id = b.co...'"]
INFO       [PD:3  MD:21]	.....................Expression_D_Grammar         	OneOf.match PRN     	    	[ns=2, ps=3, ms=0, pruned=[<Ref: BooleanLiteralGrammar>, <Ref: NullLiteralSegment>, <Ref: DateTimeLiteralGrammar>], opts=[<Ref: QuotedLiteralSegment>, <Ref: NumericLiteralSegment>]]
DEBUG      [PD:3  MD:22]	......................Expression_D_Grammar        	Ref.match OUT       	    	[match=<MatchResult 0/5: ''>, seg="'= b.common_id'"]
DEBUG      [PD:3  MD:22]	......................Expression_D_Grammar        	Ref.match OUT       	    	[match=<MatchResult 0/5: ''>, seg="'= b.common_id'"]
INFO       [PD:3  MD:21]	.....................Expression_D_Grammar         	OneOf.match OUT     	    	[match=<MatchResult 0/5: ''>, seg="'= b.common_id'"]
INFO       [PD:3  MD:20]	....................Expression_D_Grammar          	Seque.match OUT     	    	[match=<MatchResult 0/9: ''>, seg="'tbl.common_id = b.co...'"]
INFO       [PD:3  MD:19]	...................Expression_D_Grammar           	OneOf.match OUT     	+   	[match=<MatchResult 1/7: 'tbl.common_id'>, seg="'tbl.common_id = b.co...'"]
INFO       [PD:3  MD:19]	...................Accessor_Grammar               	AnyNu.match PRN     	    	[ns=0, ps=1, ms=0, pruned=[<Ref: ArrayAccessorSegment>], opts='ALL']
INFO       [PD:3  MD:19]	...................Accessor_Grammar               	AnyNu.match OUT     	    	[match=<MatchResult 0/5: ''>, seg="'= b.common_id'"]
DEBUG      [PD:3  MD:19]	...................Expression_D_Grammar           	Ref.match OUT       	    	[match=<MatchResult 0/5: ''>, seg="'= b.common_id'"]
INFO       [PD:3  MD:19]	...................Expression_D_Grammar           	AnyNu.match PRN     	    	[ns=0, ps=1, ms=0, pruned=[<Ref: ShorthandCastSegment>], opts='ALL']
INFO       [PD:3  MD:19]	...................Expression_D_Grammar           	AnyNu.match OUT     	    	[match=<MatchResult 0/5: ''>, seg="'= b.common_id'"]
INFO       [PD:3  MD:18]	..................Expression_D_Grammar            	Seque.match OUT     	+   	[match=<MatchResult 1/7: 'tbl.common_id'>, seg="'tbl.common_id = b.co...'"]
DEBUG      [PD:3  MD:18]	..................Expression_C_Grammar            	Ref.match OUT       	+   	[match=<MatchResult 1/7: 'tbl.common_id'>, seg="'tbl.common_id = b.co...'"]
INFO       [PD:3  MD:17]	.................Expression_C_Grammar             	OneOf.match OUT     	+   	[match=<MatchResult 1/7: 'tbl.common_id'>, seg="'tbl.common_id = b.co...'"]
DEBUG      [PD:3  MD:17]	.................Expression_A_Grammar             	Ref.match OUT       	+   	[match=<MatchResult 1/7: 'tbl.common_id'>, seg="'tbl.common_id = b.co...'"]
INFO       [PD:3  MD:16]	................Expression_A_Grammar              	OneOf.match OUT     	+   	[match=<MatchResult 1/7: 'tbl.common_id'>, seg="'tbl.common_id = b.co...'"]
INFO       [PD:3  MD:16]	................Expression_A_Grammar              	AnyNu.match PRN     	    	[ns=1, ps=0, ms=0, pruned=[], opts=[<OneOf: [<Sequence: [<OneOf: [<Sequence: [<Ref: N..., <Sequence: [<Ref: NotKeywordSegment [opt..., <Sequence:...]>]]
INFO       [PD:3  MD:17]	.................Expression_A_Grammar             	OneOf.match PRN     	    	[ns=3, ps=5, ms=0, pruned=[<Sequence: [<Ref: NotKeywordSegment [opt]>, <Ref: InKeywordSegment>, <Bracketed: [<OneOf: [<Delimited: [<Ref:...]>, <Sequence: [<Ref: NotKeywordSegment [opt]>, <Ref: InKeywordSegment>, <Ref: FunctionSegment>]>, <Sequence: [<Ref: IsKeywordSegment>, <Ref: NotKeywordSegment [opt]>, <Ref: IsClauseGrammar>]>, <Sequence: [<Ref: NotKeywordSegment>, <Ref: Expression_C_Grammar>]>, <Sequence: [<Ref: NotKeywordSegment [opt]>, <Ref: BetweenKeywordSegment>, <Ref: Expression_C_Grammar>, <AnyNumbe...]>], opts=[<Sequence: [<OneOf: [<Sequence: [<Ref: NotKeywordSeg..., <Ref: Expression_C_Grammar>, <Sequence: [<Ref: EscapeKe...]>, <Ref: IsNullGrammar>, <Ref: NotNullGrammar>]]
INFO       [PD:3  MD:19]	...................Expression_A_Grammar           	OneOf.match PRN     	    	[ns=1, ps=1, ms=0, pruned=[<Sequence: [<Ref: NotKeywordSegment [opt]>, <Ref: LikeGrammar>]>], opts=[<Sequence: [<Ref: BinaryOperatorGrammar>, <Ref: NotKeywordSegment [opt]>]>]]
INFO       [PD:3  MD:21]	.....................BinaryOperatorGrammar        	OneOf.match PRN     	    	[ns=1, ps=3, ms=0, pruned=[<Ref: ArithmeticBinaryOperatorGrammar>, <Ref: StringBinaryOperatorGrammar>, <Ref: BooleanBinaryOperatorGrammar>], opts=[<Ref: ComparisonOperatorGrammar>]]
INFO       [PD:3  MD:22]	......................ComparisonOperatorGrammar   	OneOf.match PRN     	    	[ns=1, ps=6, ms=1, pruned=[<Ref: GreaterThanSegment>, <Ref: LessThanSegment>, <Ref: GreaterThanOrEqualToSegment>, <Ref: LessThanOrEqualToSegment>, <Ref: NotEqualToSegment_a>, <Ref: NotEqualToSegment_b>], opts=[<Ref: EqualsSegment>, <Ref: LikeOperatorSegment>]]
DEBUG      [PD:3  MD:23]	.......................ComparisonOperatorGrammar  	Ref.match OUT       	+   	[match=<MatchResult 1/5: '='>, seg="'= b.common_id'"]
DEBUG      [PD:3  MD:23]	.......................ComparisonOperatorGrammar  	Ref.match OUT       	    	[match=<MatchResult 0/5: ''>, seg="'= b.common_id'"]
INFO       [PD:3  MD:22]	......................ComparisonOperatorGrammar   	OneOf.match OUT     	+   	[match=<MatchResult 1/5: '='>, seg="'= b.common_id'"]
DEBUG      [PD:3  MD:22]	......................BinaryOperatorGrammar       	Ref.match OUT       	+   	[match=<MatchResult 1/5: '='>, seg="'= b.common_id'"]
INFO       [PD:3  MD:21]	.....................BinaryOperatorGrammar        	OneOf.match OUT     	+   	[match=<MatchResult 1/5: '='>, seg="'= b.common_id'"]
DEBUG      [PD:3  MD:21]	.....................Expression_A_Grammar         	Ref.match OUT       	+   	[match=<MatchResult 1/5: '='>, seg="'= b.common_id'"]
DEBUG      [PD:3  MD:21]	.....................Expression_A_Grammar         	Ref.match OUT       	    	[match=<MatchResult 0/3: ''>, seg="'b.common_id'"]
INFO       [PD:3  MD:20]	....................Expression_A_Grammar          	Seque.match OUT     	+   	[match=<MatchResult 1/5: '='>, seg="'= b.common_id'"]
INFO       [PD:3  MD:19]	...................Expression_A_Grammar           	OneOf.match OUT     	+   	[match=<MatchResult 1/5: '='>, seg="'= b.common_id'"]
INFO       [PD:3  MD:19]	...................Expression_C_Grammar           	OneOf.match PRN     	    	[ns=1, ps=2, ms=0, pruned=[<Sequence: [<Ref: ExistsKeywordSegment>, <Bracketed: [<Ref: SelectStatementSegmen...]>, <Ref: CaseExpressionSegment>], opts=[<Ref: Expression_D_Grammar>]]
INFO       [PD:3  MD:21]	.....................Expression_D_Grammar         	OneOf.match PRN     	    	[ns=6, ps=3, ms=0, pruned=[<Bracketed: [<OneOf: [<Ref: ExpressionSegment>, <Ref:...]>, <Ref: SelectStatementSegment>, <Ref: IntervalExpressionSegment>], opts=[<Ref: BareFunctionSegment>, <Ref: FunctionSegment>, <Ref: LiteralGrammar>, <Ref: ColumnReferenceSegment>, <Sequence: [<Ref: SimpleArrayTypeGrammar [opt]>, <Ref: ArrayLiteralSegment>]>, <Sequence: [<Ref: DatatypeSegment>, <OneOf: [<Ref: QuotedLiteralSegment>, <R...]>]]
DEBUG      [PD:3  MD:22]	......................Expression_D_Grammar        	Ref.match OUT       	    	[match=<MatchResult 0/3: ''>, seg="'b.common_id'"]
INFO       [PD:3  MD:23]	.......................FunctionSegment            	OneOf.match PRN     	    	[ns=1, ps=1, ms=0, pruned=[<Sequence: [<Sequence: [<Ref: DateAddFunctionNameSeg...]>], opts=[<Sequence: [<Sequence: [<AnyNumberOf: [<Ref: Functio..., <Ref: PostFunctionGrammar [opt]>]>]]
DEBUG      [PD:3  MD:29]	.............................DateAddFunctionNameSegment	Ref.match OUT       	    	[match=<MatchResult 0/3: ''>, seg="'b.common_id'"]
INFO       [PD:3  MD:28]	............................DateAddFunctionNameSegment	Seque.match OUT     	    	[match=<MatchResult 0/3: ''>, seg="'b.common_id'"]
DEBUG      [PD:3  MD:27]	...........................DateAddFunctionNameSegment	DateA.match OUT     	    	[match=<MatchResult 0/3: ''>, seg="'b.common_id'"]
DEBUG      [PD:3  MD:27]	...........................FunctionSegment        	Ref.match OUT       	    	[match=<MatchResult 0/3: ''>, seg="'b.common_id'"]
INFO       [PD:3  MD:26]	..........................FunctionSegment         	AnyNu.match PRN     	    	[ns=1, ps=0, ms=0, pruned=[], opts=[<Ref: FunctionNameSegment>]]
INFO       [PD:3  MD:29]	.............................FunctionNameSegment  	AnyNu.match PRN     	    	[ns=1, ps=0, ms=0, pruned=[], opts=[<Sequence: [<Ref: SingleIdentifierGrammar>, <Ref: DotSegment>]>]]
INFO       [PD:3  MD:31]	...............................SingleIdentifierGrammar	OneOf.match PRN     	    	[ns=2, ps=0, ms=0, pruned=[], opts=[<Ref: NakedIdentifierSegment>, <Ref: QuotedIdentifierSegment>]]
DEBUG      [PD:3  MD:32]	................................SingleIdentifierGrammar	Ref.match OUT       	+   	[match=<MatchResult 1/3: 'b'>, seg="'b.common_id'"]
DEBUG      [PD:3  MD:32]	................................SingleIdentifierGrammar	Ref.match OUT       	    	[match=<MatchResult 0/3: ''>, seg="'b.common_id'"]
INFO       [PD:3  MD:31]	...............................SingleIdentifierGrammar	OneOf.match OUT     	+   	[match=<MatchResult 1/3: 'b'>, seg="'b.common_id'"]
DEBUG      [PD:3  MD:31]	...............................FunctionNameSegment	Ref.match OUT       	+   	[match=<MatchResult 1/3: 'b'>, seg="'b.common_id'"]
DEBUG      [PD:3  MD:31]	...............................FunctionNameSegment	Ref.match OUT       	+   	[match=<MatchResult 1/2: '.'>, seg="'.common_id'"]
INFO       [PD:3  MD:30]	..............................FunctionNameSegment 	Seque.match OUT     	+   	[match=<MatchResult 2/3: 'b.'>, seg="'b.common_id'"]
INFO       [PD:3  MD:29]	.............................FunctionNameSegment  	AnyNu.match PRN     	    	[ns=1, ps=0, ms=0, pruned=[], opts=[<Sequence: [<Ref: SingleIdentifierGrammar>, <Ref: DotSegment>]>]]
INFO       [PD:3  MD:31]	...............................SingleIdentifierGrammar	OneOf.match PRN     	    	[ns=2, ps=0, ms=0, pruned=[], opts=[<Ref: NakedIdentifierSegment>, <Ref: QuotedIdentifierSegment>]]
DEBUG      [PD:3  MD:32]	................................SingleIdentifierGrammar	Ref.match OUT       	++  	[match=<MatchResult 1/1: 'common_id'>, seg="'common_id'"]
INFO       [PD:3  MD:31]	...............................SingleIdentifierGrammar	OneOf.match OUT     	++  	[match=<MatchResult 1/1: 'common_id'>, seg="'common_id'"]
DEBUG      [PD:3  MD:31]	...............................FunctionNameSegment	Ref.match OUT       	++  	[match=<MatchResult 1/1: 'common_id'>, seg="'common_id'"]
INFO       [PD:3  MD:30]	..............................FunctionNameSegment 	Seque.match OUT     	    	[match=<MatchResult 0/1: ''>, seg="'common_id'"]
INFO       [PD:3  MD:29]	.............................FunctionNameSegment  	AnyNu.match OUT     	+   	[match=<MatchResult 2/3: 'b.'>, seg="'b.common_id'"]
INFO       [PD:3  MD:29]	.............................FunctionNameSegment  	OneOf.match PRN     	    	[ns=2, ps=0, ms=0, pruned=[], opts=[<Ref: FunctionNameIdentifierSegment>, <Ref: QuotedIdentifierSegment>]]
DEBUG      [PD:3  MD:30]	..............................FunctionNameSegment 	Ref.match OUT       	++  	[match=<MatchResult 1/1: 'common_id'>, seg="'common_id'"]
INFO       [PD:3  MD:29]	.............................FunctionNameSegment  	OneOf.match OUT     	++  	[match=<MatchResult 1/1: 'common_id'>, seg="'common_id'"]
INFO       [PD:3  MD:28]	............................FunctionNameSegment   	Seque.match OUT     	++  	[match=<MatchResult 3/3: 'b.common_id'>, seg="'b.common_id'"]
DEBUG      [PD:3  MD:27]	...........................FunctionNameSegment    	Funct.match OUT     	++  	[match=<MatchResult 1/1: 'b.common_id'>, seg="'b.common_id'"]
DEBUG      [PD:3  MD:27]	...........................FunctionSegment        	Ref.match OUT       	++  	[match=<MatchResult 1/1: 'b.common_id'>, seg="'b.common_id'"]
INFO       [PD:3  MD:26]	..........................FunctionSegment         	AnyNu.match OUT     	++  	[match=<MatchResult 1/1: 'b.common_id'>, seg="'b.common_id'"]
INFO       [PD:3  MD:25]	.........................FunctionSegment          	Seque.match OUT     	    	[match=<MatchResult 0/3: ''>, seg="'b.common_id'"]
INFO       [PD:3  MD:24]	........................FunctionSegment           	Seque.match OUT     	    	[match=<MatchResult 0/3: ''>, seg="'b.common_id'"]
INFO       [PD:3  MD:23]	.......................FunctionSegment            	OneOf.match OUT     	    	[match=<MatchResult 0/3: ''>, seg="'b.common_id'"]
DEBUG      [PD:3  MD:22]	......................FunctionSegment             	Funct.match OUT     	    	[match=<MatchResult 0/3: ''>, seg="'b.common_id'"]
DEBUG      [PD:3  MD:22]	......................Expression_D_Grammar        	Ref.match OUT       	    	[match=<MatchResult 0/3: ''>, seg="'b.common_id'"]
INFO       [PD:3  MD:22]	......................LiteralGrammar              	OneOf.match PRN     	    	[ns=2, ps=4, ms=0, pruned=[<Ref: BooleanLiteralGrammar>, <Ref: QualifiedNumericLiteralSegment>, <Ref: NullLiteralSegment>, <Ref: DateTimeLiteralGrammar>], opts=[<Ref: QuotedLiteralSegment>, <Ref: NumericLiteralSegment>]]
DEBUG      [PD:3  MD:23]	.......................LiteralGrammar             	Ref.match OUT       	    	[match=<MatchResult 0/3: ''>, seg="'b.common_id'"]
DEBUG      [PD:3  MD:23]	.......................LiteralGrammar             	Ref.match OUT       	    	[match=<MatchResult 0/3: ''>, seg="'b.common_id'"]
INFO       [PD:3  MD:22]	......................LiteralGrammar              	OneOf.match OUT     	    	[match=<MatchResult 0/3: ''>, seg="'b.common_id'"]
DEBUG      [PD:3  MD:22]	......................Expression_D_Grammar        	Ref.match OUT       	    	[match=<MatchResult 0/3: ''>, seg="'b.common_id'"]
DEBUG      [PD:3  MD:24]	........................ColumnReferenceSegment    	Delim._look_ahead_match IN	    	[ls=3, seg='b.common_id']
DEBUG      [PD:3  MD:24]	........................ColumnReferenceSegment    	Delim._look_ahead_match SI	    	[mq=[(<OneOf: [<Ref: DotSegment>, <Sequence: [<Ref: DotSegment>, <Ref: Dot...]>, 1, '.'), (<OneOf: [<Ref: DotSegment>, <Sequence: [<Ref: DotSegment>, <Ref: Dot...]>, 1, '.')], sb=['B', '.', 'COMMON_ID']]
INFO       [PD:3  MD:24]	........................ColumnReferenceSegment    	OneOf.match PRN     	    	[ns=0, ps=0, ms=2, pruned=[], opts=[<Ref: DotSegment>, <Sequence: [<Ref: DotSegment>, <Ref: DotSegment>]>]]
DEBUG      [PD:3  MD:25]	.........................ColumnReferenceSegment   	Ref.match OUT       	+   	[match=<MatchResult 1/2: '.'>, seg="'.common_id'"]
DEBUG      [PD:3  MD:26]	..........................ColumnReferenceSegment  	Ref.match OUT       	+   	[match=<MatchResult 1/2: '.'>, seg="'.common_id'"]
DEBUG      [PD:3  MD:26]	..........................ColumnReferenceSegment  	Ref.match OUT       	    	[match=<MatchResult 0/1: ''>, seg="'common_id'"]
INFO       [PD:3  MD:25]	.........................ColumnReferenceSegment   	Seque.match OUT     	    	[match=<MatchResult 0/2: ''>, seg="'.common_id'"]
INFO       [PD:3  MD:24]	........................ColumnReferenceSegment    	OneOf.match OUT     	+   	[match=<MatchResult 1/2: '.'>, seg="'.common_id'"]
INFO       [PD:3  MD:24]	........................ColumnReferenceSegment    	OneOf.match PRN     	    	[ns=0, ps=0, ms=2, pruned=[], opts=[<Ref: DotSegment>, <Sequence: [<Ref: DotSegment>, <Ref: DotSegment>]>]]
DEBUG      [PD:3  MD:25]	.........................ColumnReferenceSegment   	Ref.match OUT       	+   	[match=<MatchResult 1/2: '.'>, seg="'.common_id'"]
DEBUG      [PD:3  MD:26]	..........................ColumnReferenceSegment  	Ref.match OUT       	+   	[match=<MatchResult 1/2: '.'>, seg="'.common_id'"]
DEBUG      [PD:3  MD:26]	..........................ColumnReferenceSegment  	Ref.match OUT       	    	[match=<MatchResult 0/1: ''>, seg="'common_id'"]
INFO       [PD:3  MD:25]	.........................ColumnReferenceSegment   	Seque.match OUT     	    	[match=<MatchResult 0/2: ''>, seg="'.common_id'"]
INFO       [PD:3  MD:24]	........................ColumnReferenceSegment    	OneOf.match OUT     	+   	[match=<MatchResult 1/2: '.'>, seg="'.common_id'"]
INFO       [PD:3  MD:24]	........................ColumnReferenceSegment    	OneOf.match PRN     	    	[ns=1, ps=10, ms=0, pruned=[<Ref: OnKeywordSegment>, <Ref: AsKeywordSegment>, <Ref: UsingKeywordSegment>, <Ref: CommaSegment>, <Ref: CastOperatorSegment>, <Ref: StartSquareBracketSegment>, <Ref: StartBracketSegment>, <Ref: ColonSegment>, <Ref: DelimiterSegment>, <class 'sqlfluff.core.parser.segments.base.BracketedSegment'>], opts=[<Ref: BinaryOperatorGrammar>]]
INFO       [PD:3  MD:25]	.........................BinaryOperatorGrammar    	OneOf.match PRN     	    	[ns=1, ps=3, ms=0, pruned=[<Ref: ArithmeticBinaryOperatorGrammar>, <Ref: StringBinaryOperatorGrammar>, <Ref: BooleanBinaryOperatorGrammar>], opts=[<Ref: ComparisonOperatorGrammar>]]
INFO       [PD:3  MD:26]	..........................ComparisonOperatorGrammar	OneOf.match PRN     	    	[ns=1, ps=7, ms=0, pruned=[<Ref: EqualsSegment>, <Ref: GreaterThanSegment>, <Ref: LessThanSegment>, <Ref: GreaterThanOrEqualToSegment>, <Ref: LessThanOrEqualToSegment>, <Ref: NotEqualToSegment_a>, <Ref: NotEqualToSegment_b>], opts=[<Ref: LikeOperatorSegment>]]
DEBUG      [PD:3  MD:27]	...........................ComparisonOperatorGrammar	Ref.match OUT       	    	[match=<MatchResult 0/3: ''>, seg="'b.common_id'"]
INFO       [PD:3  MD:26]	..........................ComparisonOperatorGrammar	OneOf.match OUT     	    	[match=<MatchResult 0/3: ''>, seg="'b.common_id'"]
DEBUG      [PD:3  MD:26]	..........................BinaryOperatorGrammar   	Ref.match OUT       	    	[match=<MatchResult 0/3: ''>, seg="'b.common_id'"]
INFO       [PD:3  MD:25]	.........................BinaryOperatorGrammar    	OneOf.match OUT     	    	[match=<MatchResult 0/3: ''>, seg="'b.common_id'"]
DEBUG      [PD:3  MD:25]	.........................ColumnReferenceSegment   	Ref.match OUT       	    	[match=<MatchResult 0/3: ''>, seg="'b.common_id'"]
INFO       [PD:3  MD:24]	........................ColumnReferenceSegment    	OneOf.match OUT     	    	[match=<MatchResult 0/3: ''>, seg="'b.common_id'"]
DEBUG      [PD:3  MD:24]	........................ColumnReferenceSegment    	NonCo.match OUT     	    	[match=<MatchResult 0/3: ''>, seg="'b.common_id'"]
INFO       [PD:3  MD:24]	........................ColumnReferenceSegment    	OneOf.match PRN     	    	[ns=1, ps=10, ms=0, pruned=[<Ref: OnKeywordSegment>, <Ref: AsKeywordSegment>, <Ref: UsingKeywordSegment>, <Ref: CommaSegment>, <Ref: CastOperatorSegment>, <Ref: StartSquareBracketSegment>, <Ref: StartBracketSegment>, <Ref: ColonSegment>, <Ref: DelimiterSegment>, <class 'sqlfluff.core.parser.segments.base.BracketedSegment'>], opts=[<Ref: BinaryOperatorGrammar>]]
INFO       [PD:3  MD:25]	.........................BinaryOperatorGrammar    	OneOf.match PRN     	    	[ns=1, ps=3, ms=0, pruned=[<Ref: ArithmeticBinaryOperatorGrammar>, <Ref: StringBinaryOperatorGrammar>, <Ref: BooleanBinaryOperatorGrammar>], opts=[<Ref: ComparisonOperatorGrammar>]]
INFO       [PD:3  MD:26]	..........................ComparisonOperatorGrammar	OneOf.match PRN     	    	[ns=1, ps=7, ms=0, pruned=[<Ref: EqualsSegment>, <Ref: GreaterThanSegment>, <Ref: LessThanSegment>, <Ref: GreaterThanOrEqualToSegment>, <Ref: LessThanOrEqualToSegment>, <Ref: NotEqualToSegment_a>, <Ref: NotEqualToSegment_b>], opts=[<Ref: LikeOperatorSegment>]]
DEBUG      [PD:3  MD:27]	...........................ComparisonOperatorGrammar	Ref.match OUT       	    	[match=<MatchResult 0/2: ''>, seg="'.common_id'"]
INFO       [PD:3  MD:26]	..........................ComparisonOperatorGrammar	OneOf.match OUT     	    	[match=<MatchResult 0/2: ''>, seg="'.common_id'"]
DEBUG      [PD:3  MD:26]	..........................BinaryOperatorGrammar   	Ref.match OUT       	    	[match=<MatchResult 0/2: ''>, seg="'.common_id'"]
INFO       [PD:3  MD:25]	.........................BinaryOperatorGrammar    	OneOf.match OUT     	    	[match=<MatchResult 0/2: ''>, seg="'.common_id'"]
DEBUG      [PD:3  MD:25]	.........................ColumnReferenceSegment   	Ref.match OUT       	    	[match=<MatchResult 0/2: ''>, seg="'.common_id'"]
INFO       [PD:3  MD:24]	........................ColumnReferenceSegment    	OneOf.match OUT     	    	[match=<MatchResult 0/2: ''>, seg="'.common_id'"]
DEBUG      [PD:3  MD:24]	........................ColumnReferenceSegment    	NonCo.match OUT     	    	[match=<MatchResult 0/2: ''>, seg="'.common_id'"]
INFO       [PD:3  MD:24]	........................SingleIdentifierGrammar   	OneOf.match PRN     	    	[ns=2, ps=0, ms=0, pruned=[], opts=[<Ref: NakedIdentifierSegment>, <Ref: QuotedIdentifierSegment>]]
DEBUG      [PD:3  MD:25]	.........................SingleIdentifierGrammar  	Ref.match OUT       	++  	[match=<MatchResult 1/1: 'b'>, seg="'b'"]
INFO       [PD:3  MD:24]	........................SingleIdentifierGrammar   	OneOf.match OUT     	++  	[match=<MatchResult 1/1: 'b'>, seg="'b'"]
DEBUG      [PD:3  MD:24]	........................ColumnReferenceSegment    	Ref.match OUT       	++  	[match=<MatchResult 1/1: 'b'>, seg="'b'"]
DEBUG      [PD:3  MD:24]	........................ColumnReferenceSegment    	Delim._look_ahead_match IN	    	[ls=1, seg='common_id']
DEBUG      [PD:3  MD:24]	........................ColumnReferenceSegment    	Delim._look_ahead_match SI	    	[mq=[], sb=['COMMON_ID']]
INFO       [PD:3  MD:24]	........................ColumnReferenceSegment    	OneOf.match PRN     	    	[ns=1, ps=10, ms=0, pruned=[<Ref: OnKeywordSegment>, <Ref: AsKeywordSegment>, <Ref: UsingKeywordSegment>, <Ref: CommaSegment>, <Ref: CastOperatorSegment>, <Ref: StartSquareBracketSegment>, <Ref: StartBracketSegment>, <Ref: ColonSegment>, <Ref: DelimiterSegment>, <class 'sqlfluff.core.parser.segments.base.BracketedSegment'>], opts=[<Ref: BinaryOperatorGrammar>]]
INFO       [PD:3  MD:25]	.........................BinaryOperatorGrammar    	OneOf.match PRN     	    	[ns=1, ps=3, ms=0, pruned=[<Ref: ArithmeticBinaryOperatorGrammar>, <Ref: StringBinaryOperatorGrammar>, <Ref: BooleanBinaryOperatorGrammar>], opts=[<Ref: ComparisonOperatorGrammar>]]
INFO       [PD:3  MD:26]	..........................ComparisonOperatorGrammar	OneOf.match PRN     	    	[ns=1, ps=7, ms=0, pruned=[<Ref: EqualsSegment>, <Ref: GreaterThanSegment>, <Ref: LessThanSegment>, <Ref: GreaterThanOrEqualToSegment>, <Ref: LessThanOrEqualToSegment>, <Ref: NotEqualToSegment_a>, <Ref: NotEqualToSegment_b>], opts=[<Ref: LikeOperatorSegment>]]
DEBUG      [PD:3  MD:27]	...........................ComparisonOperatorGrammar	Ref.match OUT       	    	[match=<MatchResult 0/1: ''>, seg="'common_id'"]
INFO       [PD:3  MD:26]	..........................ComparisonOperatorGrammar	OneOf.match OUT     	    	[match=<MatchResult 0/1: ''>, seg="'common_id'"]
DEBUG      [PD:3  MD:26]	..........................BinaryOperatorGrammar   	Ref.match OUT       	    	[match=<MatchResult 0/1: ''>, seg="'common_id'"]
INFO       [PD:3  MD:25]	.........................BinaryOperatorGrammar    	OneOf.match OUT     	    	[match=<MatchResult 0/1: ''>, seg="'common_id'"]
DEBUG      [PD:3  MD:25]	.........................ColumnReferenceSegment   	Ref.match OUT       	    	[match=<MatchResult 0/1: ''>, seg="'common_id'"]
INFO       [PD:3  MD:24]	........................ColumnReferenceSegment    	OneOf.match OUT     	    	[match=<MatchResult 0/1: ''>, seg="'common_id'"]
DEBUG      [PD:3  MD:24]	........................ColumnReferenceSegment    	NonCo.match OUT     	    	[match=<MatchResult 0/1: ''>, seg="'common_id'"]
INFO       [PD:3  MD:24]	........................SingleIdentifierGrammar   	OneOf.match PRN     	    	[ns=2, ps=0, ms=0, pruned=[], opts=[<Ref: NakedIdentifierSegment>, <Ref: QuotedIdentifierSegment>]]
DEBUG      [PD:3  MD:25]	.........................SingleIdentifierGrammar  	Ref.match OUT       	++  	[match=<MatchResult 1/1: 'common_id'>, seg="'common_id'"]
INFO       [PD:3  MD:24]	........................SingleIdentifierGrammar   	OneOf.match OUT     	++  	[match=<MatchResult 1/1: 'common_id'>, seg="'common_id'"]
DEBUG      [PD:3  MD:24]	........................ColumnReferenceSegment    	Ref.match OUT       	++  	[match=<MatchResult 1/1: 'common_id'>, seg="'common_id'"]
INFO       [PD:3  MD:23]	.......................ColumnReferenceSegment     	Delim.match OUT     	++  	[match=<MatchResult 3/3: 'b.common_id'>, seg="'b.common_id'"]
DEBUG      [PD:3  MD:22]	......................ColumnReferenceSegment      	Colum.match OUT     	++  	[match=<MatchResult 1/1: 'b.common_id'>, seg="'b.common_id'"]
DEBUG      [PD:3  MD:22]	......................Expression_D_Grammar        	Ref.match OUT       	++  	[match=<MatchResult 1/1: 'b.common_id'>, seg="'b.common_id'"]
INFO       [PD:3  MD:21]	.....................Expression_D_Grammar         	OneOf.match OUT     	++  	[match=<MatchResult 1/1: 'b.common_id'>, seg="'b.common_id'"]
INFO       [PD:3  MD:20]	....................Expression_D_Grammar          	Seque.match OUT     	++  	[match=<MatchResult 1/1: 'b.common_id'>, seg="'b.common_id'"]
DEBUG      [PD:3  MD:20]	....................Expression_C_Grammar          	Ref.match OUT       	++  	[match=<MatchResult 1/1: 'b.common_id'>, seg="'b.common_id'"]
INFO       [PD:3  MD:19]	...................Expression_C_Grammar           	OneOf.match OUT     	++  	[match=<MatchResult 1/1: 'b.common_id'>, seg="'b.common_id'"]
DEBUG      [PD:3  MD:19]	...................Expression_A_Grammar           	Ref.match OUT       	++  	[match=<MatchResult 1/1: 'b.common_id'>, seg="'b.common_id'"]
INFO       [PD:3  MD:18]	..................Expression_A_Grammar            	Seque.match OUT     	++  	[match=<MatchResult 3/3: '= b.common_id'>, seg="'= b.common_id'"]
INFO       [PD:3  MD:17]	.................Expression_A_Grammar             	OneOf.match OUT     	++  	[match=<MatchResult 3/3: '= b.common_id'>, seg="'= b.common_id'"]
INFO       [PD:3  MD:16]	................Expression_A_Grammar              	AnyNu.match OUT     	++  	[match=<MatchResult 3/3: '= b.common_id'>, seg="'= b.common_id'"]
INFO       [PD:3  MD:15]	...............Expression_A_Grammar               	Seque.match OUT     	++  	[match=<MatchResult 5/5: 'tbl.common_id = b.common_id'>, seg="'tbl.common_id = b.co...'"]
DEBUG      [PD:3  MD:15]	...............ExpressionSegment                  	Ref.match OUT       	++  	[match=<MatchResult 5/5: 'tbl.common_id = b.common_id'>, seg="'tbl.common_id = b.co...'"]
DEBUG      [PD:3  MD:14]	..............ExpressionSegment                   	Expre.match OUT     	++  	[match=<MatchResult 1/1: 'tbl.common_id = b.common_id'>, seg="'tbl.common_id = b.co...'"]
DEBUG      [PD:3  MD:14]	..............JoinOnConditionSegment              	Ref.match OUT       	++  	[match=<MatchResult 1/1: 'tbl.common_id = b.common_id'>, seg="'tbl.common_id = b.co...'"]
INFO       [PD:3  MD:13]	.............JoinOnConditionSegment               	Brack.match OUT     	++  	[match=<MatchResult 1/1: 'tbl.common_id = b.common_id'>, seg="'tbl.common_id = b.co...'"]
INFO       [PD:3  MD:12]	............JoinOnConditionSegment                	Brack.match OUT     	+   	[match=<MatchResult 1/19: '(tbl.common_id = b.common_id)'>, seg="'(tbl.common_id = b.c...'"]
INFO       [PD:3  MD:14]	..............Expression_A_Grammar                	OneOf.match PRN     	    	[ns=1, ps=1, ms=0, pruned=[<Sequence: [<OneOf: [<Ref: PositiveSegment>, <Ref: N..., <Ref: Expression_C_Grammar>]>], opts=[<Ref: Expression_C_Grammar>]]
INFO       [PD:3  MD:15]	...............Expression_C_Grammar               	OneOf.match PRN     	    	[ns=1, ps=2, ms=0, pruned=[<Sequence: [<Ref: ExistsKeywordSegment>, <Bracketed: [<Ref: SelectStatementSegmen...]>, <Ref: CaseExpressionSegment>], opts=[<Ref: Expression_D_Grammar>]]
INFO       [PD:3  MD:17]	.................Expression_D_Grammar             	OneOf.match PRN     	    	[ns=6, ps=2, ms=1, pruned=[<Ref: SelectStatementSegment>, <Ref: IntervalExpressionSegment>], opts=[<Ref: BareFunctionSegment>, <Ref: FunctionSegment>, <Bracketed: [<OneOf: [<Ref: ExpressionSegment>, <Ref:...]>, <Ref: LiteralGrammar>, <Ref: ColumnReferenceSegment>, <Sequence: [<Ref: SimpleArrayTypeGrammar [opt]>, <Ref: ArrayLiteralSegment>]>, <Sequence: [<Ref: DatatypeSegment>, <OneOf: [<Ref: QuotedLiteralSegment>, <R...]>]]
DEBUG      [PD:3  MD:18]	..................Expression_D_Grammar            	Ref.match OUT       	    	[match=<MatchResult 0/19: ''>, seg="'(tbl.common_id = b.c...'"]
INFO       [PD:3  MD:19]	...................FunctionSegment                	OneOf.match PRN     	    	[ns=1, ps=1, ms=0, pruned=[<Sequence: [<Sequence: [<Ref: DateAddFunctionNameSeg...]>], opts=[<Sequence: [<Sequence: [<AnyNumberOf: [<Ref: Functio..., <Ref: PostFunctionGrammar [opt]>]>]]
DEBUG      [PD:3  MD:25]	.........................DateAddFunctionNameSegment	Ref.match OUT       	    	[match=<MatchResult 0/19: ''>, seg="'(tbl.common_id = b.c...'"]
INFO       [PD:3  MD:24]	........................DateAddFunctionNameSegment	Seque.match OUT     	    	[match=<MatchResult 0/19: ''>, seg="'(tbl.common_id = b.c...'"]
DEBUG      [PD:3  MD:23]	.......................DateAddFunctionNameSegment 	DateA.match OUT     	    	[match=<MatchResult 0/19: ''>, seg="'(tbl.common_id = b.c...'"]
DEBUG      [PD:3  MD:23]	.......................FunctionSegment            	Ref.match OUT       	    	[match=<MatchResult 0/19: ''>, seg="'(tbl.common_id = b.c...'"]
INFO       [PD:3  MD:22]	......................FunctionSegment             	AnyNu.match PRN     	    	[ns=1, ps=0, ms=0, pruned=[], opts=[<Ref: FunctionNameSegment>]]
INFO       [PD:3  MD:25]	.........................FunctionNameSegment      	AnyNu.match PRN     	    	[ns=1, ps=0, ms=0, pruned=[], opts=[<Sequence: [<Ref: SingleIdentifierGrammar>, <Ref: DotSegment>]>]]
INFO       [PD:3  MD:27]	...........................SingleIdentifierGrammar	OneOf.match PRN     	    	[ns=2, ps=0, ms=0, pruned=[], opts=[<Ref: NakedIdentifierSegment>, <Ref: QuotedIdentifierSegment>]]
DEBUG      [PD:3  MD:28]	............................SingleIdentifierGrammar	Ref.match OUT       	    	[match=<MatchResult 0/19: ''>, seg="'(tbl.common_id = b.c...'"]
DEBUG      [PD:3  MD:28]	............................SingleIdentifierGrammar	Ref.match OUT       	    	[match=<MatchResult 0/19: ''>, seg="'(tbl.common_id = b.c...'"]
INFO       [PD:3  MD:27]	...........................SingleIdentifierGrammar	OneOf.match OUT     	    	[match=<MatchResult 0/19: ''>, seg="'(tbl.common_id = b.c...'"]
DEBUG      [PD:3  MD:27]	...........................FunctionNameSegment    	Ref.match OUT       	    	[match=<MatchResult 0/19: ''>, seg="'(tbl.common_id = b.c...'"]
INFO       [PD:3  MD:26]	..........................FunctionNameSegment     	Seque.match OUT     	    	[match=<MatchResult 0/19: ''>, seg="'(tbl.common_id = b.c...'"]
INFO       [PD:3  MD:25]	.........................FunctionNameSegment      	AnyNu.match OUT     	    	[match=<MatchResult 0/19: ''>, seg="'(tbl.common_id = b.c...'"]
INFO       [PD:3  MD:25]	.........................FunctionNameSegment      	OneOf.match PRN     	    	[ns=2, ps=0, ms=0, pruned=[], opts=[<Ref: FunctionNameIdentifierSegment>, <Ref: QuotedIdentifierSegment>]]
DEBUG      [PD:3  MD:26]	..........................FunctionNameSegment     	Ref.match OUT       	    	[match=<MatchResult 0/19: ''>, seg="'(tbl.common_id = b.c...'"]
DEBUG      [PD:3  MD:26]	..........................FunctionNameSegment     	Ref.match OUT       	    	[match=<MatchResult 0/19: ''>, seg="'(tbl.common_id = b.c...'"]
INFO       [PD:3  MD:25]	.........................FunctionNameSegment      	OneOf.match OUT     	    	[match=<MatchResult 0/19: ''>, seg="'(tbl.common_id = b.c...'"]
INFO       [PD:3  MD:24]	........................FunctionNameSegment       	Seque.match OUT     	    	[match=<MatchResult 0/19: ''>, seg="'(tbl.common_id = b.c...'"]
DEBUG      [PD:3  MD:23]	.......................FunctionNameSegment        	Funct.match OUT     	    	[match=<MatchResult 0/19: ''>, seg="'(tbl.common_id = b.c...'"]
DEBUG      [PD:3  MD:23]	.......................FunctionSegment            	Ref.match OUT       	    	[match=<MatchResult 0/19: ''>, seg="'(tbl.common_id = b.c...'"]
INFO       [PD:3  MD:22]	......................FunctionSegment             	AnyNu.match OUT     	    	[match=<MatchResult 0/19: ''>, seg="'(tbl.common_id = b.c...'"]
INFO       [PD:3  MD:21]	.....................FunctionSegment              	Seque.match OUT     	    	[match=<MatchResult 0/19: ''>, seg="'(tbl.common_id = b.c...'"]
INFO       [PD:3  MD:20]	....................FunctionSegment               	Seque.match OUT     	    	[match=<MatchResult 0/19: ''>, seg="'(tbl.common_id = b.c...'"]
INFO       [PD:3  MD:19]	...................FunctionSegment                	OneOf.match OUT     	    	[match=<MatchResult 0/19: ''>, seg="'(tbl.common_id = b.c...'"]
DEBUG      [PD:3  MD:18]	..................FunctionSegment                 	Funct.match OUT     	    	[match=<MatchResult 0/19: ''>, seg="'(tbl.common_id = b.c...'"]
DEBUG      [PD:3  MD:18]	..................Expression_D_Grammar            	Ref.match OUT       	    	[match=<MatchResult 0/19: ''>, seg="'(tbl.common_id = b.c...'"]
INFO       [PD:3  MD:20]	....................Expression_D_Grammar          	OneOf.match OUT     	++  	[match=<MatchResult 1/1: 'tbl.common_id = b.common_id'>, seg="'tbl.common_id = b.co...'"]
INFO       [PD:3  MD:19]	...................Expression_D_Grammar           	Brack.match OUT     	++  	[match=<MatchResult 1/1: 'tbl.common_id = b.common_id'>, seg="'tbl.common_id = b.co...'"]
INFO       [PD:3  MD:18]	..................Expression_D_Grammar            	Brack.match OUT     	+   	[match=<MatchResult 1/19: '(tbl.common_id = b.common_id)'>, seg="'(tbl.common_id = b.c...'"]
INFO       [PD:3  MD:18]	..................LiteralGrammar                  	OneOf.match PRN     	    	[ns=2, ps=4, ms=0, pruned=[<Ref: BooleanLiteralGrammar>, <Ref: QualifiedNumericLiteralSegment>, <Ref: NullLiteralSegment>, <Ref: DateTimeLiteralGrammar>], opts=[<Ref: QuotedLiteralSegment>, <Ref: NumericLiteralSegment>]]
DEBUG      [PD:3  MD:19]	...................LiteralGrammar                 	Ref.match OUT       	    	[match=<MatchResult 0/19: ''>, seg="'(tbl.common_id = b.c...'"]
DEBUG      [PD:3  MD:19]	...................LiteralGrammar                 	Ref.match OUT       	    	[match=<MatchResult 0/19: ''>, seg="'(tbl.common_id = b.c...'"]
INFO       [PD:3  MD:18]	..................LiteralGrammar                  	OneOf.match OUT     	    	[match=<MatchResult 0/19: ''>, seg="'(tbl.common_id = b.c...'"]
DEBUG      [PD:3  MD:18]	..................Expression_D_Grammar            	Ref.match OUT       	    	[match=<MatchResult 0/19: ''>, seg="'(tbl.common_id = b.c...'"]
DEBUG      [PD:3  MD:20]	....................ColumnReferenceSegment        	Delim._look_ahead_match IN	    	[ls=19, seg='(tbl.common_id = b.c...']
DEBUG      [PD:3  MD:20]	....................ColumnReferenceSegment        	Delim._look_ahead_match SI	    	[mq=[], sb=['(TBL.COMMON_ID', '', 'JOIN', '', 'C', '', 'ON', '', '(TBL.ID', '', 'LEFT', '', 'JOIN', '', 'D', '', 'ON', '', '(TBL.ID']]
INFO       [PD:3  MD:20]	....................ColumnReferenceSegment        	OneOf.match PRN     	    	[ns=1, ps=8, ms=2, pruned=[<Ref: OnKeywordSegment>, <Ref: AsKeywordSegment>, <Ref: UsingKeywordSegment>, <Ref: CommaSegment>, <Ref: CastOperatorSegment>, <Ref: StartSquareBracketSegment>, <Ref: ColonSegment>, <Ref: DelimiterSegment>], opts=[<Ref: StartBracketSegment>, <Ref: BinaryOperatorGrammar>, <class 'sqlfluff.core.parser.segments.base.BracketedSegment'>]]
DEBUG      [PD:3  MD:21]	.....................ColumnReferenceSegment       	Ref.match OUT       	    	[match=<MatchResult 0/19: ''>, seg="'(tbl.common_id = b.c...'"]
INFO       [PD:3  MD:21]	.....................BinaryOperatorGrammar        	OneOf.match PRN     	    	[ns=1, ps=3, ms=0, pruned=[<Ref: ArithmeticBinaryOperatorGrammar>, <Ref: StringBinaryOperatorGrammar>, <Ref: BooleanBinaryOperatorGrammar>], opts=[<Ref: ComparisonOperatorGrammar>]]
INFO       [PD:3  MD:22]	......................ComparisonOperatorGrammar   	OneOf.match PRN     	    	[ns=1, ps=7, ms=0, pruned=[<Ref: EqualsSegment>, <Ref: GreaterThanSegment>, <Ref: LessThanSegment>, <Ref: GreaterThanOrEqualToSegment>, <Ref: LessThanOrEqualToSegment>, <Ref: NotEqualToSegment_a>, <Ref: NotEqualToSegment_b>], opts=[<Ref: LikeOperatorSegment>]]
DEBUG      [PD:3  MD:23]	.......................ComparisonOperatorGrammar  	Ref.match OUT       	    	[match=<MatchResult 0/19: ''>, seg="'(tbl.common_id = b.c...'"]
INFO       [PD:3  MD:22]	......................ComparisonOperatorGrammar   	OneOf.match OUT     	    	[match=<MatchResult 0/19: ''>, seg="'(tbl.common_id = b.c...'"]
DEBUG      [PD:3  MD:22]	......................BinaryOperatorGrammar       	Ref.match OUT       	    	[match=<MatchResult 0/19: ''>, seg="'(tbl.common_id = b.c...'"]
INFO       [PD:3  MD:21]	.....................BinaryOperatorGrammar        	OneOf.match OUT     	    	[match=<MatchResult 0/19: ''>, seg="'(tbl.common_id = b.c...'"]
DEBUG      [PD:3  MD:21]	.....................ColumnReferenceSegment       	Ref.match OUT       	    	[match=<MatchResult 0/19: ''>, seg="'(tbl.common_id = b.c...'"]
INFO       [PD:3  MD:20]	....................ColumnReferenceSegment        	OneOf.match OUT     	+   	[match=<MatchResult 1/19: '(tbl.common_id = b.common_id)'>, seg="'(tbl.common_id = b.c...'"]
DEBUG      [PD:3  MD:20]	....................ColumnReferenceSegment        	NonCo.match OUT     	    	[match=<MatchResult 0/19: ''>, seg="'(tbl.common_id = b.c...'"]
INFO       [PD:3  MD:19]	...................ColumnReferenceSegment         	Delim.match OUT     	    	[match=<MatchResult 0/19: ''>, seg="'(tbl.common_id = b.c...'"]
DEBUG      [PD:3  MD:18]	..................ColumnReferenceSegment          	Colum.match OUT     	    	[match=<MatchResult 0/19: ''>, seg="'(tbl.common_id = b.c...'"]
DEBUG      [PD:3  MD:18]	..................Expression_D_Grammar            	Ref.match OUT       	    	[match=<MatchResult 0/19: ''>, seg="'(tbl.common_id = b.c...'"]
DEBUG      [PD:3  MD:19]	...................Expression_D_Grammar           	Ref.match OUT       	    	[match=<MatchResult 0/19: ''>, seg="'(tbl.common_id = b.c...'"]
DEBUG      [PD:3  MD:23]	.......................ArrayLiteralSegment        	Delim._look_ahead_match IN	    	[ls=1, seg='tbl.common_id = b.co...']
DEBUG      [PD:3  MD:23]	.......................ArrayLiteralSegment        	Delim._look_ahead_match SI	    	[mq=[], sb=['TBL.COMMON_ID']]
DEBUG      [PD:3  MD:23]	.......................ArrayLiteralSegment        	Delim._look_ahead_match SC	    	[bsm=None]
INFO       [PD:3  MD:25]	.........................Expression_A_Grammar     	OneOf.match PRN     	    	[ns=1, ps=1, ms=0, pruned=[<Sequence: [<OneOf: [<Ref: PositiveSegment>, <Ref: N..., <Ref: Expression_C_Grammar>]>], opts=[<Ref: Expression_C_Grammar>]]
INFO       [PD:3  MD:26]	..........................Expression_C_Grammar    	OneOf.match PRN     	    	[ns=1, ps=2, ms=0, pruned=[<Sequence: [<Ref: ExistsKeywordSegment>, <Bracketed: [<Ref: SelectStatementSegmen...]>, <Ref: CaseExpressionSegment>], opts=[<Ref: Expression_D_Grammar>]]
INFO       [PD:3  MD:28]	............................Expression_D_Grammar  	OneOf.match PRN     	    	[ns=6, ps=3, ms=0, pruned=[<Bracketed: [<OneOf: [<Ref: ExpressionSegment>, <Ref:...]>, <Ref: SelectStatementSegment>, <Ref: IntervalExpressionSegment>], opts=[<Ref: BareFunctionSegment>, <Ref: FunctionSegment>, <Ref: LiteralGrammar>, <Ref: ColumnReferenceSegment>, <Sequence: [<Ref: SimpleArrayTypeGrammar [opt]>, <Ref: ArrayLiteralSegment>]>, <Sequence: [<Ref: DatatypeSegment>, <OneOf: [<Ref: QuotedLiteralSegment>, <R...]>]]
DEBUG      [PD:3  MD:29]	.............................Expression_D_Grammar 	Ref.match OUT       	    	[match=<MatchResult 0/1: ''>, seg="'tbl.common_id = b.co...'"]
INFO       [PD:3  MD:30]	..............................FunctionSegment     	OneOf.match PRN     	    	[ns=1, ps=1, ms=0, pruned=[<Sequence: [<Sequence: [<Ref: DateAddFunctionNameSeg...]>], opts=[<Sequence: [<Sequence: [<AnyNumberOf: [<Ref: Functio..., <Ref: PostFunctionGrammar [opt]>]>]]
DEBUG      [PD:3  MD:36]	....................................DateAddFunctionNameSegment	Ref.match OUT       	    	[match=<MatchResult 0/1: ''>, seg="'tbl.common_id = b.co...'"]
INFO       [PD:3  MD:35]	...................................DateAddFunctionNameSegment	Seque.match OUT     	    	[match=<MatchResult 0/1: ''>, seg="'tbl.common_id = b.co...'"]
DEBUG      [PD:3  MD:34]	..................................DateAddFunctionNameSegment	DateA.match OUT     	    	[match=<MatchResult 0/1: ''>, seg="'tbl.common_id = b.co...'"]
DEBUG      [PD:3  MD:34]	..................................FunctionSegment 	Ref.match OUT       	    	[match=<MatchResult 0/1: ''>, seg="'tbl.common_id = b.co...'"]
INFO       [PD:3  MD:33]	.................................FunctionSegment  	AnyNu.match PRN     	    	[ns=1, ps=0, ms=0, pruned=[], opts=[<Ref: FunctionNameSegment>]]
INFO       [PD:3  MD:36]	....................................FunctionNameSegment	AnyNu.match PRN     	    	[ns=1, ps=0, ms=0, pruned=[], opts=[<Sequence: [<Ref: SingleIdentifierGrammar>, <Ref: DotSegment>]>]]
INFO       [PD:3  MD:38]	......................................SingleIdentifierGrammar	OneOf.match PRN     	    	[ns=2, ps=0, ms=0, pruned=[], opts=[<Ref: NakedIdentifierSegment>, <Ref: QuotedIdentifierSegment>]]
DEBUG      [PD:3  MD:39]	.......................................SingleIdentifierGrammar	Ref.match OUT       	    	[match=<MatchResult 0/1: ''>, seg="'tbl.common_id = b.co...'"]
DEBUG      [PD:3  MD:39]	.......................................SingleIdentifierGrammar	Ref.match OUT       	    	[match=<MatchResult 0/1: ''>, seg="'tbl.common_id = b.co...'"]
INFO       [PD:3  MD:38]	......................................SingleIdentifierGrammar	OneOf.match OUT     	    	[match=<MatchResult 0/1: ''>, seg="'tbl.common_id = b.co...'"]
DEBUG      [PD:3  MD:38]	......................................FunctionNameSegment	Ref.match OUT       	    	[match=<MatchResult 0/1: ''>, seg="'tbl.common_id = b.co...'"]
INFO       [PD:3  MD:37]	.....................................FunctionNameSegment	Seque.match OUT     	    	[match=<MatchResult 0/1: ''>, seg="'tbl.common_id = b.co...'"]
INFO       [PD:3  MD:36]	....................................FunctionNameSegment	AnyNu.match OUT     	    	[match=<MatchResult 0/1: ''>, seg="'tbl.common_id = b.co...'"]
INFO       [PD:3  MD:36]	....................................FunctionNameSegment	OneOf.match PRN     	    	[ns=2, ps=0, ms=0, pruned=[], opts=[<Ref: FunctionNameIdentifierSegment>, <Ref: QuotedIdentifierSegment>]]
DEBUG      [PD:3  MD:37]	.....................................FunctionNameSegment	Ref.match OUT       	    	[match=<MatchResult 0/1: ''>, seg="'tbl.common_id = b.co...'"]
DEBUG      [PD:3  MD:37]	.....................................FunctionNameSegment	Ref.match OUT       	    	[match=<MatchResult 0/1: ''>, seg="'tbl.common_id = b.co...'"]
INFO       [PD:3  MD:36]	....................................FunctionNameSegment	OneOf.match OUT     	    	[match=<MatchResult 0/1: ''>, seg="'tbl.common_id = b.co...'"]
INFO       [PD:3  MD:35]	...................................FunctionNameSegment	Seque.match OUT     	    	[match=<MatchResult 0/1: ''>, seg="'tbl.common_id = b.co...'"]
DEBUG      [PD:3  MD:34]	..................................FunctionNameSegment	Funct.match OUT     	    	[match=<MatchResult 0/1: ''>, seg="'tbl.common_id = b.co...'"]
DEBUG      [PD:3  MD:34]	..................................FunctionSegment 	Ref.match OUT       	    	[match=<MatchResult 0/1: ''>, seg="'tbl.common_id = b.co...'"]
INFO       [PD:3  MD:33]	.................................FunctionSegment  	AnyNu.match OUT     	    	[match=<MatchResult 0/1: ''>, seg="'tbl.common_id = b.co...'"]
INFO       [PD:3  MD:32]	................................FunctionSegment   	Seque.match OUT     	    	[match=<MatchResult 0/1: ''>, seg="'tbl.common_id = b.co...'"]
INFO       [PD:3  MD:31]	...............................FunctionSegment    	Seque.match OUT     	    	[match=<MatchResult 0/1: ''>, seg="'tbl.common_id = b.co...'"]
INFO       [PD:3  MD:30]	..............................FunctionSegment     	OneOf.match OUT     	    	[match=<MatchResult 0/1: ''>, seg="'tbl.common_id = b.co...'"]
DEBUG      [PD:3  MD:29]	.............................FunctionSegment      	Funct.match OUT     	    	[match=<MatchResult 0/1: ''>, seg="'tbl.common_id = b.co...'"]
DEBUG      [PD:3  MD:29]	.............................Expression_D_Grammar 	Ref.match OUT       	    	[match=<MatchResult 0/1: ''>, seg="'tbl.common_id = b.co...'"]
INFO       [PD:3  MD:29]	.............................LiteralGrammar       	OneOf.match PRN     	    	[ns=2, ps=4, ms=0, pruned=[<Ref: BooleanLiteralGrammar>, <Ref: QualifiedNumericLiteralSegment>, <Ref: NullLiteralSegment>, <Ref: DateTimeLiteralGrammar>], opts=[<Ref: QuotedLiteralSegment>, <Ref: NumericLiteralSegment>]]
DEBUG      [PD:3  MD:30]	..............................LiteralGrammar      	Ref.match OUT       	    	[match=<MatchResult 0/1: ''>, seg="'tbl.common_id = b.co...'"]
DEBUG      [PD:3  MD:30]	..............................LiteralGrammar      	Ref.match OUT       	    	[match=<MatchResult 0/1: ''>, seg="'tbl.common_id = b.co...'"]
INFO       [PD:3  MD:29]	.............................LiteralGrammar       	OneOf.match OUT     	    	[match=<MatchResult 0/1: ''>, seg="'tbl.common_id = b.co...'"]
DEBUG      [PD:3  MD:29]	.............................Expression_D_Grammar 	Ref.match OUT       	    	[match=<MatchResult 0/1: ''>, seg="'tbl.common_id = b.co...'"]
DEBUG      [PD:3  MD:31]	...............................ColumnReferenceSegment	Delim._look_ahead_match IN	    	[ls=1, seg='tbl.common_id = b.co...']
DEBUG      [PD:3  MD:31]	...............................ColumnReferenceSegment	Delim._look_ahead_match SI	    	[mq=[], sb=['TBL.COMMON_ID']]
INFO       [PD:3  MD:31]	...............................ColumnReferenceSegment	OneOf.match PRN     	    	[ns=1, ps=10, ms=0, pruned=[<Ref: OnKeywordSegment>, <Ref: AsKeywordSegment>, <Ref: UsingKeywordSegment>, <Ref: CommaSegment>, <Ref: CastOperatorSegment>, <Ref: StartSquareBracketSegment>, <Ref: StartBracketSegment>, <Ref: ColonSegment>, <Ref: DelimiterSegment>, <class 'sqlfluff.core.parser.segments.base.BracketedSegment'>], opts=[<Ref: BinaryOperatorGrammar>]]
INFO       [PD:3  MD:32]	................................BinaryOperatorGrammar	OneOf.match PRN     	    	[ns=1, ps=3, ms=0, pruned=[<Ref: ArithmeticBinaryOperatorGrammar>, <Ref: StringBinaryOperatorGrammar>, <Ref: BooleanBinaryOperatorGrammar>], opts=[<Ref: ComparisonOperatorGrammar>]]
INFO       [PD:3  MD:33]	.................................ComparisonOperatorGrammar	OneOf.match PRN     	    	[ns=1, ps=7, ms=0, pruned=[<Ref: EqualsSegment>, <Ref: GreaterThanSegment>, <Ref: LessThanSegment>, <Ref: GreaterThanOrEqualToSegment>, <Ref: LessThanOrEqualToSegment>, <Ref: NotEqualToSegment_a>, <Ref: NotEqualToSegment_b>], opts=[<Ref: LikeOperatorSegment>]]
DEBUG      [PD:3  MD:34]	..................................ComparisonOperatorGrammar	Ref.match OUT       	    	[match=<MatchResult 0/1: ''>, seg="'tbl.common_id = b.co...'"]
INFO       [PD:3  MD:33]	.................................ComparisonOperatorGrammar	OneOf.match OUT     	    	[match=<MatchResult 0/1: ''>, seg="'tbl.common_id = b.co...'"]
DEBUG      [PD:3  MD:33]	.................................BinaryOperatorGrammar	Ref.match OUT       	    	[match=<MatchResult 0/1: ''>, seg="'tbl.common_id = b.co...'"]
INFO       [PD:3  MD:32]	................................BinaryOperatorGrammar	OneOf.match OUT     	    	[match=<MatchResult 0/1: ''>, seg="'tbl.common_id = b.co...'"]
DEBUG      [PD:3  MD:32]	................................ColumnReferenceSegment	Ref.match OUT       	    	[match=<MatchResult 0/1: ''>, seg="'tbl.common_id = b.co...'"]
INFO       [PD:3  MD:31]	...............................ColumnReferenceSegment	OneOf.match OUT     	    	[match=<MatchResult 0/1: ''>, seg="'tbl.common_id = b.co...'"]
DEBUG      [PD:3  MD:31]	...............................ColumnReferenceSegment	NonCo.match OUT     	    	[match=<MatchResult 0/1: ''>, seg="'tbl.common_id = b.co...'"]
INFO       [PD:3  MD:31]	...............................SingleIdentifierGrammar	OneOf.match PRN     	    	[ns=2, ps=0, ms=0, pruned=[], opts=[<Ref: NakedIdentifierSegment>, <Ref: QuotedIdentifierSegment>]]
DEBUG      [PD:3  MD:32]	................................SingleIdentifierGrammar	Ref.match OUT       	    	[match=<MatchResult 0/1: ''>, seg="'tbl.common_id = b.co...'"]
DEBUG      [PD:3  MD:32]	................................SingleIdentifierGrammar	Ref.match OUT       	    	[match=<MatchResult 0/1: ''>, seg="'tbl.common_id = b.co...'"]
INFO       [PD:3  MD:31]	...............................SingleIdentifierGrammar	OneOf.match OUT     	    	[match=<MatchResult 0/1: ''>, seg="'tbl.common_id = b.co...'"]
DEBUG      [PD:3  MD:31]	...............................ColumnReferenceSegment	Ref.match OUT       	    	[match=<MatchResult 0/1: ''>, seg="'tbl.common_id = b.co...'"]
INFO       [PD:3  MD:30]	..............................ColumnReferenceSegment	Delim.match OUT     	    	[match=<MatchResult 0/1: ''>, seg="'tbl.common_id = b.co...'"]
DEBUG      [PD:3  MD:29]	.............................ColumnReferenceSegment	Colum.match OUT     	    	[match=<MatchResult 0/1: ''>, seg="'tbl.common_id = b.co...'"]
DEBUG      [PD:3  MD:29]	.............................Expression_D_Grammar 	Ref.match OUT       	    	[match=<MatchResult 0/1: ''>, seg="'tbl.common_id = b.co...'"]
DEBUG      [PD:3  MD:30]	..............................Expression_D_Grammar	Ref.match OUT       	    	[match=<MatchResult 0/1: ''>, seg="'tbl.common_id = b.co...'"]
INFO       [PD:3  MD:31]	...............................ArrayLiteralSegment	Brack.match OUT     	    	[match=<MatchResult 0/1: ''>, seg="'tbl.common_id = b.co...'"]
DEBUG      [PD:3  MD:30]	..............................ArrayLiteralSegment 	Array.match OUT     	    	[match=<MatchResult 0/1: ''>, seg="'tbl.common_id = b.co...'"]
DEBUG      [PD:3  MD:30]	..............................Expression_D_Grammar	Ref.match OUT       	    	[match=<MatchResult 0/1: ''>, seg="'tbl.common_id = b.co...'"]
INFO       [PD:3  MD:29]	.............................Expression_D_Grammar 	Seque.match OUT     	    	[match=<MatchResult 0/1: ''>, seg="'tbl.common_id = b.co...'"]
INFO       [PD:3  MD:31]	...............................DatatypeSegment    	OneOf.match PRN     	    	[ns=1, ps=2, ms=0, pruned=[<Sequence: [<OneOf: [<Ref: TimeKeywordSegment>, <Ref..., <Bracketed: [<Ref: NumericLiteralSegment..., <Sequence:...]>, <Sequence: [<Ref: DoubleKeywordSegment>, <Ref: PrecisionKeywordSegment>]>], opts=[<Sequence: [<OneOf: [<Sequence: [<OneOf: [<Ref: Char..., <Bracketed: [<OneOf: [<Delimited: [<Ref:..., <Ref: Char...]>]]
INFO       [PD:3  MD:33]	.................................DatatypeSegment  	OneOf.match PRN     	    	[ns=1, ps=1, ms=0, pruned=[<Sequence: [<OneOf: [<Ref: CharacterKeywordSegment>,..., <OneOf: [<Ref: VaryingKeywordSegment>, <...]>], opts=[<Sequence: [<Sequence: [<Ref: SingleIdentifierGramma..., <Ref: DatatypeIdentifierSegment>]>]]
INFO       [PD:3  MD:36]	....................................SingleIdentifierGrammar	OneOf.match PRN     	    	[ns=2, ps=0, ms=0, pruned=[], opts=[<Ref: NakedIdentifierSegment>, <Ref: QuotedIdentifierSegment>]]
DEBUG      [PD:3  MD:37]	.....................................SingleIdentifierGrammar	Ref.match OUT       	    	[match=<MatchResult 0/1: ''>, seg="'tbl.common_id = b.co...'"]
DEBUG      [PD:3  MD:37]	.....................................SingleIdentifierGrammar	Ref.match OUT       	    	[match=<MatchResult 0/1: ''>, seg="'tbl.common_id = b.co...'"]
INFO       [PD:3  MD:36]	....................................SingleIdentifierGrammar	OneOf.match OUT     	    	[match=<MatchResult 0/1: ''>, seg="'tbl.common_id = b.co...'"]
DEBUG      [PD:3  MD:36]	....................................DatatypeSegment	Ref.match OUT       	    	[match=<MatchResult 0/1: ''>, seg="'tbl.common_id = b.co...'"]
INFO       [PD:3  MD:35]	...................................DatatypeSegment	Seque.match OUT     	    	[match=<MatchResult 0/1: ''>, seg="'tbl.common_id = b.co...'"]
DEBUG      [PD:3  MD:35]	...................................DatatypeSegment	Ref.match OUT       	    	[match=<MatchResult 0/1: ''>, seg="'tbl.common_id = b.co...'"]
INFO       [PD:3  MD:34]	..................................DatatypeSegment 	Seque.match OUT     	    	[match=<MatchResult 0/1: ''>, seg="'tbl.common_id = b.co...'"]
INFO       [PD:3  MD:33]	.................................DatatypeSegment  	OneOf.match OUT     	    	[match=<MatchResult 0/1: ''>, seg="'tbl.common_id = b.co...'"]
INFO       [PD:3  MD:32]	................................DatatypeSegment   	Seque.match OUT     	    	[match=<MatchResult 0/1: ''>, seg="'tbl.common_id = b.co...'"]
INFO       [PD:3  MD:31]	...............................DatatypeSegment    	OneOf.match OUT     	    	[match=<MatchResult 0/1: ''>, seg="'tbl.common_id = b.co...'"]
DEBUG      [PD:3  MD:30]	..............................DatatypeSegment     	Datat.match OUT     	    	[match=<MatchResult 0/1: ''>, seg="'tbl.common_id = b.co...'"]
DEBUG      [PD:3  MD:30]	..............................Expression_D_Grammar	Ref.match OUT       	    	[match=<MatchResult 0/1: ''>, seg="'tbl.common_id = b.co...'"]
INFO       [PD:3  MD:29]	.............................Expression_D_Grammar 	Seque.match OUT     	    	[match=<MatchResult 0/1: ''>, seg="'tbl.common_id = b.co...'"]
INFO       [PD:3  MD:28]	............................Expression_D_Grammar  	OneOf.match OUT     	    	[match=<MatchResult 0/1: ''>, seg="'tbl.common_id = b.co...'"]
INFO       [PD:3  MD:27]	...........................Expression_D_Grammar   	Seque.match OUT     	    	[match=<MatchResult 0/1: ''>, seg="'tbl.common_id = b.co...'"]
DEBUG      [PD:3  MD:27]	...........................Expression_C_Grammar   	Ref.match OUT       	    	[match=<MatchResult 0/1: ''>, seg="'tbl.common_id = b.co...'"]
INFO       [PD:3  MD:26]	..........................Expression_C_Grammar    	OneOf.match OUT     	    	[match=<MatchResult 0/1: ''>, seg="'tbl.common_id = b.co...'"]
DEBUG      [PD:3  MD:26]	..........................Expression_A_Grammar    	Ref.match OUT       	    	[match=<MatchResult 0/1: ''>, seg="'tbl.common_id = b.co...'"]
INFO       [PD:3  MD:25]	.........................Expression_A_Grammar     	OneOf.match OUT     	    	[match=<MatchResult 0/1: ''>, seg="'tbl.common_id = b.co...'"]
INFO       [PD:3  MD:24]	........................Expression_A_Grammar      	Seque.match OUT     	    	[match=<MatchResult 0/1: ''>, seg="'tbl.common_id = b.co...'"]
DEBUG      [PD:3  MD:24]	........................ExpressionSegment         	Ref.match OUT       	    	[match=<MatchResult 0/1: ''>, seg="'tbl.common_id = b.co...'"]
DEBUG      [PD:3  MD:23]	.......................ExpressionSegment          	Expre.match OUT     	    	[match=<MatchResult 0/1: ''>, seg="'tbl.common_id = b.co...'"]
DEBUG      [PD:3  MD:23]	.......................ArrayLiteralSegment        	Ref.match OUT       	    	[match=<MatchResult 0/1: ''>, seg="'tbl.common_id = b.co...'"]
INFO       [PD:3  MD:22]	......................ArrayLiteralSegment         	Delim.match OUT     	    	[match=<MatchResult 0/1: ''>, seg="'tbl.common_id = b.co...'"]
INFO       [PD:3  MD:21]	.....................ArrayLiteralSegment          	Brack.match OUT     	    	[match=<MatchResult 0/1: ''>, seg="'tbl.common_id = b.co...'"]
INFO       [PD:3  MD:20]	....................ArrayLiteralSegment           	Brack.match OUT     	    	[match=<MatchResult 0/19: ''>, seg="'(tbl.common_id = b.c...'"]
DEBUG      [PD:3  MD:19]	...................ArrayLiteralSegment            	Array.match OUT     	    	[match=<MatchResult 0/19: ''>, seg="'(tbl.common_id = b.c...'"]
DEBUG      [PD:3  MD:19]	...................Expression_D_Grammar           	Ref.match OUT       	    	[match=<MatchResult 0/19: ''>, seg="'(tbl.common_id = b.c...'"]
INFO       [PD:3  MD:18]	..................Expression_D_Grammar            	Seque.match OUT     	    	[match=<MatchResult 0/19: ''>, seg="'(tbl.common_id = b.c...'"]
INFO       [PD:3  MD:20]	....................DatatypeSegment               	OneOf.match PRN     	    	[ns=1, ps=2, ms=0, pruned=[<Sequence: [<OneOf: [<Ref: TimeKeywordSegment>, <Ref..., <Bracketed: [<Ref: NumericLiteralSegment..., <Sequence:...]>, <Sequence: [<Ref: DoubleKeywordSegment>, <Ref: PrecisionKeywordSegment>]>], opts=[<Sequence: [<OneOf: [<Sequence: [<OneOf: [<Ref: Char..., <Bracketed: [<OneOf: [<Delimited: [<Ref:..., <Ref: Char...]>]]
INFO       [PD:3  MD:22]	......................DatatypeSegment             	OneOf.match PRN     	    	[ns=1, ps=1, ms=0, pruned=[<Sequence: [<OneOf: [<Ref: CharacterKeywordSegment>,..., <OneOf: [<Ref: VaryingKeywordSegment>, <...]>], opts=[<Sequence: [<Sequence: [<Ref: SingleIdentifierGramma..., <Ref: DatatypeIdentifierSegment>]>]]
INFO       [PD:3  MD:25]	.........................SingleIdentifierGrammar  	OneOf.match PRN     	    	[ns=2, ps=0, ms=0, pruned=[], opts=[<Ref: NakedIdentifierSegment>, <Ref: QuotedIdentifierSegment>]]
DEBUG      [PD:3  MD:26]	..........................SingleIdentifierGrammar 	Ref.match OUT       	    	[match=<MatchResult 0/19: ''>, seg="'(tbl.common_id = b.c...'"]
DEBUG      [PD:3  MD:26]	..........................SingleIdentifierGrammar 	Ref.match OUT       	    	[match=<MatchResult 0/19: ''>, seg="'(tbl.common_id = b.c...'"]
INFO       [PD:3  MD:25]	.........................SingleIdentifierGrammar  	OneOf.match OUT     	    	[match=<MatchResult 0/19: ''>, seg="'(tbl.common_id = b.c...'"]
DEBUG      [PD:3  MD:25]	.........................DatatypeSegment          	Ref.match OUT       	    	[match=<MatchResult 0/19: ''>, seg="'(tbl.common_id = b.c...'"]
INFO       [PD:3  MD:24]	........................DatatypeSegment           	Seque.match OUT     	    	[match=<MatchResult 0/19: ''>, seg="'(tbl.common_id = b.c...'"]
DEBUG      [PD:3  MD:24]	........................DatatypeSegment           	Ref.match OUT       	    	[match=<MatchResult 0/19: ''>, seg="'(tbl.common_id = b.c...'"]
INFO       [PD:3  MD:23]	.......................DatatypeSegment            	Seque.match OUT     	    	[match=<MatchResult 0/19: ''>, seg="'(tbl.common_id = b.c...'"]
INFO       [PD:3  MD:22]	......................DatatypeSegment             	OneOf.match OUT     	    	[match=<MatchResult 0/19: ''>, seg="'(tbl.common_id = b.c...'"]
INFO       [PD:3  MD:21]	.....................DatatypeSegment              	Seque.match OUT     	    	[match=<MatchResult 0/19: ''>, seg="'(tbl.common_id = b.c...'"]
INFO       [PD:3  MD:20]	....................DatatypeSegment               	OneOf.match OUT     	    	[match=<MatchResult 0/19: ''>, seg="'(tbl.common_id = b.c...'"]
DEBUG      [PD:3  MD:19]	...................DatatypeSegment                	Datat.match OUT     	    	[match=<MatchResult 0/19: ''>, seg="'(tbl.common_id = b.c...'"]
DEBUG      [PD:3  MD:19]	...................Expression_D_Grammar           	Ref.match OUT       	    	[match=<MatchResult 0/19: ''>, seg="'(tbl.common_id = b.c...'"]
INFO       [PD:3  MD:18]	..................Expression_D_Grammar            	Seque.match OUT     	    	[match=<MatchResult 0/19: ''>, seg="'(tbl.common_id = b.c...'"]
INFO       [PD:3  MD:17]	.................Expression_D_Grammar             	OneOf.match OUT     	+   	[match=<MatchResult 1/19: '(tbl.common_id = b.common_id)'>, seg="'(tbl.common_id = b.c...'"]
INFO       [PD:3  MD:17]	.................Accessor_Grammar                 	AnyNu.match PRN     	    	[ns=0, ps=1, ms=0, pruned=[<Ref: ArrayAccessorSegment>], opts='ALL']
INFO       [PD:3  MD:17]	.................Accessor_Grammar                 	AnyNu.match OUT     	    	[match=<MatchResult 0/17: ''>, seg="'JOIN c ON (tbl.id = ...'"]
DEBUG      [PD:3  MD:17]	.................Expression_D_Grammar             	Ref.match OUT       	    	[match=<MatchResult 0/17: ''>, seg="'JOIN c ON (tbl.id = ...'"]
INFO       [PD:3  MD:17]	.................Expression_D_Grammar             	AnyNu.match PRN     	    	[ns=0, ps=1, ms=0, pruned=[<Ref: ShorthandCastSegment>], opts='ALL']
INFO       [PD:3  MD:17]	.................Expression_D_Grammar             	AnyNu.match OUT     	    	[match=<MatchResult 0/17: ''>, seg="'JOIN c ON (tbl.id = ...'"]
INFO       [PD:3  MD:16]	................Expression_D_Grammar              	Seque.match OUT     	+   	[match=<MatchResult 1/19: '(tbl.common_id = b.common_id)'>, seg="'(tbl.common_id = b.c...'"]
DEBUG      [PD:3  MD:16]	................Expression_C_Grammar              	Ref.match OUT       	+   	[match=<MatchResult 1/19: '(tbl.common_id = b.common_id)'>, seg="'(tbl.common_id = b.c...'"]
INFO       [PD:3  MD:15]	...............Expression_C_Grammar               	OneOf.match OUT     	+   	[match=<MatchResult 1/19: '(tbl.common_id = b.common_id)'>, seg="'(tbl.common_id = b.c...'"]
DEBUG      [PD:3  MD:15]	...............Expression_A_Grammar               	Ref.match OUT       	+   	[match=<MatchResult 1/19: '(tbl.common_id = b.common_id)'>, seg="'(tbl.common_id = b.c...'"]
INFO       [PD:3  MD:14]	..............Expression_A_Grammar                	OneOf.match OUT     	+   	[match=<MatchResult 1/19: '(tbl.common_id = b.common_id)'>, seg="'(tbl.common_id = b.c...'"]
INFO       [PD:3  MD:14]	..............Expression_A_Grammar                	AnyNu.match PRN     	    	[ns=1, ps=0, ms=0, pruned=[], opts=[<OneOf: [<Sequence: [<OneOf: [<Sequence: [<Ref: N..., <Sequence: [<Ref: NotKeywordSegment [opt..., <Sequence:...]>]]
INFO       [PD:3  MD:15]	...............Expression_A_Grammar               	OneOf.match PRN     	    	[ns=3, ps=5, ms=0, pruned=[<Sequence: [<Ref: NotKeywordSegment [opt]>, <Ref: InKeywordSegment>, <Bracketed: [<OneOf: [<Delimited: [<Ref:...]>, <Sequence: [<Ref: NotKeywordSegment [opt]>, <Ref: InKeywordSegment>, <Ref: FunctionSegment>]>, <Sequence: [<Ref: IsKeywordSegment>, <Ref: NotKeywordSegment [opt]>, <Ref: IsClauseGrammar>]>, <Sequence: [<Ref: NotKeywordSegment>, <Ref: Expression_C_Grammar>]>, <Sequence: [<Ref: NotKeywordSegment [opt]>, <Ref: BetweenKeywordSegment>, <Ref: Expression_C_Grammar>, <AnyNumbe...]>], opts=[<Sequence: [<OneOf: [<Sequence: [<Ref: NotKeywordSeg..., <Ref: Expression_C_Grammar>, <Sequence: [<Ref: EscapeKe...]>, <Ref: IsNullGrammar>, <Ref: NotNullGrammar>]]
INFO       [PD:3  MD:17]	.................Expression_A_Grammar             	OneOf.match PRN     	    	[ns=1, ps=1, ms=0, pruned=[<Sequence: [<Ref: NotKeywordSegment [opt]>, <Ref: LikeGrammar>]>], opts=[<Sequence: [<Ref: BinaryOperatorGrammar>, <Ref: NotKeywordSegment [opt]>]>]]
INFO       [PD:3  MD:19]	...................BinaryOperatorGrammar          	OneOf.match PRN     	    	[ns=1, ps=3, ms=0, pruned=[<Ref: ArithmeticBinaryOperatorGrammar>, <Ref: StringBinaryOperatorGrammar>, <Ref: BooleanBinaryOperatorGrammar>], opts=[<Ref: ComparisonOperatorGrammar>]]
INFO       [PD:3  MD:20]	....................ComparisonOperatorGrammar     	OneOf.match PRN     	    	[ns=1, ps=7, ms=0, pruned=[<Ref: EqualsSegment>, <Ref: GreaterThanSegment>, <Ref: LessThanSegment>, <Ref: GreaterThanOrEqualToSegment>, <Ref: LessThanOrEqualToSegment>, <Ref: NotEqualToSegment_a>, <Ref: NotEqualToSegment_b>], opts=[<Ref: LikeOperatorSegment>]]
DEBUG      [PD:3  MD:21]	.....................ComparisonOperatorGrammar    	Ref.match OUT       	    	[match=<MatchResult 0/17: ''>, seg="'JOIN c ON (tbl.id = ...'"]
INFO       [PD:3  MD:20]	....................ComparisonOperatorGrammar     	OneOf.match OUT     	    	[match=<MatchResult 0/17: ''>, seg="'JOIN c ON (tbl.id = ...'"]
DEBUG      [PD:3  MD:20]	....................BinaryOperatorGrammar         	Ref.match OUT       	    	[match=<MatchResult 0/17: ''>, seg="'JOIN c ON (tbl.id = ...'"]
INFO       [PD:3  MD:19]	...................BinaryOperatorGrammar          	OneOf.match OUT     	    	[match=<MatchResult 0/17: ''>, seg="'JOIN c ON (tbl.id = ...'"]
DEBUG      [PD:3  MD:19]	...................Expression_A_Grammar           	Ref.match OUT       	    	[match=<MatchResult 0/17: ''>, seg="'JOIN c ON (tbl.id = ...'"]
INFO       [PD:3  MD:18]	..................Expression_A_Grammar            	Seque.match OUT     	    	[match=<MatchResult 0/17: ''>, seg="'JOIN c ON (tbl.id = ...'"]
INFO       [PD:3  MD:17]	.................Expression_A_Grammar             	OneOf.match OUT     	    	[match=<MatchResult 0/17: ''>, seg="'JOIN c ON (tbl.id = ...'"]
INFO       [PD:3  MD:16]	................Expression_A_Grammar              	Seque.match OUT     	    	[match=<MatchResult 0/17: ''>, seg="'JOIN c ON (tbl.id = ...'"]
DEBUG      [PD:3  MD:16]	................Expression_A_Grammar              	Ref.match OUT       	    	[match=<MatchResult 0/17: ''>, seg="'JOIN c ON (tbl.id = ...'"]
DEBUG      [PD:3  MD:16]	................Expression_A_Grammar              	Ref.match OUT       	    	[match=<MatchResult 0/17: ''>, seg="'JOIN c ON (tbl.id = ...'"]
INFO       [PD:3  MD:15]	...............Expression_A_Grammar               	OneOf.match OUT     	    	[match=<MatchResult 0/17: ''>, seg="'JOIN c ON (tbl.id = ...'"]
INFO       [PD:3  MD:14]	..............Expression_A_Grammar                	AnyNu.match OUT     	    	[match=<MatchResult 0/17: ''>, seg="'JOIN c ON (tbl.id = ...'"]
INFO       [PD:3  MD:13]	.............Expression_A_Grammar                 	Seque.match OUT     	+   	[match=<MatchResult 1/19: '(tbl.common_id = b.common_id)'>, seg="'(tbl.common_id = b.c...'"]
DEBUG      [PD:3  MD:13]	.............ExpressionSegment                    	Ref.match OUT       	+   	[match=<MatchResult 1/19: '(tbl.common_id = b.common_id)'>, seg="'(tbl.common_id = b.c...'"]
DEBUG      [PD:3  MD:12]	............ExpressionSegment                     	Expre.match OUT     	+   	[match=<MatchResult 1/19: '(tbl.common_id = b.common_id)'>, seg="'(tbl.common_id = b.c...'"]
DEBUG      [PD:3  MD:12]	............JoinOnConditionSegment                	Ref.match OUT       	+   	[match=<MatchResult 1/19: '(tbl.common_id = b.common_id)'>, seg="'(tbl.common_id = b.c...'"]
INFO       [PD:3  MD:11]	...........JoinOnConditionSegment                 	Optio.match OUT     	+   	[match=<MatchResult 1/19: '(tbl.common_id = b.common_id)'>, seg="'(tbl.common_id = b.c...'"]
INFO       [PD:3  MD:10]	..........JoinOnConditionSegment                  	Seque.match OUT     	+   	[match=<MatchResult 5/23: 'ON (tbl.common_id = b.common_id)'>, seg="'ON (tbl.common_id = ...'"]
DEBUG      [PD:3  MD:9 ]	.........JoinOnConditionSegment                   	JoinO.match OUT     	+   	[match=<MatchResult 1/19: 'ON (tbl.common_id = b.common_id)'>, seg="'ON (tbl.common_id = ...'"]
DEBUG      [PD:3  MD:9 ]	.........JoinClauseSegment                        	Ref.match OUT       	+   	[match=<MatchResult 1/19: 'ON (tbl.common_id = b.common_id)'>, seg="'ON (tbl.common_id = ...'"]
INFO       [PD:3  MD:8 ]	........JoinClauseSegment                         	OneOf.match OUT     	+   	[match=<MatchResult 1/19: 'ON (tbl.common_id = b.common_id)'>, seg="'ON (tbl.common_id = ...'"]
INFO       [PD:3  MD:7 ]	.......JoinClauseSegment                          	Seque.match OUT     	+   	[match=<MatchResult 3/21: 'b ON (tbl.commo... = b.common_id)'>, seg="'b ON (tbl.common_id ...'"]
INFO       [PD:3  MD:6 ]	......JoinClauseSegment                           	Seque.match OUT     	+   	[match=<MatchResult 9/27: 'INNER JOIN b ON... = b.common_id)'>, seg="'INNER JOIN b ON (tbl...'"]
DEBUG      [PD:3  MD:5 ]	.....JoinClauseSegment                            	JoinC.match OUT     	+   	[match=<MatchResult 1/19: 'INNER JOIN b ON... = b.common_id)'>, seg="'INNER JOIN b ON (tbl...'"]
DEBUG      [PD:3  MD:5 ]	.....FromExpressionSegment                        	Ref.match OUT       	+   	[match=<MatchResult 1/19: 'INNER JOIN b ON... = b.common_id)'>, seg="'INNER JOIN b ON (tbl...'"]
DEBUG      [PD:3  MD:5 ]	.....FromExpressionSegment                        	Ref.match OUT       	    	[match=<MatchResult 0/27: ''>, seg="'INNER JOIN b ON (tbl...'"]
INFO       [PD:3  MD:4 ]	....FromExpressionSegment                         	AnyNu.match PRN     	    	[ns=1, ps=0, ms=1, pruned=[], opts=[<Ref: JoinClauseSegment>, <Ref: JoinLikeClauseGrammar>]]
INFO       [PD:3  MD:7 ]	.......JoinClauseSegment                          	OneOf.match PRN     	    	[ns=0, ps=3, ms=0, pruned=[<Ref: CrossKeywordSegment>, <Ref: InnerKeywordSegment>, <Sequence: [<OneOf: [<Ref: FullKeywordSegment>, <Ref..., <Ref: OuterKeywordSegment [opt]>]>], opts='ALL']
INFO       [PD:3  MD:7 ]	.......JoinClauseSegment                          	OneOf.match OUT     	    	[match=<MatchResult 0/17: ''>, seg="'JOIN c ON (tbl.id = ...'"]
DEBUG      [PD:3  MD:8 ]	........JoinKeywords                              	Ref.match OUT       	+   	[match=<MatchResult 1/17: 'JOIN'>, seg="'JOIN c ON (tbl.id = ...'"]
INFO       [PD:3  MD:7 ]	.......JoinKeywords                               	Seque.match OUT     	+   	[match=<MatchResult 1/17: 'JOIN'>, seg="'JOIN c ON (tbl.id = ...'"]
DEBUG      [PD:3  MD:7 ]	.......JoinClauseSegment                          	Ref.match OUT       	+   	[match=<MatchResult 1/17: 'JOIN'>, seg="'JOIN c ON (tbl.id = ...'"]
DEBUG      [PD:3  MD:10]	..........FromExpressionElementSegment            	Ref.match OUT       	    	[match=<MatchResult 0/15: ''>, seg="'c ON (tbl.id = c.id)...'"]
INFO       [PD:3  MD:10]	..........FromExpressionElementSegment            	Optio.match PRN     	    	[ns=1, ps=1, ms=0, pruned=[<Bracketed: [<Ref: TableExpressionSegment>]>], opts=[<Ref: TableExpressionSegment>]]
INFO       [PD:3  MD:12]	............TableExpressionSegment                	OneOf.match PRN     	    	[ns=3, ps=1, ms=0, pruned=[<Bracketed: [<Ref: SelectableGrammar>]>], opts=[<Ref: BareFunctionSegment>, <Ref: FunctionSegment>, <Ref: TableReferenceSegment>]]
DEBUG      [PD:3  MD:13]	.............TableExpressionSegment               	Ref.match OUT       	    	[match=<MatchResult 0/15: ''>, seg="'c ON (tbl.id = c.id)...'"]
INFO       [PD:3  MD:14]	..............FunctionSegment                     	OneOf.match PRN     	    	[ns=1, ps=1, ms=0, pruned=[<Sequence: [<Sequence: [<Ref: DateAddFunctionNameSeg...]>], opts=[<Sequence: [<Sequence: [<AnyNumberOf: [<Ref: Functio..., <Ref: PostFunctionGrammar [opt]>]>]]
DEBUG      [PD:3  MD:20]	....................DateAddFunctionNameSegment    	Ref.match OUT       	    	[match=<MatchResult 0/15: ''>, seg="'c ON (tbl.id = c.id)...'"]
INFO       [PD:3  MD:19]	...................DateAddFunctionNameSegment     	Seque.match OUT     	    	[match=<MatchResult 0/15: ''>, seg="'c ON (tbl.id = c.id)...'"]
DEBUG      [PD:3  MD:18]	..................DateAddFunctionNameSegment      	DateA.match OUT     	    	[match=<MatchResult 0/15: ''>, seg="'c ON (tbl.id = c.id)...'"]
DEBUG      [PD:3  MD:18]	..................FunctionSegment                 	Ref.match OUT       	    	[match=<MatchResult 0/15: ''>, seg="'c ON (tbl.id = c.id)...'"]
INFO       [PD:3  MD:17]	.................FunctionSegment                  	AnyNu.match PRN     	    	[ns=1, ps=0, ms=0, pruned=[], opts=[<Ref: FunctionNameSegment>]]
INFO       [PD:3  MD:20]	....................FunctionNameSegment           	AnyNu.match PRN     	    	[ns=1, ps=0, ms=0, pruned=[], opts=[<Sequence: [<Ref: SingleIdentifierGrammar>, <Ref: DotSegment>]>]]
INFO       [PD:3  MD:22]	......................SingleIdentifierGrammar     	OneOf.match PRN     	    	[ns=2, ps=0, ms=0, pruned=[], opts=[<Ref: NakedIdentifierSegment>, <Ref: QuotedIdentifierSegment>]]
DEBUG      [PD:3  MD:23]	.......................SingleIdentifierGrammar    	Ref.match OUT       	+   	[match=<MatchResult 1/15: 'c'>, seg="'c ON (tbl.id = c.id)...'"]
DEBUG      [PD:3  MD:23]	.......................SingleIdentifierGrammar    	Ref.match OUT       	    	[match=<MatchResult 0/15: ''>, seg="'c ON (tbl.id = c.id)...'"]
INFO       [PD:3  MD:22]	......................SingleIdentifierGrammar     	OneOf.match OUT     	+   	[match=<MatchResult 1/15: 'c'>, seg="'c ON (tbl.id = c.id)...'"]
DEBUG      [PD:3  MD:22]	......................FunctionNameSegment         	Ref.match OUT       	+   	[match=<MatchResult 1/15: 'c'>, seg="'c ON (tbl.id = c.id)...'"]
DEBUG      [PD:3  MD:22]	......................FunctionNameSegment         	Ref.match OUT       	    	[match=<MatchResult 0/13: ''>, seg="'ON (tbl.id = c.id)\\nL...'"]
INFO       [PD:3  MD:21]	.....................FunctionNameSegment          	Seque.match OUT     	    	[match=<MatchResult 0/15: ''>, seg="'c ON (tbl.id = c.id)...'"]
INFO       [PD:3  MD:20]	....................FunctionNameSegment           	AnyNu.match OUT     	    	[match=<MatchResult 0/15: ''>, seg="'c ON (tbl.id = c.id)...'"]
INFO       [PD:3  MD:20]	....................FunctionNameSegment           	OneOf.match PRN     	    	[ns=2, ps=0, ms=0, pruned=[], opts=[<Ref: FunctionNameIdentifierSegment>, <Ref: QuotedIdentifierSegment>]]
DEBUG      [PD:3  MD:21]	.....................FunctionNameSegment          	Ref.match OUT       	+   	[match=<MatchResult 1/15: 'c'>, seg="'c ON (tbl.id = c.id)...'"]
DEBUG      [PD:3  MD:21]	.....................FunctionNameSegment          	Ref.match OUT       	    	[match=<MatchResult 0/15: ''>, seg="'c ON (tbl.id = c.id)...'"]
INFO       [PD:3  MD:20]	....................FunctionNameSegment           	OneOf.match OUT     	+   	[match=<MatchResult 1/15: 'c'>, seg="'c ON (tbl.id = c.id)...'"]
INFO       [PD:3  MD:19]	...................FunctionNameSegment            	Seque.match OUT     	+   	[match=<MatchResult 1/15: 'c'>, seg="'c ON (tbl.id = c.id)...'"]
DEBUG      [PD:3  MD:18]	..................FunctionNameSegment             	Funct.match OUT     	+   	[match=<MatchResult 1/15: 'c'>, seg="'c ON (tbl.id = c.id)...'"]
DEBUG      [PD:3  MD:18]	..................FunctionSegment                 	Ref.match OUT       	+   	[match=<MatchResult 1/15: 'c'>, seg="'c ON (tbl.id = c.id)...'"]
INFO       [PD:3  MD:17]	.................FunctionSegment                  	AnyNu.match OUT     	+   	[match=<MatchResult 1/15: 'c'>, seg="'c ON (tbl.id = c.id)...'"]
INFO       [PD:3  MD:17]	.................FunctionSegment                  	Brack.match OUT     	    	[match=<MatchResult 0/13: ''>, seg="'ON (tbl.id = c.id)\\nL...'"]
INFO       [PD:3  MD:16]	................FunctionSegment                   	Seque.match OUT     	    	[match=<MatchResult 0/15: ''>, seg="'c ON (tbl.id = c.id)...'"]
INFO       [PD:3  MD:15]	...............FunctionSegment                    	Seque.match OUT     	    	[match=<MatchResult 0/15: ''>, seg="'c ON (tbl.id = c.id)...'"]
INFO       [PD:3  MD:14]	..............FunctionSegment                     	OneOf.match OUT     	    	[match=<MatchResult 0/15: ''>, seg="'c ON (tbl.id = c.id)...'"]
DEBUG      [PD:3  MD:13]	.............FunctionSegment                      	Funct.match OUT     	    	[match=<MatchResult 0/15: ''>, seg="'c ON (tbl.id = c.id)...'"]
DEBUG      [PD:3  MD:13]	.............TableExpressionSegment               	Ref.match OUT       	    	[match=<MatchResult 0/15: ''>, seg="'c ON (tbl.id = c.id)...'"]
DEBUG      [PD:3  MD:15]	...............TableReferenceSegment              	Delim._look_ahead_match IN	    	[ls=15, seg='c ON (tbl.id = c.id)...']
DEBUG      [PD:3  MD:15]	...............TableReferenceSegment              	Delim._look_ahead_match SI	    	[mq=[], sb=['C', '', 'ON', '', '(TBL.ID', '', 'LEFT', '', 'JOIN', '', 'D', '', 'ON', '', '(TBL.ID']]
INFO       [PD:3  MD:15]	...............TableReferenceSegment              	OneOf.match PRN     	    	[ns=1, ps=10, ms=0, pruned=[<Ref: OnKeywordSegment>, <Ref: AsKeywordSegment>, <Ref: UsingKeywordSegment>, <Ref: CommaSegment>, <Ref: CastOperatorSegment>, <Ref: StartSquareBracketSegment>, <Ref: StartBracketSegment>, <Ref: ColonSegment>, <Ref: DelimiterSegment>, <class 'sqlfluff.core.parser.segments.base.BracketedSegment'>], opts=[<Ref: BinaryOperatorGrammar>]]
INFO       [PD:3  MD:16]	................BinaryOperatorGrammar             	OneOf.match PRN     	    	[ns=1, ps=3, ms=0, pruned=[<Ref: ArithmeticBinaryOperatorGrammar>, <Ref: StringBinaryOperatorGrammar>, <Ref: BooleanBinaryOperatorGrammar>], opts=[<Ref: ComparisonOperatorGrammar>]]
INFO       [PD:3  MD:17]	.................ComparisonOperatorGrammar        	OneOf.match PRN     	    	[ns=1, ps=7, ms=0, pruned=[<Ref: EqualsSegment>, <Ref: GreaterThanSegment>, <Ref: LessThanSegment>, <Ref: GreaterThanOrEqualToSegment>, <Ref: LessThanOrEqualToSegment>, <Ref: NotEqualToSegment_a>, <Ref: NotEqualToSegment_b>], opts=[<Ref: LikeOperatorSegment>]]
DEBUG      [PD:3  MD:18]	..................ComparisonOperatorGrammar       	Ref.match OUT       	    	[match=<MatchResult 0/15: ''>, seg="'c ON (tbl.id = c.id)...'"]
INFO       [PD:3  MD:17]	.................ComparisonOperatorGrammar        	OneOf.match OUT     	    	[match=<MatchResult 0/15: ''>, seg="'c ON (tbl.id = c.id)...'"]
DEBUG      [PD:3  MD:17]	.................BinaryOperatorGrammar            	Ref.match OUT       	    	[match=<MatchResult 0/15: ''>, seg="'c ON (tbl.id = c.id)...'"]
INFO       [PD:3  MD:16]	................BinaryOperatorGrammar             	OneOf.match OUT     	    	[match=<MatchResult 0/15: ''>, seg="'c ON (tbl.id = c.id)...'"]
DEBUG      [PD:3  MD:16]	................TableReferenceSegment             	Ref.match OUT       	    	[match=<MatchResult 0/15: ''>, seg="'c ON (tbl.id = c.id)...'"]
INFO       [PD:3  MD:15]	...............TableReferenceSegment              	OneOf.match OUT     	    	[match=<MatchResult 0/15: ''>, seg="'c ON (tbl.id = c.id)...'"]
DEBUG      [PD:3  MD:15]	...............TableReferenceSegment              	NonCo.match OUT     	    	[match=<MatchResult 0/15: ''>, seg="'c ON (tbl.id = c.id)...'"]
INFO       [PD:3  MD:15]	...............TableReferenceSegment              	OneOf.match PRN     	    	[ns=1, ps=9, ms=1, pruned=[<Ref: AsKeywordSegment>, <Ref: UsingKeywordSegment>, <Ref: CommaSegment>, <Ref: CastOperatorSegment>, <Ref: StartSquareBracketSegment>, <Ref: StartBracketSegment>, <Ref: ColonSegment>, <Ref: DelimiterSegment>, <class 'sqlfluff.core.parser.segments.base.BracketedSegment'>], opts=[<Ref: OnKeywordSegment>, <Ref: BinaryOperatorGrammar>]]
DEBUG      [PD:3  MD:16]	................TableReferenceSegment             	Ref.match OUT       	    	[match=<MatchResult 0/14: ''>, seg="' ON (tbl.id = c.id)\\n...'"]
INFO       [PD:3  MD:16]	................BinaryOperatorGrammar             	OneOf.match PRN     	    	[ns=1, ps=3, ms=0, pruned=[<Ref: ArithmeticBinaryOperatorGrammar>, <Ref: StringBinaryOperatorGrammar>, <Ref: BooleanBinaryOperatorGrammar>], opts=[<Ref: ComparisonOperatorGrammar>]]
INFO       [PD:3  MD:17]	.................ComparisonOperatorGrammar        	OneOf.match PRN     	    	[ns=1, ps=7, ms=0, pruned=[<Ref: EqualsSegment>, <Ref: GreaterThanSegment>, <Ref: LessThanSegment>, <Ref: GreaterThanOrEqualToSegment>, <Ref: LessThanOrEqualToSegment>, <Ref: NotEqualToSegment_a>, <Ref: NotEqualToSegment_b>], opts=[<Ref: LikeOperatorSegment>]]
DEBUG      [PD:3  MD:18]	..................ComparisonOperatorGrammar       	Ref.match OUT       	    	[match=<MatchResult 0/14: ''>, seg="' ON (tbl.id = c.id)\\n...'"]
INFO       [PD:3  MD:17]	.................ComparisonOperatorGrammar        	OneOf.match OUT     	    	[match=<MatchResult 0/14: ''>, seg="' ON (tbl.id = c.id)\\n...'"]
DEBUG      [PD:3  MD:17]	.................BinaryOperatorGrammar            	Ref.match OUT       	    	[match=<MatchResult 0/14: ''>, seg="' ON (tbl.id = c.id)\\n...'"]
INFO       [PD:3  MD:16]	................BinaryOperatorGrammar             	OneOf.match OUT     	    	[match=<MatchResult 0/14: ''>, seg="' ON (tbl.id = c.id)\\n...'"]
DEBUG      [PD:3  MD:16]	................TableReferenceSegment             	Ref.match OUT       	    	[match=<MatchResult 0/14: ''>, seg="' ON (tbl.id = c.id)\\n...'"]
INFO       [PD:3  MD:15]	...............TableReferenceSegment              	OneOf.match OUT     	    	[match=<MatchResult 0/14: ''>, seg="' ON (tbl.id = c.id)\\n...'"]
DEBUG      [PD:3  MD:15]	...............TableReferenceSegment              	NonCo.match OUT     	+   	[match=<MatchResult 1/14: ' '>, seg="' ON (tbl.id = c.id)\\n...'"]
INFO       [PD:3  MD:15]	...............SingleIdentifierGrammar            	OneOf.match PRN     	    	[ns=2, ps=0, ms=0, pruned=[], opts=[<Ref: NakedIdentifierSegment>, <Ref: QuotedIdentifierSegment>]]
DEBUG      [PD:3  MD:16]	................SingleIdentifierGrammar           	Ref.match OUT       	++  	[match=<MatchResult 1/1: 'c'>, seg="'c'"]
INFO       [PD:3  MD:15]	...............SingleIdentifierGrammar            	OneOf.match OUT     	++  	[match=<MatchResult 1/1: 'c'>, seg="'c'"]
DEBUG      [PD:3  MD:15]	...............TableReferenceSegment              	Ref.match OUT       	++  	[match=<MatchResult 1/1: 'c'>, seg="'c'"]
INFO       [PD:3  MD:14]	..............TableReferenceSegment               	Delim.match OUT     	+   	[match=<MatchResult 1/15: 'c'>, seg="'c ON (tbl.id = c.id)...'"]
DEBUG      [PD:3  MD:13]	.............TableReferenceSegment                	Table.match OUT     	+   	[match=<MatchResult 1/15: 'c'>, seg="'c ON (tbl.id = c.id)...'"]
DEBUG      [PD:3  MD:13]	.............TableExpressionSegment               	Ref.match OUT       	+   	[match=<MatchResult 1/15: 'c'>, seg="'c ON (tbl.id = c.id)...'"]
INFO       [PD:3  MD:12]	............TableExpressionSegment                	OneOf.match OUT     	+   	[match=<MatchResult 1/15: 'c'>, seg="'c ON (tbl.id = c.id)...'"]
DEBUG      [PD:3  MD:11]	...........TableExpressionSegment                 	Table.match OUT     	+   	[match=<MatchResult 1/15: 'c'>, seg="'c ON (tbl.id = c.id)...'"]
DEBUG      [PD:3  MD:11]	...........FromExpressionElementSegment           	Ref.match OUT       	+   	[match=<MatchResult 1/15: 'c'>, seg="'c ON (tbl.id = c.id)...'"]
INFO       [PD:3  MD:10]	..........FromExpressionElementSegment            	Optio.match OUT     	+   	[match=<MatchResult 1/15: 'c'>, seg="'c ON (tbl.id = c.id)...'"]
DEBUG      [PD:3  MD:11]	...........FromExpressionElementSegment           	Ref.match OUT       	    	[match=<MatchResult 0/13: ''>, seg="'ON (tbl.id = c.id)\\nL...'"]
INFO       [PD:3  MD:10]	..........FromExpressionElementSegment            	Seque.match OUT     	    	[match=<MatchResult 0/13: ''>, seg="'ON (tbl.id = c.id)\\nL...'"]
DEBUG      [PD:3  MD:12]	............AliasExpressionSegment                	Ref.match OUT       	    	[match=<MatchResult 0/13: ''>, seg="'ON (tbl.id = c.id)\\nL...'"]
INFO       [PD:3  MD:12]	............AliasExpressionSegment                	OneOf.match PRN     	    	[ns=2, ps=0, ms=0, pruned=[], opts=[<Sequence: [<Ref: SingleIdentifierGrammar>, <Bracketed: [<Ref: SingleIdentifierListS...]>, <Ref: QuotedLiteralSegment>]]
INFO       [PD:3  MD:14]	..............SingleIdentifierGrammar             	OneOf.match PRN     	    	[ns=2, ps=0, ms=0, pruned=[], opts=[<Ref: NakedIdentifierSegment>, <Ref: QuotedIdentifierSegment>]]
DEBUG      [PD:3  MD:15]	...............SingleIdentifierGrammar            	Ref.match OUT       	    	[match=<MatchResult 0/13: ''>, seg="'ON (tbl.id = c.id)\\nL...'"]
DEBUG      [PD:3  MD:15]	...............SingleIdentifierGrammar            	Ref.match OUT       	    	[match=<MatchResult 0/13: ''>, seg="'ON (tbl.id = c.id)\\nL...'"]
INFO       [PD:3  MD:14]	..............SingleIdentifierGrammar             	OneOf.match OUT     	    	[match=<MatchResult 0/13: ''>, seg="'ON (tbl.id = c.id)\\nL...'"]
DEBUG      [PD:3  MD:14]	..............AliasExpressionSegment              	Ref.match OUT       	    	[match=<MatchResult 0/13: ''>, seg="'ON (tbl.id = c.id)\\nL...'"]
INFO       [PD:3  MD:13]	.............AliasExpressionSegment               	Seque.match OUT     	    	[match=<MatchResult 0/13: ''>, seg="'ON (tbl.id = c.id)\\nL...'"]
DEBUG      [PD:3  MD:13]	.............AliasExpressionSegment               	Ref.match OUT       	    	[match=<MatchResult 0/13: ''>, seg="'ON (tbl.id = c.id)\\nL...'"]
INFO       [PD:3  MD:12]	............AliasExpressionSegment                	OneOf.match OUT     	    	[match=<MatchResult 0/13: ''>, seg="'ON (tbl.id = c.id)\\nL...'"]
INFO       [PD:3  MD:11]	...........AliasExpressionSegment                 	Seque.match OUT     	    	[match=<MatchResult 0/13: ''>, seg="'ON (tbl.id = c.id)\\nL...'"]
DEBUG      [PD:3  MD:10]	..........AliasExpressionSegment                  	Alias.match OUT     	    	[match=<MatchResult 0/13: ''>, seg="'ON (tbl.id = c.id)\\nL...'"]
DEBUG      [PD:3  MD:10]	..........FromExpressionElementSegment            	Ref.match OUT       	    	[match=<MatchResult 0/13: ''>, seg="'ON (tbl.id = c.id)\\nL...'"]
DEBUG      [PD:3  MD:10]	..........FromExpressionElementSegment            	Ref.match OUT       	    	[match=<MatchResult 0/13: ''>, seg="'ON (tbl.id = c.id)\\nL...'"]
INFO       [PD:3  MD:9 ]	.........FromExpressionElementSegment             	Seque.match OUT     	+   	[match=<MatchResult 1/15: 'c'>, seg="'c ON (tbl.id = c.id)...'"]
DEBUG      [PD:3  MD:8 ]	........FromExpressionElementSegment              	FromE.match OUT     	+   	[match=<MatchResult 1/15: 'c'>, seg="'c ON (tbl.id = c.id)...'"]
DEBUG      [PD:3  MD:8 ]	........JoinClauseSegment                         	Ref.match OUT       	+   	[match=<MatchResult 1/15: 'c'>, seg="'c ON (tbl.id = c.id)...'"]
INFO       [PD:3  MD:8 ]	........JoinClauseSegment                         	OneOf.match PRN     	    	[ns=0, ps=1, ms=1, pruned=[<Sequence: [<Ref: UsingKeywordSegment>, <class 'sqlfluff.core.parser.segments.me..., <Bracketed: [<Delimited: [<...]>], opts=[<Ref: JoinOnConditionSegment>]]
DEBUG      [PD:3  MD:11]	...........JoinOnConditionSegment                 	Ref.match OUT       	+   	[match=<MatchResult 1/13: 'ON'>, seg="'ON (tbl.id = c.id)\\nL...'"]
INFO       [PD:3  MD:11]	...........JoinOnConditionSegment                 	Optio.match PRN     	    	[ns=1, ps=0, ms=1, pruned=[], opts=[<Bracketed: [<Ref: ExpressionSegment>]>, <Ref: ExpressionSegment>]]
INFO       [PD:3  MD:16]	................Expression_A_Grammar              	OneOf.match PRN     	    	[ns=1, ps=1, ms=0, pruned=[<Sequence: [<OneOf: [<Ref: PositiveSegment>, <Ref: N..., <Ref: Expression_C_Grammar>]>], opts=[<Ref: Expression_C_Grammar>]]
INFO       [PD:3  MD:17]	.................Expression_C_Grammar             	OneOf.match PRN     	    	[ns=1, ps=2, ms=0, pruned=[<Sequence: [<Ref: ExistsKeywordSegment>, <Bracketed: [<Ref: SelectStatementSegmen...]>, <Ref: CaseExpressionSegment>], opts=[<Ref: Expression_D_Grammar>]]
INFO       [PD:3  MD:19]	...................Expression_D_Grammar           	OneOf.match PRN     	    	[ns=6, ps=3, ms=0, pruned=[<Bracketed: [<OneOf: [<Ref: ExpressionSegment>, <Ref:...]>, <Ref: SelectStatementSegment>, <Ref: IntervalExpressionSegment>], opts=[<Ref: BareFunctionSegment>, <Ref: FunctionSegment>, <Ref: LiteralGrammar>, <Ref: ColumnReferenceSegment>, <Sequence: [<Ref: SimpleArrayTypeGrammar [opt]>, <Ref: ArrayLiteralSegment>]>, <Sequence: [<Ref: DatatypeSegment>, <OneOf: [<Ref: QuotedLiteralSegment>, <R...]>]]
DEBUG      [PD:3  MD:20]	....................Expression_D_Grammar          	Ref.match OUT       	    	[match=<MatchResult 0/9: ''>, seg="'tbl.id = c.id'"]
INFO       [PD:3  MD:21]	.....................FunctionSegment              	OneOf.match PRN     	    	[ns=1, ps=1, ms=0, pruned=[<Sequence: [<Sequence: [<Ref: DateAddFunctionNameSeg...]>], opts=[<Sequence: [<Sequence: [<AnyNumberOf: [<Ref: Functio..., <Ref: PostFunctionGrammar [opt]>]>]]
DEBUG      [PD:3  MD:27]	...........................DateAddFunctionNameSegment	Ref.match OUT       	    	[match=<MatchResult 0/9: ''>, seg="'tbl.id = c.id'"]
INFO       [PD:3  MD:26]	..........................DateAddFunctionNameSegment	Seque.match OUT     	    	[match=<MatchResult 0/9: ''>, seg="'tbl.id = c.id'"]
DEBUG      [PD:3  MD:25]	.........................DateAddFunctionNameSegment	DateA.match OUT     	    	[match=<MatchResult 0/9: ''>, seg="'tbl.id = c.id'"]
DEBUG      [PD:3  MD:25]	.........................FunctionSegment          	Ref.match OUT       	    	[match=<MatchResult 0/9: ''>, seg="'tbl.id = c.id'"]
INFO       [PD:3  MD:24]	........................FunctionSegment           	AnyNu.match PRN     	    	[ns=1, ps=0, ms=0, pruned=[], opts=[<Ref: FunctionNameSegment>]]
INFO       [PD:3  MD:27]	...........................FunctionNameSegment    	AnyNu.match PRN     	    	[ns=1, ps=0, ms=0, pruned=[], opts=[<Sequence: [<Ref: SingleIdentifierGrammar>, <Ref: DotSegment>]>]]
INFO       [PD:3  MD:29]	.............................SingleIdentifierGrammar	OneOf.match PRN     	    	[ns=2, ps=0, ms=0, pruned=[], opts=[<Ref: NakedIdentifierSegment>, <Ref: QuotedIdentifierSegment>]]
DEBUG      [PD:3  MD:30]	..............................SingleIdentifierGrammar	Ref.match OUT       	+   	[match=<MatchResult 1/9: 'tbl'>, seg="'tbl.id = c.id'"]
DEBUG      [PD:3  MD:30]	..............................SingleIdentifierGrammar	Ref.match OUT       	    	[match=<MatchResult 0/9: ''>, seg="'tbl.id = c.id'"]
INFO       [PD:3  MD:29]	.............................SingleIdentifierGrammar	OneOf.match OUT     	+   	[match=<MatchResult 1/9: 'tbl'>, seg="'tbl.id = c.id'"]
DEBUG      [PD:3  MD:29]	.............................FunctionNameSegment  	Ref.match OUT       	+   	[match=<MatchResult 1/9: 'tbl'>, seg="'tbl.id = c.id'"]
DEBUG      [PD:3  MD:29]	.............................FunctionNameSegment  	Ref.match OUT       	+   	[match=<MatchResult 1/8: '.'>, seg="'.id = c.id'"]
INFO       [PD:3  MD:28]	............................FunctionNameSegment   	Seque.match OUT     	+   	[match=<MatchResult 2/9: 'tbl.'>, seg="'tbl.id = c.id'"]
INFO       [PD:3  MD:27]	...........................FunctionNameSegment    	AnyNu.match PRN     	    	[ns=1, ps=0, ms=0, pruned=[], opts=[<Sequence: [<Ref: SingleIdentifierGrammar>, <Ref: DotSegment>]>]]
INFO       [PD:3  MD:29]	.............................SingleIdentifierGrammar	OneOf.match PRN     	    	[ns=2, ps=0, ms=0, pruned=[], opts=[<Ref: NakedIdentifierSegment>, <Ref: QuotedIdentifierSegment>]]
DEBUG      [PD:3  MD:30]	..............................SingleIdentifierGrammar	Ref.match OUT       	+   	[match=<MatchResult 1/7: 'id'>, seg="'id = c.id'"]
DEBUG      [PD:3  MD:30]	..............................SingleIdentifierGrammar	Ref.match OUT       	    	[match=<MatchResult 0/7: ''>, seg="'id = c.id'"]
INFO       [PD:3  MD:29]	.............................SingleIdentifierGrammar	OneOf.match OUT     	+   	[match=<MatchResult 1/7: 'id'>, seg="'id = c.id'"]
DEBUG      [PD:3  MD:29]	.............................FunctionNameSegment  	Ref.match OUT       	+   	[match=<MatchResult 1/7: 'id'>, seg="'id = c.id'"]
DEBUG      [PD:3  MD:29]	.............................FunctionNameSegment  	Ref.match OUT       	    	[match=<MatchResult 0/5: ''>, seg="'= c.id'"]
INFO       [PD:3  MD:28]	............................FunctionNameSegment   	Seque.match OUT     	    	[match=<MatchResult 0/7: ''>, seg="'id = c.id'"]
INFO       [PD:3  MD:27]	...........................FunctionNameSegment    	AnyNu.match OUT     	+   	[match=<MatchResult 2/9: 'tbl.'>, seg="'tbl.id = c.id'"]
INFO       [PD:3  MD:27]	...........................FunctionNameSegment    	OneOf.match PRN     	    	[ns=2, ps=0, ms=0, pruned=[], opts=[<Ref: FunctionNameIdentifierSegment>, <Ref: QuotedIdentifierSegment>]]
DEBUG      [PD:3  MD:28]	............................FunctionNameSegment   	Ref.match OUT       	+   	[match=<MatchResult 1/7: 'id'>, seg="'id = c.id'"]
DEBUG      [PD:3  MD:28]	............................FunctionNameSegment   	Ref.match OUT       	    	[match=<MatchResult 0/7: ''>, seg="'id = c.id'"]
INFO       [PD:3  MD:27]	...........................FunctionNameSegment    	OneOf.match OUT     	+   	[match=<MatchResult 1/7: 'id'>, seg="'id = c.id'"]
INFO       [PD:3  MD:26]	..........................FunctionNameSegment     	Seque.match OUT     	+   	[match=<MatchResult 3/9: 'tbl.id'>, seg="'tbl.id = c.id'"]
DEBUG      [PD:3  MD:25]	.........................FunctionNameSegment      	Funct.match OUT     	+   	[match=<MatchResult 1/7: 'tbl.id'>, seg="'tbl.id = c.id'"]
DEBUG      [PD:3  MD:25]	.........................FunctionSegment          	Ref.match OUT       	+   	[match=<MatchResult 1/7: 'tbl.id'>, seg="'tbl.id = c.id'"]
INFO       [PD:3  MD:24]	........................FunctionSegment           	AnyNu.match OUT     	+   	[match=<MatchResult 1/7: 'tbl.id'>, seg="'tbl.id = c.id'"]
INFO       [PD:3  MD:24]	........................FunctionSegment           	Brack.match OUT     	    	[match=<MatchResult 0/5: ''>, seg="'= c.id'"]
INFO       [PD:3  MD:23]	.......................FunctionSegment            	Seque.match OUT     	    	[match=<MatchResult 0/9: ''>, seg="'tbl.id = c.id'"]
INFO       [PD:3  MD:22]	......................FunctionSegment             	Seque.match OUT     	    	[match=<MatchResult 0/9: ''>, seg="'tbl.id = c.id'"]
INFO       [PD:3  MD:21]	.....................FunctionSegment              	OneOf.match OUT     	    	[match=<MatchResult 0/9: ''>, seg="'tbl.id = c.id'"]
DEBUG      [PD:3  MD:20]	....................FunctionSegment               	Funct.match OUT     	    	[match=<MatchResult 0/9: ''>, seg="'tbl.id = c.id'"]
DEBUG      [PD:3  MD:20]	....................Expression_D_Grammar          	Ref.match OUT       	    	[match=<MatchResult 0/9: ''>, seg="'tbl.id = c.id'"]
INFO       [PD:3  MD:20]	....................LiteralGrammar                	OneOf.match PRN     	    	[ns=2, ps=4, ms=0, pruned=[<Ref: BooleanLiteralGrammar>, <Ref: QualifiedNumericLiteralSegment>, <Ref: NullLiteralSegment>, <Ref: DateTimeLiteralGrammar>], opts=[<Ref: QuotedLiteralSegment>, <Ref: NumericLiteralSegment>]]
DEBUG      [PD:3  MD:21]	.....................LiteralGrammar               	Ref.match OUT       	    	[match=<MatchResult 0/9: ''>, seg="'tbl.id = c.id'"]
DEBUG      [PD:3  MD:21]	.....................LiteralGrammar               	Ref.match OUT       	    	[match=<MatchResult 0/9: ''>, seg="'tbl.id = c.id'"]
INFO       [PD:3  MD:20]	....................LiteralGrammar                	OneOf.match OUT     	    	[match=<MatchResult 0/9: ''>, seg="'tbl.id = c.id'"]
DEBUG      [PD:3  MD:20]	....................Expression_D_Grammar          	Ref.match OUT       	    	[match=<MatchResult 0/9: ''>, seg="'tbl.id = c.id'"]
DEBUG      [PD:3  MD:22]	......................ColumnReferenceSegment      	Delim._look_ahead_match IN	    	[ls=9, seg='tbl.id = c.id']
DEBUG      [PD:3  MD:22]	......................ColumnReferenceSegment      	Delim._look_ahead_match SI	    	[mq=[(<OneOf: [<Ref: DotSegment>, <Sequence: [<Ref: DotSegment>, <Ref: Dot...]>, 1, '.'), (<OneOf: [<Ref: DotSegment>, <Sequence: [<Ref: DotSegment>, <Ref: Dot...]>, 1, '.'), (<OneOf: [<Ref: DotSegment>, <Sequence: [<Ref: DotSegment>, <Ref: Dot...]>, 7, '.'), (<OneOf: [<Ref: DotSegment>, <Sequence: [<Ref: DotSegment>, <Ref: Dot...]>, 7, '.')], sb=['TBL', '.', 'ID', '', '=', '', 'C', '.', 'ID']]
INFO       [PD:3  MD:22]	......................ColumnReferenceSegment      	OneOf.match PRN     	    	[ns=0, ps=0, ms=2, pruned=[], opts=[<Ref: DotSegment>, <Sequence: [<Ref: DotSegment>, <Ref: DotSegment>]>]]
DEBUG      [PD:3  MD:23]	.......................ColumnReferenceSegment     	Ref.match OUT       	+   	[match=<MatchResult 1/2: '.'>, seg="'.id'"]
DEBUG      [PD:3  MD:24]	........................ColumnReferenceSegment    	Ref.match OUT       	+   	[match=<MatchResult 1/2: '.'>, seg="'.id'"]
DEBUG      [PD:3  MD:24]	........................ColumnReferenceSegment    	Ref.match OUT       	    	[match=<MatchResult 0/1: ''>, seg="'id'"]
INFO       [PD:3  MD:23]	.......................ColumnReferenceSegment     	Seque.match OUT     	    	[match=<MatchResult 0/2: ''>, seg="'.id'"]
INFO       [PD:3  MD:22]	......................ColumnReferenceSegment      	OneOf.match OUT     	+   	[match=<MatchResult 1/2: '.'>, seg="'.id'"]
INFO       [PD:3  MD:22]	......................ColumnReferenceSegment      	OneOf.match PRN     	    	[ns=0, ps=0, ms=2, pruned=[], opts=[<Ref: DotSegment>, <Sequence: [<Ref: DotSegment>, <Ref: DotSegment>]>]]
DEBUG      [PD:3  MD:23]	.......................ColumnReferenceSegment     	Ref.match OUT       	+   	[match=<MatchResult 1/2: '.'>, seg="'.id'"]
DEBUG      [PD:3  MD:24]	........................ColumnReferenceSegment    	Ref.match OUT       	+   	[match=<MatchResult 1/2: '.'>, seg="'.id'"]
DEBUG      [PD:3  MD:24]	........................ColumnReferenceSegment    	Ref.match OUT       	    	[match=<MatchResult 0/1: ''>, seg="'id'"]
INFO       [PD:3  MD:23]	.......................ColumnReferenceSegment     	Seque.match OUT     	    	[match=<MatchResult 0/2: ''>, seg="'.id'"]
INFO       [PD:3  MD:22]	......................ColumnReferenceSegment      	OneOf.match OUT     	+   	[match=<MatchResult 1/2: '.'>, seg="'.id'"]
INFO       [PD:3  MD:22]	......................ColumnReferenceSegment      	OneOf.match PRN     	    	[ns=0, ps=0, ms=2, pruned=[], opts=[<Ref: DotSegment>, <Sequence: [<Ref: DotSegment>, <Ref: DotSegment>]>]]
DEBUG      [PD:3  MD:23]	.......................ColumnReferenceSegment     	Ref.match OUT       	+   	[match=<MatchResult 1/8: '.'>, seg="'.id = c.id'"]
DEBUG      [PD:3  MD:24]	........................ColumnReferenceSegment    	Ref.match OUT       	+   	[match=<MatchResult 1/8: '.'>, seg="'.id = c.id'"]
DEBUG      [PD:3  MD:24]	........................ColumnReferenceSegment    	Ref.match OUT       	    	[match=<MatchResult 0/7: ''>, seg="'id = c.id'"]
INFO       [PD:3  MD:23]	.......................ColumnReferenceSegment     	Seque.match OUT     	    	[match=<MatchResult 0/8: ''>, seg="'.id = c.id'"]
INFO       [PD:3  MD:22]	......................ColumnReferenceSegment      	OneOf.match OUT     	+   	[match=<MatchResult 1/8: '.'>, seg="'.id = c.id'"]
INFO       [PD:3  MD:22]	......................ColumnReferenceSegment      	OneOf.match PRN     	    	[ns=0, ps=0, ms=2, pruned=[], opts=[<Ref: DotSegment>, <Sequence: [<Ref: DotSegment>, <Ref: DotSegment>]>]]
DEBUG      [PD:3  MD:23]	.......................ColumnReferenceSegment     	Ref.match OUT       	+   	[match=<MatchResult 1/8: '.'>, seg="'.id = c.id'"]
DEBUG      [PD:3  MD:24]	........................ColumnReferenceSegment    	Ref.match OUT       	+   	[match=<MatchResult 1/8: '.'>, seg="'.id = c.id'"]
DEBUG      [PD:3  MD:24]	........................ColumnReferenceSegment    	Ref.match OUT       	    	[match=<MatchResult 0/7: ''>, seg="'id = c.id'"]
INFO       [PD:3  MD:23]	.......................ColumnReferenceSegment     	Seque.match OUT     	    	[match=<MatchResult 0/8: ''>, seg="'.id = c.id'"]
INFO       [PD:3  MD:22]	......................ColumnReferenceSegment      	OneOf.match OUT     	+   	[match=<MatchResult 1/8: '.'>, seg="'.id = c.id'"]
INFO       [PD:3  MD:22]	......................ColumnReferenceSegment      	OneOf.match PRN     	    	[ns=1, ps=10, ms=0, pruned=[<Ref: OnKeywordSegment>, <Ref: AsKeywordSegment>, <Ref: UsingKeywordSegment>, <Ref: CommaSegment>, <Ref: CastOperatorSegment>, <Ref: StartSquareBracketSegment>, <Ref: StartBracketSegment>, <Ref: ColonSegment>, <Ref: DelimiterSegment>, <class 'sqlfluff.core.parser.segments.base.BracketedSegment'>], opts=[<Ref: BinaryOperatorGrammar>]]
INFO       [PD:3  MD:23]	.......................BinaryOperatorGrammar      	OneOf.match PRN     	    	[ns=1, ps=3, ms=0, pruned=[<Ref: ArithmeticBinaryOperatorGrammar>, <Ref: StringBinaryOperatorGrammar>, <Ref: BooleanBinaryOperatorGrammar>], opts=[<Ref: ComparisonOperatorGrammar>]]
INFO       [PD:3  MD:24]	........................ComparisonOperatorGrammar 	OneOf.match PRN     	    	[ns=1, ps=7, ms=0, pruned=[<Ref: EqualsSegment>, <Ref: GreaterThanSegment>, <Ref: LessThanSegment>, <Ref: GreaterThanOrEqualToSegment>, <Ref: LessThanOrEqualToSegment>, <Ref: NotEqualToSegment_a>, <Ref: NotEqualToSegment_b>], opts=[<Ref: LikeOperatorSegment>]]
DEBUG      [PD:3  MD:25]	.........................ComparisonOperatorGrammar	Ref.match OUT       	    	[match=<MatchResult 0/9: ''>, seg="'tbl.id = c.id'"]
INFO       [PD:3  MD:24]	........................ComparisonOperatorGrammar 	OneOf.match OUT     	    	[match=<MatchResult 0/9: ''>, seg="'tbl.id = c.id'"]
DEBUG      [PD:3  MD:24]	........................BinaryOperatorGrammar     	Ref.match OUT       	    	[match=<MatchResult 0/9: ''>, seg="'tbl.id = c.id'"]
INFO       [PD:3  MD:23]	.......................BinaryOperatorGrammar      	OneOf.match OUT     	    	[match=<MatchResult 0/9: ''>, seg="'tbl.id = c.id'"]
DEBUG      [PD:3  MD:23]	.......................ColumnReferenceSegment     	Ref.match OUT       	    	[match=<MatchResult 0/9: ''>, seg="'tbl.id = c.id'"]
INFO       [PD:3  MD:22]	......................ColumnReferenceSegment      	OneOf.match OUT     	    	[match=<MatchResult 0/9: ''>, seg="'tbl.id = c.id'"]
DEBUG      [PD:3  MD:22]	......................ColumnReferenceSegment      	NonCo.match OUT     	    	[match=<MatchResult 0/9: ''>, seg="'tbl.id = c.id'"]
INFO       [PD:3  MD:22]	......................ColumnReferenceSegment      	OneOf.match PRN     	    	[ns=1, ps=10, ms=0, pruned=[<Ref: OnKeywordSegment>, <Ref: AsKeywordSegment>, <Ref: UsingKeywordSegment>, <Ref: CommaSegment>, <Ref: CastOperatorSegment>, <Ref: StartSquareBracketSegment>, <Ref: StartBracketSegment>, <Ref: ColonSegment>, <Ref: DelimiterSegment>, <class 'sqlfluff.core.parser.segments.base.BracketedSegment'>], opts=[<Ref: BinaryOperatorGrammar>]]
INFO       [PD:3  MD:23]	.......................BinaryOperatorGrammar      	OneOf.match PRN     	    	[ns=1, ps=3, ms=0, pruned=[<Ref: ArithmeticBinaryOperatorGrammar>, <Ref: StringBinaryOperatorGrammar>, <Ref: BooleanBinaryOperatorGrammar>], opts=[<Ref: ComparisonOperatorGrammar>]]
INFO       [PD:3  MD:24]	........................ComparisonOperatorGrammar 	OneOf.match PRN     	    	[ns=1, ps=7, ms=0, pruned=[<Ref: EqualsSegment>, <Ref: GreaterThanSegment>, <Ref: LessThanSegment>, <Ref: GreaterThanOrEqualToSegment>, <Ref: LessThanOrEqualToSegment>, <Ref: NotEqualToSegment_a>, <Ref: NotEqualToSegment_b>], opts=[<Ref: LikeOperatorSegment>]]
DEBUG      [PD:3  MD:25]	.........................ComparisonOperatorGrammar	Ref.match OUT       	    	[match=<MatchResult 0/8: ''>, seg="'.id = c.id'"]
INFO       [PD:3  MD:24]	........................ComparisonOperatorGrammar 	OneOf.match OUT     	    	[match=<MatchResult 0/8: ''>, seg="'.id = c.id'"]
DEBUG      [PD:3  MD:24]	........................BinaryOperatorGrammar     	Ref.match OUT       	    	[match=<MatchResult 0/8: ''>, seg="'.id = c.id'"]
INFO       [PD:3  MD:23]	.......................BinaryOperatorGrammar      	OneOf.match OUT     	    	[match=<MatchResult 0/8: ''>, seg="'.id = c.id'"]
DEBUG      [PD:3  MD:23]	.......................ColumnReferenceSegment     	Ref.match OUT       	    	[match=<MatchResult 0/8: ''>, seg="'.id = c.id'"]
INFO       [PD:3  MD:22]	......................ColumnReferenceSegment      	OneOf.match OUT     	    	[match=<MatchResult 0/8: ''>, seg="'.id = c.id'"]
DEBUG      [PD:3  MD:22]	......................ColumnReferenceSegment      	NonCo.match OUT     	    	[match=<MatchResult 0/8: ''>, seg="'.id = c.id'"]
INFO       [PD:3  MD:22]	......................SingleIdentifierGrammar     	OneOf.match PRN     	    	[ns=2, ps=0, ms=0, pruned=[], opts=[<Ref: NakedIdentifierSegment>, <Ref: QuotedIdentifierSegment>]]
DEBUG      [PD:3  MD:23]	.......................SingleIdentifierGrammar    	Ref.match OUT       	++  	[match=<MatchResult 1/1: 'tbl'>, seg="'tbl'"]
INFO       [PD:3  MD:22]	......................SingleIdentifierGrammar     	OneOf.match OUT     	++  	[match=<MatchResult 1/1: 'tbl'>, seg="'tbl'"]
DEBUG      [PD:3  MD:22]	......................ColumnReferenceSegment      	Ref.match OUT       	++  	[match=<MatchResult 1/1: 'tbl'>, seg="'tbl'"]
DEBUG      [PD:3  MD:22]	......................ColumnReferenceSegment      	Delim._look_ahead_match IN	    	[ls=7, seg='id = c.id']
DEBUG      [PD:3  MD:22]	......................ColumnReferenceSegment      	Delim._look_ahead_match SI	    	[mq=[(<OneOf: [<Ref: DotSegment>, <Sequence: [<Ref: DotSegment>, <Ref: Dot...]>, 5, '.'), (<OneOf: [<Ref: DotSegment>, <Sequence: [<Ref: DotSegment>, <Ref: Dot...]>, 5, '.')], sb=['ID', '', '=', '', 'C', '.', 'ID']]
INFO       [PD:3  MD:22]	......................ColumnReferenceSegment      	OneOf.match PRN     	    	[ns=0, ps=0, ms=2, pruned=[], opts=[<Ref: DotSegment>, <Sequence: [<Ref: DotSegment>, <Ref: DotSegment>]>]]
DEBUG      [PD:3  MD:23]	.......................ColumnReferenceSegment     	Ref.match OUT       	+   	[match=<MatchResult 1/2: '.'>, seg="'.id'"]
DEBUG      [PD:3  MD:24]	........................ColumnReferenceSegment    	Ref.match OUT       	+   	[match=<MatchResult 1/2: '.'>, seg="'.id'"]
DEBUG      [PD:3  MD:24]	........................ColumnReferenceSegment    	Ref.match OUT       	    	[match=<MatchResult 0/1: ''>, seg="'id'"]
INFO       [PD:3  MD:23]	.......................ColumnReferenceSegment     	Seque.match OUT     	    	[match=<MatchResult 0/2: ''>, seg="'.id'"]
INFO       [PD:3  MD:22]	......................ColumnReferenceSegment      	OneOf.match OUT     	+   	[match=<MatchResult 1/2: '.'>, seg="'.id'"]
INFO       [PD:3  MD:22]	......................ColumnReferenceSegment      	OneOf.match PRN     	    	[ns=0, ps=0, ms=2, pruned=[], opts=[<Ref: DotSegment>, <Sequence: [<Ref: DotSegment>, <Ref: DotSegment>]>]]
DEBUG      [PD:3  MD:23]	.......................ColumnReferenceSegment     	Ref.match OUT       	+   	[match=<MatchResult 1/2: '.'>, seg="'.id'"]
DEBUG      [PD:3  MD:24]	........................ColumnReferenceSegment    	Ref.match OUT       	+   	[match=<MatchResult 1/2: '.'>, seg="'.id'"]
DEBUG      [PD:3  MD:24]	........................ColumnReferenceSegment    	Ref.match OUT       	    	[match=<MatchResult 0/1: ''>, seg="'id'"]
INFO       [PD:3  MD:23]	.......................ColumnReferenceSegment     	Seque.match OUT     	    	[match=<MatchResult 0/2: ''>, seg="'.id'"]
INFO       [PD:3  MD:22]	......................ColumnReferenceSegment      	OneOf.match OUT     	+   	[match=<MatchResult 1/2: '.'>, seg="'.id'"]
INFO       [PD:3  MD:22]	......................ColumnReferenceSegment      	OneOf.match PRN     	    	[ns=1, ps=10, ms=0, pruned=[<Ref: OnKeywordSegment>, <Ref: AsKeywordSegment>, <Ref: UsingKeywordSegment>, <Ref: CommaSegment>, <Ref: CastOperatorSegment>, <Ref: StartSquareBracketSegment>, <Ref: StartBracketSegment>, <Ref: ColonSegment>, <Ref: DelimiterSegment>, <class 'sqlfluff.core.parser.segments.base.BracketedSegment'>], opts=[<Ref: BinaryOperatorGrammar>]]
INFO       [PD:3  MD:23]	.......................BinaryOperatorGrammar      	OneOf.match PRN     	    	[ns=1, ps=3, ms=0, pruned=[<Ref: ArithmeticBinaryOperatorGrammar>, <Ref: StringBinaryOperatorGrammar>, <Ref: BooleanBinaryOperatorGrammar>], opts=[<Ref: ComparisonOperatorGrammar>]]
INFO       [PD:3  MD:24]	........................ComparisonOperatorGrammar 	OneOf.match PRN     	    	[ns=1, ps=7, ms=0, pruned=[<Ref: EqualsSegment>, <Ref: GreaterThanSegment>, <Ref: LessThanSegment>, <Ref: GreaterThanOrEqualToSegment>, <Ref: LessThanOrEqualToSegment>, <Ref: NotEqualToSegment_a>, <Ref: NotEqualToSegment_b>], opts=[<Ref: LikeOperatorSegment>]]
DEBUG      [PD:3  MD:25]	.........................ComparisonOperatorGrammar	Ref.match OUT       	    	[match=<MatchResult 0/7: ''>, seg="'id = c.id'"]
INFO       [PD:3  MD:24]	........................ComparisonOperatorGrammar 	OneOf.match OUT     	    	[match=<MatchResult 0/7: ''>, seg="'id = c.id'"]
DEBUG      [PD:3  MD:24]	........................BinaryOperatorGrammar     	Ref.match OUT       	    	[match=<MatchResult 0/7: ''>, seg="'id = c.id'"]
INFO       [PD:3  MD:23]	.......................BinaryOperatorGrammar      	OneOf.match OUT     	    	[match=<MatchResult 0/7: ''>, seg="'id = c.id'"]
DEBUG      [PD:3  MD:23]	.......................ColumnReferenceSegment     	Ref.match OUT       	    	[match=<MatchResult 0/7: ''>, seg="'id = c.id'"]
INFO       [PD:3  MD:22]	......................ColumnReferenceSegment      	OneOf.match OUT     	    	[match=<MatchResult 0/7: ''>, seg="'id = c.id'"]
DEBUG      [PD:3  MD:22]	......................ColumnReferenceSegment      	NonCo.match OUT     	    	[match=<MatchResult 0/7: ''>, seg="'id = c.id'"]
INFO       [PD:3  MD:22]	......................ColumnReferenceSegment      	OneOf.match PRN     	    	[ns=1, ps=10, ms=0, pruned=[<Ref: OnKeywordSegment>, <Ref: AsKeywordSegment>, <Ref: UsingKeywordSegment>, <Ref: CommaSegment>, <Ref: CastOperatorSegment>, <Ref: StartSquareBracketSegment>, <Ref: StartBracketSegment>, <Ref: ColonSegment>, <Ref: DelimiterSegment>, <class 'sqlfluff.core.parser.segments.base.BracketedSegment'>], opts=[<Ref: BinaryOperatorGrammar>]]
INFO       [PD:3  MD:23]	.......................BinaryOperatorGrammar      	OneOf.match PRN     	    	[ns=1, ps=3, ms=0, pruned=[<Ref: ArithmeticBinaryOperatorGrammar>, <Ref: StringBinaryOperatorGrammar>, <Ref: BooleanBinaryOperatorGrammar>], opts=[<Ref: ComparisonOperatorGrammar>]]
INFO       [PD:3  MD:24]	........................ComparisonOperatorGrammar 	OneOf.match PRN     	    	[ns=1, ps=6, ms=1, pruned=[<Ref: GreaterThanSegment>, <Ref: LessThanSegment>, <Ref: GreaterThanOrEqualToSegment>, <Ref: LessThanOrEqualToSegment>, <Ref: NotEqualToSegment_a>, <Ref: NotEqualToSegment_b>], opts=[<Ref: EqualsSegment>, <Ref: LikeOperatorSegment>]]
DEBUG      [PD:3  MD:25]	.........................ComparisonOperatorGrammar	Ref.match OUT       	    	[match=<MatchResult 0/6: ''>, seg="' = c.id'"]
DEBUG      [PD:3  MD:25]	.........................ComparisonOperatorGrammar	Ref.match OUT       	    	[match=<MatchResult 0/6: ''>, seg="' = c.id'"]
INFO       [PD:3  MD:24]	........................ComparisonOperatorGrammar 	OneOf.match OUT     	    	[match=<MatchResult 0/6: ''>, seg="' = c.id'"]
DEBUG      [PD:3  MD:24]	........................BinaryOperatorGrammar     	Ref.match OUT       	    	[match=<MatchResult 0/6: ''>, seg="' = c.id'"]
INFO       [PD:3  MD:23]	.......................BinaryOperatorGrammar      	OneOf.match OUT     	    	[match=<MatchResult 0/6: ''>, seg="' = c.id'"]
DEBUG      [PD:3  MD:23]	.......................ColumnReferenceSegment     	Ref.match OUT       	    	[match=<MatchResult 0/6: ''>, seg="' = c.id'"]
INFO       [PD:3  MD:22]	......................ColumnReferenceSegment      	OneOf.match OUT     	    	[match=<MatchResult 0/6: ''>, seg="' = c.id'"]
DEBUG      [PD:3  MD:22]	......................ColumnReferenceSegment      	NonCo.match OUT     	+   	[match=<MatchResult 1/6: ' '>, seg="' = c.id'"]
INFO       [PD:3  MD:22]	......................SingleIdentifierGrammar     	OneOf.match PRN     	    	[ns=2, ps=0, ms=0, pruned=[], opts=[<Ref: NakedIdentifierSegment>, <Ref: QuotedIdentifierSegment>]]
DEBUG      [PD:3  MD:23]	.......................SingleIdentifierGrammar    	Ref.match OUT       	++  	[match=<MatchResult 1/1: 'id'>, seg="'id'"]
INFO       [PD:3  MD:22]	......................SingleIdentifierGrammar     	OneOf.match OUT     	++  	[match=<MatchResult 1/1: 'id'>, seg="'id'"]
DEBUG      [PD:3  MD:22]	......................ColumnReferenceSegment      	Ref.match OUT       	++  	[match=<MatchResult 1/1: 'id'>, seg="'id'"]
INFO       [PD:3  MD:21]	.....................ColumnReferenceSegment       	Delim.match OUT     	+   	[match=<MatchResult 3/9: 'tbl.id'>, seg="'tbl.id = c.id'"]
DEBUG      [PD:3  MD:20]	....................ColumnReferenceSegment        	Colum.match OUT     	+   	[match=<MatchResult 1/7: 'tbl.id'>, seg="'tbl.id = c.id'"]
DEBUG      [PD:3  MD:20]	....................Expression_D_Grammar          	Ref.match OUT       	+   	[match=<MatchResult 1/7: 'tbl.id'>, seg="'tbl.id = c.id'"]
DEBUG      [PD:3  MD:21]	.....................Expression_D_Grammar         	Ref.match OUT       	    	[match=<MatchResult 0/9: ''>, seg="'tbl.id = c.id'"]
INFO       [PD:3  MD:22]	......................ArrayLiteralSegment         	Brack.match OUT     	    	[match=<MatchResult 0/9: ''>, seg="'tbl.id = c.id'"]
DEBUG      [PD:3  MD:21]	.....................ArrayLiteralSegment          	Array.match OUT     	    	[match=<MatchResult 0/9: ''>, seg="'tbl.id = c.id'"]
DEBUG      [PD:3  MD:21]	.....................Expression_D_Grammar         	Ref.match OUT       	    	[match=<MatchResult 0/9: ''>, seg="'tbl.id = c.id'"]
INFO       [PD:3  MD:20]	....................Expression_D_Grammar          	Seque.match OUT     	    	[match=<MatchResult 0/9: ''>, seg="'tbl.id = c.id'"]
INFO       [PD:3  MD:22]	......................DatatypeSegment             	OneOf.match PRN     	    	[ns=1, ps=2, ms=0, pruned=[<Sequence: [<OneOf: [<Ref: TimeKeywordSegment>, <Ref..., <Bracketed: [<Ref: NumericLiteralSegment..., <Sequence:...]>, <Sequence: [<Ref: DoubleKeywordSegment>, <Ref: PrecisionKeywordSegment>]>], opts=[<Sequence: [<OneOf: [<Sequence: [<OneOf: [<Ref: Char..., <Bracketed: [<OneOf: [<Delimited: [<Ref:..., <Ref: Char...]>]]
INFO       [PD:3  MD:24]	........................DatatypeSegment           	OneOf.match PRN     	    	[ns=1, ps=1, ms=0, pruned=[<Sequence: [<OneOf: [<Ref: CharacterKeywordSegment>,..., <OneOf: [<Ref: VaryingKeywordSegment>, <...]>], opts=[<Sequence: [<Sequence: [<Ref: SingleIdentifierGramma..., <Ref: DatatypeIdentifierSegment>]>]]
INFO       [PD:3  MD:27]	...........................SingleIdentifierGrammar	OneOf.match PRN     	    	[ns=2, ps=0, ms=0, pruned=[], opts=[<Ref: NakedIdentifierSegment>, <Ref: QuotedIdentifierSegment>]]
DEBUG      [PD:3  MD:28]	............................SingleIdentifierGrammar	Ref.match OUT       	+   	[match=<MatchResult 1/9: 'tbl'>, seg="'tbl.id = c.id'"]
DEBUG      [PD:3  MD:28]	............................SingleIdentifierGrammar	Ref.match OUT       	    	[match=<MatchResult 0/9: ''>, seg="'tbl.id = c.id'"]
INFO       [PD:3  MD:27]	...........................SingleIdentifierGrammar	OneOf.match OUT     	+   	[match=<MatchResult 1/9: 'tbl'>, seg="'tbl.id = c.id'"]
DEBUG      [PD:3  MD:27]	...........................DatatypeSegment        	Ref.match OUT       	+   	[match=<MatchResult 1/9: 'tbl'>, seg="'tbl.id = c.id'"]
DEBUG      [PD:3  MD:27]	...........................DatatypeSegment        	Ref.match OUT       	+   	[match=<MatchResult 1/8: '.'>, seg="'.id = c.id'"]
INFO       [PD:3  MD:26]	..........................DatatypeSegment         	Seque.match OUT     	+   	[match=<MatchResult 2/9: 'tbl.'>, seg="'tbl.id = c.id'"]
DEBUG      [PD:3  MD:26]	..........................DatatypeSegment         	Ref.match OUT       	+   	[match=<MatchResult 1/7: 'id'>, seg="'id = c.id'"]
INFO       [PD:3  MD:25]	.........................DatatypeSegment          	Seque.match OUT     	+   	[match=<MatchResult 3/9: 'tbl.id'>, seg="'tbl.id = c.id'"]
INFO       [PD:3  MD:24]	........................DatatypeSegment           	OneOf.match OUT     	+   	[match=<MatchResult 3/9: 'tbl.id'>, seg="'tbl.id = c.id'"]
INFO       [PD:3  MD:24]	........................DatatypeSegment           	Brack.match OUT     	    	[match=<MatchResult 0/5: ''>, seg="'= c.id'"]
DEBUG      [PD:3  MD:24]	........................DatatypeSegment           	Ref.match OUT       	    	[match=<MatchResult 0/5: ''>, seg="'= c.id'"]
INFO       [PD:3  MD:23]	.......................DatatypeSegment            	Seque.match OUT     	+   	[match=<MatchResult 3/9: 'tbl.id'>, seg="'tbl.id = c.id'"]
INFO       [PD:3  MD:22]	......................DatatypeSegment             	OneOf.match OUT     	+   	[match=<MatchResult 3/9: 'tbl.id'>, seg="'tbl.id = c.id'"]
DEBUG      [PD:3  MD:21]	.....................DatatypeSegment              	Datat.match OUT     	+   	[match=<MatchResult 1/7: 'tbl.id'>, seg="'tbl.id = c.id'"]
DEBUG      [PD:3  MD:21]	.....................Expression_D_Grammar         	Ref.match OUT       	+   	[match=<MatchResult 1/7: 'tbl.id'>, seg="'tbl.id = c.id'"]
INFO       [PD:3  MD:21]	.....................Expression_D_Grammar         	OneOf.match PRN     	    	[ns=2, ps=3, ms=0, pruned=[<Ref: BooleanLiteralGrammar>, <Ref: NullLiteralSegment>, <Ref: DateTimeLiteralGrammar>], opts=[<Ref: QuotedLiteralSegment>, <Ref: NumericLiteralSegment>]]
DEBUG      [PD:3  MD:22]	......................Expression_D_Grammar        	Ref.match OUT       	    	[match=<MatchResult 0/5: ''>, seg="'= c.id'"]
DEBUG      [PD:3  MD:22]	......................Expression_D_Grammar        	Ref.match OUT       	    	[match=<MatchResult 0/5: ''>, seg="'= c.id'"]
INFO       [PD:3  MD:21]	.....................Expression_D_Grammar         	OneOf.match OUT     	    	[match=<MatchResult 0/5: ''>, seg="'= c.id'"]
INFO       [PD:3  MD:20]	....................Expression_D_Grammar          	Seque.match OUT     	    	[match=<MatchResult 0/9: ''>, seg="'tbl.id = c.id'"]
INFO       [PD:3  MD:19]	...................Expression_D_Grammar           	OneOf.match OUT     	+   	[match=<MatchResult 1/7: 'tbl.id'>, seg="'tbl.id = c.id'"]
INFO       [PD:3  MD:19]	...................Accessor_Grammar               	AnyNu.match PRN     	    	[ns=0, ps=1, ms=0, pruned=[<Ref: ArrayAccessorSegment>], opts='ALL']
INFO       [PD:3  MD:19]	...................Accessor_Grammar               	AnyNu.match OUT     	    	[match=<MatchResult 0/5: ''>, seg="'= c.id'"]
DEBUG      [PD:3  MD:19]	...................Expression_D_Grammar           	Ref.match OUT       	    	[match=<MatchResult 0/5: ''>, seg="'= c.id'"]
INFO       [PD:3  MD:19]	...................Expression_D_Grammar           	AnyNu.match PRN     	    	[ns=0, ps=1, ms=0, pruned=[<Ref: ShorthandCastSegment>], opts='ALL']
INFO       [PD:3  MD:19]	...................Expression_D_Grammar           	AnyNu.match OUT     	    	[match=<MatchResult 0/5: ''>, seg="'= c.id'"]
INFO       [PD:3  MD:18]	..................Expression_D_Grammar            	Seque.match OUT     	+   	[match=<MatchResult 1/7: 'tbl.id'>, seg="'tbl.id = c.id'"]
DEBUG      [PD:3  MD:18]	..................Expression_C_Grammar            	Ref.match OUT       	+   	[match=<MatchResult 1/7: 'tbl.id'>, seg="'tbl.id = c.id'"]
INFO       [PD:3  MD:17]	.................Expression_C_Grammar             	OneOf.match OUT     	+   	[match=<MatchResult 1/7: 'tbl.id'>, seg="'tbl.id = c.id'"]
DEBUG      [PD:3  MD:17]	.................Expression_A_Grammar             	Ref.match OUT       	+   	[match=<MatchResult 1/7: 'tbl.id'>, seg="'tbl.id = c.id'"]
INFO       [PD:3  MD:16]	................Expression_A_Grammar              	OneOf.match OUT     	+   	[match=<MatchResult 1/7: 'tbl.id'>, seg="'tbl.id = c.id'"]
INFO       [PD:3  MD:16]	................Expression_A_Grammar              	AnyNu.match PRN     	    	[ns=1, ps=0, ms=0, pruned=[], opts=[<OneOf: [<Sequence: [<OneOf: [<Sequence: [<Ref: N..., <Sequence: [<Ref: NotKeywordSegment [opt..., <Sequence:...]>]]
INFO       [PD:3  MD:17]	.................Expression_A_Grammar             	OneOf.match PRN     	    	[ns=3, ps=5, ms=0, pruned=[<Sequence: [<Ref: NotKeywordSegment [opt]>, <Ref: InKeywordSegment>, <Bracketed: [<OneOf: [<Delimited: [<Ref:...]>, <Sequence: [<Ref: NotKeywordSegment [opt]>, <Ref: InKeywordSegment>, <Ref: FunctionSegment>]>, <Sequence: [<Ref: IsKeywordSegment>, <Ref: NotKeywordSegment [opt]>, <Ref: IsClauseGrammar>]>, <Sequence: [<Ref: NotKeywordSegment>, <Ref: Expression_C_Grammar>]>, <Sequence: [<Ref: NotKeywordSegment [opt]>, <Ref: BetweenKeywordSegment>, <Ref: Expression_C_Grammar>, <AnyNumbe...]>], opts=[<Sequence: [<OneOf: [<Sequence: [<Ref: NotKeywordSeg..., <Ref: Expression_C_Grammar>, <Sequence: [<Ref: EscapeKe...]>, <Ref: IsNullGrammar>, <Ref: NotNullGrammar>]]
INFO       [PD:3  MD:19]	...................Expression_A_Grammar           	OneOf.match PRN     	    	[ns=1, ps=1, ms=0, pruned=[<Sequence: [<Ref: NotKeywordSegment [opt]>, <Ref: LikeGrammar>]>], opts=[<Sequence: [<Ref: BinaryOperatorGrammar>, <Ref: NotKeywordSegment [opt]>]>]]
INFO       [PD:3  MD:21]	.....................BinaryOperatorGrammar        	OneOf.match PRN     	    	[ns=1, ps=3, ms=0, pruned=[<Ref: ArithmeticBinaryOperatorGrammar>, <Ref: StringBinaryOperatorGrammar>, <Ref: BooleanBinaryOperatorGrammar>], opts=[<Ref: ComparisonOperatorGrammar>]]
INFO       [PD:3  MD:22]	......................ComparisonOperatorGrammar   	OneOf.match PRN     	    	[ns=1, ps=6, ms=1, pruned=[<Ref: GreaterThanSegment>, <Ref: LessThanSegment>, <Ref: GreaterThanOrEqualToSegment>, <Ref: LessThanOrEqualToSegment>, <Ref: NotEqualToSegment_a>, <Ref: NotEqualToSegment_b>], opts=[<Ref: EqualsSegment>, <Ref: LikeOperatorSegment>]]
DEBUG      [PD:3  MD:23]	.......................ComparisonOperatorGrammar  	Ref.match OUT       	+   	[match=<MatchResult 1/5: '='>, seg="'= c.id'"]
DEBUG      [PD:3  MD:23]	.......................ComparisonOperatorGrammar  	Ref.match OUT       	    	[match=<MatchResult 0/5: ''>, seg="'= c.id'"]
INFO       [PD:3  MD:22]	......................ComparisonOperatorGrammar   	OneOf.match OUT     	+   	[match=<MatchResult 1/5: '='>, seg="'= c.id'"]
DEBUG      [PD:3  MD:22]	......................BinaryOperatorGrammar       	Ref.match OUT       	+   	[match=<MatchResult 1/5: '='>, seg="'= c.id'"]
INFO       [PD:3  MD:21]	.....................BinaryOperatorGrammar        	OneOf.match OUT     	+   	[match=<MatchResult 1/5: '='>, seg="'= c.id'"]
DEBUG      [PD:3  MD:21]	.....................Expression_A_Grammar         	Ref.match OUT       	+   	[match=<MatchResult 1/5: '='>, seg="'= c.id'"]
DEBUG      [PD:3  MD:21]	.....................Expression_A_Grammar         	Ref.match OUT       	    	[match=<MatchResult 0/3: ''>, seg="'c.id'"]
INFO       [PD:3  MD:20]	....................Expression_A_Grammar          	Seque.match OUT     	+   	[match=<MatchResult 1/5: '='>, seg="'= c.id'"]
INFO       [PD:3  MD:19]	...................Expression_A_Grammar           	OneOf.match OUT     	+   	[match=<MatchResult 1/5: '='>, seg="'= c.id'"]
INFO       [PD:3  MD:19]	...................Expression_C_Grammar           	OneOf.match PRN     	    	[ns=1, ps=2, ms=0, pruned=[<Sequence: [<Ref: ExistsKeywordSegment>, <Bracketed: [<Ref: SelectStatementSegmen...]>, <Ref: CaseExpressionSegment>], opts=[<Ref: Expression_D_Grammar>]]
INFO       [PD:3  MD:21]	.....................Expression_D_Grammar         	OneOf.match PRN     	    	[ns=6, ps=3, ms=0, pruned=[<Bracketed: [<OneOf: [<Ref: ExpressionSegment>, <Ref:...]>, <Ref: SelectStatementSegment>, <Ref: IntervalExpressionSegment>], opts=[<Ref: BareFunctionSegment>, <Ref: FunctionSegment>, <Ref: LiteralGrammar>, <Ref: ColumnReferenceSegment>, <Sequence: [<Ref: SimpleArrayTypeGrammar [opt]>, <Ref: ArrayLiteralSegment>]>, <Sequence: [<Ref: DatatypeSegment>, <OneOf: [<Ref: QuotedLiteralSegment>, <R...]>]]
DEBUG      [PD:3  MD:22]	......................Expression_D_Grammar        	Ref.match OUT       	    	[match=<MatchResult 0/3: ''>, seg="'c.id'"]
INFO       [PD:3  MD:23]	.......................FunctionSegment            	OneOf.match PRN     	    	[ns=1, ps=1, ms=0, pruned=[<Sequence: [<Sequence: [<Ref: DateAddFunctionNameSeg...]>], opts=[<Sequence: [<Sequence: [<AnyNumberOf: [<Ref: Functio..., <Ref: PostFunctionGrammar [opt]>]>]]
DEBUG      [PD:3  MD:29]	.............................DateAddFunctionNameSegment	Ref.match OUT       	    	[match=<MatchResult 0/3: ''>, seg="'c.id'"]
INFO       [PD:3  MD:28]	............................DateAddFunctionNameSegment	Seque.match OUT     	    	[match=<MatchResult 0/3: ''>, seg="'c.id'"]
DEBUG      [PD:3  MD:27]	...........................DateAddFunctionNameSegment	DateA.match OUT     	    	[match=<MatchResult 0/3: ''>, seg="'c.id'"]
DEBUG      [PD:3  MD:27]	...........................FunctionSegment        	Ref.match OUT       	    	[match=<MatchResult 0/3: ''>, seg="'c.id'"]
INFO       [PD:3  MD:26]	..........................FunctionSegment         	AnyNu.match PRN     	    	[ns=1, ps=0, ms=0, pruned=[], opts=[<Ref: FunctionNameSegment>]]
INFO       [PD:3  MD:29]	.............................FunctionNameSegment  	AnyNu.match PRN     	    	[ns=1, ps=0, ms=0, pruned=[], opts=[<Sequence: [<Ref: SingleIdentifierGrammar>, <Ref: DotSegment>]>]]
INFO       [PD:3  MD:31]	...............................SingleIdentifierGrammar	OneOf.match PRN     	    	[ns=2, ps=0, ms=0, pruned=[], opts=[<Ref: NakedIdentifierSegment>, <Ref: QuotedIdentifierSegment>]]
DEBUG      [PD:3  MD:32]	................................SingleIdentifierGrammar	Ref.match OUT       	+   	[match=<MatchResult 1/3: 'c'>, seg="'c.id'"]
DEBUG      [PD:3  MD:32]	................................SingleIdentifierGrammar	Ref.match OUT       	    	[match=<MatchResult 0/3: ''>, seg="'c.id'"]
INFO       [PD:3  MD:31]	...............................SingleIdentifierGrammar	OneOf.match OUT     	+   	[match=<MatchResult 1/3: 'c'>, seg="'c.id'"]
DEBUG      [PD:3  MD:31]	...............................FunctionNameSegment	Ref.match OUT       	+   	[match=<MatchResult 1/3: 'c'>, seg="'c.id'"]
DEBUG      [PD:3  MD:31]	...............................FunctionNameSegment	Ref.match OUT       	+   	[match=<MatchResult 1/2: '.'>, seg="'.id'"]
INFO       [PD:3  MD:30]	..............................FunctionNameSegment 	Seque.match OUT     	+   	[match=<MatchResult 2/3: 'c.'>, seg="'c.id'"]
INFO       [PD:3  MD:29]	.............................FunctionNameSegment  	AnyNu.match PRN     	    	[ns=1, ps=0, ms=0, pruned=[], opts=[<Sequence: [<Ref: SingleIdentifierGrammar>, <Ref: DotSegment>]>]]
INFO       [PD:3  MD:31]	...............................SingleIdentifierGrammar	OneOf.match PRN     	    	[ns=2, ps=0, ms=0, pruned=[], opts=[<Ref: NakedIdentifierSegment>, <Ref: QuotedIdentifierSegment>]]
DEBUG      [PD:3  MD:32]	................................SingleIdentifierGrammar	Ref.match OUT       	++  	[match=<MatchResult 1/1: 'id'>, seg="'id'"]
INFO       [PD:3  MD:31]	...............................SingleIdentifierGrammar	OneOf.match OUT     	++  	[match=<MatchResult 1/1: 'id'>, seg="'id'"]
DEBUG      [PD:3  MD:31]	...............................FunctionNameSegment	Ref.match OUT       	++  	[match=<MatchResult 1/1: 'id'>, seg="'id'"]
INFO       [PD:3  MD:30]	..............................FunctionNameSegment 	Seque.match OUT     	    	[match=<MatchResult 0/1: ''>, seg="'id'"]
INFO       [PD:3  MD:29]	.............................FunctionNameSegment  	AnyNu.match OUT     	+   	[match=<MatchResult 2/3: 'c.'>, seg="'c.id'"]
INFO       [PD:3  MD:29]	.............................FunctionNameSegment  	OneOf.match PRN     	    	[ns=2, ps=0, ms=0, pruned=[], opts=[<Ref: FunctionNameIdentifierSegment>, <Ref: QuotedIdentifierSegment>]]
DEBUG      [PD:3  MD:30]	..............................FunctionNameSegment 	Ref.match OUT       	++  	[match=<MatchResult 1/1: 'id'>, seg="'id'"]
INFO       [PD:3  MD:29]	.............................FunctionNameSegment  	OneOf.match OUT     	++  	[match=<MatchResult 1/1: 'id'>, seg="'id'"]
INFO       [PD:3  MD:28]	............................FunctionNameSegment   	Seque.match OUT     	++  	[match=<MatchResult 3/3: 'c.id'>, seg="'c.id'"]
DEBUG      [PD:3  MD:27]	...........................FunctionNameSegment    	Funct.match OUT     	++  	[match=<MatchResult 1/1: 'c.id'>, seg="'c.id'"]
DEBUG      [PD:3  MD:27]	...........................FunctionSegment        	Ref.match OUT       	++  	[match=<MatchResult 1/1: 'c.id'>, seg="'c.id'"]
INFO       [PD:3  MD:26]	..........................FunctionSegment         	AnyNu.match OUT     	++  	[match=<MatchResult 1/1: 'c.id'>, seg="'c.id'"]
INFO       [PD:3  MD:25]	.........................FunctionSegment          	Seque.match OUT     	    	[match=<MatchResult 0/3: ''>, seg="'c.id'"]
INFO       [PD:3  MD:24]	........................FunctionSegment           	Seque.match OUT     	    	[match=<MatchResult 0/3: ''>, seg="'c.id'"]
INFO       [PD:3  MD:23]	.......................FunctionSegment            	OneOf.match OUT     	    	[match=<MatchResult 0/3: ''>, seg="'c.id'"]
DEBUG      [PD:3  MD:22]	......................FunctionSegment             	Funct.match OUT     	    	[match=<MatchResult 0/3: ''>, seg="'c.id'"]
DEBUG      [PD:3  MD:22]	......................Expression_D_Grammar        	Ref.match OUT       	    	[match=<MatchResult 0/3: ''>, seg="'c.id'"]
INFO       [PD:3  MD:22]	......................LiteralGrammar              	OneOf.match PRN     	    	[ns=2, ps=4, ms=0, pruned=[<Ref: BooleanLiteralGrammar>, <Ref: QualifiedNumericLiteralSegment>, <Ref: NullLiteralSegment>, <Ref: DateTimeLiteralGrammar>], opts=[<Ref: QuotedLiteralSegment>, <Ref: NumericLiteralSegment>]]
DEBUG      [PD:3  MD:23]	.......................LiteralGrammar             	Ref.match OUT       	    	[match=<MatchResult 0/3: ''>, seg="'c.id'"]
DEBUG      [PD:3  MD:23]	.......................LiteralGrammar             	Ref.match OUT       	    	[match=<MatchResult 0/3: ''>, seg="'c.id'"]
INFO       [PD:3  MD:22]	......................LiteralGrammar              	OneOf.match OUT     	    	[match=<MatchResult 0/3: ''>, seg="'c.id'"]
DEBUG      [PD:3  MD:22]	......................Expression_D_Grammar        	Ref.match OUT       	    	[match=<MatchResult 0/3: ''>, seg="'c.id'"]
DEBUG      [PD:3  MD:24]	........................ColumnReferenceSegment    	Delim._look_ahead_match IN	    	[ls=3, seg='c.id']
DEBUG      [PD:3  MD:24]	........................ColumnReferenceSegment    	Delim._look_ahead_match SI	    	[mq=[(<OneOf: [<Ref: DotSegment>, <Sequence: [<Ref: DotSegment>, <Ref: Dot...]>, 1, '.'), (<OneOf: [<Ref: DotSegment>, <Sequence: [<Ref: DotSegment>, <Ref: Dot...]>, 1, '.')], sb=['C', '.', 'ID']]
INFO       [PD:3  MD:24]	........................ColumnReferenceSegment    	OneOf.match PRN     	    	[ns=0, ps=0, ms=2, pruned=[], opts=[<Ref: DotSegment>, <Sequence: [<Ref: DotSegment>, <Ref: DotSegment>]>]]
DEBUG      [PD:3  MD:25]	.........................ColumnReferenceSegment   	Ref.match OUT       	+   	[match=<MatchResult 1/2: '.'>, seg="'.id'"]
DEBUG      [PD:3  MD:26]	..........................ColumnReferenceSegment  	Ref.match OUT       	+   	[match=<MatchResult 1/2: '.'>, seg="'.id'"]
DEBUG      [PD:3  MD:26]	..........................ColumnReferenceSegment  	Ref.match OUT       	    	[match=<MatchResult 0/1: ''>, seg="'id'"]
INFO       [PD:3  MD:25]	.........................ColumnReferenceSegment   	Seque.match OUT     	    	[match=<MatchResult 0/2: ''>, seg="'.id'"]
INFO       [PD:3  MD:24]	........................ColumnReferenceSegment    	OneOf.match OUT     	+   	[match=<MatchResult 1/2: '.'>, seg="'.id'"]
INFO       [PD:3  MD:24]	........................ColumnReferenceSegment    	OneOf.match PRN     	    	[ns=0, ps=0, ms=2, pruned=[], opts=[<Ref: DotSegment>, <Sequence: [<Ref: DotSegment>, <Ref: DotSegment>]>]]
DEBUG      [PD:3  MD:25]	.........................ColumnReferenceSegment   	Ref.match OUT       	+   	[match=<MatchResult 1/2: '.'>, seg="'.id'"]
DEBUG      [PD:3  MD:26]	..........................ColumnReferenceSegment  	Ref.match OUT       	+   	[match=<MatchResult 1/2: '.'>, seg="'.id'"]
DEBUG      [PD:3  MD:26]	..........................ColumnReferenceSegment  	Ref.match OUT       	    	[match=<MatchResult 0/1: ''>, seg="'id'"]
INFO       [PD:3  MD:25]	.........................ColumnReferenceSegment   	Seque.match OUT     	    	[match=<MatchResult 0/2: ''>, seg="'.id'"]
INFO       [PD:3  MD:24]	........................ColumnReferenceSegment    	OneOf.match OUT     	+   	[match=<MatchResult 1/2: '.'>, seg="'.id'"]
INFO       [PD:3  MD:24]	........................ColumnReferenceSegment    	OneOf.match PRN     	    	[ns=1, ps=10, ms=0, pruned=[<Ref: OnKeywordSegment>, <Ref: AsKeywordSegment>, <Ref: UsingKeywordSegment>, <Ref: CommaSegment>, <Ref: CastOperatorSegment>, <Ref: StartSquareBracketSegment>, <Ref: StartBracketSegment>, <Ref: ColonSegment>, <Ref: DelimiterSegment>, <class 'sqlfluff.core.parser.segments.base.BracketedSegment'>], opts=[<Ref: BinaryOperatorGrammar>]]
INFO       [PD:3  MD:25]	.........................BinaryOperatorGrammar    	OneOf.match PRN     	    	[ns=1, ps=3, ms=0, pruned=[<Ref: ArithmeticBinaryOperatorGrammar>, <Ref: StringBinaryOperatorGrammar>, <Ref: BooleanBinaryOperatorGrammar>], opts=[<Ref: ComparisonOperatorGrammar>]]
INFO       [PD:3  MD:26]	..........................ComparisonOperatorGrammar	OneOf.match PRN     	    	[ns=1, ps=7, ms=0, pruned=[<Ref: EqualsSegment>, <Ref: GreaterThanSegment>, <Ref: LessThanSegment>, <Ref: GreaterThanOrEqualToSegment>, <Ref: LessThanOrEqualToSegment>, <Ref: NotEqualToSegment_a>, <Ref: NotEqualToSegment_b>], opts=[<Ref: LikeOperatorSegment>]]
DEBUG      [PD:3  MD:27]	...........................ComparisonOperatorGrammar	Ref.match OUT       	    	[match=<MatchResult 0/3: ''>, seg="'c.id'"]
INFO       [PD:3  MD:26]	..........................ComparisonOperatorGrammar	OneOf.match OUT     	    	[match=<MatchResult 0/3: ''>, seg="'c.id'"]
DEBUG      [PD:3  MD:26]	..........................BinaryOperatorGrammar   	Ref.match OUT       	    	[match=<MatchResult 0/3: ''>, seg="'c.id'"]
INFO       [PD:3  MD:25]	.........................BinaryOperatorGrammar    	OneOf.match OUT     	    	[match=<MatchResult 0/3: ''>, seg="'c.id'"]
DEBUG      [PD:3  MD:25]	.........................ColumnReferenceSegment   	Ref.match OUT       	    	[match=<MatchResult 0/3: ''>, seg="'c.id'"]
INFO       [PD:3  MD:24]	........................ColumnReferenceSegment    	OneOf.match OUT     	    	[match=<MatchResult 0/3: ''>, seg="'c.id'"]
DEBUG      [PD:3  MD:24]	........................ColumnReferenceSegment    	NonCo.match OUT     	    	[match=<MatchResult 0/3: ''>, seg="'c.id'"]
INFO       [PD:3  MD:24]	........................ColumnReferenceSegment    	OneOf.match PRN     	    	[ns=1, ps=10, ms=0, pruned=[<Ref: OnKeywordSegment>, <Ref: AsKeywordSegment>, <Ref: UsingKeywordSegment>, <Ref: CommaSegment>, <Ref: CastOperatorSegment>, <Ref: StartSquareBracketSegment>, <Ref: StartBracketSegment>, <Ref: ColonSegment>, <Ref: DelimiterSegment>, <class 'sqlfluff.core.parser.segments.base.BracketedSegment'>], opts=[<Ref: BinaryOperatorGrammar>]]
INFO       [PD:3  MD:25]	.........................BinaryOperatorGrammar    	OneOf.match PRN     	    	[ns=1, ps=3, ms=0, pruned=[<Ref: ArithmeticBinaryOperatorGrammar>, <Ref: StringBinaryOperatorGrammar>, <Ref: BooleanBinaryOperatorGrammar>], opts=[<Ref: ComparisonOperatorGrammar>]]
INFO       [PD:3  MD:26]	..........................ComparisonOperatorGrammar	OneOf.match PRN     	    	[ns=1, ps=7, ms=0, pruned=[<Ref: EqualsSegment>, <Ref: GreaterThanSegment>, <Ref: LessThanSegment>, <Ref: GreaterThanOrEqualToSegment>, <Ref: LessThanOrEqualToSegment>, <Ref: NotEqualToSegment_a>, <Ref: NotEqualToSegment_b>], opts=[<Ref: LikeOperatorSegment>]]
DEBUG      [PD:3  MD:27]	...........................ComparisonOperatorGrammar	Ref.match OUT       	    	[match=<MatchResult 0/2: ''>, seg="'.id'"]
INFO       [PD:3  MD:26]	..........................ComparisonOperatorGrammar	OneOf.match OUT     	    	[match=<MatchResult 0/2: ''>, seg="'.id'"]
DEBUG      [PD:3  MD:26]	..........................BinaryOperatorGrammar   	Ref.match OUT       	    	[match=<MatchResult 0/2: ''>, seg="'.id'"]
INFO       [PD:3  MD:25]	.........................BinaryOperatorGrammar    	OneOf.match OUT     	    	[match=<MatchResult 0/2: ''>, seg="'.id'"]
DEBUG      [PD:3  MD:25]	.........................ColumnReferenceSegment   	Ref.match OUT       	    	[match=<MatchResult 0/2: ''>, seg="'.id'"]
INFO       [PD:3  MD:24]	........................ColumnReferenceSegment    	OneOf.match OUT     	    	[match=<MatchResult 0/2: ''>, seg="'.id'"]
DEBUG      [PD:3  MD:24]	........................ColumnReferenceSegment    	NonCo.match OUT     	    	[match=<MatchResult 0/2: ''>, seg="'.id'"]
INFO       [PD:3  MD:24]	........................SingleIdentifierGrammar   	OneOf.match PRN     	    	[ns=2, ps=0, ms=0, pruned=[], opts=[<Ref: NakedIdentifierSegment>, <Ref: QuotedIdentifierSegment>]]
DEBUG      [PD:3  MD:25]	.........................SingleIdentifierGrammar  	Ref.match OUT       	++  	[match=<MatchResult 1/1: 'c'>, seg="'c'"]
INFO       [PD:3  MD:24]	........................SingleIdentifierGrammar   	OneOf.match OUT     	++  	[match=<MatchResult 1/1: 'c'>, seg="'c'"]
DEBUG      [PD:3  MD:24]	........................ColumnReferenceSegment    	Ref.match OUT       	++  	[match=<MatchResult 1/1: 'c'>, seg="'c'"]
DEBUG      [PD:3  MD:24]	........................ColumnReferenceSegment    	Delim._look_ahead_match IN	    	[ls=1, seg='id']
DEBUG      [PD:3  MD:24]	........................ColumnReferenceSegment    	Delim._look_ahead_match SI	    	[mq=[], sb=['ID']]
INFO       [PD:3  MD:24]	........................ColumnReferenceSegment    	OneOf.match PRN     	    	[ns=1, ps=10, ms=0, pruned=[<Ref: OnKeywordSegment>, <Ref: AsKeywordSegment>, <Ref: UsingKeywordSegment>, <Ref: CommaSegment>, <Ref: CastOperatorSegment>, <Ref: StartSquareBracketSegment>, <Ref: StartBracketSegment>, <Ref: ColonSegment>, <Ref: DelimiterSegment>, <class 'sqlfluff.core.parser.segments.base.BracketedSegment'>], opts=[<Ref: BinaryOperatorGrammar>]]
INFO       [PD:3  MD:25]	.........................BinaryOperatorGrammar    	OneOf.match PRN     	    	[ns=1, ps=3, ms=0, pruned=[<Ref: ArithmeticBinaryOperatorGrammar>, <Ref: StringBinaryOperatorGrammar>, <Ref: BooleanBinaryOperatorGrammar>], opts=[<Ref: ComparisonOperatorGrammar>]]
INFO       [PD:3  MD:26]	..........................ComparisonOperatorGrammar	OneOf.match PRN     	    	[ns=1, ps=7, ms=0, pruned=[<Ref: EqualsSegment>, <Ref: GreaterThanSegment>, <Ref: LessThanSegment>, <Ref: GreaterThanOrEqualToSegment>, <Ref: LessThanOrEqualToSegment>, <Ref: NotEqualToSegment_a>, <Ref: NotEqualToSegment_b>], opts=[<Ref: LikeOperatorSegment>]]
DEBUG      [PD:3  MD:27]	...........................ComparisonOperatorGrammar	Ref.match OUT       	    	[match=<MatchResult 0/1: ''>, seg="'id'"]
INFO       [PD:3  MD:26]	..........................ComparisonOperatorGrammar	OneOf.match OUT     	    	[match=<MatchResult 0/1: ''>, seg="'id'"]
DEBUG      [PD:3  MD:26]	..........................BinaryOperatorGrammar   	Ref.match OUT       	    	[match=<MatchResult 0/1: ''>, seg="'id'"]
INFO       [PD:3  MD:25]	.........................BinaryOperatorGrammar    	OneOf.match OUT     	    	[match=<MatchResult 0/1: ''>, seg="'id'"]
DEBUG      [PD:3  MD:25]	.........................ColumnReferenceSegment   	Ref.match OUT       	    	[match=<MatchResult 0/1: ''>, seg="'id'"]
INFO       [PD:3  MD:24]	........................ColumnReferenceSegment    	OneOf.match OUT     	    	[match=<MatchResult 0/1: ''>, seg="'id'"]
DEBUG      [PD:3  MD:24]	........................ColumnReferenceSegment    	NonCo.match OUT     	    	[match=<MatchResult 0/1: ''>, seg="'id'"]
INFO       [PD:3  MD:24]	........................SingleIdentifierGrammar   	OneOf.match PRN     	    	[ns=2, ps=0, ms=0, pruned=[], opts=[<Ref: NakedIdentifierSegment>, <Ref: QuotedIdentifierSegment>]]
DEBUG      [PD:3  MD:25]	.........................SingleIdentifierGrammar  	Ref.match OUT       	++  	[match=<MatchResult 1/1: 'id'>, seg="'id'"]
INFO       [PD:3  MD:24]	........................SingleIdentifierGrammar   	OneOf.match OUT     	++  	[match=<MatchResult 1/1: 'id'>, seg="'id'"]
DEBUG      [PD:3  MD:24]	........................ColumnReferenceSegment    	Ref.match OUT       	++  	[match=<MatchResult 1/1: 'id'>, seg="'id'"]
INFO       [PD:3  MD:23]	.......................ColumnReferenceSegment     	Delim.match OUT     	++  	[match=<MatchResult 3/3: 'c.id'>, seg="'c.id'"]
DEBUG      [PD:3  MD:22]	......................ColumnReferenceSegment      	Colum.match OUT     	++  	[match=<MatchResult 1/1: 'c.id'>, seg="'c.id'"]
DEBUG      [PD:3  MD:22]	......................Expression_D_Grammar        	Ref.match OUT       	++  	[match=<MatchResult 1/1: 'c.id'>, seg="'c.id'"]
INFO       [PD:3  MD:21]	.....................Expression_D_Grammar         	OneOf.match OUT     	++  	[match=<MatchResult 1/1: 'c.id'>, seg="'c.id'"]
INFO       [PD:3  MD:20]	....................Expression_D_Grammar          	Seque.match OUT     	++  	[match=<MatchResult 1/1: 'c.id'>, seg="'c.id'"]
DEBUG      [PD:3  MD:20]	....................Expression_C_Grammar          	Ref.match OUT       	++  	[match=<MatchResult 1/1: 'c.id'>, seg="'c.id'"]
INFO       [PD:3  MD:19]	...................Expression_C_Grammar           	OneOf.match OUT     	++  	[match=<MatchResult 1/1: 'c.id'>, seg="'c.id'"]
DEBUG      [PD:3  MD:19]	...................Expression_A_Grammar           	Ref.match OUT       	++  	[match=<MatchResult 1/1: 'c.id'>, seg="'c.id'"]
INFO       [PD:3  MD:18]	..................Expression_A_Grammar            	Seque.match OUT     	++  	[match=<MatchResult 3/3: '= c.id'>, seg="'= c.id'"]
INFO       [PD:3  MD:17]	.................Expression_A_Grammar             	OneOf.match OUT     	++  	[match=<MatchResult 3/3: '= c.id'>, seg="'= c.id'"]
INFO       [PD:3  MD:16]	................Expression_A_Grammar              	AnyNu.match OUT     	++  	[match=<MatchResult 3/3: '= c.id'>, seg="'= c.id'"]
INFO       [PD:3  MD:15]	...............Expression_A_Grammar               	Seque.match OUT     	++  	[match=<MatchResult 5/5: 'tbl.id = c.id'>, seg="'tbl.id = c.id'"]
DEBUG      [PD:3  MD:15]	...............ExpressionSegment                  	Ref.match OUT       	++  	[match=<MatchResult 5/5: 'tbl.id = c.id'>, seg="'tbl.id = c.id'"]
DEBUG      [PD:3  MD:14]	..............ExpressionSegment                   	Expre.match OUT     	++  	[match=<MatchResult 1/1: 'tbl.id = c.id'>, seg="'tbl.id = c.id'"]
DEBUG      [PD:3  MD:14]	..............JoinOnConditionSegment              	Ref.match OUT       	++  	[match=<MatchResult 1/1: 'tbl.id = c.id'>, seg="'tbl.id = c.id'"]
INFO       [PD:3  MD:13]	.............JoinOnConditionSegment               	Brack.match OUT     	++  	[match=<MatchResult 1/1: 'tbl.id = c.id'>, seg="'tbl.id = c.id'"]
INFO       [PD:3  MD:12]	............JoinOnConditionSegment                	Brack.match OUT     	+   	[match=<MatchResult 1/11: '(tbl.id = c.id)'>, seg="'(tbl.id = c.id)\\nLEFT...'"]
INFO       [PD:3  MD:14]	..............Expression_A_Grammar                	OneOf.match PRN     	    	[ns=1, ps=1, ms=0, pruned=[<Sequence: [<OneOf: [<Ref: PositiveSegment>, <Ref: N..., <Ref: Expression_C_Grammar>]>], opts=[<Ref: Expression_C_Grammar>]]
INFO       [PD:3  MD:15]	...............Expression_C_Grammar               	OneOf.match PRN     	    	[ns=1, ps=2, ms=0, pruned=[<Sequence: [<Ref: ExistsKeywordSegment>, <Bracketed: [<Ref: SelectStatementSegmen...]>, <Ref: CaseExpressionSegment>], opts=[<Ref: Expression_D_Grammar>]]
INFO       [PD:3  MD:17]	.................Expression_D_Grammar             	OneOf.match PRN     	    	[ns=6, ps=2, ms=1, pruned=[<Ref: SelectStatementSegment>, <Ref: IntervalExpressionSegment>], opts=[<Ref: BareFunctionSegment>, <Ref: FunctionSegment>, <Bracketed: [<OneOf: [<Ref: ExpressionSegment>, <Ref:...]>, <Ref: LiteralGrammar>, <Ref: ColumnReferenceSegment>, <Sequence: [<Ref: SimpleArrayTypeGrammar [opt]>, <Ref: ArrayLiteralSegment>]>, <Sequence: [<Ref: DatatypeSegment>, <OneOf: [<Ref: QuotedLiteralSegment>, <R...]>]]
DEBUG      [PD:3  MD:18]	..................Expression_D_Grammar            	Ref.match OUT       	    	[match=<MatchResult 0/11: ''>, seg="'(tbl.id = c.id)\\nLEFT...'"]
INFO       [PD:3  MD:19]	...................FunctionSegment                	OneOf.match PRN     	    	[ns=1, ps=1, ms=0, pruned=[<Sequence: [<Sequence: [<Ref: DateAddFunctionNameSeg...]>], opts=[<Sequence: [<Sequence: [<AnyNumberOf: [<Ref: Functio..., <Ref: PostFunctionGrammar [opt]>]>]]
DEBUG      [PD:3  MD:25]	.........................DateAddFunctionNameSegment	Ref.match OUT       	    	[match=<MatchResult 0/11: ''>, seg="'(tbl.id = c.id)\\nLEFT...'"]
INFO       [PD:3  MD:24]	........................DateAddFunctionNameSegment	Seque.match OUT     	    	[match=<MatchResult 0/11: ''>, seg="'(tbl.id = c.id)\\nLEFT...'"]
DEBUG      [PD:3  MD:23]	.......................DateAddFunctionNameSegment 	DateA.match OUT     	    	[match=<MatchResult 0/11: ''>, seg="'(tbl.id = c.id)\\nLEFT...'"]
DEBUG      [PD:3  MD:23]	.......................FunctionSegment            	Ref.match OUT       	    	[match=<MatchResult 0/11: ''>, seg="'(tbl.id = c.id)\\nLEFT...'"]
INFO       [PD:3  MD:22]	......................FunctionSegment             	AnyNu.match PRN     	    	[ns=1, ps=0, ms=0, pruned=[], opts=[<Ref: FunctionNameSegment>]]
INFO       [PD:3  MD:25]	.........................FunctionNameSegment      	AnyNu.match PRN     	    	[ns=1, ps=0, ms=0, pruned=[], opts=[<Sequence: [<Ref: SingleIdentifierGrammar>, <Ref: DotSegment>]>]]
INFO       [PD:3  MD:27]	...........................SingleIdentifierGrammar	OneOf.match PRN     	    	[ns=2, ps=0, ms=0, pruned=[], opts=[<Ref: NakedIdentifierSegment>, <Ref: QuotedIdentifierSegment>]]
DEBUG      [PD:3  MD:28]	............................SingleIdentifierGrammar	Ref.match OUT       	    	[match=<MatchResult 0/11: ''>, seg="'(tbl.id = c.id)\\nLEFT...'"]
DEBUG      [PD:3  MD:28]	............................SingleIdentifierGrammar	Ref.match OUT       	    	[match=<MatchResult 0/11: ''>, seg="'(tbl.id = c.id)\\nLEFT...'"]
INFO       [PD:3  MD:27]	...........................SingleIdentifierGrammar	OneOf.match OUT     	    	[match=<MatchResult 0/11: ''>, seg="'(tbl.id = c.id)\\nLEFT...'"]
DEBUG      [PD:3  MD:27]	...........................FunctionNameSegment    	Ref.match OUT       	    	[match=<MatchResult 0/11: ''>, seg="'(tbl.id = c.id)\\nLEFT...'"]
INFO       [PD:3  MD:26]	..........................FunctionNameSegment     	Seque.match OUT     	    	[match=<MatchResult 0/11: ''>, seg="'(tbl.id = c.id)\\nLEFT...'"]
INFO       [PD:3  MD:25]	.........................FunctionNameSegment      	AnyNu.match OUT     	    	[match=<MatchResult 0/11: ''>, seg="'(tbl.id = c.id)\\nLEFT...'"]
INFO       [PD:3  MD:25]	.........................FunctionNameSegment      	OneOf.match PRN     	    	[ns=2, ps=0, ms=0, pruned=[], opts=[<Ref: FunctionNameIdentifierSegment>, <Ref: QuotedIdentifierSegment>]]
DEBUG      [PD:3  MD:26]	..........................FunctionNameSegment     	Ref.match OUT       	    	[match=<MatchResult 0/11: ''>, seg="'(tbl.id = c.id)\\nLEFT...'"]
DEBUG      [PD:3  MD:26]	..........................FunctionNameSegment     	Ref.match OUT       	    	[match=<MatchResult 0/11: ''>, seg="'(tbl.id = c.id)\\nLEFT...'"]
INFO       [PD:3  MD:25]	.........................FunctionNameSegment      	OneOf.match OUT     	    	[match=<MatchResult 0/11: ''>, seg="'(tbl.id = c.id)\\nLEFT...'"]
INFO       [PD:3  MD:24]	........................FunctionNameSegment       	Seque.match OUT     	    	[match=<MatchResult 0/11: ''>, seg="'(tbl.id = c.id)\\nLEFT...'"]
DEBUG      [PD:3  MD:23]	.......................FunctionNameSegment        	Funct.match OUT     	    	[match=<MatchResult 0/11: ''>, seg="'(tbl.id = c.id)\\nLEFT...'"]
DEBUG      [PD:3  MD:23]	.......................FunctionSegment            	Ref.match OUT       	    	[match=<MatchResult 0/11: ''>, seg="'(tbl.id = c.id)\\nLEFT...'"]
INFO       [PD:3  MD:22]	......................FunctionSegment             	AnyNu.match OUT     	    	[match=<MatchResult 0/11: ''>, seg="'(tbl.id = c.id)\\nLEFT...'"]
INFO       [PD:3  MD:21]	.....................FunctionSegment              	Seque.match OUT     	    	[match=<MatchResult 0/11: ''>, seg="'(tbl.id = c.id)\\nLEFT...'"]
INFO       [PD:3  MD:20]	....................FunctionSegment               	Seque.match OUT     	    	[match=<MatchResult 0/11: ''>, seg="'(tbl.id = c.id)\\nLEFT...'"]
INFO       [PD:3  MD:19]	...................FunctionSegment                	OneOf.match OUT     	    	[match=<MatchResult 0/11: ''>, seg="'(tbl.id = c.id)\\nLEFT...'"]
DEBUG      [PD:3  MD:18]	..................FunctionSegment                 	Funct.match OUT     	    	[match=<MatchResult 0/11: ''>, seg="'(tbl.id = c.id)\\nLEFT...'"]
DEBUG      [PD:3  MD:18]	..................Expression_D_Grammar            	Ref.match OUT       	    	[match=<MatchResult 0/11: ''>, seg="'(tbl.id = c.id)\\nLEFT...'"]
INFO       [PD:3  MD:20]	....................Expression_D_Grammar          	OneOf.match OUT     	++  	[match=<MatchResult 1/1: 'tbl.id = c.id'>, seg="'tbl.id = c.id'"]
INFO       [PD:3  MD:19]	...................Expression_D_Grammar           	Brack.match OUT     	++  	[match=<MatchResult 1/1: 'tbl.id = c.id'>, seg="'tbl.id = c.id'"]
INFO       [PD:3  MD:18]	..................Expression_D_Grammar            	Brack.match OUT     	+   	[match=<MatchResult 1/11: '(tbl.id = c.id)'>, seg="'(tbl.id = c.id)\\nLEFT...'"]
INFO       [PD:3  MD:18]	..................LiteralGrammar                  	OneOf.match PRN     	    	[ns=2, ps=4, ms=0, pruned=[<Ref: BooleanLiteralGrammar>, <Ref: QualifiedNumericLiteralSegment>, <Ref: NullLiteralSegment>, <Ref: DateTimeLiteralGrammar>], opts=[<Ref: QuotedLiteralSegment>, <Ref: NumericLiteralSegment>]]
DEBUG      [PD:3  MD:19]	...................LiteralGrammar                 	Ref.match OUT       	    	[match=<MatchResult 0/11: ''>, seg="'(tbl.id = c.id)\\nLEFT...'"]
DEBUG      [PD:3  MD:19]	...................LiteralGrammar                 	Ref.match OUT       	    	[match=<MatchResult 0/11: ''>, seg="'(tbl.id = c.id)\\nLEFT...'"]
INFO       [PD:3  MD:18]	..................LiteralGrammar                  	OneOf.match OUT     	    	[match=<MatchResult 0/11: ''>, seg="'(tbl.id = c.id)\\nLEFT...'"]
DEBUG      [PD:3  MD:18]	..................Expression_D_Grammar            	Ref.match OUT       	    	[match=<MatchResult 0/11: ''>, seg="'(tbl.id = c.id)\\nLEFT...'"]
DEBUG      [PD:3  MD:20]	....................ColumnReferenceSegment        	Delim._look_ahead_match IN	    	[ls=11, seg='(tbl.id = c.id)\nLEFT...']
DEBUG      [PD:3  MD:20]	....................ColumnReferenceSegment        	Delim._look_ahead_match SI	    	[mq=[], sb=['(TBL.ID', '', 'LEFT', '', 'JOIN', '', 'D', '', 'ON', '', '(TBL.ID']]
INFO       [PD:3  MD:20]	....................ColumnReferenceSegment        	OneOf.match PRN     	    	[ns=1, ps=8, ms=2, pruned=[<Ref: OnKeywordSegment>, <Ref: AsKeywordSegment>, <Ref: UsingKeywordSegment>, <Ref: CommaSegment>, <Ref: CastOperatorSegment>, <Ref: StartSquareBracketSegment>, <Ref: ColonSegment>, <Ref: DelimiterSegment>], opts=[<Ref: StartBracketSegment>, <Ref: BinaryOperatorGrammar>, <class 'sqlfluff.core.parser.segments.base.BracketedSegment'>]]
DEBUG      [PD:3  MD:21]	.....................ColumnReferenceSegment       	Ref.match OUT       	    	[match=<MatchResult 0/11: ''>, seg="'(tbl.id = c.id)\\nLEFT...'"]
INFO       [PD:3  MD:21]	.....................BinaryOperatorGrammar        	OneOf.match PRN     	    	[ns=1, ps=3, ms=0, pruned=[<Ref: ArithmeticBinaryOperatorGrammar>, <Ref: StringBinaryOperatorGrammar>, <Ref: BooleanBinaryOperatorGrammar>], opts=[<Ref: ComparisonOperatorGrammar>]]
INFO       [PD:3  MD:22]	......................ComparisonOperatorGrammar   	OneOf.match PRN     	    	[ns=1, ps=7, ms=0, pruned=[<Ref: EqualsSegment>, <Ref: GreaterThanSegment>, <Ref: LessThanSegment>, <Ref: GreaterThanOrEqualToSegment>, <Ref: LessThanOrEqualToSegment>, <Ref: NotEqualToSegment_a>, <Ref: NotEqualToSegment_b>], opts=[<Ref: LikeOperatorSegment>]]
DEBUG      [PD:3  MD:23]	.......................ComparisonOperatorGrammar  	Ref.match OUT       	    	[match=<MatchResult 0/11: ''>, seg="'(tbl.id = c.id)\\nLEFT...'"]
INFO       [PD:3  MD:22]	......................ComparisonOperatorGrammar   	OneOf.match OUT     	    	[match=<MatchResult 0/11: ''>, seg="'(tbl.id = c.id)\\nLEFT...'"]
DEBUG      [PD:3  MD:22]	......................BinaryOperatorGrammar       	Ref.match OUT       	    	[match=<MatchResult 0/11: ''>, seg="'(tbl.id = c.id)\\nLEFT...'"]
INFO       [PD:3  MD:21]	.....................BinaryOperatorGrammar        	OneOf.match OUT     	    	[match=<MatchResult 0/11: ''>, seg="'(tbl.id = c.id)\\nLEFT...'"]
DEBUG      [PD:3  MD:21]	.....................ColumnReferenceSegment       	Ref.match OUT       	    	[match=<MatchResult 0/11: ''>, seg="'(tbl.id = c.id)\\nLEFT...'"]
INFO       [PD:3  MD:20]	....................ColumnReferenceSegment        	OneOf.match OUT     	+   	[match=<MatchResult 1/11: '(tbl.id = c.id)'>, seg="'(tbl.id = c.id)\\nLEFT...'"]
DEBUG      [PD:3  MD:20]	....................ColumnReferenceSegment        	NonCo.match OUT     	    	[match=<MatchResult 0/11: ''>, seg="'(tbl.id = c.id)\\nLEFT...'"]
INFO       [PD:3  MD:19]	...................ColumnReferenceSegment         	Delim.match OUT     	    	[match=<MatchResult 0/11: ''>, seg="'(tbl.id = c.id)\\nLEFT...'"]
DEBUG      [PD:3  MD:18]	..................ColumnReferenceSegment          	Colum.match OUT     	    	[match=<MatchResult 0/11: ''>, seg="'(tbl.id = c.id)\\nLEFT...'"]
DEBUG      [PD:3  MD:18]	..................Expression_D_Grammar            	Ref.match OUT       	    	[match=<MatchResult 0/11: ''>, seg="'(tbl.id = c.id)\\nLEFT...'"]
DEBUG      [PD:3  MD:19]	...................Expression_D_Grammar           	Ref.match OUT       	    	[match=<MatchResult 0/11: ''>, seg="'(tbl.id = c.id)\\nLEFT...'"]
DEBUG      [PD:3  MD:23]	.......................ArrayLiteralSegment        	Delim._look_ahead_match IN	    	[ls=1, seg='tbl.id = c.id']
DEBUG      [PD:3  MD:23]	.......................ArrayLiteralSegment        	Delim._look_ahead_match SI	    	[mq=[], sb=['TBL.ID']]
DEBUG      [PD:3  MD:23]	.......................ArrayLiteralSegment        	Delim._look_ahead_match SC	    	[bsm=None]
INFO       [PD:3  MD:25]	.........................Expression_A_Grammar     	OneOf.match PRN     	    	[ns=1, ps=1, ms=0, pruned=[<Sequence: [<OneOf: [<Ref: PositiveSegment>, <Ref: N..., <Ref: Expression_C_Grammar>]>], opts=[<Ref: Expression_C_Grammar>]]
INFO       [PD:3  MD:26]	..........................Expression_C_Grammar    	OneOf.match PRN     	    	[ns=1, ps=2, ms=0, pruned=[<Sequence: [<Ref: ExistsKeywordSegment>, <Bracketed: [<Ref: SelectStatementSegmen...]>, <Ref: CaseExpressionSegment>], opts=[<Ref: Expression_D_Grammar>]]
INFO       [PD:3  MD:28]	............................Expression_D_Grammar  	OneOf.match PRN     	    	[ns=6, ps=3, ms=0, pruned=[<Bracketed: [<OneOf: [<Ref: ExpressionSegment>, <Ref:...]>, <Ref: SelectStatementSegment>, <Ref: IntervalExpressionSegment>], opts=[<Ref: BareFunctionSegment>, <Ref: FunctionSegment>, <Ref: LiteralGrammar>, <Ref: ColumnReferenceSegment>, <Sequence: [<Ref: SimpleArrayTypeGrammar [opt]>, <Ref: ArrayLiteralSegment>]>, <Sequence: [<Ref: DatatypeSegment>, <OneOf: [<Ref: QuotedLiteralSegment>, <R...]>]]
DEBUG      [PD:3  MD:29]	.............................Expression_D_Grammar 	Ref.match OUT       	    	[match=<MatchResult 0/1: ''>, seg="'tbl.id = c.id'"]
INFO       [PD:3  MD:30]	..............................FunctionSegment     	OneOf.match PRN     	    	[ns=1, ps=1, ms=0, pruned=[<Sequence: [<Sequence: [<Ref: DateAddFunctionNameSeg...]>], opts=[<Sequence: [<Sequence: [<AnyNumberOf: [<Ref: Functio..., <Ref: PostFunctionGrammar [opt]>]>]]
DEBUG      [PD:3  MD:36]	....................................DateAddFunctionNameSegment	Ref.match OUT       	    	[match=<MatchResult 0/1: ''>, seg="'tbl.id = c.id'"]
INFO       [PD:3  MD:35]	...................................DateAddFunctionNameSegment	Seque.match OUT     	    	[match=<MatchResult 0/1: ''>, seg="'tbl.id = c.id'"]
DEBUG      [PD:3  MD:34]	..................................DateAddFunctionNameSegment	DateA.match OUT     	    	[match=<MatchResult 0/1: ''>, seg="'tbl.id = c.id'"]
DEBUG      [PD:3  MD:34]	..................................FunctionSegment 	Ref.match OUT       	    	[match=<MatchResult 0/1: ''>, seg="'tbl.id = c.id'"]
INFO       [PD:3  MD:33]	.................................FunctionSegment  	AnyNu.match PRN     	    	[ns=1, ps=0, ms=0, pruned=[], opts=[<Ref: FunctionNameSegment>]]
INFO       [PD:3  MD:36]	....................................FunctionNameSegment	AnyNu.match PRN     	    	[ns=1, ps=0, ms=0, pruned=[], opts=[<Sequence: [<Ref: SingleIdentifierGrammar>, <Ref: DotSegment>]>]]
INFO       [PD:3  MD:38]	......................................SingleIdentifierGrammar	OneOf.match PRN     	    	[ns=2, ps=0, ms=0, pruned=[], opts=[<Ref: NakedIdentifierSegment>, <Ref: QuotedIdentifierSegment>]]
DEBUG      [PD:3  MD:39]	.......................................SingleIdentifierGrammar	Ref.match OUT       	    	[match=<MatchResult 0/1: ''>, seg="'tbl.id = c.id'"]
DEBUG      [PD:3  MD:39]	.......................................SingleIdentifierGrammar	Ref.match OUT       	    	[match=<MatchResult 0/1: ''>, seg="'tbl.id = c.id'"]
INFO       [PD:3  MD:38]	......................................SingleIdentifierGrammar	OneOf.match OUT     	    	[match=<MatchResult 0/1: ''>, seg="'tbl.id = c.id'"]
DEBUG      [PD:3  MD:38]	......................................FunctionNameSegment	Ref.match OUT       	    	[match=<MatchResult 0/1: ''>, seg="'tbl.id = c.id'"]
INFO       [PD:3  MD:37]	.....................................FunctionNameSegment	Seque.match OUT     	    	[match=<MatchResult 0/1: ''>, seg="'tbl.id = c.id'"]
INFO       [PD:3  MD:36]	....................................FunctionNameSegment	AnyNu.match OUT     	    	[match=<MatchResult 0/1: ''>, seg="'tbl.id = c.id'"]
INFO       [PD:3  MD:36]	....................................FunctionNameSegment	OneOf.match PRN     	    	[ns=2, ps=0, ms=0, pruned=[], opts=[<Ref: FunctionNameIdentifierSegment>, <Ref: QuotedIdentifierSegment>]]
DEBUG      [PD:3  MD:37]	.....................................FunctionNameSegment	Ref.match OUT       	    	[match=<MatchResult 0/1: ''>, seg="'tbl.id = c.id'"]
DEBUG      [PD:3  MD:37]	.....................................FunctionNameSegment	Ref.match OUT       	    	[match=<MatchResult 0/1: ''>, seg="'tbl.id = c.id'"]
INFO       [PD:3  MD:36]	....................................FunctionNameSegment	OneOf.match OUT     	    	[match=<MatchResult 0/1: ''>, seg="'tbl.id = c.id'"]
INFO       [PD:3  MD:35]	...................................FunctionNameSegment	Seque.match OUT     	    	[match=<MatchResult 0/1: ''>, seg="'tbl.id = c.id'"]
DEBUG      [PD:3  MD:34]	..................................FunctionNameSegment	Funct.match OUT     	    	[match=<MatchResult 0/1: ''>, seg="'tbl.id = c.id'"]
DEBUG      [PD:3  MD:34]	..................................FunctionSegment 	Ref.match OUT       	    	[match=<MatchResult 0/1: ''>, seg="'tbl.id = c.id'"]
INFO       [PD:3  MD:33]	.................................FunctionSegment  	AnyNu.match OUT     	    	[match=<MatchResult 0/1: ''>, seg="'tbl.id = c.id'"]
INFO       [PD:3  MD:32]	................................FunctionSegment   	Seque.match OUT     	    	[match=<MatchResult 0/1: ''>, seg="'tbl.id = c.id'"]
INFO       [PD:3  MD:31]	...............................FunctionSegment    	Seque.match OUT     	    	[match=<MatchResult 0/1: ''>, seg="'tbl.id = c.id'"]
INFO       [PD:3  MD:30]	..............................FunctionSegment     	OneOf.match OUT     	    	[match=<MatchResult 0/1: ''>, seg="'tbl.id = c.id'"]
DEBUG      [PD:3  MD:29]	.............................FunctionSegment      	Funct.match OUT     	    	[match=<MatchResult 0/1: ''>, seg="'tbl.id = c.id'"]
DEBUG      [PD:3  MD:29]	.............................Expression_D_Grammar 	Ref.match OUT       	    	[match=<MatchResult 0/1: ''>, seg="'tbl.id = c.id'"]
INFO       [PD:3  MD:29]	.............................LiteralGrammar       	OneOf.match PRN     	    	[ns=2, ps=4, ms=0, pruned=[<Ref: BooleanLiteralGrammar>, <Ref: QualifiedNumericLiteralSegment>, <Ref: NullLiteralSegment>, <Ref: DateTimeLiteralGrammar>], opts=[<Ref: QuotedLiteralSegment>, <Ref: NumericLiteralSegment>]]
DEBUG      [PD:3  MD:30]	..............................LiteralGrammar      	Ref.match OUT       	    	[match=<MatchResult 0/1: ''>, seg="'tbl.id = c.id'"]
DEBUG      [PD:3  MD:30]	..............................LiteralGrammar      	Ref.match OUT       	    	[match=<MatchResult 0/1: ''>, seg="'tbl.id = c.id'"]
INFO       [PD:3  MD:29]	.............................LiteralGrammar       	OneOf.match OUT     	    	[match=<MatchResult 0/1: ''>, seg="'tbl.id = c.id'"]
DEBUG      [PD:3  MD:29]	.............................Expression_D_Grammar 	Ref.match OUT       	    	[match=<MatchResult 0/1: ''>, seg="'tbl.id = c.id'"]
DEBUG      [PD:3  MD:31]	...............................ColumnReferenceSegment	Delim._look_ahead_match IN	    	[ls=1, seg='tbl.id = c.id']
DEBUG      [PD:3  MD:31]	...............................ColumnReferenceSegment	Delim._look_ahead_match SI	    	[mq=[], sb=['TBL.ID']]
INFO       [PD:3  MD:31]	...............................ColumnReferenceSegment	OneOf.match PRN     	    	[ns=1, ps=10, ms=0, pruned=[<Ref: OnKeywordSegment>, <Ref: AsKeywordSegment>, <Ref: UsingKeywordSegment>, <Ref: CommaSegment>, <Ref: CastOperatorSegment>, <Ref: StartSquareBracketSegment>, <Ref: StartBracketSegment>, <Ref: ColonSegment>, <Ref: DelimiterSegment>, <class 'sqlfluff.core.parser.segments.base.BracketedSegment'>], opts=[<Ref: BinaryOperatorGrammar>]]
INFO       [PD:3  MD:32]	................................BinaryOperatorGrammar	OneOf.match PRN     	    	[ns=1, ps=3, ms=0, pruned=[<Ref: ArithmeticBinaryOperatorGrammar>, <Ref: StringBinaryOperatorGrammar>, <Ref: BooleanBinaryOperatorGrammar>], opts=[<Ref: ComparisonOperatorGrammar>]]
INFO       [PD:3  MD:33]	.................................ComparisonOperatorGrammar	OneOf.match PRN     	    	[ns=1, ps=7, ms=0, pruned=[<Ref: EqualsSegment>, <Ref: GreaterThanSegment>, <Ref: LessThanSegment>, <Ref: GreaterThanOrEqualToSegment>, <Ref: LessThanOrEqualToSegment>, <Ref: NotEqualToSegment_a>, <Ref: NotEqualToSegment_b>], opts=[<Ref: LikeOperatorSegment>]]
DEBUG      [PD:3  MD:34]	..................................ComparisonOperatorGrammar	Ref.match OUT       	    	[match=<MatchResult 0/1: ''>, seg="'tbl.id = c.id'"]
INFO       [PD:3  MD:33]	.................................ComparisonOperatorGrammar	OneOf.match OUT     	    	[match=<MatchResult 0/1: ''>, seg="'tbl.id = c.id'"]
DEBUG      [PD:3  MD:33]	.................................BinaryOperatorGrammar	Ref.match OUT       	    	[match=<MatchResult 0/1: ''>, seg="'tbl.id = c.id'"]
INFO       [PD:3  MD:32]	................................BinaryOperatorGrammar	OneOf.match OUT     	    	[match=<MatchResult 0/1: ''>, seg="'tbl.id = c.id'"]
DEBUG      [PD:3  MD:32]	................................ColumnReferenceSegment	Ref.match OUT       	    	[match=<MatchResult 0/1: ''>, seg="'tbl.id = c.id'"]
INFO       [PD:3  MD:31]	...............................ColumnReferenceSegment	OneOf.match OUT     	    	[match=<MatchResult 0/1: ''>, seg="'tbl.id = c.id'"]
DEBUG      [PD:3  MD:31]	...............................ColumnReferenceSegment	NonCo.match OUT     	    	[match=<MatchResult 0/1: ''>, seg="'tbl.id = c.id'"]
INFO       [PD:3  MD:31]	...............................SingleIdentifierGrammar	OneOf.match PRN     	    	[ns=2, ps=0, ms=0, pruned=[], opts=[<Ref: NakedIdentifierSegment>, <Ref: QuotedIdentifierSegment>]]
DEBUG      [PD:3  MD:32]	................................SingleIdentifierGrammar	Ref.match OUT       	    	[match=<MatchResult 0/1: ''>, seg="'tbl.id = c.id'"]
DEBUG      [PD:3  MD:32]	................................SingleIdentifierGrammar	Ref.match OUT       	    	[match=<MatchResult 0/1: ''>, seg="'tbl.id = c.id'"]
INFO       [PD:3  MD:31]	...............................SingleIdentifierGrammar	OneOf.match OUT     	    	[match=<MatchResult 0/1: ''>, seg="'tbl.id = c.id'"]
DEBUG      [PD:3  MD:31]	...............................ColumnReferenceSegment	Ref.match OUT       	    	[match=<MatchResult 0/1: ''>, seg="'tbl.id = c.id'"]
INFO       [PD:3  MD:30]	..............................ColumnReferenceSegment	Delim.match OUT     	    	[match=<MatchResult 0/1: ''>, seg="'tbl.id = c.id'"]
DEBUG      [PD:3  MD:29]	.............................ColumnReferenceSegment	Colum.match OUT     	    	[match=<MatchResult 0/1: ''>, seg="'tbl.id = c.id'"]
DEBUG      [PD:3  MD:29]	.............................Expression_D_Grammar 	Ref.match OUT       	    	[match=<MatchResult 0/1: ''>, seg="'tbl.id = c.id'"]
DEBUG      [PD:3  MD:30]	..............................Expression_D_Grammar	Ref.match OUT       	    	[match=<MatchResult 0/1: ''>, seg="'tbl.id = c.id'"]
INFO       [PD:3  MD:31]	...............................ArrayLiteralSegment	Brack.match OUT     	    	[match=<MatchResult 0/1: ''>, seg="'tbl.id = c.id'"]
DEBUG      [PD:3  MD:30]	..............................ArrayLiteralSegment 	Array.match OUT     	    	[match=<MatchResult 0/1: ''>, seg="'tbl.id = c.id'"]
DEBUG      [PD:3  MD:30]	..............................Expression_D_Grammar	Ref.match OUT       	    	[match=<MatchResult 0/1: ''>, seg="'tbl.id = c.id'"]
INFO       [PD:3  MD:29]	.............................Expression_D_Grammar 	Seque.match OUT     	    	[match=<MatchResult 0/1: ''>, seg="'tbl.id = c.id'"]
INFO       [PD:3  MD:31]	...............................DatatypeSegment    	OneOf.match PRN     	    	[ns=1, ps=2, ms=0, pruned=[<Sequence: [<OneOf: [<Ref: TimeKeywordSegment>, <Ref..., <Bracketed: [<Ref: NumericLiteralSegment..., <Sequence:...]>, <Sequence: [<Ref: DoubleKeywordSegment>, <Ref: PrecisionKeywordSegment>]>], opts=[<Sequence: [<OneOf: [<Sequence: [<OneOf: [<Ref: Char..., <Bracketed: [<OneOf: [<Delimited: [<Ref:..., <Ref: Char...]>]]
INFO       [PD:3  MD:33]	.................................DatatypeSegment  	OneOf.match PRN     	    	[ns=1, ps=1, ms=0, pruned=[<Sequence: [<OneOf: [<Ref: CharacterKeywordSegment>,..., <OneOf: [<Ref: VaryingKeywordSegment>, <...]>], opts=[<Sequence: [<Sequence: [<Ref: SingleIdentifierGramma..., <Ref: DatatypeIdentifierSegment>]>]]
INFO       [PD:3  MD:36]	....................................SingleIdentifierGrammar	OneOf.match PRN     	    	[ns=2, ps=0, ms=0, pruned=[], opts=[<Ref: NakedIdentifierSegment>, <Ref: QuotedIdentifierSegment>]]
DEBUG      [PD:3  MD:37]	.....................................SingleIdentifierGrammar	Ref.match OUT       	    	[match=<MatchResult 0/1: ''>, seg="'tbl.id = c.id'"]
DEBUG      [PD:3  MD:37]	.....................................SingleIdentifierGrammar	Ref.match OUT       	    	[match=<MatchResult 0/1: ''>, seg="'tbl.id = c.id'"]
INFO       [PD:3  MD:36]	....................................SingleIdentifierGrammar	OneOf.match OUT     	    	[match=<MatchResult 0/1: ''>, seg="'tbl.id = c.id'"]
DEBUG      [PD:3  MD:36]	....................................DatatypeSegment	Ref.match OUT       	    	[match=<MatchResult 0/1: ''>, seg="'tbl.id = c.id'"]
INFO       [PD:3  MD:35]	...................................DatatypeSegment	Seque.match OUT     	    	[match=<MatchResult 0/1: ''>, seg="'tbl.id = c.id'"]
DEBUG      [PD:3  MD:35]	...................................DatatypeSegment	Ref.match OUT       	    	[match=<MatchResult 0/1: ''>, seg="'tbl.id = c.id'"]
INFO       [PD:3  MD:34]	..................................DatatypeSegment 	Seque.match OUT     	    	[match=<MatchResult 0/1: ''>, seg="'tbl.id = c.id'"]
INFO       [PD:3  MD:33]	.................................DatatypeSegment  	OneOf.match OUT     	    	[match=<MatchResult 0/1: ''>, seg="'tbl.id = c.id'"]
INFO       [PD:3  MD:32]	................................DatatypeSegment   	Seque.match OUT     	    	[match=<MatchResult 0/1: ''>, seg="'tbl.id = c.id'"]
INFO       [PD:3  MD:31]	...............................DatatypeSegment    	OneOf.match OUT     	    	[match=<MatchResult 0/1: ''>, seg="'tbl.id = c.id'"]
DEBUG      [PD:3  MD:30]	..............................DatatypeSegment     	Datat.match OUT     	    	[match=<MatchResult 0/1: ''>, seg="'tbl.id = c.id'"]
DEBUG      [PD:3  MD:30]	..............................Expression_D_Grammar	Ref.match OUT       	    	[match=<MatchResult 0/1: ''>, seg="'tbl.id = c.id'"]
INFO       [PD:3  MD:29]	.............................Expression_D_Grammar 	Seque.match OUT     	    	[match=<MatchResult 0/1: ''>, seg="'tbl.id = c.id'"]
INFO       [PD:3  MD:28]	............................Expression_D_Grammar  	OneOf.match OUT     	    	[match=<MatchResult 0/1: ''>, seg="'tbl.id = c.id'"]
INFO       [PD:3  MD:27]	...........................Expression_D_Grammar   	Seque.match OUT     	    	[match=<MatchResult 0/1: ''>, seg="'tbl.id = c.id'"]
DEBUG      [PD:3  MD:27]	...........................Expression_C_Grammar   	Ref.match OUT       	    	[match=<MatchResult 0/1: ''>, seg="'tbl.id = c.id'"]
INFO       [PD:3  MD:26]	..........................Expression_C_Grammar    	OneOf.match OUT     	    	[match=<MatchResult 0/1: ''>, seg="'tbl.id = c.id'"]
DEBUG      [PD:3  MD:26]	..........................Expression_A_Grammar    	Ref.match OUT       	    	[match=<MatchResult 0/1: ''>, seg="'tbl.id = c.id'"]
INFO       [PD:3  MD:25]	.........................Expression_A_Grammar     	OneOf.match OUT     	    	[match=<MatchResult 0/1: ''>, seg="'tbl.id = c.id'"]
INFO       [PD:3  MD:24]	........................Expression_A_Grammar      	Seque.match OUT     	    	[match=<MatchResult 0/1: ''>, seg="'tbl.id = c.id'"]
DEBUG      [PD:3  MD:24]	........................ExpressionSegment         	Ref.match OUT       	    	[match=<MatchResult 0/1: ''>, seg="'tbl.id = c.id'"]
DEBUG      [PD:3  MD:23]	.......................ExpressionSegment          	Expre.match OUT     	    	[match=<MatchResult 0/1: ''>, seg="'tbl.id = c.id'"]
DEBUG      [PD:3  MD:23]	.......................ArrayLiteralSegment        	Ref.match OUT       	    	[match=<MatchResult 0/1: ''>, seg="'tbl.id = c.id'"]
INFO       [PD:3  MD:22]	......................ArrayLiteralSegment         	Delim.match OUT     	    	[match=<MatchResult 0/1: ''>, seg="'tbl.id = c.id'"]
INFO       [PD:3  MD:21]	.....................ArrayLiteralSegment          	Brack.match OUT     	    	[match=<MatchResult 0/1: ''>, seg="'tbl.id = c.id'"]
INFO       [PD:3  MD:20]	....................ArrayLiteralSegment           	Brack.match OUT     	    	[match=<MatchResult 0/11: ''>, seg="'(tbl.id = c.id)\\nLEFT...'"]
DEBUG      [PD:3  MD:19]	...................ArrayLiteralSegment            	Array.match OUT     	    	[match=<MatchResult 0/11: ''>, seg="'(tbl.id = c.id)\\nLEFT...'"]
DEBUG      [PD:3  MD:19]	...................Expression_D_Grammar           	Ref.match OUT       	    	[match=<MatchResult 0/11: ''>, seg="'(tbl.id = c.id)\\nLEFT...'"]
INFO       [PD:3  MD:18]	..................Expression_D_Grammar            	Seque.match OUT     	    	[match=<MatchResult 0/11: ''>, seg="'(tbl.id = c.id)\\nLEFT...'"]
INFO       [PD:3  MD:20]	....................DatatypeSegment               	OneOf.match PRN     	    	[ns=1, ps=2, ms=0, pruned=[<Sequence: [<OneOf: [<Ref: TimeKeywordSegment>, <Ref..., <Bracketed: [<Ref: NumericLiteralSegment..., <Sequence:...]>, <Sequence: [<Ref: DoubleKeywordSegment>, <Ref: PrecisionKeywordSegment>]>], opts=[<Sequence: [<OneOf: [<Sequence: [<OneOf: [<Ref: Char..., <Bracketed: [<OneOf: [<Delimited: [<Ref:..., <Ref: Char...]>]]
INFO       [PD:3  MD:22]	......................DatatypeSegment             	OneOf.match PRN     	    	[ns=1, ps=1, ms=0, pruned=[<Sequence: [<OneOf: [<Ref: CharacterKeywordSegment>,..., <OneOf: [<Ref: VaryingKeywordSegment>, <...]>], opts=[<Sequence: [<Sequence: [<Ref: SingleIdentifierGramma..., <Ref: DatatypeIdentifierSegment>]>]]
INFO       [PD:3  MD:25]	.........................SingleIdentifierGrammar  	OneOf.match PRN     	    	[ns=2, ps=0, ms=0, pruned=[], opts=[<Ref: NakedIdentifierSegment>, <Ref: QuotedIdentifierSegment>]]
DEBUG      [PD:3  MD:26]	..........................SingleIdentifierGrammar 	Ref.match OUT       	    	[match=<MatchResult 0/11: ''>, seg="'(tbl.id = c.id)\\nLEFT...'"]
DEBUG      [PD:3  MD:26]	..........................SingleIdentifierGrammar 	Ref.match OUT       	    	[match=<MatchResult 0/11: ''>, seg="'(tbl.id = c.id)\\nLEFT...'"]
INFO       [PD:3  MD:25]	.........................SingleIdentifierGrammar  	OneOf.match OUT     	    	[match=<MatchResult 0/11: ''>, seg="'(tbl.id = c.id)\\nLEFT...'"]
DEBUG      [PD:3  MD:25]	.........................DatatypeSegment          	Ref.match OUT       	    	[match=<MatchResult 0/11: ''>, seg="'(tbl.id = c.id)\\nLEFT...'"]
INFO       [PD:3  MD:24]	........................DatatypeSegment           	Seque.match OUT     	    	[match=<MatchResult 0/11: ''>, seg="'(tbl.id = c.id)\\nLEFT...'"]
DEBUG      [PD:3  MD:24]	........................DatatypeSegment           	Ref.match OUT       	    	[match=<MatchResult 0/11: ''>, seg="'(tbl.id = c.id)\\nLEFT...'"]
INFO       [PD:3  MD:23]	.......................DatatypeSegment            	Seque.match OUT     	    	[match=<MatchResult 0/11: ''>, seg="'(tbl.id = c.id)\\nLEFT...'"]
INFO       [PD:3  MD:22]	......................DatatypeSegment             	OneOf.match OUT     	    	[match=<MatchResult 0/11: ''>, seg="'(tbl.id = c.id)\\nLEFT...'"]
INFO       [PD:3  MD:21]	.....................DatatypeSegment              	Seque.match OUT     	    	[match=<MatchResult 0/11: ''>, seg="'(tbl.id = c.id)\\nLEFT...'"]
INFO       [PD:3  MD:20]	....................DatatypeSegment               	OneOf.match OUT     	    	[match=<MatchResult 0/11: ''>, seg="'(tbl.id = c.id)\\nLEFT...'"]
DEBUG      [PD:3  MD:19]	...................DatatypeSegment                	Datat.match OUT     	    	[match=<MatchResult 0/11: ''>, seg="'(tbl.id = c.id)\\nLEFT...'"]
DEBUG      [PD:3  MD:19]	...................Expression_D_Grammar           	Ref.match OUT       	    	[match=<MatchResult 0/11: ''>, seg="'(tbl.id = c.id)\\nLEFT...'"]
INFO       [PD:3  MD:18]	..................Expression_D_Grammar            	Seque.match OUT     	    	[match=<MatchResult 0/11: ''>, seg="'(tbl.id = c.id)\\nLEFT...'"]
INFO       [PD:3  MD:17]	.................Expression_D_Grammar             	OneOf.match OUT     	+   	[match=<MatchResult 1/11: '(tbl.id = c.id)'>, seg="'(tbl.id = c.id)\\nLEFT...'"]
INFO       [PD:3  MD:17]	.................Accessor_Grammar                 	AnyNu.match PRN     	    	[ns=0, ps=1, ms=0, pruned=[<Ref: ArrayAccessorSegment>], opts='ALL']
INFO       [PD:3  MD:17]	.................Accessor_Grammar                 	AnyNu.match OUT     	    	[match=<MatchResult 0/9: ''>, seg="'LEFT JOIN d ON (tbl....'"]
DEBUG      [PD:3  MD:17]	.................Expression_D_Grammar             	Ref.match OUT       	    	[match=<MatchResult 0/9: ''>, seg="'LEFT JOIN d ON (tbl....'"]
INFO       [PD:3  MD:17]	.................Expression_D_Grammar             	AnyNu.match PRN     	    	[ns=0, ps=1, ms=0, pruned=[<Ref: ShorthandCastSegment>], opts='ALL']
INFO       [PD:3  MD:17]	.................Expression_D_Grammar             	AnyNu.match OUT     	    	[match=<MatchResult 0/9: ''>, seg="'LEFT JOIN d ON (tbl....'"]
INFO       [PD:3  MD:16]	................Expression_D_Grammar              	Seque.match OUT     	+   	[match=<MatchResult 1/11: '(tbl.id = c.id)'>, seg="'(tbl.id = c.id)\\nLEFT...'"]
DEBUG      [PD:3  MD:16]	................Expression_C_Grammar              	Ref.match OUT       	+   	[match=<MatchResult 1/11: '(tbl.id = c.id)'>, seg="'(tbl.id = c.id)\\nLEFT...'"]
INFO       [PD:3  MD:15]	...............Expression_C_Grammar               	OneOf.match OUT     	+   	[match=<MatchResult 1/11: '(tbl.id = c.id)'>, seg="'(tbl.id = c.id)\\nLEFT...'"]
DEBUG      [PD:3  MD:15]	...............Expression_A_Grammar               	Ref.match OUT       	+   	[match=<MatchResult 1/11: '(tbl.id = c.id)'>, seg="'(tbl.id = c.id)\\nLEFT...'"]
INFO       [PD:3  MD:14]	..............Expression_A_Grammar                	OneOf.match OUT     	+   	[match=<MatchResult 1/11: '(tbl.id = c.id)'>, seg="'(tbl.id = c.id)\\nLEFT...'"]
INFO       [PD:3  MD:14]	..............Expression_A_Grammar                	AnyNu.match PRN     	    	[ns=1, ps=0, ms=0, pruned=[], opts=[<OneOf: [<Sequence: [<OneOf: [<Sequence: [<Ref: N..., <Sequence: [<Ref: NotKeywordSegment [opt..., <Sequence:...]>]]
INFO       [PD:3  MD:15]	...............Expression_A_Grammar               	OneOf.match PRN     	    	[ns=3, ps=5, ms=0, pruned=[<Sequence: [<Ref: NotKeywordSegment [opt]>, <Ref: InKeywordSegment>, <Bracketed: [<OneOf: [<Delimited: [<Ref:...]>, <Sequence: [<Ref: NotKeywordSegment [opt]>, <Ref: InKeywordSegment>, <Ref: FunctionSegment>]>, <Sequence: [<Ref: IsKeywordSegment>, <Ref: NotKeywordSegment [opt]>, <Ref: IsClauseGrammar>]>, <Sequence: [<Ref: NotKeywordSegment>, <Ref: Expression_C_Grammar>]>, <Sequence: [<Ref: NotKeywordSegment [opt]>, <Ref: BetweenKeywordSegment>, <Ref: Expression_C_Grammar>, <AnyNumbe...]>], opts=[<Sequence: [<OneOf: [<Sequence: [<Ref: NotKeywordSeg..., <Ref: Expression_C_Grammar>, <Sequence: [<Ref: EscapeKe...]>, <Ref: IsNullGrammar>, <Ref: NotNullGrammar>]]
INFO       [PD:3  MD:17]	.................Expression_A_Grammar             	OneOf.match PRN     	    	[ns=1, ps=1, ms=0, pruned=[<Sequence: [<Ref: NotKeywordSegment [opt]>, <Ref: LikeGrammar>]>], opts=[<Sequence: [<Ref: BinaryOperatorGrammar>, <Ref: NotKeywordSegment [opt]>]>]]
INFO       [PD:3  MD:19]	...................BinaryOperatorGrammar          	OneOf.match PRN     	    	[ns=1, ps=3, ms=0, pruned=[<Ref: ArithmeticBinaryOperatorGrammar>, <Ref: StringBinaryOperatorGrammar>, <Ref: BooleanBinaryOperatorGrammar>], opts=[<Ref: ComparisonOperatorGrammar>]]
INFO       [PD:3  MD:20]	....................ComparisonOperatorGrammar     	OneOf.match PRN     	    	[ns=1, ps=7, ms=0, pruned=[<Ref: EqualsSegment>, <Ref: GreaterThanSegment>, <Ref: LessThanSegment>, <Ref: GreaterThanOrEqualToSegment>, <Ref: LessThanOrEqualToSegment>, <Ref: NotEqualToSegment_a>, <Ref: NotEqualToSegment_b>], opts=[<Ref: LikeOperatorSegment>]]
DEBUG      [PD:3  MD:21]	.....................ComparisonOperatorGrammar    	Ref.match OUT       	    	[match=<MatchResult 0/9: ''>, seg="'LEFT JOIN d ON (tbl....'"]
INFO       [PD:3  MD:20]	....................ComparisonOperatorGrammar     	OneOf.match OUT     	    	[match=<MatchResult 0/9: ''>, seg="'LEFT JOIN d ON (tbl....'"]
DEBUG      [PD:3  MD:20]	....................BinaryOperatorGrammar         	Ref.match OUT       	    	[match=<MatchResult 0/9: ''>, seg="'LEFT JOIN d ON (tbl....'"]
INFO       [PD:3  MD:19]	...................BinaryOperatorGrammar          	OneOf.match OUT     	    	[match=<MatchResult 0/9: ''>, seg="'LEFT JOIN d ON (tbl....'"]
DEBUG      [PD:3  MD:19]	...................Expression_A_Grammar           	Ref.match OUT       	    	[match=<MatchResult 0/9: ''>, seg="'LEFT JOIN d ON (tbl....'"]
INFO       [PD:3  MD:18]	..................Expression_A_Grammar            	Seque.match OUT     	    	[match=<MatchResult 0/9: ''>, seg="'LEFT JOIN d ON (tbl....'"]
INFO       [PD:3  MD:17]	.................Expression_A_Grammar             	OneOf.match OUT     	    	[match=<MatchResult 0/9: ''>, seg="'LEFT JOIN d ON (tbl....'"]
INFO       [PD:3  MD:16]	................Expression_A_Grammar              	Seque.match OUT     	    	[match=<MatchResult 0/9: ''>, seg="'LEFT JOIN d ON (tbl....'"]
DEBUG      [PD:3  MD:16]	................Expression_A_Grammar              	Ref.match OUT       	    	[match=<MatchResult 0/9: ''>, seg="'LEFT JOIN d ON (tbl....'"]
DEBUG      [PD:3  MD:16]	................Expression_A_Grammar              	Ref.match OUT       	    	[match=<MatchResult 0/9: ''>, seg="'LEFT JOIN d ON (tbl....'"]
INFO       [PD:3  MD:15]	...............Expression_A_Grammar               	OneOf.match OUT     	    	[match=<MatchResult 0/9: ''>, seg="'LEFT JOIN d ON (tbl....'"]
INFO       [PD:3  MD:14]	..............Expression_A_Grammar                	AnyNu.match OUT     	    	[match=<MatchResult 0/9: ''>, seg="'LEFT JOIN d ON (tbl....'"]
INFO       [PD:3  MD:13]	.............Expression_A_Grammar                 	Seque.match OUT     	+   	[match=<MatchResult 1/11: '(tbl.id = c.id)'>, seg="'(tbl.id = c.id)\\nLEFT...'"]
DEBUG      [PD:3  MD:13]	.............ExpressionSegment                    	Ref.match OUT       	+   	[match=<MatchResult 1/11: '(tbl.id = c.id)'>, seg="'(tbl.id = c.id)\\nLEFT...'"]
DEBUG      [PD:3  MD:12]	............ExpressionSegment                     	Expre.match OUT     	+   	[match=<MatchResult 1/11: '(tbl.id = c.id)'>, seg="'(tbl.id = c.id)\\nLEFT...'"]
DEBUG      [PD:3  MD:12]	............JoinOnConditionSegment                	Ref.match OUT       	+   	[match=<MatchResult 1/11: '(tbl.id = c.id)'>, seg="'(tbl.id = c.id)\\nLEFT...'"]
INFO       [PD:3  MD:11]	...........JoinOnConditionSegment                 	Optio.match OUT     	+   	[match=<MatchResult 1/11: '(tbl.id = c.id)'>, seg="'(tbl.id = c.id)\\nLEFT...'"]
INFO       [PD:3  MD:10]	..........JoinOnConditionSegment                  	Seque.match OUT     	+   	[match=<MatchResult 5/15: 'ON (tbl.id = c.id)'>, seg="'ON (tbl.id = c.id)\\nL...'"]
DEBUG      [PD:3  MD:9 ]	.........JoinOnConditionSegment                   	JoinO.match OUT     	+   	[match=<MatchResult 1/11: 'ON (tbl.id = c.id)'>, seg="'ON (tbl.id = c.id)\\nL...'"]
DEBUG      [PD:3  MD:9 ]	.........JoinClauseSegment                        	Ref.match OUT       	+   	[match=<MatchResult 1/11: 'ON (tbl.id = c.id)'>, seg="'ON (tbl.id = c.id)\\nL...'"]
INFO       [PD:3  MD:8 ]	........JoinClauseSegment                         	OneOf.match OUT     	+   	[match=<MatchResult 1/11: 'ON (tbl.id = c.id)'>, seg="'ON (tbl.id = c.id)\\nL...'"]
INFO       [PD:3  MD:7 ]	.......JoinClauseSegment                          	Seque.match OUT     	+   	[match=<MatchResult 3/13: 'c ON (tbl.id = c.id)'>, seg="'c ON (tbl.id = c.id)...'"]
INFO       [PD:3  MD:6 ]	......JoinClauseSegment                           	Seque.match OUT     	+   	[match=<MatchResult 7/17: 'JOIN c ON (tbl.id = c.id)'>, seg="'JOIN c ON (tbl.id = ...'"]
DEBUG      [PD:3  MD:5 ]	.....JoinClauseSegment                            	JoinC.match OUT     	+   	[match=<MatchResult 1/11: 'JOIN c ON (tbl.id = c.id)'>, seg="'JOIN c ON (tbl.id = ...'"]
DEBUG      [PD:3  MD:5 ]	.....FromExpressionSegment                        	Ref.match OUT       	+   	[match=<MatchResult 1/11: 'JOIN c ON (tbl.id = c.id)'>, seg="'JOIN c ON (tbl.id = ...'"]
DEBUG      [PD:3  MD:5 ]	.....FromExpressionSegment                        	Ref.match OUT       	    	[match=<MatchResult 0/17: ''>, seg="'JOIN c ON (tbl.id = ...'"]
INFO       [PD:3  MD:4 ]	....FromExpressionSegment                         	AnyNu.match PRN     	    	[ns=1, ps=0, ms=1, pruned=[], opts=[<Ref: JoinClauseSegment>, <Ref: JoinLikeClauseGrammar>]]
INFO       [PD:3  MD:7 ]	.......JoinClauseSegment                          	OneOf.match PRN     	    	[ns=0, ps=2, ms=1, pruned=[<Ref: CrossKeywordSegment>, <Ref: InnerKeywordSegment>], opts=[<Sequence: [<OneOf: [<Ref: FullKeywordSegment>, <Ref..., <Ref: OuterKeywordSegment [opt]>]>]]
INFO       [PD:3  MD:9 ]	.........JoinClauseSegment                        	OneOf.match PRN     	    	[ns=0, ps=2, ms=1, pruned=[<Ref: FullKeywordSegment>, <Ref: RightKeywordSegment>], opts=[<Ref: LeftKeywordSegment>]]
DEBUG      [PD:3  MD:10]	..........JoinClauseSegment                       	Ref.match OUT       	+   	[match=<MatchResult 1/9: 'LEFT'>, seg="'LEFT JOIN d ON (tbl....'"]
INFO       [PD:3  MD:9 ]	.........JoinClauseSegment                        	OneOf.match OUT     	+   	[match=<MatchResult 1/9: 'LEFT'>, seg="'LEFT JOIN d ON (tbl....'"]
DEBUG      [PD:3  MD:9 ]	.........JoinClauseSegment                        	Ref.match OUT       	    	[match=<MatchResult 0/7: ''>, seg="'JOIN d ON (tbl.id = ...'"]
INFO       [PD:3  MD:8 ]	........JoinClauseSegment                         	Seque.match OUT     	+   	[match=<MatchResult 1/9: 'LEFT'>, seg="'LEFT JOIN d ON (tbl....'"]
INFO       [PD:3  MD:7 ]	.......JoinClauseSegment                          	OneOf.match OUT     	+   	[match=<MatchResult 1/9: 'LEFT'>, seg="'LEFT JOIN d ON (tbl....'"]
DEBUG      [PD:3  MD:8 ]	........JoinKeywords                              	Ref.match OUT       	+   	[match=<MatchResult 1/7: 'JOIN'>, seg="'JOIN d ON (tbl.id = ...'"]
INFO       [PD:3  MD:7 ]	.......JoinKeywords                               	Seque.match OUT     	+   	[match=<MatchResult 1/7: 'JOIN'>, seg="'JOIN d ON (tbl.id = ...'"]
DEBUG      [PD:3  MD:7 ]	.......JoinClauseSegment                          	Ref.match OUT       	+   	[match=<MatchResult 1/7: 'JOIN'>, seg="'JOIN d ON (tbl.id = ...'"]
DEBUG      [PD:3  MD:10]	..........FromExpressionElementSegment            	Ref.match OUT       	    	[match=<MatchResult 0/5: ''>, seg="'d ON (tbl.id = d.oth...'"]
INFO       [PD:3  MD:10]	..........FromExpressionElementSegment            	Optio.match PRN     	    	[ns=1, ps=1, ms=0, pruned=[<Bracketed: [<Ref: TableExpressionSegment>]>], opts=[<Ref: TableExpressionSegment>]]
INFO       [PD:3  MD:12]	............TableExpressionSegment                	OneOf.match PRN     	    	[ns=3, ps=1, ms=0, pruned=[<Bracketed: [<Ref: SelectableGrammar>]>], opts=[<Ref: BareFunctionSegment>, <Ref: FunctionSegment>, <Ref: TableReferenceSegment>]]
DEBUG      [PD:3  MD:13]	.............TableExpressionSegment               	Ref.match OUT       	    	[match=<MatchResult 0/5: ''>, seg="'d ON (tbl.id = d.oth...'"]
INFO       [PD:3  MD:14]	..............FunctionSegment                     	OneOf.match PRN     	    	[ns=1, ps=1, ms=0, pruned=[<Sequence: [<Sequence: [<Ref: DateAddFunctionNameSeg...]>], opts=[<Sequence: [<Sequence: [<AnyNumberOf: [<Ref: Functio..., <Ref: PostFunctionGrammar [opt]>]>]]
DEBUG      [PD:3  MD:20]	....................DateAddFunctionNameSegment    	Ref.match OUT       	    	[match=<MatchResult 0/5: ''>, seg="'d ON (tbl.id = d.oth...'"]
INFO       [PD:3  MD:19]	...................DateAddFunctionNameSegment     	Seque.match OUT     	    	[match=<MatchResult 0/5: ''>, seg="'d ON (tbl.id = d.oth...'"]
DEBUG      [PD:3  MD:18]	..................DateAddFunctionNameSegment      	DateA.match OUT     	    	[match=<MatchResult 0/5: ''>, seg="'d ON (tbl.id = d.oth...'"]
DEBUG      [PD:3  MD:18]	..................FunctionSegment                 	Ref.match OUT       	    	[match=<MatchResult 0/5: ''>, seg="'d ON (tbl.id = d.oth...'"]
INFO       [PD:3  MD:17]	.................FunctionSegment                  	AnyNu.match PRN     	    	[ns=1, ps=0, ms=0, pruned=[], opts=[<Ref: FunctionNameSegment>]]
INFO       [PD:3  MD:20]	....................FunctionNameSegment           	AnyNu.match PRN     	    	[ns=1, ps=0, ms=0, pruned=[], opts=[<Sequence: [<Ref: SingleIdentifierGrammar>, <Ref: DotSegment>]>]]
INFO       [PD:3  MD:22]	......................SingleIdentifierGrammar     	OneOf.match PRN     	    	[ns=2, ps=0, ms=0, pruned=[], opts=[<Ref: NakedIdentifierSegment>, <Ref: QuotedIdentifierSegment>]]
DEBUG      [PD:3  MD:23]	.......................SingleIdentifierGrammar    	Ref.match OUT       	+   	[match=<MatchResult 1/5: 'd'>, seg="'d ON (tbl.id = d.oth...'"]
DEBUG      [PD:3  MD:23]	.......................SingleIdentifierGrammar    	Ref.match OUT       	    	[match=<MatchResult 0/5: ''>, seg="'d ON (tbl.id = d.oth...'"]
INFO       [PD:3  MD:22]	......................SingleIdentifierGrammar     	OneOf.match OUT     	+   	[match=<MatchResult 1/5: 'd'>, seg="'d ON (tbl.id = d.oth...'"]
DEBUG      [PD:3  MD:22]	......................FunctionNameSegment         	Ref.match OUT       	+   	[match=<MatchResult 1/5: 'd'>, seg="'d ON (tbl.id = d.oth...'"]
DEBUG      [PD:3  MD:22]	......................FunctionNameSegment         	Ref.match OUT       	    	[match=<MatchResult 0/3: ''>, seg="'ON (tbl.id = d.other...'"]
INFO       [PD:3  MD:21]	.....................FunctionNameSegment          	Seque.match OUT     	    	[match=<MatchResult 0/5: ''>, seg="'d ON (tbl.id = d.oth...'"]
INFO       [PD:3  MD:20]	....................FunctionNameSegment           	AnyNu.match OUT     	    	[match=<MatchResult 0/5: ''>, seg="'d ON (tbl.id = d.oth...'"]
INFO       [PD:3  MD:20]	....................FunctionNameSegment           	OneOf.match PRN     	    	[ns=2, ps=0, ms=0, pruned=[], opts=[<Ref: FunctionNameIdentifierSegment>, <Ref: QuotedIdentifierSegment>]]
DEBUG      [PD:3  MD:21]	.....................FunctionNameSegment          	Ref.match OUT       	+   	[match=<MatchResult 1/5: 'd'>, seg="'d ON (tbl.id = d.oth...'"]
DEBUG      [PD:3  MD:21]	.....................FunctionNameSegment          	Ref.match OUT       	    	[match=<MatchResult 0/5: ''>, seg="'d ON (tbl.id = d.oth...'"]
INFO       [PD:3  MD:20]	....................FunctionNameSegment           	OneOf.match OUT     	+   	[match=<MatchResult 1/5: 'd'>, seg="'d ON (tbl.id = d.oth...'"]
INFO       [PD:3  MD:19]	...................FunctionNameSegment            	Seque.match OUT     	+   	[match=<MatchResult 1/5: 'd'>, seg="'d ON (tbl.id = d.oth...'"]
DEBUG      [PD:3  MD:18]	..................FunctionNameSegment             	Funct.match OUT     	+   	[match=<MatchResult 1/5: 'd'>, seg="'d ON (tbl.id = d.oth...'"]
DEBUG      [PD:3  MD:18]	..................FunctionSegment                 	Ref.match OUT       	+   	[match=<MatchResult 1/5: 'd'>, seg="'d ON (tbl.id = d.oth...'"]
INFO       [PD:3  MD:17]	.................FunctionSegment                  	AnyNu.match OUT     	+   	[match=<MatchResult 1/5: 'd'>, seg="'d ON (tbl.id = d.oth...'"]
INFO       [PD:3  MD:17]	.................FunctionSegment                  	Brack.match OUT     	    	[match=<MatchResult 0/3: ''>, seg="'ON (tbl.id = d.other...'"]
INFO       [PD:3  MD:16]	................FunctionSegment                   	Seque.match OUT     	    	[match=<MatchResult 0/5: ''>, seg="'d ON (tbl.id = d.oth...'"]
INFO       [PD:3  MD:15]	...............FunctionSegment                    	Seque.match OUT     	    	[match=<MatchResult 0/5: ''>, seg="'d ON (tbl.id = d.oth...'"]
INFO       [PD:3  MD:14]	..............FunctionSegment                     	OneOf.match OUT     	    	[match=<MatchResult 0/5: ''>, seg="'d ON (tbl.id = d.oth...'"]
DEBUG      [PD:3  MD:13]	.............FunctionSegment                      	Funct.match OUT     	    	[match=<MatchResult 0/5: ''>, seg="'d ON (tbl.id = d.oth...'"]
DEBUG      [PD:3  MD:13]	.............TableExpressionSegment               	Ref.match OUT       	    	[match=<MatchResult 0/5: ''>, seg="'d ON (tbl.id = d.oth...'"]
DEBUG      [PD:3  MD:15]	...............TableReferenceSegment              	Delim._look_ahead_match IN	    	[ls=5, seg='d ON (tbl.id = d.oth...']
DEBUG      [PD:3  MD:15]	...............TableReferenceSegment              	Delim._look_ahead_match SI	    	[mq=[], sb=['D', '', 'ON', '', '(TBL.ID']]
INFO       [PD:3  MD:15]	...............TableReferenceSegment              	OneOf.match PRN     	    	[ns=1, ps=10, ms=0, pruned=[<Ref: OnKeywordSegment>, <Ref: AsKeywordSegment>, <Ref: UsingKeywordSegment>, <Ref: CommaSegment>, <Ref: CastOperatorSegment>, <Ref: StartSquareBracketSegment>, <Ref: StartBracketSegment>, <Ref: ColonSegment>, <Ref: DelimiterSegment>, <class 'sqlfluff.core.parser.segments.base.BracketedSegment'>], opts=[<Ref: BinaryOperatorGrammar>]]
INFO       [PD:3  MD:16]	................BinaryOperatorGrammar             	OneOf.match PRN     	    	[ns=1, ps=3, ms=0, pruned=[<Ref: ArithmeticBinaryOperatorGrammar>, <Ref: StringBinaryOperatorGrammar>, <Ref: BooleanBinaryOperatorGrammar>], opts=[<Ref: ComparisonOperatorGrammar>]]
INFO       [PD:3  MD:17]	.................ComparisonOperatorGrammar        	OneOf.match PRN     	    	[ns=1, ps=7, ms=0, pruned=[<Ref: EqualsSegment>, <Ref: GreaterThanSegment>, <Ref: LessThanSegment>, <Ref: GreaterThanOrEqualToSegment>, <Ref: LessThanOrEqualToSegment>, <Ref: NotEqualToSegment_a>, <Ref: NotEqualToSegment_b>], opts=[<Ref: LikeOperatorSegment>]]
DEBUG      [PD:3  MD:18]	..................ComparisonOperatorGrammar       	Ref.match OUT       	    	[match=<MatchResult 0/5: ''>, seg="'d ON (tbl.id = d.oth...'"]
INFO       [PD:3  MD:17]	.................ComparisonOperatorGrammar        	OneOf.match OUT     	    	[match=<MatchResult 0/5: ''>, seg="'d ON (tbl.id = d.oth...'"]
DEBUG      [PD:3  MD:17]	.................BinaryOperatorGrammar            	Ref.match OUT       	    	[match=<MatchResult 0/5: ''>, seg="'d ON (tbl.id = d.oth...'"]
INFO       [PD:3  MD:16]	................BinaryOperatorGrammar             	OneOf.match OUT     	    	[match=<MatchResult 0/5: ''>, seg="'d ON (tbl.id = d.oth...'"]
DEBUG      [PD:3  MD:16]	................TableReferenceSegment             	Ref.match OUT       	    	[match=<MatchResult 0/5: ''>, seg="'d ON (tbl.id = d.oth...'"]
INFO       [PD:3  MD:15]	...............TableReferenceSegment              	OneOf.match OUT     	    	[match=<MatchResult 0/5: ''>, seg="'d ON (tbl.id = d.oth...'"]
DEBUG      [PD:3  MD:15]	...............TableReferenceSegment              	NonCo.match OUT     	    	[match=<MatchResult 0/5: ''>, seg="'d ON (tbl.id = d.oth...'"]
INFO       [PD:3  MD:15]	...............TableReferenceSegment              	OneOf.match PRN     	    	[ns=1, ps=9, ms=1, pruned=[<Ref: AsKeywordSegment>, <Ref: UsingKeywordSegment>, <Ref: CommaSegment>, <Ref: CastOperatorSegment>, <Ref: StartSquareBracketSegment>, <Ref: StartBracketSegment>, <Ref: ColonSegment>, <Ref: DelimiterSegment>, <class 'sqlfluff.core.parser.segments.base.BracketedSegment'>], opts=[<Ref: OnKeywordSegment>, <Ref: BinaryOperatorGrammar>]]
DEBUG      [PD:3  MD:16]	................TableReferenceSegment             	Ref.match OUT       	    	[match=<MatchResult 0/4: ''>, seg="' ON (tbl.id = d.othe...'"]
INFO       [PD:3  MD:16]	................BinaryOperatorGrammar             	OneOf.match PRN     	    	[ns=1, ps=3, ms=0, pruned=[<Ref: ArithmeticBinaryOperatorGrammar>, <Ref: StringBinaryOperatorGrammar>, <Ref: BooleanBinaryOperatorGrammar>], opts=[<Ref: ComparisonOperatorGrammar>]]
INFO       [PD:3  MD:17]	.................ComparisonOperatorGrammar        	OneOf.match PRN     	    	[ns=1, ps=7, ms=0, pruned=[<Ref: EqualsSegment>, <Ref: GreaterThanSegment>, <Ref: LessThanSegment>, <Ref: GreaterThanOrEqualToSegment>, <Ref: LessThanOrEqualToSegment>, <Ref: NotEqualToSegment_a>, <Ref: NotEqualToSegment_b>], opts=[<Ref: LikeOperatorSegment>]]
DEBUG      [PD:3  MD:18]	..................ComparisonOperatorGrammar       	Ref.match OUT       	    	[match=<MatchResult 0/4: ''>, seg="' ON (tbl.id = d.othe...'"]
INFO       [PD:3  MD:17]	.................ComparisonOperatorGrammar        	OneOf.match OUT     	    	[match=<MatchResult 0/4: ''>, seg="' ON (tbl.id = d.othe...'"]
DEBUG      [PD:3  MD:17]	.................BinaryOperatorGrammar            	Ref.match OUT       	    	[match=<MatchResult 0/4: ''>, seg="' ON (tbl.id = d.othe...'"]
INFO       [PD:3  MD:16]	................BinaryOperatorGrammar             	OneOf.match OUT     	    	[match=<MatchResult 0/4: ''>, seg="' ON (tbl.id = d.othe...'"]
DEBUG      [PD:3  MD:16]	................TableReferenceSegment             	Ref.match OUT       	    	[match=<MatchResult 0/4: ''>, seg="' ON (tbl.id = d.othe...'"]
INFO       [PD:3  MD:15]	...............TableReferenceSegment              	OneOf.match OUT     	    	[match=<MatchResult 0/4: ''>, seg="' ON (tbl.id = d.othe...'"]
DEBUG      [PD:3  MD:15]	...............TableReferenceSegment              	NonCo.match OUT     	+   	[match=<MatchResult 1/4: ' '>, seg="' ON (tbl.id = d.othe...'"]
INFO       [PD:3  MD:15]	...............SingleIdentifierGrammar            	OneOf.match PRN     	    	[ns=2, ps=0, ms=0, pruned=[], opts=[<Ref: NakedIdentifierSegment>, <Ref: QuotedIdentifierSegment>]]
DEBUG      [PD:3  MD:16]	................SingleIdentifierGrammar           	Ref.match OUT       	++  	[match=<MatchResult 1/1: 'd'>, seg="'d'"]
INFO       [PD:3  MD:15]	...............SingleIdentifierGrammar            	OneOf.match OUT     	++  	[match=<MatchResult 1/1: 'd'>, seg="'d'"]
DEBUG      [PD:3  MD:15]	...............TableReferenceSegment              	Ref.match OUT       	++  	[match=<MatchResult 1/1: 'd'>, seg="'d'"]
INFO       [PD:3  MD:14]	..............TableReferenceSegment               	Delim.match OUT     	+   	[match=<MatchResult 1/5: 'd'>, seg="'d ON (tbl.id = d.oth...'"]
DEBUG      [PD:3  MD:13]	.............TableReferenceSegment                	Table.match OUT     	+   	[match=<MatchResult 1/5: 'd'>, seg="'d ON (tbl.id = d.oth...'"]
DEBUG      [PD:3  MD:13]	.............TableExpressionSegment               	Ref.match OUT       	+   	[match=<MatchResult 1/5: 'd'>, seg="'d ON (tbl.id = d.oth...'"]
INFO       [PD:3  MD:12]	............TableExpressionSegment                	OneOf.match OUT     	+   	[match=<MatchResult 1/5: 'd'>, seg="'d ON (tbl.id = d.oth...'"]
DEBUG      [PD:3  MD:11]	...........TableExpressionSegment                 	Table.match OUT     	+   	[match=<MatchResult 1/5: 'd'>, seg="'d ON (tbl.id = d.oth...'"]
DEBUG      [PD:3  MD:11]	...........FromExpressionElementSegment           	Ref.match OUT       	+   	[match=<MatchResult 1/5: 'd'>, seg="'d ON (tbl.id = d.oth...'"]
INFO       [PD:3  MD:10]	..........FromExpressionElementSegment            	Optio.match OUT     	+   	[match=<MatchResult 1/5: 'd'>, seg="'d ON (tbl.id = d.oth...'"]
DEBUG      [PD:3  MD:11]	...........FromExpressionElementSegment           	Ref.match OUT       	    	[match=<MatchResult 0/3: ''>, seg="'ON (tbl.id = d.other...'"]
INFO       [PD:3  MD:10]	..........FromExpressionElementSegment            	Seque.match OUT     	    	[match=<MatchResult 0/3: ''>, seg="'ON (tbl.id = d.other...'"]
DEBUG      [PD:3  MD:12]	............AliasExpressionSegment                	Ref.match OUT       	    	[match=<MatchResult 0/3: ''>, seg="'ON (tbl.id = d.other...'"]
INFO       [PD:3  MD:12]	............AliasExpressionSegment                	OneOf.match PRN     	    	[ns=2, ps=0, ms=0, pruned=[], opts=[<Sequence: [<Ref: SingleIdentifierGrammar>, <Bracketed: [<Ref: SingleIdentifierListS...]>, <Ref: QuotedLiteralSegment>]]
INFO       [PD:3  MD:14]	..............SingleIdentifierGrammar             	OneOf.match PRN     	    	[ns=2, ps=0, ms=0, pruned=[], opts=[<Ref: NakedIdentifierSegment>, <Ref: QuotedIdentifierSegment>]]
DEBUG      [PD:3  MD:15]	...............SingleIdentifierGrammar            	Ref.match OUT       	    	[match=<MatchResult 0/3: ''>, seg="'ON (tbl.id = d.other...'"]
DEBUG      [PD:3  MD:15]	...............SingleIdentifierGrammar            	Ref.match OUT       	    	[match=<MatchResult 0/3: ''>, seg="'ON (tbl.id = d.other...'"]
INFO       [PD:3  MD:14]	..............SingleIdentifierGrammar             	OneOf.match OUT     	    	[match=<MatchResult 0/3: ''>, seg="'ON (tbl.id = d.other...'"]
DEBUG      [PD:3  MD:14]	..............AliasExpressionSegment              	Ref.match OUT       	    	[match=<MatchResult 0/3: ''>, seg="'ON (tbl.id = d.other...'"]
INFO       [PD:3  MD:13]	.............AliasExpressionSegment               	Seque.match OUT     	    	[match=<MatchResult 0/3: ''>, seg="'ON (tbl.id = d.other...'"]
DEBUG      [PD:3  MD:13]	.............AliasExpressionSegment               	Ref.match OUT       	    	[match=<MatchResult 0/3: ''>, seg="'ON (tbl.id = d.other...'"]
INFO       [PD:3  MD:12]	............AliasExpressionSegment                	OneOf.match OUT     	    	[match=<MatchResult 0/3: ''>, seg="'ON (tbl.id = d.other...'"]
INFO       [PD:3  MD:11]	...........AliasExpressionSegment                 	Seque.match OUT     	    	[match=<MatchResult 0/3: ''>, seg="'ON (tbl.id = d.other...'"]
DEBUG      [PD:3  MD:10]	..........AliasExpressionSegment                  	Alias.match OUT     	    	[match=<MatchResult 0/3: ''>, seg="'ON (tbl.id = d.other...'"]
DEBUG      [PD:3  MD:10]	..........FromExpressionElementSegment            	Ref.match OUT       	    	[match=<MatchResult 0/3: ''>, seg="'ON (tbl.id = d.other...'"]
DEBUG      [PD:3  MD:10]	..........FromExpressionElementSegment            	Ref.match OUT       	    	[match=<MatchResult 0/3: ''>, seg="'ON (tbl.id = d.other...'"]
INFO       [PD:3  MD:9 ]	.........FromExpressionElementSegment             	Seque.match OUT     	+   	[match=<MatchResult 1/5: 'd'>, seg="'d ON (tbl.id = d.oth...'"]
DEBUG      [PD:3  MD:8 ]	........FromExpressionElementSegment              	FromE.match OUT     	+   	[match=<MatchResult 1/5: 'd'>, seg="'d ON (tbl.id = d.oth...'"]
DEBUG      [PD:3  MD:8 ]	........JoinClauseSegment                         	Ref.match OUT       	+   	[match=<MatchResult 1/5: 'd'>, seg="'d ON (tbl.id = d.oth...'"]
INFO       [PD:3  MD:8 ]	........JoinClauseSegment                         	OneOf.match PRN     	    	[ns=0, ps=1, ms=1, pruned=[<Sequence: [<Ref: UsingKeywordSegment>, <class 'sqlfluff.core.parser.segments.me..., <Bracketed: [<Delimited: [<...]>], opts=[<Ref: JoinOnConditionSegment>]]
DEBUG      [PD:3  MD:11]	...........JoinOnConditionSegment                 	Ref.match OUT       	+   	[match=<MatchResult 1/3: 'ON'>, seg="'ON (tbl.id = d.other...'"]
INFO       [PD:3  MD:11]	...........JoinOnConditionSegment                 	Optio.match PRN     	    	[ns=1, ps=0, ms=1, pruned=[], opts=[<Bracketed: [<Ref: ExpressionSegment>]>, <Ref: ExpressionSegment>]]
INFO       [PD:3  MD:16]	................Expression_A_Grammar              	OneOf.match PRN     	    	[ns=1, ps=1, ms=0, pruned=[<Sequence: [<OneOf: [<Ref: PositiveSegment>, <Ref: N..., <Ref: Expression_C_Grammar>]>], opts=[<Ref: Expression_C_Grammar>]]
INFO       [PD:3  MD:17]	.................Expression_C_Grammar             	OneOf.match PRN     	    	[ns=1, ps=2, ms=0, pruned=[<Sequence: [<Ref: ExistsKeywordSegment>, <Bracketed: [<Ref: SelectStatementSegmen...]>, <Ref: CaseExpressionSegment>], opts=[<Ref: Expression_D_Grammar>]]
INFO       [PD:3  MD:19]	...................Expression_D_Grammar           	OneOf.match PRN     	    	[ns=6, ps=3, ms=0, pruned=[<Bracketed: [<OneOf: [<Ref: ExpressionSegment>, <Ref:...]>, <Ref: SelectStatementSegment>, <Ref: IntervalExpressionSegment>], opts=[<Ref: BareFunctionSegment>, <Ref: FunctionSegment>, <Ref: LiteralGrammar>, <Ref: ColumnReferenceSegment>, <Sequence: [<Ref: SimpleArrayTypeGrammar [opt]>, <Ref: ArrayLiteralSegment>]>, <Sequence: [<Ref: DatatypeSegment>, <OneOf: [<Ref: QuotedLiteralSegment>, <R...]>]]
DEBUG      [PD:3  MD:20]	....................Expression_D_Grammar          	Ref.match OUT       	    	[match=<MatchResult 0/9: ''>, seg="'tbl.id = d.other_id'"]
INFO       [PD:3  MD:21]	.....................FunctionSegment              	OneOf.match PRN     	    	[ns=1, ps=1, ms=0, pruned=[<Sequence: [<Sequence: [<Ref: DateAddFunctionNameSeg...]>], opts=[<Sequence: [<Sequence: [<AnyNumberOf: [<Ref: Functio..., <Ref: PostFunctionGrammar [opt]>]>]]
DEBUG      [PD:3  MD:27]	...........................DateAddFunctionNameSegment	Ref.match OUT       	    	[match=<MatchResult 0/9: ''>, seg="'tbl.id = d.other_id'"]
INFO       [PD:3  MD:26]	..........................DateAddFunctionNameSegment	Seque.match OUT     	    	[match=<MatchResult 0/9: ''>, seg="'tbl.id = d.other_id'"]
DEBUG      [PD:3  MD:25]	.........................DateAddFunctionNameSegment	DateA.match OUT     	    	[match=<MatchResult 0/9: ''>, seg="'tbl.id = d.other_id'"]
DEBUG      [PD:3  MD:25]	.........................FunctionSegment          	Ref.match OUT       	    	[match=<MatchResult 0/9: ''>, seg="'tbl.id = d.other_id'"]
INFO       [PD:3  MD:24]	........................FunctionSegment           	AnyNu.match PRN     	    	[ns=1, ps=0, ms=0, pruned=[], opts=[<Ref: FunctionNameSegment>]]
INFO       [PD:3  MD:27]	...........................FunctionNameSegment    	AnyNu.match PRN     	    	[ns=1, ps=0, ms=0, pruned=[], opts=[<Sequence: [<Ref: SingleIdentifierGrammar>, <Ref: DotSegment>]>]]
INFO       [PD:3  MD:29]	.............................SingleIdentifierGrammar	OneOf.match PRN     	    	[ns=2, ps=0, ms=0, pruned=[], opts=[<Ref: NakedIdentifierSegment>, <Ref: QuotedIdentifierSegment>]]
DEBUG      [PD:3  MD:30]	..............................SingleIdentifierGrammar	Ref.match OUT       	+   	[match=<MatchResult 1/9: 'tbl'>, seg="'tbl.id = d.other_id'"]
DEBUG      [PD:3  MD:30]	..............................SingleIdentifierGrammar	Ref.match OUT       	    	[match=<MatchResult 0/9: ''>, seg="'tbl.id = d.other_id'"]
INFO       [PD:3  MD:29]	.............................SingleIdentifierGrammar	OneOf.match OUT     	+   	[match=<MatchResult 1/9: 'tbl'>, seg="'tbl.id = d.other_id'"]
DEBUG      [PD:3  MD:29]	.............................FunctionNameSegment  	Ref.match OUT       	+   	[match=<MatchResult 1/9: 'tbl'>, seg="'tbl.id = d.other_id'"]
DEBUG      [PD:3  MD:29]	.............................FunctionNameSegment  	Ref.match OUT       	+   	[match=<MatchResult 1/8: '.'>, seg="'.id = d.other_id'"]
INFO       [PD:3  MD:28]	............................FunctionNameSegment   	Seque.match OUT     	+   	[match=<MatchResult 2/9: 'tbl.'>, seg="'tbl.id = d.other_id'"]
INFO       [PD:3  MD:27]	...........................FunctionNameSegment    	AnyNu.match PRN     	    	[ns=1, ps=0, ms=0, pruned=[], opts=[<Sequence: [<Ref: SingleIdentifierGrammar>, <Ref: DotSegment>]>]]
INFO       [PD:3  MD:29]	.............................SingleIdentifierGrammar	OneOf.match PRN     	    	[ns=2, ps=0, ms=0, pruned=[], opts=[<Ref: NakedIdentifierSegment>, <Ref: QuotedIdentifierSegment>]]
DEBUG      [PD:3  MD:30]	..............................SingleIdentifierGrammar	Ref.match OUT       	+   	[match=<MatchResult 1/7: 'id'>, seg="'id = d.other_id'"]
DEBUG      [PD:3  MD:30]	..............................SingleIdentifierGrammar	Ref.match OUT       	    	[match=<MatchResult 0/7: ''>, seg="'id = d.other_id'"]
INFO       [PD:3  MD:29]	.............................SingleIdentifierGrammar	OneOf.match OUT     	+   	[match=<MatchResult 1/7: 'id'>, seg="'id = d.other_id'"]
DEBUG      [PD:3  MD:29]	.............................FunctionNameSegment  	Ref.match OUT       	+   	[match=<MatchResult 1/7: 'id'>, seg="'id = d.other_id'"]
DEBUG      [PD:3  MD:29]	.............................FunctionNameSegment  	Ref.match OUT       	    	[match=<MatchResult 0/5: ''>, seg="'= d.other_id'"]
INFO       [PD:3  MD:28]	............................FunctionNameSegment   	Seque.match OUT     	    	[match=<MatchResult 0/7: ''>, seg="'id = d.other_id'"]
INFO       [PD:3  MD:27]	...........................FunctionNameSegment    	AnyNu.match OUT     	+   	[match=<MatchResult 2/9: 'tbl.'>, seg="'tbl.id = d.other_id'"]
INFO       [PD:3  MD:27]	...........................FunctionNameSegment    	OneOf.match PRN     	    	[ns=2, ps=0, ms=0, pruned=[], opts=[<Ref: FunctionNameIdentifierSegment>, <Ref: QuotedIdentifierSegment>]]
DEBUG      [PD:3  MD:28]	............................FunctionNameSegment   	Ref.match OUT       	+   	[match=<MatchResult 1/7: 'id'>, seg="'id = d.other_id'"]
DEBUG      [PD:3  MD:28]	............................FunctionNameSegment   	Ref.match OUT       	    	[match=<MatchResult 0/7: ''>, seg="'id = d.other_id'"]
INFO       [PD:3  MD:27]	...........................FunctionNameSegment    	OneOf.match OUT     	+   	[match=<MatchResult 1/7: 'id'>, seg="'id = d.other_id'"]
INFO       [PD:3  MD:26]	..........................FunctionNameSegment     	Seque.match OUT     	+   	[match=<MatchResult 3/9: 'tbl.id'>, seg="'tbl.id = d.other_id'"]
DEBUG      [PD:3  MD:25]	.........................FunctionNameSegment      	Funct.match OUT     	+   	[match=<MatchResult 1/7: 'tbl.id'>, seg="'tbl.id = d.other_id'"]
DEBUG      [PD:3  MD:25]	.........................FunctionSegment          	Ref.match OUT       	+   	[match=<MatchResult 1/7: 'tbl.id'>, seg="'tbl.id = d.other_id'"]
INFO       [PD:3  MD:24]	........................FunctionSegment           	AnyNu.match OUT     	+   	[match=<MatchResult 1/7: 'tbl.id'>, seg="'tbl.id = d.other_id'"]
INFO       [PD:3  MD:24]	........................FunctionSegment           	Brack.match OUT     	    	[match=<MatchResult 0/5: ''>, seg="'= d.other_id'"]
INFO       [PD:3  MD:23]	.......................FunctionSegment            	Seque.match OUT     	    	[match=<MatchResult 0/9: ''>, seg="'tbl.id = d.other_id'"]
INFO       [PD:3  MD:22]	......................FunctionSegment             	Seque.match OUT     	    	[match=<MatchResult 0/9: ''>, seg="'tbl.id = d.other_id'"]
INFO       [PD:3  MD:21]	.....................FunctionSegment              	OneOf.match OUT     	    	[match=<MatchResult 0/9: ''>, seg="'tbl.id = d.other_id'"]
DEBUG      [PD:3  MD:20]	....................FunctionSegment               	Funct.match OUT     	    	[match=<MatchResult 0/9: ''>, seg="'tbl.id = d.other_id'"]
DEBUG      [PD:3  MD:20]	....................Expression_D_Grammar          	Ref.match OUT       	    	[match=<MatchResult 0/9: ''>, seg="'tbl.id = d.other_id'"]
INFO       [PD:3  MD:20]	....................LiteralGrammar                	OneOf.match PRN     	    	[ns=2, ps=4, ms=0, pruned=[<Ref: BooleanLiteralGrammar>, <Ref: QualifiedNumericLiteralSegment>, <Ref: NullLiteralSegment>, <Ref: DateTimeLiteralGrammar>], opts=[<Ref: QuotedLiteralSegment>, <Ref: NumericLiteralSegment>]]
DEBUG      [PD:3  MD:21]	.....................LiteralGrammar               	Ref.match OUT       	    	[match=<MatchResult 0/9: ''>, seg="'tbl.id = d.other_id'"]
DEBUG      [PD:3  MD:21]	.....................LiteralGrammar               	Ref.match OUT       	    	[match=<MatchResult 0/9: ''>, seg="'tbl.id = d.other_id'"]
INFO       [PD:3  MD:20]	....................LiteralGrammar                	OneOf.match OUT     	    	[match=<MatchResult 0/9: ''>, seg="'tbl.id = d.other_id'"]
DEBUG      [PD:3  MD:20]	....................Expression_D_Grammar          	Ref.match OUT       	    	[match=<MatchResult 0/9: ''>, seg="'tbl.id = d.other_id'"]
DEBUG      [PD:3  MD:22]	......................ColumnReferenceSegment      	Delim._look_ahead_match IN	    	[ls=9, seg='tbl.id = d.other_id']
DEBUG      [PD:3  MD:22]	......................ColumnReferenceSegment      	Delim._look_ahead_match SI	    	[mq=[(<OneOf: [<Ref: DotSegment>, <Sequence: [<Ref: DotSegment>, <Ref: Dot...]>, 1, '.'), (<OneOf: [<Ref: DotSegment>, <Sequence: [<Ref: DotSegment>, <Ref: Dot...]>, 1, '.'), (<OneOf: [<Ref: DotSegment>, <Sequence: [<Ref: DotSegment>, <Ref: Dot...]>, 7, '.'), (<OneOf: [<Ref: DotSegment>, <Sequence: [<Ref: DotSegment>, <Ref: Dot...]>, 7, '.')], sb=['TBL', '.', 'ID', '', '=', '', 'D', '.', 'OTHER_ID']]
INFO       [PD:3  MD:22]	......................ColumnReferenceSegment      	OneOf.match PRN     	    	[ns=0, ps=0, ms=2, pruned=[], opts=[<Ref: DotSegment>, <Sequence: [<Ref: DotSegment>, <Ref: DotSegment>]>]]
DEBUG      [PD:3  MD:23]	.......................ColumnReferenceSegment     	Ref.match OUT       	+   	[match=<MatchResult 1/2: '.'>, seg="'.other_id'"]
DEBUG      [PD:3  MD:24]	........................ColumnReferenceSegment    	Ref.match OUT       	+   	[match=<MatchResult 1/2: '.'>, seg="'.other_id'"]
DEBUG      [PD:3  MD:24]	........................ColumnReferenceSegment    	Ref.match OUT       	    	[match=<MatchResult 0/1: ''>, seg="'other_id'"]
INFO       [PD:3  MD:23]	.......................ColumnReferenceSegment     	Seque.match OUT     	    	[match=<MatchResult 0/2: ''>, seg="'.other_id'"]
INFO       [PD:3  MD:22]	......................ColumnReferenceSegment      	OneOf.match OUT     	+   	[match=<MatchResult 1/2: '.'>, seg="'.other_id'"]
INFO       [PD:3  MD:22]	......................ColumnReferenceSegment      	OneOf.match PRN     	    	[ns=0, ps=0, ms=2, pruned=[], opts=[<Ref: DotSegment>, <Sequence: [<Ref: DotSegment>, <Ref: DotSegment>]>]]
DEBUG      [PD:3  MD:23]	.......................ColumnReferenceSegment     	Ref.match OUT       	+   	[match=<MatchResult 1/2: '.'>, seg="'.other_id'"]
DEBUG      [PD:3  MD:24]	........................ColumnReferenceSegment    	Ref.match OUT       	+   	[match=<MatchResult 1/2: '.'>, seg="'.other_id'"]
DEBUG      [PD:3  MD:24]	........................ColumnReferenceSegment    	Ref.match OUT       	    	[match=<MatchResult 0/1: ''>, seg="'other_id'"]
INFO       [PD:3  MD:23]	.......................ColumnReferenceSegment     	Seque.match OUT     	    	[match=<MatchResult 0/2: ''>, seg="'.other_id'"]
INFO       [PD:3  MD:22]	......................ColumnReferenceSegment      	OneOf.match OUT     	+   	[match=<MatchResult 1/2: '.'>, seg="'.other_id'"]
INFO       [PD:3  MD:22]	......................ColumnReferenceSegment      	OneOf.match PRN     	    	[ns=0, ps=0, ms=2, pruned=[], opts=[<Ref: DotSegment>, <Sequence: [<Ref: DotSegment>, <Ref: DotSegment>]>]]
DEBUG      [PD:3  MD:23]	.......................ColumnReferenceSegment     	Ref.match OUT       	+   	[match=<MatchResult 1/8: '.'>, seg="'.id = d.other_id'"]
DEBUG      [PD:3  MD:24]	........................ColumnReferenceSegment    	Ref.match OUT       	+   	[match=<MatchResult 1/8: '.'>, seg="'.id = d.other_id'"]
DEBUG      [PD:3  MD:24]	........................ColumnReferenceSegment    	Ref.match OUT       	    	[match=<MatchResult 0/7: ''>, seg="'id = d.other_id'"]
INFO       [PD:3  MD:23]	.......................ColumnReferenceSegment     	Seque.match OUT     	    	[match=<MatchResult 0/8: ''>, seg="'.id = d.other_id'"]
INFO       [PD:3  MD:22]	......................ColumnReferenceSegment      	OneOf.match OUT     	+   	[match=<MatchResult 1/8: '.'>, seg="'.id = d.other_id'"]
INFO       [PD:3  MD:22]	......................ColumnReferenceSegment      	OneOf.match PRN     	    	[ns=0, ps=0, ms=2, pruned=[], opts=[<Ref: DotSegment>, <Sequence: [<Ref: DotSegment>, <Ref: DotSegment>]>]]
DEBUG      [PD:3  MD:23]	.......................ColumnReferenceSegment     	Ref.match OUT       	+   	[match=<MatchResult 1/8: '.'>, seg="'.id = d.other_id'"]
DEBUG      [PD:3  MD:24]	........................ColumnReferenceSegment    	Ref.match OUT       	+   	[match=<MatchResult 1/8: '.'>, seg="'.id = d.other_id'"]
DEBUG      [PD:3  MD:24]	........................ColumnReferenceSegment    	Ref.match OUT       	    	[match=<MatchResult 0/7: ''>, seg="'id = d.other_id'"]
INFO       [PD:3  MD:23]	.......................ColumnReferenceSegment     	Seque.match OUT     	    	[match=<MatchResult 0/8: ''>, seg="'.id = d.other_id'"]
INFO       [PD:3  MD:22]	......................ColumnReferenceSegment      	OneOf.match OUT     	+   	[match=<MatchResult 1/8: '.'>, seg="'.id = d.other_id'"]
INFO       [PD:3  MD:22]	......................ColumnReferenceSegment      	OneOf.match PRN     	    	[ns=1, ps=10, ms=0, pruned=[<Ref: OnKeywordSegment>, <Ref: AsKeywordSegment>, <Ref: UsingKeywordSegment>, <Ref: CommaSegment>, <Ref: CastOperatorSegment>, <Ref: StartSquareBracketSegment>, <Ref: StartBracketSegment>, <Ref: ColonSegment>, <Ref: DelimiterSegment>, <class 'sqlfluff.core.parser.segments.base.BracketedSegment'>], opts=[<Ref: BinaryOperatorGrammar>]]
INFO       [PD:3  MD:23]	.......................BinaryOperatorGrammar      	OneOf.match PRN     	    	[ns=1, ps=3, ms=0, pruned=[<Ref: ArithmeticBinaryOperatorGrammar>, <Ref: StringBinaryOperatorGrammar>, <Ref: BooleanBinaryOperatorGrammar>], opts=[<Ref: ComparisonOperatorGrammar>]]
INFO       [PD:3  MD:24]	........................ComparisonOperatorGrammar 	OneOf.match PRN     	    	[ns=1, ps=7, ms=0, pruned=[<Ref: EqualsSegment>, <Ref: GreaterThanSegment>, <Ref: LessThanSegment>, <Ref: GreaterThanOrEqualToSegment>, <Ref: LessThanOrEqualToSegment>, <Ref: NotEqualToSegment_a>, <Ref: NotEqualToSegment_b>], opts=[<Ref: LikeOperatorSegment>]]
DEBUG      [PD:3  MD:25]	.........................ComparisonOperatorGrammar	Ref.match OUT       	    	[match=<MatchResult 0/9: ''>, seg="'tbl.id = d.other_id'"]
INFO       [PD:3  MD:24]	........................ComparisonOperatorGrammar 	OneOf.match OUT     	    	[match=<MatchResult 0/9: ''>, seg="'tbl.id = d.other_id'"]
DEBUG      [PD:3  MD:24]	........................BinaryOperatorGrammar     	Ref.match OUT       	    	[match=<MatchResult 0/9: ''>, seg="'tbl.id = d.other_id'"]
INFO       [PD:3  MD:23]	.......................BinaryOperatorGrammar      	OneOf.match OUT     	    	[match=<MatchResult 0/9: ''>, seg="'tbl.id = d.other_id'"]
DEBUG      [PD:3  MD:23]	.......................ColumnReferenceSegment     	Ref.match OUT       	    	[match=<MatchResult 0/9: ''>, seg="'tbl.id = d.other_id'"]
INFO       [PD:3  MD:22]	......................ColumnReferenceSegment      	OneOf.match OUT     	    	[match=<MatchResult 0/9: ''>, seg="'tbl.id = d.other_id'"]
DEBUG      [PD:3  MD:22]	......................ColumnReferenceSegment      	NonCo.match OUT     	    	[match=<MatchResult 0/9: ''>, seg="'tbl.id = d.other_id'"]
INFO       [PD:3  MD:22]	......................ColumnReferenceSegment      	OneOf.match PRN     	    	[ns=1, ps=10, ms=0, pruned=[<Ref: OnKeywordSegment>, <Ref: AsKeywordSegment>, <Ref: UsingKeywordSegment>, <Ref: CommaSegment>, <Ref: CastOperatorSegment>, <Ref: StartSquareBracketSegment>, <Ref: StartBracketSegment>, <Ref: ColonSegment>, <Ref: DelimiterSegment>, <class 'sqlfluff.core.parser.segments.base.BracketedSegment'>], opts=[<Ref: BinaryOperatorGrammar>]]
INFO       [PD:3  MD:23]	.......................BinaryOperatorGrammar      	OneOf.match PRN     	    	[ns=1, ps=3, ms=0, pruned=[<Ref: ArithmeticBinaryOperatorGrammar>, <Ref: StringBinaryOperatorGrammar>, <Ref: BooleanBinaryOperatorGrammar>], opts=[<Ref: ComparisonOperatorGrammar>]]
INFO       [PD:3  MD:24]	........................ComparisonOperatorGrammar 	OneOf.match PRN     	    	[ns=1, ps=7, ms=0, pruned=[<Ref: EqualsSegment>, <Ref: GreaterThanSegment>, <Ref: LessThanSegment>, <Ref: GreaterThanOrEqualToSegment>, <Ref: LessThanOrEqualToSegment>, <Ref: NotEqualToSegment_a>, <Ref: NotEqualToSegment_b>], opts=[<Ref: LikeOperatorSegment>]]
DEBUG      [PD:3  MD:25]	.........................ComparisonOperatorGrammar	Ref.match OUT       	    	[match=<MatchResult 0/8: ''>, seg="'.id = d.other_id'"]
INFO       [PD:3  MD:24]	........................ComparisonOperatorGrammar 	OneOf.match OUT     	    	[match=<MatchResult 0/8: ''>, seg="'.id = d.other_id'"]
DEBUG      [PD:3  MD:24]	........................BinaryOperatorGrammar     	Ref.match OUT       	    	[match=<MatchResult 0/8: ''>, seg="'.id = d.other_id'"]
INFO       [PD:3  MD:23]	.......................BinaryOperatorGrammar      	OneOf.match OUT     	    	[match=<MatchResult 0/8: ''>, seg="'.id = d.other_id'"]
DEBUG      [PD:3  MD:23]	.......................ColumnReferenceSegment     	Ref.match OUT       	    	[match=<MatchResult 0/8: ''>, seg="'.id = d.other_id'"]
INFO       [PD:3  MD:22]	......................ColumnReferenceSegment      	OneOf.match OUT     	    	[match=<MatchResult 0/8: ''>, seg="'.id = d.other_id'"]
DEBUG      [PD:3  MD:22]	......................ColumnReferenceSegment      	NonCo.match OUT     	    	[match=<MatchResult 0/8: ''>, seg="'.id = d.other_id'"]
INFO       [PD:3  MD:22]	......................SingleIdentifierGrammar     	OneOf.match PRN     	    	[ns=2, ps=0, ms=0, pruned=[], opts=[<Ref: NakedIdentifierSegment>, <Ref: QuotedIdentifierSegment>]]
DEBUG      [PD:3  MD:23]	.......................SingleIdentifierGrammar    	Ref.match OUT       	++  	[match=<MatchResult 1/1: 'tbl'>, seg="'tbl'"]
INFO       [PD:3  MD:22]	......................SingleIdentifierGrammar     	OneOf.match OUT     	++  	[match=<MatchResult 1/1: 'tbl'>, seg="'tbl'"]
DEBUG      [PD:3  MD:22]	......................ColumnReferenceSegment      	Ref.match OUT       	++  	[match=<MatchResult 1/1: 'tbl'>, seg="'tbl'"]
DEBUG      [PD:3  MD:22]	......................ColumnReferenceSegment      	Delim._look_ahead_match IN	    	[ls=7, seg='id = d.other_id']
DEBUG      [PD:3  MD:22]	......................ColumnReferenceSegment      	Delim._look_ahead_match SI	    	[mq=[(<OneOf: [<Ref: DotSegment>, <Sequence: [<Ref: DotSegment>, <Ref: Dot...]>, 5, '.'), (<OneOf: [<Ref: DotSegment>, <Sequence: [<Ref: DotSegment>, <Ref: Dot...]>, 5, '.')], sb=['ID', '', '=', '', 'D', '.', 'OTHER_ID']]
INFO       [PD:3  MD:22]	......................ColumnReferenceSegment      	OneOf.match PRN     	    	[ns=0, ps=0, ms=2, pruned=[], opts=[<Ref: DotSegment>, <Sequence: [<Ref: DotSegment>, <Ref: DotSegment>]>]]
DEBUG      [PD:3  MD:23]	.......................ColumnReferenceSegment     	Ref.match OUT       	+   	[match=<MatchResult 1/2: '.'>, seg="'.other_id'"]
DEBUG      [PD:3  MD:24]	........................ColumnReferenceSegment    	Ref.match OUT       	+   	[match=<MatchResult 1/2: '.'>, seg="'.other_id'"]
DEBUG      [PD:3  MD:24]	........................ColumnReferenceSegment    	Ref.match OUT       	    	[match=<MatchResult 0/1: ''>, seg="'other_id'"]
INFO       [PD:3  MD:23]	.......................ColumnReferenceSegment     	Seque.match OUT     	    	[match=<MatchResult 0/2: ''>, seg="'.other_id'"]
INFO       [PD:3  MD:22]	......................ColumnReferenceSegment      	OneOf.match OUT     	+   	[match=<MatchResult 1/2: '.'>, seg="'.other_id'"]
INFO       [PD:3  MD:22]	......................ColumnReferenceSegment      	OneOf.match PRN     	    	[ns=0, ps=0, ms=2, pruned=[], opts=[<Ref: DotSegment>, <Sequence: [<Ref: DotSegment>, <Ref: DotSegment>]>]]
DEBUG      [PD:3  MD:23]	.......................ColumnReferenceSegment     	Ref.match OUT       	+   	[match=<MatchResult 1/2: '.'>, seg="'.other_id'"]
DEBUG      [PD:3  MD:24]	........................ColumnReferenceSegment    	Ref.match OUT       	+   	[match=<MatchResult 1/2: '.'>, seg="'.other_id'"]
DEBUG      [PD:3  MD:24]	........................ColumnReferenceSegment    	Ref.match OUT       	    	[match=<MatchResult 0/1: ''>, seg="'other_id'"]
INFO       [PD:3  MD:23]	.......................ColumnReferenceSegment     	Seque.match OUT     	    	[match=<MatchResult 0/2: ''>, seg="'.other_id'"]
INFO       [PD:3  MD:22]	......................ColumnReferenceSegment      	OneOf.match OUT     	+   	[match=<MatchResult 1/2: '.'>, seg="'.other_id'"]
INFO       [PD:3  MD:22]	......................ColumnReferenceSegment      	OneOf.match PRN     	    	[ns=1, ps=10, ms=0, pruned=[<Ref: OnKeywordSegment>, <Ref: AsKeywordSegment>, <Ref: UsingKeywordSegment>, <Ref: CommaSegment>, <Ref: CastOperatorSegment>, <Ref: StartSquareBracketSegment>, <Ref: StartBracketSegment>, <Ref: ColonSegment>, <Ref: DelimiterSegment>, <class 'sqlfluff.core.parser.segments.base.BracketedSegment'>], opts=[<Ref: BinaryOperatorGrammar>]]
INFO       [PD:3  MD:23]	.......................BinaryOperatorGrammar      	OneOf.match PRN     	    	[ns=1, ps=3, ms=0, pruned=[<Ref: ArithmeticBinaryOperatorGrammar>, <Ref: StringBinaryOperatorGrammar>, <Ref: BooleanBinaryOperatorGrammar>], opts=[<Ref: ComparisonOperatorGrammar>]]
INFO       [PD:3  MD:24]	........................ComparisonOperatorGrammar 	OneOf.match PRN     	    	[ns=1, ps=7, ms=0, pruned=[<Ref: EqualsSegment>, <Ref: GreaterThanSegment>, <Ref: LessThanSegment>, <Ref: GreaterThanOrEqualToSegment>, <Ref: LessThanOrEqualToSegment>, <Ref: NotEqualToSegment_a>, <Ref: NotEqualToSegment_b>], opts=[<Ref: LikeOperatorSegment>]]
DEBUG      [PD:3  MD:25]	.........................ComparisonOperatorGrammar	Ref.match OUT       	    	[match=<MatchResult 0/7: ''>, seg="'id = d.other_id'"]
INFO       [PD:3  MD:24]	........................ComparisonOperatorGrammar 	OneOf.match OUT     	    	[match=<MatchResult 0/7: ''>, seg="'id = d.other_id'"]
DEBUG      [PD:3  MD:24]	........................BinaryOperatorGrammar     	Ref.match OUT       	    	[match=<MatchResult 0/7: ''>, seg="'id = d.other_id'"]
INFO       [PD:3  MD:23]	.......................BinaryOperatorGrammar      	OneOf.match OUT     	    	[match=<MatchResult 0/7: ''>, seg="'id = d.other_id'"]
DEBUG      [PD:3  MD:23]	.......................ColumnReferenceSegment     	Ref.match OUT       	    	[match=<MatchResult 0/7: ''>, seg="'id = d.other_id'"]
INFO       [PD:3  MD:22]	......................ColumnReferenceSegment      	OneOf.match OUT     	    	[match=<MatchResult 0/7: ''>, seg="'id = d.other_id'"]
DEBUG      [PD:3  MD:22]	......................ColumnReferenceSegment      	NonCo.match OUT     	    	[match=<MatchResult 0/7: ''>, seg="'id = d.other_id'"]
INFO       [PD:3  MD:22]	......................ColumnReferenceSegment      	OneOf.match PRN     	    	[ns=1, ps=10, ms=0, pruned=[<Ref: OnKeywordSegment>, <Ref: AsKeywordSegment>, <Ref: UsingKeywordSegment>, <Ref: CommaSegment>, <Ref: CastOperatorSegment>, <Ref: StartSquareBracketSegment>, <Ref: StartBracketSegment>, <Ref: ColonSegment>, <Ref: DelimiterSegment>, <class 'sqlfluff.core.parser.segments.base.BracketedSegment'>], opts=[<Ref: BinaryOperatorGrammar>]]
INFO       [PD:3  MD:23]	.......................BinaryOperatorGrammar      	OneOf.match PRN     	    	[ns=1, ps=3, ms=0, pruned=[<Ref: ArithmeticBinaryOperatorGrammar>, <Ref: StringBinaryOperatorGrammar>, <Ref: BooleanBinaryOperatorGrammar>], opts=[<Ref: ComparisonOperatorGrammar>]]
INFO       [PD:3  MD:24]	........................ComparisonOperatorGrammar 	OneOf.match PRN     	    	[ns=1, ps=6, ms=1, pruned=[<Ref: GreaterThanSegment>, <Ref: LessThanSegment>, <Ref: GreaterThanOrEqualToSegment>, <Ref: LessThanOrEqualToSegment>, <Ref: NotEqualToSegment_a>, <Ref: NotEqualToSegment_b>], opts=[<Ref: EqualsSegment>, <Ref: LikeOperatorSegment>]]
DEBUG      [PD:3  MD:25]	.........................ComparisonOperatorGrammar	Ref.match OUT       	    	[match=<MatchResult 0/6: ''>, seg="' = d.other_id'"]
DEBUG      [PD:3  MD:25]	.........................ComparisonOperatorGrammar	Ref.match OUT       	    	[match=<MatchResult 0/6: ''>, seg="' = d.other_id'"]
INFO       [PD:3  MD:24]	........................ComparisonOperatorGrammar 	OneOf.match OUT     	    	[match=<MatchResult 0/6: ''>, seg="' = d.other_id'"]
DEBUG      [PD:3  MD:24]	........................BinaryOperatorGrammar     	Ref.match OUT       	    	[match=<MatchResult 0/6: ''>, seg="' = d.other_id'"]
INFO       [PD:3  MD:23]	.......................BinaryOperatorGrammar      	OneOf.match OUT     	    	[match=<MatchResult 0/6: ''>, seg="' = d.other_id'"]
DEBUG      [PD:3  MD:23]	.......................ColumnReferenceSegment     	Ref.match OUT       	    	[match=<MatchResult 0/6: ''>, seg="' = d.other_id'"]
INFO       [PD:3  MD:22]	......................ColumnReferenceSegment      	OneOf.match OUT     	    	[match=<MatchResult 0/6: ''>, seg="' = d.other_id'"]
DEBUG      [PD:3  MD:22]	......................ColumnReferenceSegment      	NonCo.match OUT     	+   	[match=<MatchResult 1/6: ' '>, seg="' = d.other_id'"]
INFO       [PD:3  MD:22]	......................SingleIdentifierGrammar     	OneOf.match PRN     	    	[ns=2, ps=0, ms=0, pruned=[], opts=[<Ref: NakedIdentifierSegment>, <Ref: QuotedIdentifierSegment>]]
DEBUG      [PD:3  MD:23]	.......................SingleIdentifierGrammar    	Ref.match OUT       	++  	[match=<MatchResult 1/1: 'id'>, seg="'id'"]
INFO       [PD:3  MD:22]	......................SingleIdentifierGrammar     	OneOf.match OUT     	++  	[match=<MatchResult 1/1: 'id'>, seg="'id'"]
DEBUG      [PD:3  MD:22]	......................ColumnReferenceSegment      	Ref.match OUT       	++  	[match=<MatchResult 1/1: 'id'>, seg="'id'"]
INFO       [PD:3  MD:21]	.....................ColumnReferenceSegment       	Delim.match OUT     	+   	[match=<MatchResult 3/9: 'tbl.id'>, seg="'tbl.id = d.other_id'"]
DEBUG      [PD:3  MD:20]	....................ColumnReferenceSegment        	Colum.match OUT     	+   	[match=<MatchResult 1/7: 'tbl.id'>, seg="'tbl.id = d.other_id'"]
DEBUG      [PD:3  MD:20]	....................Expression_D_Grammar          	Ref.match OUT       	+   	[match=<MatchResult 1/7: 'tbl.id'>, seg="'tbl.id = d.other_id'"]
DEBUG      [PD:3  MD:21]	.....................Expression_D_Grammar         	Ref.match OUT       	    	[match=<MatchResult 0/9: ''>, seg="'tbl.id = d.other_id'"]
INFO       [PD:3  MD:22]	......................ArrayLiteralSegment         	Brack.match OUT     	    	[match=<MatchResult 0/9: ''>, seg="'tbl.id = d.other_id'"]
DEBUG      [PD:3  MD:21]	.....................ArrayLiteralSegment          	Array.match OUT     	    	[match=<MatchResult 0/9: ''>, seg="'tbl.id = d.other_id'"]
DEBUG      [PD:3  MD:21]	.....................Expression_D_Grammar         	Ref.match OUT       	    	[match=<MatchResult 0/9: ''>, seg="'tbl.id = d.other_id'"]
INFO       [PD:3  MD:20]	....................Expression_D_Grammar          	Seque.match OUT     	    	[match=<MatchResult 0/9: ''>, seg="'tbl.id = d.other_id'"]
INFO       [PD:3  MD:22]	......................DatatypeSegment             	OneOf.match PRN     	    	[ns=1, ps=2, ms=0, pruned=[<Sequence: [<OneOf: [<Ref: TimeKeywordSegment>, <Ref..., <Bracketed: [<Ref: NumericLiteralSegment..., <Sequence:...]>, <Sequence: [<Ref: DoubleKeywordSegment>, <Ref: PrecisionKeywordSegment>]>], opts=[<Sequence: [<OneOf: [<Sequence: [<OneOf: [<Ref: Char..., <Bracketed: [<OneOf: [<Delimited: [<Ref:..., <Ref: Char...]>]]
INFO       [PD:3  MD:24]	........................DatatypeSegment           	OneOf.match PRN     	    	[ns=1, ps=1, ms=0, pruned=[<Sequence: [<OneOf: [<Ref: CharacterKeywordSegment>,..., <OneOf: [<Ref: VaryingKeywordSegment>, <...]>], opts=[<Sequence: [<Sequence: [<Ref: SingleIdentifierGramma..., <Ref: DatatypeIdentifierSegment>]>]]
INFO       [PD:3  MD:27]	...........................SingleIdentifierGrammar	OneOf.match PRN     	    	[ns=2, ps=0, ms=0, pruned=[], opts=[<Ref: NakedIdentifierSegment>, <Ref: QuotedIdentifierSegment>]]
DEBUG      [PD:3  MD:28]	............................SingleIdentifierGrammar	Ref.match OUT       	+   	[match=<MatchResult 1/9: 'tbl'>, seg="'tbl.id = d.other_id'"]
DEBUG      [PD:3  MD:28]	............................SingleIdentifierGrammar	Ref.match OUT       	    	[match=<MatchResult 0/9: ''>, seg="'tbl.id = d.other_id'"]
INFO       [PD:3  MD:27]	...........................SingleIdentifierGrammar	OneOf.match OUT     	+   	[match=<MatchResult 1/9: 'tbl'>, seg="'tbl.id = d.other_id'"]
DEBUG      [PD:3  MD:27]	...........................DatatypeSegment        	Ref.match OUT       	+   	[match=<MatchResult 1/9: 'tbl'>, seg="'tbl.id = d.other_id'"]
DEBUG      [PD:3  MD:27]	...........................DatatypeSegment        	Ref.match OUT       	+   	[match=<MatchResult 1/8: '.'>, seg="'.id = d.other_id'"]
INFO       [PD:3  MD:26]	..........................DatatypeSegment         	Seque.match OUT     	+   	[match=<MatchResult 2/9: 'tbl.'>, seg="'tbl.id = d.other_id'"]
DEBUG      [PD:3  MD:26]	..........................DatatypeSegment         	Ref.match OUT       	+   	[match=<MatchResult 1/7: 'id'>, seg="'id = d.other_id'"]
INFO       [PD:3  MD:25]	.........................DatatypeSegment          	Seque.match OUT     	+   	[match=<MatchResult 3/9: 'tbl.id'>, seg="'tbl.id = d.other_id'"]
INFO       [PD:3  MD:24]	........................DatatypeSegment           	OneOf.match OUT     	+   	[match=<MatchResult 3/9: 'tbl.id'>, seg="'tbl.id = d.other_id'"]
INFO       [PD:3  MD:24]	........................DatatypeSegment           	Brack.match OUT     	    	[match=<MatchResult 0/5: ''>, seg="'= d.other_id'"]
DEBUG      [PD:3  MD:24]	........................DatatypeSegment           	Ref.match OUT       	    	[match=<MatchResult 0/5: ''>, seg="'= d.other_id'"]
INFO       [PD:3  MD:23]	.......................DatatypeSegment            	Seque.match OUT     	+   	[match=<MatchResult 3/9: 'tbl.id'>, seg="'tbl.id = d.other_id'"]
INFO       [PD:3  MD:22]	......................DatatypeSegment             	OneOf.match OUT     	+   	[match=<MatchResult 3/9: 'tbl.id'>, seg="'tbl.id = d.other_id'"]
DEBUG      [PD:3  MD:21]	.....................DatatypeSegment              	Datat.match OUT     	+   	[match=<MatchResult 1/7: 'tbl.id'>, seg="'tbl.id = d.other_id'"]
DEBUG      [PD:3  MD:21]	.....................Expression_D_Grammar         	Ref.match OUT       	+   	[match=<MatchResult 1/7: 'tbl.id'>, seg="'tbl.id = d.other_id'"]
INFO       [PD:3  MD:21]	.....................Expression_D_Grammar         	OneOf.match PRN     	    	[ns=2, ps=3, ms=0, pruned=[<Ref: BooleanLiteralGrammar>, <Ref: NullLiteralSegment>, <Ref: DateTimeLiteralGrammar>], opts=[<Ref: QuotedLiteralSegment>, <Ref: NumericLiteralSegment>]]
DEBUG      [PD:3  MD:22]	......................Expression_D_Grammar        	Ref.match OUT       	    	[match=<MatchResult 0/5: ''>, seg="'= d.other_id'"]
DEBUG      [PD:3  MD:22]	......................Expression_D_Grammar        	Ref.match OUT       	    	[match=<MatchResult 0/5: ''>, seg="'= d.other_id'"]
INFO       [PD:3  MD:21]	.....................Expression_D_Grammar         	OneOf.match OUT     	    	[match=<MatchResult 0/5: ''>, seg="'= d.other_id'"]
INFO       [PD:3  MD:20]	....................Expression_D_Grammar          	Seque.match OUT     	    	[match=<MatchResult 0/9: ''>, seg="'tbl.id = d.other_id'"]
INFO       [PD:3  MD:19]	...................Expression_D_Grammar           	OneOf.match OUT     	+   	[match=<MatchResult 1/7: 'tbl.id'>, seg="'tbl.id = d.other_id'"]
INFO       [PD:3  MD:19]	...................Accessor_Grammar               	AnyNu.match PRN     	    	[ns=0, ps=1, ms=0, pruned=[<Ref: ArrayAccessorSegment>], opts='ALL']
INFO       [PD:3  MD:19]	...................Accessor_Grammar               	AnyNu.match OUT     	    	[match=<MatchResult 0/5: ''>, seg="'= d.other_id'"]
DEBUG      [PD:3  MD:19]	...................Expression_D_Grammar           	Ref.match OUT       	    	[match=<MatchResult 0/5: ''>, seg="'= d.other_id'"]
INFO       [PD:3  MD:19]	...................Expression_D_Grammar           	AnyNu.match PRN     	    	[ns=0, ps=1, ms=0, pruned=[<Ref: ShorthandCastSegment>], opts='ALL']
INFO       [PD:3  MD:19]	...................Expression_D_Grammar           	AnyNu.match OUT     	    	[match=<MatchResult 0/5: ''>, seg="'= d.other_id'"]
INFO       [PD:3  MD:18]	..................Expression_D_Grammar            	Seque.match OUT     	+   	[match=<MatchResult 1/7: 'tbl.id'>, seg="'tbl.id = d.other_id'"]
DEBUG      [PD:3  MD:18]	..................Expression_C_Grammar            	Ref.match OUT       	+   	[match=<MatchResult 1/7: 'tbl.id'>, seg="'tbl.id = d.other_id'"]
INFO       [PD:3  MD:17]	.................Expression_C_Grammar             	OneOf.match OUT     	+   	[match=<MatchResult 1/7: 'tbl.id'>, seg="'tbl.id = d.other_id'"]
DEBUG      [PD:3  MD:17]	.................Expression_A_Grammar             	Ref.match OUT       	+   	[match=<MatchResult 1/7: 'tbl.id'>, seg="'tbl.id = d.other_id'"]
INFO       [PD:3  MD:16]	................Expression_A_Grammar              	OneOf.match OUT     	+   	[match=<MatchResult 1/7: 'tbl.id'>, seg="'tbl.id = d.other_id'"]
INFO       [PD:3  MD:16]	................Expression_A_Grammar              	AnyNu.match PRN     	    	[ns=1, ps=0, ms=0, pruned=[], opts=[<OneOf: [<Sequence: [<OneOf: [<Sequence: [<Ref: N..., <Sequence: [<Ref: NotKeywordSegment [opt..., <Sequence:...]>]]
INFO       [PD:3  MD:17]	.................Expression_A_Grammar             	OneOf.match PRN     	    	[ns=3, ps=5, ms=0, pruned=[<Sequence: [<Ref: NotKeywordSegment [opt]>, <Ref: InKeywordSegment>, <Bracketed: [<OneOf: [<Delimited: [<Ref:...]>, <Sequence: [<Ref: NotKeywordSegment [opt]>, <Ref: InKeywordSegment>, <Ref: FunctionSegment>]>, <Sequence: [<Ref: IsKeywordSegment>, <Ref: NotKeywordSegment [opt]>, <Ref: IsClauseGrammar>]>, <Sequence: [<Ref: NotKeywordSegment>, <Ref: Expression_C_Grammar>]>, <Sequence: [<Ref: NotKeywordSegment [opt]>, <Ref: BetweenKeywordSegment>, <Ref: Expression_C_Grammar>, <AnyNumbe...]>], opts=[<Sequence: [<OneOf: [<Sequence: [<Ref: NotKeywordSeg..., <Ref: Expression_C_Grammar>, <Sequence: [<Ref: EscapeKe...]>, <Ref: IsNullGrammar>, <Ref: NotNullGrammar>]]
INFO       [PD:3  MD:19]	...................Expression_A_Grammar           	OneOf.match PRN     	    	[ns=1, ps=1, ms=0, pruned=[<Sequence: [<Ref: NotKeywordSegment [opt]>, <Ref: LikeGrammar>]>], opts=[<Sequence: [<Ref: BinaryOperatorGrammar>, <Ref: NotKeywordSegment [opt]>]>]]
INFO       [PD:3  MD:21]	.....................BinaryOperatorGrammar        	OneOf.match PRN     	    	[ns=1, ps=3, ms=0, pruned=[<Ref: ArithmeticBinaryOperatorGrammar>, <Ref: StringBinaryOperatorGrammar>, <Ref: BooleanBinaryOperatorGrammar>], opts=[<Ref: ComparisonOperatorGrammar>]]
INFO       [PD:3  MD:22]	......................ComparisonOperatorGrammar   	OneOf.match PRN     	    	[ns=1, ps=6, ms=1, pruned=[<Ref: GreaterThanSegment>, <Ref: LessThanSegment>, <Ref: GreaterThanOrEqualToSegment>, <Ref: LessThanOrEqualToSegment>, <Ref: NotEqualToSegment_a>, <Ref: NotEqualToSegment_b>], opts=[<Ref: EqualsSegment>, <Ref: LikeOperatorSegment>]]
DEBUG      [PD:3  MD:23]	.......................ComparisonOperatorGrammar  	Ref.match OUT       	+   	[match=<MatchResult 1/5: '='>, seg="'= d.other_id'"]
DEBUG      [PD:3  MD:23]	.......................ComparisonOperatorGrammar  	Ref.match OUT       	    	[match=<MatchResult 0/5: ''>, seg="'= d.other_id'"]
INFO       [PD:3  MD:22]	......................ComparisonOperatorGrammar   	OneOf.match OUT     	+   	[match=<MatchResult 1/5: '='>, seg="'= d.other_id'"]
DEBUG      [PD:3  MD:22]	......................BinaryOperatorGrammar       	Ref.match OUT       	+   	[match=<MatchResult 1/5: '='>, seg="'= d.other_id'"]
INFO       [PD:3  MD:21]	.....................BinaryOperatorGrammar        	OneOf.match OUT     	+   	[match=<MatchResult 1/5: '='>, seg="'= d.other_id'"]
DEBUG      [PD:3  MD:21]	.....................Expression_A_Grammar         	Ref.match OUT       	+   	[match=<MatchResult 1/5: '='>, seg="'= d.other_id'"]
DEBUG      [PD:3  MD:21]	.....................Expression_A_Grammar         	Ref.match OUT       	    	[match=<MatchResult 0/3: ''>, seg="'d.other_id'"]
INFO       [PD:3  MD:20]	....................Expression_A_Grammar          	Seque.match OUT     	+   	[match=<MatchResult 1/5: '='>, seg="'= d.other_id'"]
INFO       [PD:3  MD:19]	...................Expression_A_Grammar           	OneOf.match OUT     	+   	[match=<MatchResult 1/5: '='>, seg="'= d.other_id'"]
INFO       [PD:3  MD:19]	...................Expression_C_Grammar           	OneOf.match PRN     	    	[ns=1, ps=2, ms=0, pruned=[<Sequence: [<Ref: ExistsKeywordSegment>, <Bracketed: [<Ref: SelectStatementSegmen...]>, <Ref: CaseExpressionSegment>], opts=[<Ref: Expression_D_Grammar>]]
INFO       [PD:3  MD:21]	.....................Expression_D_Grammar         	OneOf.match PRN     	    	[ns=6, ps=3, ms=0, pruned=[<Bracketed: [<OneOf: [<Ref: ExpressionSegment>, <Ref:...]>, <Ref: SelectStatementSegment>, <Ref: IntervalExpressionSegment>], opts=[<Ref: BareFunctionSegment>, <Ref: FunctionSegment>, <Ref: LiteralGrammar>, <Ref: ColumnReferenceSegment>, <Sequence: [<Ref: SimpleArrayTypeGrammar [opt]>, <Ref: ArrayLiteralSegment>]>, <Sequence: [<Ref: DatatypeSegment>, <OneOf: [<Ref: QuotedLiteralSegment>, <R...]>]]
DEBUG      [PD:3  MD:22]	......................Expression_D_Grammar        	Ref.match OUT       	    	[match=<MatchResult 0/3: ''>, seg="'d.other_id'"]
INFO       [PD:3  MD:23]	.......................FunctionSegment            	OneOf.match PRN     	    	[ns=1, ps=1, ms=0, pruned=[<Sequence: [<Sequence: [<Ref: DateAddFunctionNameSeg...]>], opts=[<Sequence: [<Sequence: [<AnyNumberOf: [<Ref: Functio..., <Ref: PostFunctionGrammar [opt]>]>]]
DEBUG      [PD:3  MD:29]	.............................DateAddFunctionNameSegment	Ref.match OUT       	    	[match=<MatchResult 0/3: ''>, seg="'d.other_id'"]
INFO       [PD:3  MD:28]	............................DateAddFunctionNameSegment	Seque.match OUT     	    	[match=<MatchResult 0/3: ''>, seg="'d.other_id'"]
DEBUG      [PD:3  MD:27]	...........................DateAddFunctionNameSegment	DateA.match OUT     	    	[match=<MatchResult 0/3: ''>, seg="'d.other_id'"]
DEBUG      [PD:3  MD:27]	...........................FunctionSegment        	Ref.match OUT       	    	[match=<MatchResult 0/3: ''>, seg="'d.other_id'"]
INFO       [PD:3  MD:26]	..........................FunctionSegment         	AnyNu.match PRN     	    	[ns=1, ps=0, ms=0, pruned=[], opts=[<Ref: FunctionNameSegment>]]
INFO       [PD:3  MD:29]	.............................FunctionNameSegment  	AnyNu.match PRN     	    	[ns=1, ps=0, ms=0, pruned=[], opts=[<Sequence: [<Ref: SingleIdentifierGrammar>, <Ref: DotSegment>]>]]
INFO       [PD:3  MD:31]	...............................SingleIdentifierGrammar	OneOf.match PRN     	    	[ns=2, ps=0, ms=0, pruned=[], opts=[<Ref: NakedIdentifierSegment>, <Ref: QuotedIdentifierSegment>]]
DEBUG      [PD:3  MD:32]	................................SingleIdentifierGrammar	Ref.match OUT       	+   	[match=<MatchResult 1/3: 'd'>, seg="'d.other_id'"]
DEBUG      [PD:3  MD:32]	................................SingleIdentifierGrammar	Ref.match OUT       	    	[match=<MatchResult 0/3: ''>, seg="'d.other_id'"]
INFO       [PD:3  MD:31]	...............................SingleIdentifierGrammar	OneOf.match OUT     	+   	[match=<MatchResult 1/3: 'd'>, seg="'d.other_id'"]
DEBUG      [PD:3  MD:31]	...............................FunctionNameSegment	Ref.match OUT       	+   	[match=<MatchResult 1/3: 'd'>, seg="'d.other_id'"]
DEBUG      [PD:3  MD:31]	...............................FunctionNameSegment	Ref.match OUT       	+   	[match=<MatchResult 1/2: '.'>, seg="'.other_id'"]
INFO       [PD:3  MD:30]	..............................FunctionNameSegment 	Seque.match OUT     	+   	[match=<MatchResult 2/3: 'd.'>, seg="'d.other_id'"]
INFO       [PD:3  MD:29]	.............................FunctionNameSegment  	AnyNu.match PRN     	    	[ns=1, ps=0, ms=0, pruned=[], opts=[<Sequence: [<Ref: SingleIdentifierGrammar>, <Ref: DotSegment>]>]]
INFO       [PD:3  MD:31]	...............................SingleIdentifierGrammar	OneOf.match PRN     	    	[ns=2, ps=0, ms=0, pruned=[], opts=[<Ref: NakedIdentifierSegment>, <Ref: QuotedIdentifierSegment>]]
DEBUG      [PD:3  MD:32]	................................SingleIdentifierGrammar	Ref.match OUT       	++  	[match=<MatchResult 1/1: 'other_id'>, seg="'other_id'"]
INFO       [PD:3  MD:31]	...............................SingleIdentifierGrammar	OneOf.match OUT     	++  	[match=<MatchResult 1/1: 'other_id'>, seg="'other_id'"]
DEBUG      [PD:3  MD:31]	...............................FunctionNameSegment	Ref.match OUT       	++  	[match=<MatchResult 1/1: 'other_id'>, seg="'other_id'"]
INFO       [PD:3  MD:30]	..............................FunctionNameSegment 	Seque.match OUT     	    	[match=<MatchResult 0/1: ''>, seg="'other_id'"]
INFO       [PD:3  MD:29]	.............................FunctionNameSegment  	AnyNu.match OUT     	+   	[match=<MatchResult 2/3: 'd.'>, seg="'d.other_id'"]
INFO       [PD:3  MD:29]	.............................FunctionNameSegment  	OneOf.match PRN     	    	[ns=2, ps=0, ms=0, pruned=[], opts=[<Ref: FunctionNameIdentifierSegment>, <Ref: QuotedIdentifierSegment>]]
DEBUG      [PD:3  MD:30]	..............................FunctionNameSegment 	Ref.match OUT       	++  	[match=<MatchResult 1/1: 'other_id'>, seg="'other_id'"]
INFO       [PD:3  MD:29]	.............................FunctionNameSegment  	OneOf.match OUT     	++  	[match=<MatchResult 1/1: 'other_id'>, seg="'other_id'"]
INFO       [PD:3  MD:28]	............................FunctionNameSegment   	Seque.match OUT     	++  	[match=<MatchResult 3/3: 'd.other_id'>, seg="'d.other_id'"]
DEBUG      [PD:3  MD:27]	...........................FunctionNameSegment    	Funct.match OUT     	++  	[match=<MatchResult 1/1: 'd.other_id'>, seg="'d.other_id'"]
DEBUG      [PD:3  MD:27]	...........................FunctionSegment        	Ref.match OUT       	++  	[match=<MatchResult 1/1: 'd.other_id'>, seg="'d.other_id'"]
INFO       [PD:3  MD:26]	..........................FunctionSegment         	AnyNu.match OUT     	++  	[match=<MatchResult 1/1: 'd.other_id'>, seg="'d.other_id'"]
INFO       [PD:3  MD:25]	.........................FunctionSegment          	Seque.match OUT     	    	[match=<MatchResult 0/3: ''>, seg="'d.other_id'"]
INFO       [PD:3  MD:24]	........................FunctionSegment           	Seque.match OUT     	    	[match=<MatchResult 0/3: ''>, seg="'d.other_id'"]
INFO       [PD:3  MD:23]	.......................FunctionSegment            	OneOf.match OUT     	    	[match=<MatchResult 0/3: ''>, seg="'d.other_id'"]
DEBUG      [PD:3  MD:22]	......................FunctionSegment             	Funct.match OUT     	    	[match=<MatchResult 0/3: ''>, seg="'d.other_id'"]
DEBUG      [PD:3  MD:22]	......................Expression_D_Grammar        	Ref.match OUT       	    	[match=<MatchResult 0/3: ''>, seg="'d.other_id'"]
INFO       [PD:3  MD:22]	......................LiteralGrammar              	OneOf.match PRN     	    	[ns=2, ps=4, ms=0, pruned=[<Ref: BooleanLiteralGrammar>, <Ref: QualifiedNumericLiteralSegment>, <Ref: NullLiteralSegment>, <Ref: DateTimeLiteralGrammar>], opts=[<Ref: QuotedLiteralSegment>, <Ref: NumericLiteralSegment>]]
DEBUG      [PD:3  MD:23]	.......................LiteralGrammar             	Ref.match OUT       	    	[match=<MatchResult 0/3: ''>, seg="'d.other_id'"]
DEBUG      [PD:3  MD:23]	.......................LiteralGrammar             	Ref.match OUT       	    	[match=<MatchResult 0/3: ''>, seg="'d.other_id'"]
INFO       [PD:3  MD:22]	......................LiteralGrammar              	OneOf.match OUT     	    	[match=<MatchResult 0/3: ''>, seg="'d.other_id'"]
DEBUG      [PD:3  MD:22]	......................Expression_D_Grammar        	Ref.match OUT       	    	[match=<MatchResult 0/3: ''>, seg="'d.other_id'"]
DEBUG      [PD:3  MD:24]	........................ColumnReferenceSegment    	Delim._look_ahead_match IN	    	[ls=3, seg='d.other_id']
DEBUG      [PD:3  MD:24]	........................ColumnReferenceSegment    	Delim._look_ahead_match SI	    	[mq=[(<OneOf: [<Ref: DotSegment>, <Sequence: [<Ref: DotSegment>, <Ref: Dot...]>, 1, '.'), (<OneOf: [<Ref: DotSegment>, <Sequence: [<Ref: DotSegment>, <Ref: Dot...]>, 1, '.')], sb=['D', '.', 'OTHER_ID']]
INFO       [PD:3  MD:24]	........................ColumnReferenceSegment    	OneOf.match PRN     	    	[ns=0, ps=0, ms=2, pruned=[], opts=[<Ref: DotSegment>, <Sequence: [<Ref: DotSegment>, <Ref: DotSegment>]>]]
DEBUG      [PD:3  MD:25]	.........................ColumnReferenceSegment   	Ref.match OUT       	+   	[match=<MatchResult 1/2: '.'>, seg="'.other_id'"]
DEBUG      [PD:3  MD:26]	..........................ColumnReferenceSegment  	Ref.match OUT       	+   	[match=<MatchResult 1/2: '.'>, seg="'.other_id'"]
DEBUG      [PD:3  MD:26]	..........................ColumnReferenceSegment  	Ref.match OUT       	    	[match=<MatchResult 0/1: ''>, seg="'other_id'"]
INFO       [PD:3  MD:25]	.........................ColumnReferenceSegment   	Seque.match OUT     	    	[match=<MatchResult 0/2: ''>, seg="'.other_id'"]
INFO       [PD:3  MD:24]	........................ColumnReferenceSegment    	OneOf.match OUT     	+   	[match=<MatchResult 1/2: '.'>, seg="'.other_id'"]
INFO       [PD:3  MD:24]	........................ColumnReferenceSegment    	OneOf.match PRN     	    	[ns=0, ps=0, ms=2, pruned=[], opts=[<Ref: DotSegment>, <Sequence: [<Ref: DotSegment>, <Ref: DotSegment>]>]]
DEBUG      [PD:3  MD:25]	.........................ColumnReferenceSegment   	Ref.match OUT       	+   	[match=<MatchResult 1/2: '.'>, seg="'.other_id'"]
DEBUG      [PD:3  MD:26]	..........................ColumnReferenceSegment  	Ref.match OUT       	+   	[match=<MatchResult 1/2: '.'>, seg="'.other_id'"]
DEBUG      [PD:3  MD:26]	..........................ColumnReferenceSegment  	Ref.match OUT       	    	[match=<MatchResult 0/1: ''>, seg="'other_id'"]
INFO       [PD:3  MD:25]	.........................ColumnReferenceSegment   	Seque.match OUT     	    	[match=<MatchResult 0/2: ''>, seg="'.other_id'"]
INFO       [PD:3  MD:24]	........................ColumnReferenceSegment    	OneOf.match OUT     	+   	[match=<MatchResult 1/2: '.'>, seg="'.other_id'"]
INFO       [PD:3  MD:24]	........................ColumnReferenceSegment    	OneOf.match PRN     	    	[ns=1, ps=10, ms=0, pruned=[<Ref: OnKeywordSegment>, <Ref: AsKeywordSegment>, <Ref: UsingKeywordSegment>, <Ref: CommaSegment>, <Ref: CastOperatorSegment>, <Ref: StartSquareBracketSegment>, <Ref: StartBracketSegment>, <Ref: ColonSegment>, <Ref: DelimiterSegment>, <class 'sqlfluff.core.parser.segments.base.BracketedSegment'>], opts=[<Ref: BinaryOperatorGrammar>]]
INFO       [PD:3  MD:25]	.........................BinaryOperatorGrammar    	OneOf.match PRN     	    	[ns=1, ps=3, ms=0, pruned=[<Ref: ArithmeticBinaryOperatorGrammar>, <Ref: StringBinaryOperatorGrammar>, <Ref: BooleanBinaryOperatorGrammar>], opts=[<Ref: ComparisonOperatorGrammar>]]
INFO       [PD:3  MD:26]	..........................ComparisonOperatorGrammar	OneOf.match PRN     	    	[ns=1, ps=7, ms=0, pruned=[<Ref: EqualsSegment>, <Ref: GreaterThanSegment>, <Ref: LessThanSegment>, <Ref: GreaterThanOrEqualToSegment>, <Ref: LessThanOrEqualToSegment>, <Ref: NotEqualToSegment_a>, <Ref: NotEqualToSegment_b>], opts=[<Ref: LikeOperatorSegment>]]
DEBUG      [PD:3  MD:27]	...........................ComparisonOperatorGrammar	Ref.match OUT       	    	[match=<MatchResult 0/3: ''>, seg="'d.other_id'"]
INFO       [PD:3  MD:26]	..........................ComparisonOperatorGrammar	OneOf.match OUT     	    	[match=<MatchResult 0/3: ''>, seg="'d.other_id'"]
DEBUG      [PD:3  MD:26]	..........................BinaryOperatorGrammar   	Ref.match OUT       	    	[match=<MatchResult 0/3: ''>, seg="'d.other_id'"]
INFO       [PD:3  MD:25]	.........................BinaryOperatorGrammar    	OneOf.match OUT     	    	[match=<MatchResult 0/3: ''>, seg="'d.other_id'"]
DEBUG      [PD:3  MD:25]	.........................ColumnReferenceSegment   	Ref.match OUT       	    	[match=<MatchResult 0/3: ''>, seg="'d.other_id'"]
INFO       [PD:3  MD:24]	........................ColumnReferenceSegment    	OneOf.match OUT     	    	[match=<MatchResult 0/3: ''>, seg="'d.other_id'"]
DEBUG      [PD:3  MD:24]	........................ColumnReferenceSegment    	NonCo.match OUT     	    	[match=<MatchResult 0/3: ''>, seg="'d.other_id'"]
INFO       [PD:3  MD:24]	........................ColumnReferenceSegment    	OneOf.match PRN     	    	[ns=1, ps=10, ms=0, pruned=[<Ref: OnKeywordSegment>, <Ref: AsKeywordSegment>, <Ref: UsingKeywordSegment>, <Ref: CommaSegment>, <Ref: CastOperatorSegment>, <Ref: StartSquareBracketSegment>, <Ref: StartBracketSegment>, <Ref: ColonSegment>, <Ref: DelimiterSegment>, <class 'sqlfluff.core.parser.segments.base.BracketedSegment'>], opts=[<Ref: BinaryOperatorGrammar>]]
INFO       [PD:3  MD:25]	.........................BinaryOperatorGrammar    	OneOf.match PRN     	    	[ns=1, ps=3, ms=0, pruned=[<Ref: ArithmeticBinaryOperatorGrammar>, <Ref: StringBinaryOperatorGrammar>, <Ref: BooleanBinaryOperatorGrammar>], opts=[<Ref: ComparisonOperatorGrammar>]]
INFO       [PD:3  MD:26]	..........................ComparisonOperatorGrammar	OneOf.match PRN     	    	[ns=1, ps=7, ms=0, pruned=[<Ref: EqualsSegment>, <Ref: GreaterThanSegment>, <Ref: LessThanSegment>, <Ref: GreaterThanOrEqualToSegment>, <Ref: LessThanOrEqualToSegment>, <Ref: NotEqualToSegment_a>, <Ref: NotEqualToSegment_b>], opts=[<Ref: LikeOperatorSegment>]]
DEBUG      [PD:3  MD:27]	...........................ComparisonOperatorGrammar	Ref.match OUT       	    	[match=<MatchResult 0/2: ''>, seg="'.other_id'"]
INFO       [PD:3  MD:26]	..........................ComparisonOperatorGrammar	OneOf.match OUT     	    	[match=<MatchResult 0/2: ''>, seg="'.other_id'"]
DEBUG      [PD:3  MD:26]	..........................BinaryOperatorGrammar   	Ref.match OUT       	    	[match=<MatchResult 0/2: ''>, seg="'.other_id'"]
INFO       [PD:3  MD:25]	.........................BinaryOperatorGrammar    	OneOf.match OUT     	    	[match=<MatchResult 0/2: ''>, seg="'.other_id'"]
DEBUG      [PD:3  MD:25]	.........................ColumnReferenceSegment   	Ref.match OUT       	    	[match=<MatchResult 0/2: ''>, seg="'.other_id'"]
INFO       [PD:3  MD:24]	........................ColumnReferenceSegment    	OneOf.match OUT     	    	[match=<MatchResult 0/2: ''>, seg="'.other_id'"]
DEBUG      [PD:3  MD:24]	........................ColumnReferenceSegment    	NonCo.match OUT     	    	[match=<MatchResult 0/2: ''>, seg="'.other_id'"]
INFO       [PD:3  MD:24]	........................SingleIdentifierGrammar   	OneOf.match PRN     	    	[ns=2, ps=0, ms=0, pruned=[], opts=[<Ref: NakedIdentifierSegment>, <Ref: QuotedIdentifierSegment>]]
DEBUG      [PD:3  MD:25]	.........................SingleIdentifierGrammar  	Ref.match OUT       	++  	[match=<MatchResult 1/1: 'd'>, seg="'d'"]
INFO       [PD:3  MD:24]	........................SingleIdentifierGrammar   	OneOf.match OUT     	++  	[match=<MatchResult 1/1: 'd'>, seg="'d'"]
DEBUG      [PD:3  MD:24]	........................ColumnReferenceSegment    	Ref.match OUT       	++  	[match=<MatchResult 1/1: 'd'>, seg="'d'"]
DEBUG      [PD:3  MD:24]	........................ColumnReferenceSegment    	Delim._look_ahead_match IN	    	[ls=1, seg='other_id']
DEBUG      [PD:3  MD:24]	........................ColumnReferenceSegment    	Delim._look_ahead_match SI	    	[mq=[], sb=['OTHER_ID']]
INFO       [PD:3  MD:24]	........................ColumnReferenceSegment    	OneOf.match PRN     	    	[ns=1, ps=10, ms=0, pruned=[<Ref: OnKeywordSegment>, <Ref: AsKeywordSegment>, <Ref: UsingKeywordSegment>, <Ref: CommaSegment>, <Ref: CastOperatorSegment>, <Ref: StartSquareBracketSegment>, <Ref: StartBracketSegment>, <Ref: ColonSegment>, <Ref: DelimiterSegment>, <class 'sqlfluff.core.parser.segments.base.BracketedSegment'>], opts=[<Ref: BinaryOperatorGrammar>]]
INFO       [PD:3  MD:25]	.........................BinaryOperatorGrammar    	OneOf.match PRN     	    	[ns=1, ps=3, ms=0, pruned=[<Ref: ArithmeticBinaryOperatorGrammar>, <Ref: StringBinaryOperatorGrammar>, <Ref: BooleanBinaryOperatorGrammar>], opts=[<Ref: ComparisonOperatorGrammar>]]
INFO       [PD:3  MD:26]	..........................ComparisonOperatorGrammar	OneOf.match PRN     	    	[ns=1, ps=7, ms=0, pruned=[<Ref: EqualsSegment>, <Ref: GreaterThanSegment>, <Ref: LessThanSegment>, <Ref: GreaterThanOrEqualToSegment>, <Ref: LessThanOrEqualToSegment>, <Ref: NotEqualToSegment_a>, <Ref: NotEqualToSegment_b>], opts=[<Ref: LikeOperatorSegment>]]
DEBUG      [PD:3  MD:27]	...........................ComparisonOperatorGrammar	Ref.match OUT       	    	[match=<MatchResult 0/1: ''>, seg="'other_id'"]
INFO       [PD:3  MD:26]	..........................ComparisonOperatorGrammar	OneOf.match OUT     	    	[match=<MatchResult 0/1: ''>, seg="'other_id'"]
DEBUG      [PD:3  MD:26]	..........................BinaryOperatorGrammar   	Ref.match OUT       	    	[match=<MatchResult 0/1: ''>, seg="'other_id'"]
INFO       [PD:3  MD:25]	.........................BinaryOperatorGrammar    	OneOf.match OUT     	    	[match=<MatchResult 0/1: ''>, seg="'other_id'"]
DEBUG      [PD:3  MD:25]	.........................ColumnReferenceSegment   	Ref.match OUT       	    	[match=<MatchResult 0/1: ''>, seg="'other_id'"]
INFO       [PD:3  MD:24]	........................ColumnReferenceSegment    	OneOf.match OUT     	    	[match=<MatchResult 0/1: ''>, seg="'other_id'"]
DEBUG      [PD:3  MD:24]	........................ColumnReferenceSegment    	NonCo.match OUT     	    	[match=<MatchResult 0/1: ''>, seg="'other_id'"]
INFO       [PD:3  MD:24]	........................SingleIdentifierGrammar   	OneOf.match PRN     	    	[ns=2, ps=0, ms=0, pruned=[], opts=[<Ref: NakedIdentifierSegment>, <Ref: QuotedIdentifierSegment>]]
DEBUG      [PD:3  MD:25]	.........................SingleIdentifierGrammar  	Ref.match OUT       	++  	[match=<MatchResult 1/1: 'other_id'>, seg="'other_id'"]
INFO       [PD:3  MD:24]	........................SingleIdentifierGrammar   	OneOf.match OUT     	++  	[match=<MatchResult 1/1: 'other_id'>, seg="'other_id'"]
DEBUG      [PD:3  MD:24]	........................ColumnReferenceSegment    	Ref.match OUT       	++  	[match=<MatchResult 1/1: 'other_id'>, seg="'other_id'"]
INFO       [PD:3  MD:23]	.......................ColumnReferenceSegment     	Delim.match OUT     	++  	[match=<MatchResult 3/3: 'd.other_id'>, seg="'d.other_id'"]
DEBUG      [PD:3  MD:22]	......................ColumnReferenceSegment      	Colum.match OUT     	++  	[match=<MatchResult 1/1: 'd.other_id'>, seg="'d.other_id'"]
DEBUG      [PD:3  MD:22]	......................Expression_D_Grammar        	Ref.match OUT       	++  	[match=<MatchResult 1/1: 'd.other_id'>, seg="'d.other_id'"]
INFO       [PD:3  MD:21]	.....................Expression_D_Grammar         	OneOf.match OUT     	++  	[match=<MatchResult 1/1: 'd.other_id'>, seg="'d.other_id'"]
INFO       [PD:3  MD:20]	....................Expression_D_Grammar          	Seque.match OUT     	++  	[match=<MatchResult 1/1: 'd.other_id'>, seg="'d.other_id'"]
DEBUG      [PD:3  MD:20]	....................Expression_C_Grammar          	Ref.match OUT       	++  	[match=<MatchResult 1/1: 'd.other_id'>, seg="'d.other_id'"]
INFO       [PD:3  MD:19]	...................Expression_C_Grammar           	OneOf.match OUT     	++  	[match=<MatchResult 1/1: 'd.other_id'>, seg="'d.other_id'"]
DEBUG      [PD:3  MD:19]	...................Expression_A_Grammar           	Ref.match OUT       	++  	[match=<MatchResult 1/1: 'd.other_id'>, seg="'d.other_id'"]
INFO       [PD:3  MD:18]	..................Expression_A_Grammar            	Seque.match OUT     	++  	[match=<MatchResult 3/3: '= d.other_id'>, seg="'= d.other_id'"]
INFO       [PD:3  MD:17]	.................Expression_A_Grammar             	OneOf.match OUT     	++  	[match=<MatchResult 3/3: '= d.other_id'>, seg="'= d.other_id'"]
INFO       [PD:3  MD:16]	................Expression_A_Grammar              	AnyNu.match OUT     	++  	[match=<MatchResult 3/3: '= d.other_id'>, seg="'= d.other_id'"]
INFO       [PD:3  MD:15]	...............Expression_A_Grammar               	Seque.match OUT     	++  	[match=<MatchResult 5/5: 'tbl.id = d.other_id'>, seg="'tbl.id = d.other_id'"]
DEBUG      [PD:3  MD:15]	...............ExpressionSegment                  	Ref.match OUT       	++  	[match=<MatchResult 5/5: 'tbl.id = d.other_id'>, seg="'tbl.id = d.other_id'"]
DEBUG      [PD:3  MD:14]	..............ExpressionSegment                   	Expre.match OUT     	++  	[match=<MatchResult 1/1: 'tbl.id = d.other_id'>, seg="'tbl.id = d.other_id'"]
DEBUG      [PD:3  MD:14]	..............JoinOnConditionSegment              	Ref.match OUT       	++  	[match=<MatchResult 1/1: 'tbl.id = d.other_id'>, seg="'tbl.id = d.other_id'"]
INFO       [PD:3  MD:13]	.............JoinOnConditionSegment               	Brack.match OUT     	++  	[match=<MatchResult 1/1: 'tbl.id = d.other_id'>, seg="'tbl.id = d.other_id'"]
INFO       [PD:3  MD:12]	............JoinOnConditionSegment                	Brack.match OUT     	++  	[match=<MatchResult 1/1: '(tbl.id = d.other_id)'>, seg="'(tbl.id = d.other_id...'"]
INFO       [PD:3  MD:11]	...........JoinOnConditionSegment                 	Optio.match OUT     	++  	[match=<MatchResult 1/1: '(tbl.id = d.other_id)'>, seg="'(tbl.id = d.other_id...'"]
INFO       [PD:3  MD:10]	..........JoinOnConditionSegment                  	Seque.match OUT     	++  	[match=<MatchResult 5/5: 'ON (tbl.id = d.other_id)'>, seg="'ON (tbl.id = d.other...'"]
DEBUG      [PD:3  MD:9 ]	.........JoinOnConditionSegment                   	JoinO.match OUT     	++  	[match=<MatchResult 1/1: 'ON (tbl.id = d.other_id)'>, seg="'ON (tbl.id = d.other...'"]
DEBUG      [PD:3  MD:9 ]	.........JoinClauseSegment                        	Ref.match OUT       	++  	[match=<MatchResult 1/1: 'ON (tbl.id = d.other_id)'>, seg="'ON (tbl.id = d.other...'"]
INFO       [PD:3  MD:8 ]	........JoinClauseSegment                         	OneOf.match OUT     	++  	[match=<MatchResult 1/1: 'ON (tbl.id = d.other_id)'>, seg="'ON (tbl.id = d.other...'"]
INFO       [PD:3  MD:7 ]	.......JoinClauseSegment                          	Seque.match OUT     	++  	[match=<MatchResult 3/3: 'd ON (tbl.id = d.other_id)'>, seg="'d ON (tbl.id = d.oth...'"]
INFO       [PD:3  MD:6 ]	......JoinClauseSegment                           	Seque.match OUT     	++  	[match=<MatchResult 9/9: 'LEFT JOIN d ON ...d = d.other_id)'>, seg="'LEFT JOIN d ON (tbl....'"]
DEBUG      [PD:3  MD:5 ]	.....JoinClauseSegment                            	JoinC.match OUT     	++  	[match=<MatchResult 1/1: 'LEFT JOIN d ON ...d = d.other_id)'>, seg="'LEFT JOIN d ON (tbl....'"]
DEBUG      [PD:3  MD:5 ]	.....FromExpressionSegment                        	Ref.match OUT       	++  	[match=<MatchResult 1/1: 'LEFT JOIN d ON ...d = d.other_id)'>, seg="'LEFT JOIN d ON (tbl....'"]
INFO       [PD:3  MD:4 ]	....FromExpressionSegment                         	AnyNu.match OUT     	++  	[match=<MatchResult 5/5: 'INNER JOIN b ON...d = d.other_id)'>, seg="'INNER JOIN b ON (tbl...'"]
INFO       [PD:3  MD:3 ]	...FromExpressionSegment                          	Seque.match OUT     	++  	[match=<MatchResult 9/9: 'tbl\nINNER JOIN ...d = d.other_id)'>, seg="'tbl\\nINNER JOIN b ON ...'"]
DEBUG      [PD:3  MD:2 ]	..FromExpressionSegment                           	FromE.match OUT     	++  	[match=<MatchResult 1/1: 'tbl\nINNER JOIN ...d = d.other_id)'>, seg="'tbl\\nINNER JOIN b ON ...'"]
DEBUG      [PD:3  MD:2 ]	..FromClauseSegment                               	Ref.match OUT       	++  	[match=<MatchResult 1/1: 'tbl\nINNER JOIN ...d = d.other_id)'>, seg="'tbl\\nINNER JOIN b ON ...'"]
INFO       [PD:3  MD:1 ]	.FromClauseSegment                                	Delim.match OUT     	++  	[match=<MatchResult 1/1: 'tbl\nINNER JOIN ...d = d.other_id)'>, seg="'tbl\\nINNER JOIN b ON ...'"]
INFO       [PD:3  MD:0 ]	FromClauseSegment                                 	Seque.match OUT     	++  	[match=<MatchResult 3/3: 'FROM tbl\nINNER ...d = d.other_id)'>, seg="'FROM tbl\\nINNER JOIN ...'"]
DEBUG      FromClauseSegment.parse: Done Parse. Plotting Recursion. Recurse=True
DEBUG      ###
#
# Beginning Parse Depth 4: FromClauseSegment
#
###
Initial Structure:
[L: 10, P:  1]      |from_clause:
[L: 10, P:  1]      |    keyword:                                                  'FROM'
[L: 10, P:  5]      |    whitespace:                                               ' '
[L: 10, P:  6]      |    from_expression:
[L: 10, P:  6]      |        [META] indent:
[L: 10, P:  6]      |        from_expression_element:
[L: 10, P:  6]      |            table_expression:
[L: 10, P:  6]      |                table_reference:
[L: 10, P:  6]      |                    identifier:                               'tbl'
[L: 10, P:  9]      |        newline:                                              '\n'
[L: 11, P:  1]      |        [META] dedent:
[L: 11, P:  1]      |        join_clause:
[L: 11, P:  1]      |            keyword:                                          'INNER'
[L: 11, P:  6]      |            whitespace:                                       ' '
[L: 11, P:  7]      |            keyword:                                          'JOIN'
[L: 11, P: 11]      |            [META] indent:
[L: 11, P: 11]      |            whitespace:                                       ' '
[L: 11, P: 12]      |            from_expression_element:
[L: 11, P: 12]      |                table_expression:
[L: 11, P: 12]      |                    table_reference:
[L: 11, P: 12]      |                        identifier:                           'b'
[L: 11, P: 13]      |            whitespace:                                       ' '
[L: 11, P: 14]      |            join_on_condition:
[L: 11, P: 14]      |                keyword:                                      'ON'
[L: 11, P: 16]      |                [META] indent:
[L: 11, P: 16]      |                whitespace:                                   ' '
[L: 11, P: 17]      |                bracketed:
[L: 11, P: 17]      |                    start_bracket:                            '('
[L: 11, P: 18]      |                    [META] indent:
[L: 11, P: 18]      |                    ephemeral:
[L: 11, P: 18]      |                        expression:
[L: 11, P: 18]      |                            column_reference:
[L: 11, P: 18]      |                                identifier:                   'tbl'
[L: 11, P: 21]      |                                dot:                          '.'
[L: 11, P: 22]      |                                identifier:                   'common_id'
[L: 11, P: 31]      |                            whitespace:                       ' '
[L: 11, P: 32]      |                            comparison_operator:              '='
[L: 11, P: 33]      |                            whitespace:                       ' '
[L: 11, P: 34]      |                            column_reference:
[L: 11, P: 34]      |                                identifier:                   'b'
[L: 11, P: 35]      |                                dot:                          '.'
[L: 11, P: 36]      |                                identifier:                   'common_id'
[L: 11, P: 45]      |                    [META] dedent:
[L: 11, P: 45]      |                    end_bracket:                              ')'
[L: 11, P: 46]      |                [META] dedent:
[L: 11, P: 46]      |            [META] dedent:
[L: 11, P: 46]      |        newline:                                              '\n'
[L: 12, P:  1]      |        join_clause:
[L: 12, P:  1]      |            keyword:                                          'JOIN'
[L: 12, P:  5]      |            [META] indent:
[L: 12, P:  5]      |            whitespace:                                       ' '
[L: 12, P:  6]      |            from_expression_element:
[L: 12, P:  6]      |                table_expression:
[L: 12, P:  6]      |                    table_reference:
[L: 12, P:  6]      |                        identifier:                           'c'
[L: 12, P:  7]      |            whitespace:                                       ' '
[L: 12, P:  8]      |            join_on_condition:
[L: 12, P:  8]      |                keyword:                                      'ON'
[L: 12, P: 10]      |                [META] indent:
[L: 12, P: 10]      |                whitespace:                                   ' '
[L: 12, P: 11]      |                bracketed:
[L: 12, P: 11]      |                    start_bracket:                            '('
[L: 12, P: 12]      |                    [META] indent:
[L: 12, P: 12]      |                    ephemeral:
[L: 12, P: 12]      |                        expression:
[L: 12, P: 12]      |                            column_reference:
[L: 12, P: 12]      |                                identifier:                   'tbl'
[L: 12, P: 15]      |                                dot:                          '.'
[L: 12, P: 16]      |                                identifier:                   'id'
[L: 12, P: 18]      |                            whitespace:                       ' '
[L: 12, P: 19]      |                            comparison_operator:              '='
[L: 12, P: 20]      |                            whitespace:                       ' '
[L: 12, P: 21]      |                            column_reference:
[L: 12, P: 21]      |                                identifier:                   'c'
[L: 12, P: 22]      |                                dot:                          '.'
[L: 12, P: 23]      |                                identifier:                   'id'
[L: 12, P: 25]      |                    [META] dedent:
[L: 12, P: 25]      |                    end_bracket:                              ')'
[L: 12, P: 26]      |                [META] dedent:
[L: 12, P: 26]      |            [META] dedent:
[L: 12, P: 26]      |        newline:                                              '\n'
[L: 13, P:  1]      |        join_clause:
[L: 13, P:  1]      |            keyword:                                          'LEFT'
[L: 13, P:  5]      |            whitespace:                                       ' '
[L: 13, P:  6]      |            keyword:                                          'JOIN'
[L: 13, P: 10]      |            [META] indent:
[L: 13, P: 10]      |            whitespace:                                       ' '
[L: 13, P: 11]      |            from_expression_element:
[L: 13, P: 11]      |                table_expression:
[L: 13, P: 11]      |                    table_reference:
[L: 13, P: 11]      |                        identifier:                           'd'
[L: 13, P: 12]      |            whitespace:                                       ' '
[L: 13, P: 13]      |            join_on_condition:
[L: 13, P: 13]      |                keyword:                                      'ON'
[L: 13, P: 15]      |                [META] indent:
[L: 13, P: 15]      |                whitespace:                                   ' '
[L: 13, P: 16]      |                bracketed:
[L: 13, P: 16]      |                    start_bracket:                            '('
[L: 13, P: 17]      |                    [META] indent:
[L: 13, P: 17]      |                    expression:
[L: 13, P: 17]      |                        column_reference:
[L: 13, P: 17]      |                            identifier:                       'tbl'
[L: 13, P: 20]      |                            dot:                              '.'
[L: 13, P: 21]      |                            identifier:                       'id'
[L: 13, P: 23]      |                        whitespace:                           ' '
[L: 13, P: 24]      |                        comparison_operator:                  '='
[L: 13, P: 25]      |                        whitespace:                           ' '
[L: 13, P: 26]      |                        column_reference:
[L: 13, P: 26]      |                            identifier:                       'd'
[L: 13, P: 27]      |                            dot:                              '.'
[L: 13, P: 28]      |                            identifier:                       'other_id'
[L: 13, P: 36]      |                    [META] dedent:
[L: 13, P: 36]      |                    end_bracket:                              ')'
[L: 13, P: 37]      |                [META] dedent:
[L: 13, P: 37]      |            [META] dedent:

INFO       [PD:4] Skipping expansion of <KeywordSegment: ([L: 10, P:  1]) 'FROM'>...
INFO       [PD:4] Skipping expansion of <WhitespaceSegment: ([L: 10, P:  5]) ' '>...
INFO       
###
#
# Parse Depth 4. Expanding: FromExpressionSegment: 'tbl\nINNER JOIN b ON (tbl.common_id = b.c...'
#
###
DEBUG      FromExpressionSegment.parse: no grammar. Going straight to expansion
DEBUG      FromExpressionSegment.parse: Done Parse. Plotting Recursion. Recurse=True
DEBUG      ###
#
# Beginning Parse Depth 5: FromExpressionSegment
#
###
Initial Structure:
[L: 10, P:  6]      |from_expression:
[L: 10, P:  6]      |    [META] indent:
[L: 10, P:  6]      |    from_expression_element:
[L: 10, P:  6]      |        table_expression:
[L: 10, P:  6]      |            table_reference:
[L: 10, P:  6]      |                identifier:                                   'tbl'
[L: 10, P:  9]      |    newline:                                                  '\n'
[L: 11, P:  1]      |    [META] dedent:
[L: 11, P:  1]      |    join_clause:
[L: 11, P:  1]      |        keyword:                                              'INNER'
[L: 11, P:  6]      |        whitespace:                                           ' '
[L: 11, P:  7]      |        keyword:                                              'JOIN'
[L: 11, P: 11]      |        [META] indent:
[L: 11, P: 11]      |        whitespace:                                           ' '
[L: 11, P: 12]      |        from_expression_element:
[L: 11, P: 12]      |            table_expression:
[L: 11, P: 12]      |                table_reference:
[L: 11, P: 12]      |                    identifier:                               'b'
[L: 11, P: 13]      |        whitespace:                                           ' '
[L: 11, P: 14]      |        join_on_condition:
[L: 11, P: 14]      |            keyword:                                          'ON'
[L: 11, P: 16]      |            [META] indent:
[L: 11, P: 16]      |            whitespace:                                       ' '
[L: 11, P: 17]      |            bracketed:
[L: 11, P: 17]      |                start_bracket:                                '('
[L: 11, P: 18]      |                [META] indent:
[L: 11, P: 18]      |                ephemeral:
[L: 11, P: 18]      |                    expression:
[L: 11, P: 18]      |                        column_reference:
[L: 11, P: 18]      |                            identifier:                       'tbl'
[L: 11, P: 21]      |                            dot:                              '.'
[L: 11, P: 22]      |                            identifier:                       'common_id'
[L: 11, P: 31]      |                        whitespace:                           ' '
[L: 11, P: 32]      |                        comparison_operator:                  '='
[L: 11, P: 33]      |                        whitespace:                           ' '
[L: 11, P: 34]      |                        column_reference:
[L: 11, P: 34]      |                            identifier:                       'b'
[L: 11, P: 35]      |                            dot:                              '.'
[L: 11, P: 36]      |                            identifier:                       'common_id'
[L: 11, P: 45]      |                [META] dedent:
[L: 11, P: 45]      |                end_bracket:                                  ')'
[L: 11, P: 46]      |            [META] dedent:
[L: 11, P: 46]      |        [META] dedent:
[L: 11, P: 46]      |    newline:                                                  '\n'
[L: 12, P:  1]      |    join_clause:
[L: 12, P:  1]      |        keyword:                                              'JOIN'
[L: 12, P:  5]      |        [META] indent:
[L: 12, P:  5]      |        whitespace:                                           ' '
[L: 12, P:  6]      |        from_expression_element:
[L: 12, P:  6]      |            table_expression:
[L: 12, P:  6]      |                table_reference:
[L: 12, P:  6]      |                    identifier:                               'c'
[L: 12, P:  7]      |        whitespace:                                           ' '
[L: 12, P:  8]      |        join_on_condition:
[L: 12, P:  8]      |            keyword:                                          'ON'
[L: 12, P: 10]      |            [META] indent:
[L: 12, P: 10]      |            whitespace:                                       ' '
[L: 12, P: 11]      |            bracketed:
[L: 12, P: 11]      |                start_bracket:                                '('
[L: 12, P: 12]      |                [META] indent:
[L: 12, P: 12]      |                ephemeral:
[L: 12, P: 12]      |                    expression:
[L: 12, P: 12]      |                        column_reference:
[L: 12, P: 12]      |                            identifier:                       'tbl'
[L: 12, P: 15]      |                            dot:                              '.'
[L: 12, P: 16]      |                            identifier:                       'id'
[L: 12, P: 18]      |                        whitespace:                           ' '
[L: 12, P: 19]      |                        comparison_operator:                  '='
[L: 12, P: 20]      |                        whitespace:                           ' '
[L: 12, P: 21]      |                        column_reference:
[L: 12, P: 21]      |                            identifier:                       'c'
[L: 12, P: 22]      |                            dot:                              '.'
[L: 12, P: 23]      |                            identifier:                       'id'
[L: 12, P: 25]      |                [META] dedent:
[L: 12, P: 25]      |                end_bracket:                                  ')'
[L: 12, P: 26]      |            [META] dedent:
[L: 12, P: 26]      |        [META] dedent:
[L: 12, P: 26]      |    newline:                                                  '\n'
[L: 13, P:  1]      |    join_clause:
[L: 13, P:  1]      |        keyword:                                              'LEFT'
[L: 13, P:  5]      |        whitespace:                                           ' '
[L: 13, P:  6]      |        keyword:                                              'JOIN'
[L: 13, P: 10]      |        [META] indent:
[L: 13, P: 10]      |        whitespace:                                           ' '
[L: 13, P: 11]      |        from_expression_element:
[L: 13, P: 11]      |            table_expression:
[L: 13, P: 11]      |                table_reference:
[L: 13, P: 11]      |                    identifier:                               'd'
[L: 13, P: 12]      |        whitespace:                                           ' '
[L: 13, P: 13]      |        join_on_condition:
[L: 13, P: 13]      |            keyword:                                          'ON'
[L: 13, P: 15]      |            [META] indent:
[L: 13, P: 15]      |            whitespace:                                       ' '
[L: 13, P: 16]      |            bracketed:
[L: 13, P: 16]      |                start_bracket:                                '('
[L: 13, P: 17]      |                [META] indent:
[L: 13, P: 17]      |                expression:
[L: 13, P: 17]      |                    column_reference:
[L: 13, P: 17]      |                        identifier:                           'tbl'
[L: 13, P: 20]      |                        dot:                                  '.'
[L: 13, P: 21]      |                        identifier:                           'id'
[L: 13, P: 23]      |                    whitespace:                               ' '
[L: 13, P: 24]      |                    comparison_operator:                      '='
[L: 13, P: 25]      |                    whitespace:                               ' '
[L: 13, P: 26]      |                    column_reference:
[L: 13, P: 26]      |                        identifier:                           'd'
[L: 13, P: 27]      |                        dot:                                  '.'
[L: 13, P: 28]      |                        identifier:                           'other_id'
[L: 13, P: 36]      |                [META] dedent:
[L: 13, P: 36]      |                end_bracket:                                  ')'
[L: 13, P: 37]      |            [META] dedent:
[L: 13, P: 37]      |        [META] dedent:

INFO       [PD:5] Skipping expansion of <Indent: ([L: 10, P:  6]) ''>...
INFO       [PD:5] Skipping expansion of <FromExpressionElementSegment: ([L: 10, P:  6])>...
INFO       [PD:5] Skipping expansion of <NewlineSegment: ([L: 10, P:  9]) '\n'>...
INFO       [PD:5] Skipping expansion of <Dedent: ([L: 11, P:  1]) ''>...
INFO       
###
#
# Parse Depth 5. Expanding: JoinClauseSegment: 'INNER JOIN b ON (tbl.common_id = b.commo...'
#
###
DEBUG      JoinClauseSegment.parse: no grammar. Going straight to expansion
DEBUG      JoinClauseSegment.parse: Done Parse. Plotting Recursion. Recurse=True
DEBUG      ###
#
# Beginning Parse Depth 6: JoinClauseSegment
#
###
Initial Structure:
[L: 11, P:  1]      |join_clause:
[L: 11, P:  1]      |    keyword:                                                  'INNER'
[L: 11, P:  6]      |    whitespace:                                               ' '
[L: 11, P:  7]      |    keyword:                                                  'JOIN'
[L: 11, P: 11]      |    [META] indent:
[L: 11, P: 11]      |    whitespace:                                               ' '
[L: 11, P: 12]      |    from_expression_element:
[L: 11, P: 12]      |        table_expression:
[L: 11, P: 12]      |            table_reference:
[L: 11, P: 12]      |                identifier:                                   'b'
[L: 11, P: 13]      |    whitespace:                                               ' '
[L: 11, P: 14]      |    join_on_condition:
[L: 11, P: 14]      |        keyword:                                              'ON'
[L: 11, P: 16]      |        [META] indent:
[L: 11, P: 16]      |        whitespace:                                           ' '
[L: 11, P: 17]      |        bracketed:
[L: 11, P: 17]      |            start_bracket:                                    '('
[L: 11, P: 18]      |            [META] indent:
[L: 11, P: 18]      |            ephemeral:
[L: 11, P: 18]      |                expression:
[L: 11, P: 18]      |                    column_reference:
[L: 11, P: 18]      |                        identifier:                           'tbl'
[L: 11, P: 21]      |                        dot:                                  '.'
[L: 11, P: 22]      |                        identifier:                           'common_id'
[L: 11, P: 31]      |                    whitespace:                               ' '
[L: 11, P: 32]      |                    comparison_operator:                      '='
[L: 11, P: 33]      |                    whitespace:                               ' '
[L: 11, P: 34]      |                    column_reference:
[L: 11, P: 34]      |                        identifier:                           'b'
[L: 11, P: 35]      |                        dot:                                  '.'
[L: 11, P: 36]      |                        identifier:                           'common_id'
[L: 11, P: 45]      |            [META] dedent:
[L: 11, P: 45]      |            end_bracket:                                      ')'
[L: 11, P: 46]      |        [META] dedent:
[L: 11, P: 46]      |    [META] dedent:

INFO       [PD:6] Skipping expansion of <KeywordSegment: ([L: 11, P:  1]) 'INNER'>...
INFO       [PD:6] Skipping expansion of <WhitespaceSegment: ([L: 11, P:  6]) ' '>...
INFO       [PD:6] Skipping expansion of <KeywordSegment: ([L: 11, P:  7]) 'JOIN'>...
INFO       [PD:6] Skipping expansion of <Indent: ([L: 11, P: 11]) ''>...
INFO       [PD:6] Skipping expansion of <WhitespaceSegment: ([L: 11, P: 11]) ' '>...
INFO       [PD:6] Skipping expansion of <FromExpressionElementSegment: ([L: 11, P: 12])>...
INFO       [PD:6] Skipping expansion of <WhitespaceSegment: ([L: 11, P: 13]) ' '>...
INFO       
###
#
# Parse Depth 6. Expanding: JoinOnConditionSegment: 'ON (tbl.common_id = b.common_id)'
#
###
DEBUG      JoinOnConditionSegment.parse: no grammar. Going straight to expansion
DEBUG      JoinOnConditionSegment.parse: Done Parse. Plotting Recursion. Recurse=True
DEBUG      ###
#
# Beginning Parse Depth 7: JoinOnConditionSegment
#
###
Initial Structure:
[L: 11, P: 14]      |join_on_condition:
[L: 11, P: 14]      |    keyword:                                                  'ON'
[L: 11, P: 16]      |    [META] indent:
[L: 11, P: 16]      |    whitespace:                                               ' '
[L: 11, P: 17]      |    bracketed:
[L: 11, P: 17]      |        start_bracket:                                        '('
[L: 11, P: 18]      |        [META] indent:
[L: 11, P: 18]      |        ephemeral:
[L: 11, P: 18]      |            expression:
[L: 11, P: 18]      |                column_reference:
[L: 11, P: 18]      |                    identifier:                               'tbl'
[L: 11, P: 21]      |                    dot:                                      '.'
[L: 11, P: 22]      |                    identifier:                               'common_id'
[L: 11, P: 31]      |                whitespace:                                   ' '
[L: 11, P: 32]      |                comparison_operator:                          '='
[L: 11, P: 33]      |                whitespace:                                   ' '
[L: 11, P: 34]      |                column_reference:
[L: 11, P: 34]      |                    identifier:                               'b'
[L: 11, P: 35]      |                    dot:                                      '.'
[L: 11, P: 36]      |                    identifier:                               'common_id'
[L: 11, P: 45]      |        [META] dedent:
[L: 11, P: 45]      |        end_bracket:                                          ')'
[L: 11, P: 46]      |    [META] dedent:

INFO       [PD:7] Skipping expansion of <KeywordSegment: ([L: 11, P: 14]) 'ON'>...
INFO       [PD:7] Skipping expansion of <Indent: ([L: 11, P: 16]) ''>...
INFO       [PD:7] Skipping expansion of <WhitespaceSegment: ([L: 11, P: 16]) ' '>...
INFO       
###
#
# Parse Depth 7. Expanding: BracketedSegment: '(tbl.common_id = b.common_id)'
#
###
DEBUG      BracketedSegment.parse: no grammar. Going straight to expansion
DEBUG      BracketedSegment.parse: Done Parse. Plotting Recursion. Recurse=True
DEBUG      ###
#
# Beginning Parse Depth 8: BracketedSegment
#
###
Initial Structure:
[L: 11, P: 17]      |bracketed:
[L: 11, P: 17]      |    start_bracket:                                            '('
[L: 11, P: 18]      |    [META] indent:
[L: 11, P: 18]      |    ephemeral:
[L: 11, P: 18]      |        expression:
[L: 11, P: 18]      |            column_reference:
[L: 11, P: 18]      |                identifier:                                   'tbl'
[L: 11, P: 21]      |                dot:                                          '.'
[L: 11, P: 22]      |                identifier:                                   'common_id'
[L: 11, P: 31]      |            whitespace:                                       ' '
[L: 11, P: 32]      |            comparison_operator:                              '='
[L: 11, P: 33]      |            whitespace:                                       ' '
[L: 11, P: 34]      |            column_reference:
[L: 11, P: 34]      |                identifier:                                   'b'
[L: 11, P: 35]      |                dot:                                          '.'
[L: 11, P: 36]      |                identifier:                                   'common_id'
[L: 11, P: 45]      |    [META] dedent:
[L: 11, P: 45]      |    end_bracket:                                              ')'

INFO       [PD:8] Skipping expansion of <SymbolSegment: ([L: 11, P: 17]) '('>...
INFO       [PD:8] Skipping expansion of <Indent: ([L: 11, P: 18]) ''>...
INFO       
###
#
# Parse Depth 8. Expanding: EphemeralSegment: 'tbl.common_id = b.common_id'
#
###
INFO       [PD:8  MD:0 ]	EphemeralSegment                                  	OneOf.match PRN     	    	[ns=2, ps=1, ms=0, pruned=[<Ref: SelectableGrammar>], opts=[<Ref: ExpressionSegment>, <Delimited: [<Ref: ColumnReferenceSegment>, <Ref: FunctionSegment>, <Ref: LiteralGrammar>]>]]
INFO       [PD:8  MD:1 ]	.ExpressionSegment                                	Expre._match SELF   	    
DEBUG      [PD:8  MD:1 ]	.ExpressionSegment                                	Expre.match OUT     	++  	[match=<MatchResult 1/1: 'tbl.common_id = b.common_id'>, seg="'tbl.common_id = b.co...'"]
DEBUG      [PD:8  MD:1 ]	.EphemeralSegment                                 	Ref.match OUT       	++  	[match=<MatchResult 1/1: 'tbl.common_id = b.common_id'>, seg="'tbl.common_id = b.co...'"]
INFO       [PD:8  MD:0 ]	EphemeralSegment                                  	OneOf.match OUT     	++  	[match=<MatchResult 1/1: 'tbl.common_id = b.common_id'>, seg="'tbl.common_id = b.co...'"]
DEBUG      EphemeralSegment.parse: Done Parse. Plotting Recursion. Recurse=True
DEBUG      ###
#
# Beginning Parse Depth 9: EphemeralSegment
#
###
Initial Structure:
[L: 11, P: 18]      |ephemeral:
[L: 11, P: 18]      |    expression:
[L: 11, P: 18]      |        column_reference:
[L: 11, P: 18]      |            identifier:                                       'tbl'
[L: 11, P: 21]      |            dot:                                              '.'
[L: 11, P: 22]      |            identifier:                                       'common_id'
[L: 11, P: 31]      |        whitespace:                                           ' '
[L: 11, P: 32]      |        comparison_operator:                                  '='
[L: 11, P: 33]      |        whitespace:                                           ' '
[L: 11, P: 34]      |        column_reference:
[L: 11, P: 34]      |            identifier:                                       'b'
[L: 11, P: 35]      |            dot:                                              '.'
[L: 11, P: 36]      |            identifier:                                       'common_id'

INFO       [PD:9] Skipping expansion of <ExpressionSegment: ([L: 11, P: 18])>...
INFO       [PD:8] Skipping expansion of <Dedent: ([L: 11, P: 45]) ''>...
INFO       [PD:8] Skipping expansion of <SymbolSegment: ([L: 11, P: 45]) ')'>...
INFO       [PD:7] Skipping expansion of <Dedent: ([L: 11, P: 46]) ''>...
INFO       [PD:6] Skipping expansion of <Dedent: ([L: 11, P: 46]) ''>...
INFO       [PD:5] Skipping expansion of <NewlineSegment: ([L: 11, P: 46]) '\n'>...
INFO       
###
#
# Parse Depth 5. Expanding: JoinClauseSegment: 'JOIN c ON (tbl.id = c.id)'
#
###
DEBUG      JoinClauseSegment.parse: no grammar. Going straight to expansion
DEBUG      JoinClauseSegment.parse: Done Parse. Plotting Recursion. Recurse=True
DEBUG      ###
#
# Beginning Parse Depth 6: JoinClauseSegment
#
###
Initial Structure:
[L: 12, P:  1]      |join_clause:
[L: 12, P:  1]      |    keyword:                                                  'JOIN'
[L: 12, P:  5]      |    [META] indent:
[L: 12, P:  5]      |    whitespace:                                               ' '
[L: 12, P:  6]      |    from_expression_element:
[L: 12, P:  6]      |        table_expression:
[L: 12, P:  6]      |            table_reference:
[L: 12, P:  6]      |                identifier:                                   'c'
[L: 12, P:  7]      |    whitespace:                                               ' '
[L: 12, P:  8]      |    join_on_condition:
[L: 12, P:  8]      |        keyword:                                              'ON'
[L: 12, P: 10]      |        [META] indent:
[L: 12, P: 10]      |        whitespace:                                           ' '
[L: 12, P: 11]      |        bracketed:
[L: 12, P: 11]      |            start_bracket:                                    '('
[L: 12, P: 12]      |            [META] indent:
[L: 12, P: 12]      |            ephemeral:
[L: 12, P: 12]      |                expression:
[L: 12, P: 12]      |                    column_reference:
[L: 12, P: 12]      |                        identifier:                           'tbl'
[L: 12, P: 15]      |                        dot:                                  '.'
[L: 12, P: 16]      |                        identifier:                           'id'
[L: 12, P: 18]      |                    whitespace:                               ' '
[L: 12, P: 19]      |                    comparison_operator:                      '='
[L: 12, P: 20]      |                    whitespace:                               ' '
[L: 12, P: 21]      |                    column_reference:
[L: 12, P: 21]      |                        identifier:                           'c'
[L: 12, P: 22]      |                        dot:                                  '.'
[L: 12, P: 23]      |                        identifier:                           'id'
[L: 12, P: 25]      |            [META] dedent:
[L: 12, P: 25]      |            end_bracket:                                      ')'
[L: 12, P: 26]      |        [META] dedent:
[L: 12, P: 26]      |    [META] dedent:

INFO       [PD:6] Skipping expansion of <KeywordSegment: ([L: 12, P:  1]) 'JOIN'>...
INFO       [PD:6] Skipping expansion of <Indent: ([L: 12, P:  5]) ''>...
INFO       [PD:6] Skipping expansion of <WhitespaceSegment: ([L: 12, P:  5]) ' '>...
INFO       [PD:6] Skipping expansion of <FromExpressionElementSegment: ([L: 12, P:  6])>...
INFO       [PD:6] Skipping expansion of <WhitespaceSegment: ([L: 12, P:  7]) ' '>...
INFO       
###
#
# Parse Depth 6. Expanding: JoinOnConditionSegment: 'ON (tbl.id = c.id)'
#
###
DEBUG      JoinOnConditionSegment.parse: no grammar. Going straight to expansion
DEBUG      JoinOnConditionSegment.parse: Done Parse. Plotting Recursion. Recurse=True
DEBUG      ###
#
# Beginning Parse Depth 7: JoinOnConditionSegment
#
###
Initial Structure:
[L: 12, P:  8]      |join_on_condition:
[L: 12, P:  8]      |    keyword:                                                  'ON'
[L: 12, P: 10]      |    [META] indent:
[L: 12, P: 10]      |    whitespace:                                               ' '
[L: 12, P: 11]      |    bracketed:
[L: 12, P: 11]      |        start_bracket:                                        '('
[L: 12, P: 12]      |        [META] indent:
[L: 12, P: 12]      |        ephemeral:
[L: 12, P: 12]      |            expression:
[L: 12, P: 12]      |                column_reference:
[L: 12, P: 12]      |                    identifier:                               'tbl'
[L: 12, P: 15]      |                    dot:                                      '.'
[L: 12, P: 16]      |                    identifier:                               'id'
[L: 12, P: 18]      |                whitespace:                                   ' '
[L: 12, P: 19]      |                comparison_operator:                          '='
[L: 12, P: 20]      |                whitespace:                                   ' '
[L: 12, P: 21]      |                column_reference:
[L: 12, P: 21]      |                    identifier:                               'c'
[L: 12, P: 22]      |                    dot:                                      '.'
[L: 12, P: 23]      |                    identifier:                               'id'
[L: 12, P: 25]      |        [META] dedent:
[L: 12, P: 25]      |        end_bracket:                                          ')'
[L: 12, P: 26]      |    [META] dedent:

INFO       [PD:7] Skipping expansion of <KeywordSegment: ([L: 12, P:  8]) 'ON'>...
INFO       [PD:7] Skipping expansion of <Indent: ([L: 12, P: 10]) ''>...
INFO       [PD:7] Skipping expansion of <WhitespaceSegment: ([L: 12, P: 10]) ' '>...
INFO       
###
#
# Parse Depth 7. Expanding: BracketedSegment: '(tbl.id = c.id)'
#
###
DEBUG      BracketedSegment.parse: no grammar. Going straight to expansion
DEBUG      BracketedSegment.parse: Done Parse. Plotting Recursion. Recurse=True
DEBUG      ###
#
# Beginning Parse Depth 8: BracketedSegment
#
###
Initial Structure:
[L: 12, P: 11]      |bracketed:
[L: 12, P: 11]      |    start_bracket:                                            '('
[L: 12, P: 12]      |    [META] indent:
[L: 12, P: 12]      |    ephemeral:
[L: 12, P: 12]      |        expression:
[L: 12, P: 12]      |            column_reference:
[L: 12, P: 12]      |                identifier:                                   'tbl'
[L: 12, P: 15]      |                dot:                                          '.'
[L: 12, P: 16]      |                identifier:                                   'id'
[L: 12, P: 18]      |            whitespace:                                       ' '
[L: 12, P: 19]      |            comparison_operator:                              '='
[L: 12, P: 20]      |            whitespace:                                       ' '
[L: 12, P: 21]      |            column_reference:
[L: 12, P: 21]      |                identifier:                                   'c'
[L: 12, P: 22]      |                dot:                                          '.'
[L: 12, P: 23]      |                identifier:                                   'id'
[L: 12, P: 25]      |    [META] dedent:
[L: 12, P: 25]      |    end_bracket:                                              ')'

INFO       [PD:8] Skipping expansion of <SymbolSegment: ([L: 12, P: 11]) '('>...
INFO       [PD:8] Skipping expansion of <Indent: ([L: 12, P: 12]) ''>...
INFO       
###
#
# Parse Depth 8. Expanding: EphemeralSegment: 'tbl.id = c.id'
#
###
INFO       [PD:8  MD:0 ]	EphemeralSegment                                  	OneOf.match PRN     	    	[ns=2, ps=1, ms=0, pruned=[<Ref: SelectableGrammar>], opts=[<Ref: ExpressionSegment>, <Delimited: [<Ref: ColumnReferenceSegment>, <Ref: FunctionSegment>, <Ref: LiteralGrammar>]>]]
INFO       [PD:8  MD:1 ]	.ExpressionSegment                                	Expre._match SELF   	    
DEBUG      [PD:8  MD:1 ]	.ExpressionSegment                                	Expre.match OUT     	++  	[match=<MatchResult 1/1: 'tbl.id = c.id'>, seg="'tbl.id = c.id'"]
DEBUG      [PD:8  MD:1 ]	.EphemeralSegment                                 	Ref.match OUT       	++  	[match=<MatchResult 1/1: 'tbl.id = c.id'>, seg="'tbl.id = c.id'"]
INFO       [PD:8  MD:0 ]	EphemeralSegment                                  	OneOf.match OUT     	++  	[match=<MatchResult 1/1: 'tbl.id = c.id'>, seg="'tbl.id = c.id'"]
DEBUG      EphemeralSegment.parse: Done Parse. Plotting Recursion. Recurse=True
DEBUG      ###
#
# Beginning Parse Depth 9: EphemeralSegment
#
###
Initial Structure:
[L: 12, P: 12]      |ephemeral:
[L: 12, P: 12]      |    expression:
[L: 12, P: 12]      |        column_reference:
[L: 12, P: 12]      |            identifier:                                       'tbl'
[L: 12, P: 15]      |            dot:                                              '.'
[L: 12, P: 16]      |            identifier:                                       'id'
[L: 12, P: 18]      |        whitespace:                                           ' '
[L: 12, P: 19]      |        comparison_operator:                                  '='
[L: 12, P: 20]      |        whitespace:                                           ' '
[L: 12, P: 21]      |        column_reference:
[L: 12, P: 21]      |            identifier:                                       'c'
[L: 12, P: 22]      |            dot:                                              '.'
[L: 12, P: 23]      |            identifier:                                       'id'

INFO       [PD:9] Skipping expansion of <ExpressionSegment: ([L: 12, P: 12])>...
INFO       [PD:8] Skipping expansion of <Dedent: ([L: 12, P: 25]) ''>...
INFO       [PD:8] Skipping expansion of <SymbolSegment: ([L: 12, P: 25]) ')'>...
INFO       [PD:7] Skipping expansion of <Dedent: ([L: 12, P: 26]) ''>...
INFO       [PD:6] Skipping expansion of <Dedent: ([L: 12, P: 26]) ''>...
INFO       [PD:5] Skipping expansion of <NewlineSegment: ([L: 12, P: 26]) '\n'>...
INFO       [PD:5] Skipping expansion of <JoinClauseSegment: ([L: 13, P:  1])>...
INFO       [PD:3] Skipping expansion of <NewlineSegment: ([L: 13, P: 37]) '\n'>...
INFO       
###
#
# Parse Depth 3. Expanding: OrderByClauseSegment: 'ORDER BY tbl.name ASC'
#
###
DEBUG      [PD:3  MD:1 ]	.OrderByClauseSegment                             	Ref.match OUT       	+   	[match=<MatchResult 1/9: 'ORDER'>, seg="'ORDER BY tbl.name AS...'"]
DEBUG      [PD:3  MD:1 ]	.OrderByClauseSegment                             	Ref.match OUT       	+   	[match=<MatchResult 1/7: 'BY'>, seg="'BY tbl.name ASC'"]
DEBUG      [PD:3  MD:2 ]	..OrderByClauseSegment                            	Delim._look_ahead_match IN	    	[ls=5, seg='tbl.name ASC']
DEBUG      [PD:3  MD:2 ]	..OrderByClauseSegment                            	Delim._look_ahead_match SI	    	[mq=[], sb=['TBL', '.', 'NAME', '', 'ASC']]
DEBUG      [PD:3  MD:2 ]	..OrderByClauseSegment                            	Delim._look_ahead_match SC	    	[bsm=None]
INFO       [PD:3  MD:3 ]	...OrderByClauseSegment                           	OneOf.match PRN     	    	[ns=3, ps=0, ms=0, pruned=[], opts=[<Ref: ColumnReferenceSegment>, <Ref: NumericLiteralSegment>, <Ref: ExpressionSegment>]]
DEBUG      [PD:3  MD:6 ]	......ColumnReferenceSegment                      	Delim._look_ahead_match IN	    	[ls=5, seg='tbl.name ASC']
DEBUG      [PD:3  MD:6 ]	......ColumnReferenceSegment                      	Delim._look_ahead_match SI	    	[mq=[(<OneOf: [<Ref: DotSegment>, <Sequence: [<Ref: DotSegment>, <Ref: Dot...]>, 1, '.'), (<OneOf: [<Ref: DotSegment>, <Sequence: [<Ref: DotSegment>, <Ref: Dot...]>, 1, '.')], sb=['TBL', '.', 'NAME', '', 'ASC']]
INFO       [PD:3  MD:6 ]	......ColumnReferenceSegment                      	OneOf.match PRN     	    	[ns=0, ps=0, ms=2, pruned=[], opts=[<Ref: DotSegment>, <Sequence: [<Ref: DotSegment>, <Ref: DotSegment>]>]]
DEBUG      [PD:3  MD:7 ]	.......ColumnReferenceSegment                     	Ref.match OUT       	+   	[match=<MatchResult 1/4: '.'>, seg="'.name ASC'"]
DEBUG      [PD:3  MD:8 ]	........ColumnReferenceSegment                    	Ref.match OUT       	+   	[match=<MatchResult 1/4: '.'>, seg="'.name ASC'"]
DEBUG      [PD:3  MD:8 ]	........ColumnReferenceSegment                    	Ref.match OUT       	    	[match=<MatchResult 0/3: ''>, seg="'name ASC'"]
INFO       [PD:3  MD:7 ]	.......ColumnReferenceSegment                     	Seque.match OUT     	    	[match=<MatchResult 0/4: ''>, seg="'.name ASC'"]
INFO       [PD:3  MD:6 ]	......ColumnReferenceSegment                      	OneOf.match OUT     	+   	[match=<MatchResult 1/4: '.'>, seg="'.name ASC'"]
INFO       [PD:3  MD:6 ]	......ColumnReferenceSegment                      	OneOf.match PRN     	    	[ns=0, ps=0, ms=2, pruned=[], opts=[<Ref: DotSegment>, <Sequence: [<Ref: DotSegment>, <Ref: DotSegment>]>]]
DEBUG      [PD:3  MD:7 ]	.......ColumnReferenceSegment                     	Ref.match OUT       	+   	[match=<MatchResult 1/4: '.'>, seg="'.name ASC'"]
DEBUG      [PD:3  MD:8 ]	........ColumnReferenceSegment                    	Ref.match OUT       	+   	[match=<MatchResult 1/4: '.'>, seg="'.name ASC'"]
DEBUG      [PD:3  MD:8 ]	........ColumnReferenceSegment                    	Ref.match OUT       	    	[match=<MatchResult 0/3: ''>, seg="'name ASC'"]
INFO       [PD:3  MD:7 ]	.......ColumnReferenceSegment                     	Seque.match OUT     	    	[match=<MatchResult 0/4: ''>, seg="'.name ASC'"]
INFO       [PD:3  MD:6 ]	......ColumnReferenceSegment                      	OneOf.match OUT     	+   	[match=<MatchResult 1/4: '.'>, seg="'.name ASC'"]
INFO       [PD:3  MD:6 ]	......ColumnReferenceSegment                      	OneOf.match PRN     	    	[ns=1, ps=10, ms=0, pruned=[<Ref: OnKeywordSegment>, <Ref: AsKeywordSegment>, <Ref: UsingKeywordSegment>, <Ref: CommaSegment>, <Ref: CastOperatorSegment>, <Ref: StartSquareBracketSegment>, <Ref: StartBracketSegment>, <Ref: ColonSegment>, <Ref: DelimiterSegment>, <class 'sqlfluff.core.parser.segments.base.BracketedSegment'>], opts=[<Ref: BinaryOperatorGrammar>]]
INFO       [PD:3  MD:7 ]	.......BinaryOperatorGrammar                      	OneOf.match PRN     	    	[ns=1, ps=3, ms=0, pruned=[<Ref: ArithmeticBinaryOperatorGrammar>, <Ref: StringBinaryOperatorGrammar>, <Ref: BooleanBinaryOperatorGrammar>], opts=[<Ref: ComparisonOperatorGrammar>]]
INFO       [PD:3  MD:8 ]	........ComparisonOperatorGrammar                 	OneOf.match PRN     	    	[ns=1, ps=7, ms=0, pruned=[<Ref: EqualsSegment>, <Ref: GreaterThanSegment>, <Ref: LessThanSegment>, <Ref: GreaterThanOrEqualToSegment>, <Ref: LessThanOrEqualToSegment>, <Ref: NotEqualToSegment_a>, <Ref: NotEqualToSegment_b>], opts=[<Ref: LikeOperatorSegment>]]
DEBUG      [PD:3  MD:9 ]	.........ComparisonOperatorGrammar                	Ref.match OUT       	    	[match=<MatchResult 0/5: ''>, seg="'tbl.name ASC'"]
INFO       [PD:3  MD:8 ]	........ComparisonOperatorGrammar                 	OneOf.match OUT     	    	[match=<MatchResult 0/5: ''>, seg="'tbl.name ASC'"]
DEBUG      [PD:3  MD:8 ]	........BinaryOperatorGrammar                     	Ref.match OUT       	    	[match=<MatchResult 0/5: ''>, seg="'tbl.name ASC'"]
INFO       [PD:3  MD:7 ]	.......BinaryOperatorGrammar                      	OneOf.match OUT     	    	[match=<MatchResult 0/5: ''>, seg="'tbl.name ASC'"]
DEBUG      [PD:3  MD:7 ]	.......ColumnReferenceSegment                     	Ref.match OUT       	    	[match=<MatchResult 0/5: ''>, seg="'tbl.name ASC'"]
INFO       [PD:3  MD:6 ]	......ColumnReferenceSegment                      	OneOf.match OUT     	    	[match=<MatchResult 0/5: ''>, seg="'tbl.name ASC'"]
DEBUG      [PD:3  MD:6 ]	......ColumnReferenceSegment                      	NonCo.match OUT     	    	[match=<MatchResult 0/5: ''>, seg="'tbl.name ASC'"]
INFO       [PD:3  MD:6 ]	......ColumnReferenceSegment                      	OneOf.match PRN     	    	[ns=1, ps=10, ms=0, pruned=[<Ref: OnKeywordSegment>, <Ref: AsKeywordSegment>, <Ref: UsingKeywordSegment>, <Ref: CommaSegment>, <Ref: CastOperatorSegment>, <Ref: StartSquareBracketSegment>, <Ref: StartBracketSegment>, <Ref: ColonSegment>, <Ref: DelimiterSegment>, <class 'sqlfluff.core.parser.segments.base.BracketedSegment'>], opts=[<Ref: BinaryOperatorGrammar>]]
INFO       [PD:3  MD:7 ]	.......BinaryOperatorGrammar                      	OneOf.match PRN     	    	[ns=1, ps=3, ms=0, pruned=[<Ref: ArithmeticBinaryOperatorGrammar>, <Ref: StringBinaryOperatorGrammar>, <Ref: BooleanBinaryOperatorGrammar>], opts=[<Ref: ComparisonOperatorGrammar>]]
INFO       [PD:3  MD:8 ]	........ComparisonOperatorGrammar                 	OneOf.match PRN     	    	[ns=1, ps=7, ms=0, pruned=[<Ref: EqualsSegment>, <Ref: GreaterThanSegment>, <Ref: LessThanSegment>, <Ref: GreaterThanOrEqualToSegment>, <Ref: LessThanOrEqualToSegment>, <Ref: NotEqualToSegment_a>, <Ref: NotEqualToSegment_b>], opts=[<Ref: LikeOperatorSegment>]]
DEBUG      [PD:3  MD:9 ]	.........ComparisonOperatorGrammar                	Ref.match OUT       	    	[match=<MatchResult 0/4: ''>, seg="'.name ASC'"]
INFO       [PD:3  MD:8 ]	........ComparisonOperatorGrammar                 	OneOf.match OUT     	    	[match=<MatchResult 0/4: ''>, seg="'.name ASC'"]
DEBUG      [PD:3  MD:8 ]	........BinaryOperatorGrammar                     	Ref.match OUT       	    	[match=<MatchResult 0/4: ''>, seg="'.name ASC'"]
INFO       [PD:3  MD:7 ]	.......BinaryOperatorGrammar                      	OneOf.match OUT     	    	[match=<MatchResult 0/4: ''>, seg="'.name ASC'"]
DEBUG      [PD:3  MD:7 ]	.......ColumnReferenceSegment                     	Ref.match OUT       	    	[match=<MatchResult 0/4: ''>, seg="'.name ASC'"]
INFO       [PD:3  MD:6 ]	......ColumnReferenceSegment                      	OneOf.match OUT     	    	[match=<MatchResult 0/4: ''>, seg="'.name ASC'"]
DEBUG      [PD:3  MD:6 ]	......ColumnReferenceSegment                      	NonCo.match OUT     	    	[match=<MatchResult 0/4: ''>, seg="'.name ASC'"]
INFO       [PD:3  MD:6 ]	......SingleIdentifierGrammar                     	OneOf.match PRN     	    	[ns=2, ps=0, ms=0, pruned=[], opts=[<Ref: NakedIdentifierSegment>, <Ref: QuotedIdentifierSegment>]]
DEBUG      [PD:3  MD:7 ]	.......SingleIdentifierGrammar                    	Ref.match OUT       	++  	[match=<MatchResult 1/1: 'tbl'>, seg="'tbl'"]
INFO       [PD:3  MD:6 ]	......SingleIdentifierGrammar                     	OneOf.match OUT     	++  	[match=<MatchResult 1/1: 'tbl'>, seg="'tbl'"]
DEBUG      [PD:3  MD:6 ]	......ColumnReferenceSegment                      	Ref.match OUT       	++  	[match=<MatchResult 1/1: 'tbl'>, seg="'tbl'"]
DEBUG      [PD:3  MD:6 ]	......ColumnReferenceSegment                      	Delim._look_ahead_match IN	    	[ls=3, seg='name ASC']
DEBUG      [PD:3  MD:6 ]	......ColumnReferenceSegment                      	Delim._look_ahead_match SI	    	[mq=[], sb=['NAME', '', 'ASC']]
INFO       [PD:3  MD:6 ]	......ColumnReferenceSegment                      	OneOf.match PRN     	    	[ns=1, ps=10, ms=0, pruned=[<Ref: OnKeywordSegment>, <Ref: AsKeywordSegment>, <Ref: UsingKeywordSegment>, <Ref: CommaSegment>, <Ref: CastOperatorSegment>, <Ref: StartSquareBracketSegment>, <Ref: StartBracketSegment>, <Ref: ColonSegment>, <Ref: DelimiterSegment>, <class 'sqlfluff.core.parser.segments.base.BracketedSegment'>], opts=[<Ref: BinaryOperatorGrammar>]]
INFO       [PD:3  MD:7 ]	.......BinaryOperatorGrammar                      	OneOf.match PRN     	    	[ns=1, ps=3, ms=0, pruned=[<Ref: ArithmeticBinaryOperatorGrammar>, <Ref: StringBinaryOperatorGrammar>, <Ref: BooleanBinaryOperatorGrammar>], opts=[<Ref: ComparisonOperatorGrammar>]]
INFO       [PD:3  MD:8 ]	........ComparisonOperatorGrammar                 	OneOf.match PRN     	    	[ns=1, ps=7, ms=0, pruned=[<Ref: EqualsSegment>, <Ref: GreaterThanSegment>, <Ref: LessThanSegment>, <Ref: GreaterThanOrEqualToSegment>, <Ref: LessThanOrEqualToSegment>, <Ref: NotEqualToSegment_a>, <Ref: NotEqualToSegment_b>], opts=[<Ref: LikeOperatorSegment>]]
DEBUG      [PD:3  MD:9 ]	.........ComparisonOperatorGrammar                	Ref.match OUT       	    	[match=<MatchResult 0/3: ''>, seg="'name ASC'"]
INFO       [PD:3  MD:8 ]	........ComparisonOperatorGrammar                 	OneOf.match OUT     	    	[match=<MatchResult 0/3: ''>, seg="'name ASC'"]
DEBUG      [PD:3  MD:8 ]	........BinaryOperatorGrammar                     	Ref.match OUT       	    	[match=<MatchResult 0/3: ''>, seg="'name ASC'"]
INFO       [PD:3  MD:7 ]	.......BinaryOperatorGrammar                      	OneOf.match OUT     	    	[match=<MatchResult 0/3: ''>, seg="'name ASC'"]
DEBUG      [PD:3  MD:7 ]	.......ColumnReferenceSegment                     	Ref.match OUT       	    	[match=<MatchResult 0/3: ''>, seg="'name ASC'"]
INFO       [PD:3  MD:6 ]	......ColumnReferenceSegment                      	OneOf.match OUT     	    	[match=<MatchResult 0/3: ''>, seg="'name ASC'"]
DEBUG      [PD:3  MD:6 ]	......ColumnReferenceSegment                      	NonCo.match OUT     	    	[match=<MatchResult 0/3: ''>, seg="'name ASC'"]
INFO       [PD:3  MD:6 ]	......ColumnReferenceSegment                      	OneOf.match PRN     	    	[ns=1, ps=10, ms=0, pruned=[<Ref: OnKeywordSegment>, <Ref: AsKeywordSegment>, <Ref: UsingKeywordSegment>, <Ref: CommaSegment>, <Ref: CastOperatorSegment>, <Ref: StartSquareBracketSegment>, <Ref: StartBracketSegment>, <Ref: ColonSegment>, <Ref: DelimiterSegment>, <class 'sqlfluff.core.parser.segments.base.BracketedSegment'>], opts=[<Ref: BinaryOperatorGrammar>]]
INFO       [PD:3  MD:7 ]	.......BinaryOperatorGrammar                      	OneOf.match PRN     	    	[ns=1, ps=3, ms=0, pruned=[<Ref: ArithmeticBinaryOperatorGrammar>, <Ref: StringBinaryOperatorGrammar>, <Ref: BooleanBinaryOperatorGrammar>], opts=[<Ref: ComparisonOperatorGrammar>]]
INFO       [PD:3  MD:8 ]	........ComparisonOperatorGrammar                 	OneOf.match PRN     	    	[ns=1, ps=7, ms=0, pruned=[<Ref: EqualsSegment>, <Ref: GreaterThanSegment>, <Ref: LessThanSegment>, <Ref: GreaterThanOrEqualToSegment>, <Ref: LessThanOrEqualToSegment>, <Ref: NotEqualToSegment_a>, <Ref: NotEqualToSegment_b>], opts=[<Ref: LikeOperatorSegment>]]
DEBUG      [PD:3  MD:9 ]	.........ComparisonOperatorGrammar                	Ref.match OUT       	    	[match=<MatchResult 0/2: ''>, seg="' ASC'"]
INFO       [PD:3  MD:8 ]	........ComparisonOperatorGrammar                 	OneOf.match OUT     	    	[match=<MatchResult 0/2: ''>, seg="' ASC'"]
DEBUG      [PD:3  MD:8 ]	........BinaryOperatorGrammar                     	Ref.match OUT       	    	[match=<MatchResult 0/2: ''>, seg="' ASC'"]
INFO       [PD:3  MD:7 ]	.......BinaryOperatorGrammar                      	OneOf.match OUT     	    	[match=<MatchResult 0/2: ''>, seg="' ASC'"]
DEBUG      [PD:3  MD:7 ]	.......ColumnReferenceSegment                     	Ref.match OUT       	    	[match=<MatchResult 0/2: ''>, seg="' ASC'"]
INFO       [PD:3  MD:6 ]	......ColumnReferenceSegment                      	OneOf.match OUT     	    	[match=<MatchResult 0/2: ''>, seg="' ASC'"]
DEBUG      [PD:3  MD:6 ]	......ColumnReferenceSegment                      	NonCo.match OUT     	+   	[match=<MatchResult 1/2: ' '>, seg="' ASC'"]
INFO       [PD:3  MD:6 ]	......SingleIdentifierGrammar                     	OneOf.match PRN     	    	[ns=2, ps=0, ms=0, pruned=[], opts=[<Ref: NakedIdentifierSegment>, <Ref: QuotedIdentifierSegment>]]
DEBUG      [PD:3  MD:7 ]	.......SingleIdentifierGrammar                    	Ref.match OUT       	++  	[match=<MatchResult 1/1: 'name'>, seg="'name'"]
INFO       [PD:3  MD:6 ]	......SingleIdentifierGrammar                     	OneOf.match OUT     	++  	[match=<MatchResult 1/1: 'name'>, seg="'name'"]
DEBUG      [PD:3  MD:6 ]	......ColumnReferenceSegment                      	Ref.match OUT       	++  	[match=<MatchResult 1/1: 'name'>, seg="'name'"]
INFO       [PD:3  MD:5 ]	.....ColumnReferenceSegment                       	Delim.match OUT     	+   	[match=<MatchResult 3/5: 'tbl.name'>, seg="'tbl.name ASC'"]
DEBUG      [PD:3  MD:4 ]	....ColumnReferenceSegment                        	Colum.match OUT     	+   	[match=<MatchResult 1/3: 'tbl.name'>, seg="'tbl.name ASC'"]
DEBUG      [PD:3  MD:4 ]	....OrderByClauseSegment                          	Ref.match OUT       	+   	[match=<MatchResult 1/3: 'tbl.name'>, seg="'tbl.name ASC'"]
DEBUG      [PD:3  MD:4 ]	....OrderByClauseSegment                          	Ref.match OUT       	    	[match=<MatchResult 0/5: ''>, seg="'tbl.name ASC'"]
INFO       [PD:3  MD:6 ]	......Expression_A_Grammar                        	OneOf.match PRN     	    	[ns=1, ps=1, ms=0, pruned=[<Sequence: [<OneOf: [<Ref: PositiveSegment>, <Ref: N..., <Ref: Expression_C_Grammar>]>], opts=[<Ref: Expression_C_Grammar>]]
INFO       [PD:3  MD:7 ]	.......Expression_C_Grammar                       	OneOf.match PRN     	    	[ns=1, ps=2, ms=0, pruned=[<Sequence: [<Ref: ExistsKeywordSegment>, <Bracketed: [<Ref: SelectStatementSegmen...]>, <Ref: CaseExpressionSegment>], opts=[<Ref: Expression_D_Grammar>]]
INFO       [PD:3  MD:9 ]	.........Expression_D_Grammar                     	OneOf.match PRN     	    	[ns=6, ps=3, ms=0, pruned=[<Bracketed: [<OneOf: [<Ref: ExpressionSegment>, <Ref:...]>, <Ref: SelectStatementSegment>, <Ref: IntervalExpressionSegment>], opts=[<Ref: BareFunctionSegment>, <Ref: FunctionSegment>, <Ref: LiteralGrammar>, <Ref: ColumnReferenceSegment>, <Sequence: [<Ref: SimpleArrayTypeGrammar [opt]>, <Ref: ArrayLiteralSegment>]>, <Sequence: [<Ref: DatatypeSegment>, <OneOf: [<Ref: QuotedLiteralSegment>, <R...]>]]
DEBUG      [PD:3  MD:10]	..........Expression_D_Grammar                    	Ref.match OUT       	    	[match=<MatchResult 0/5: ''>, seg="'tbl.name ASC'"]
INFO       [PD:3  MD:11]	...........FunctionSegment                        	OneOf.match PRN     	    	[ns=1, ps=1, ms=0, pruned=[<Sequence: [<Sequence: [<Ref: DateAddFunctionNameSeg...]>], opts=[<Sequence: [<Sequence: [<AnyNumberOf: [<Ref: Functio..., <Ref: PostFunctionGrammar [opt]>]>]]
DEBUG      [PD:3  MD:17]	.................DateAddFunctionNameSegment       	Ref.match OUT       	    	[match=<MatchResult 0/5: ''>, seg="'tbl.name ASC'"]
INFO       [PD:3  MD:16]	................DateAddFunctionNameSegment        	Seque.match OUT     	    	[match=<MatchResult 0/5: ''>, seg="'tbl.name ASC'"]
DEBUG      [PD:3  MD:15]	...............DateAddFunctionNameSegment         	DateA.match OUT     	    	[match=<MatchResult 0/5: ''>, seg="'tbl.name ASC'"]
DEBUG      [PD:3  MD:15]	...............FunctionSegment                    	Ref.match OUT       	    	[match=<MatchResult 0/5: ''>, seg="'tbl.name ASC'"]
INFO       [PD:3  MD:14]	..............FunctionSegment                     	AnyNu.match PRN     	    	[ns=1, ps=0, ms=0, pruned=[], opts=[<Ref: FunctionNameSegment>]]
INFO       [PD:3  MD:17]	.................FunctionNameSegment              	AnyNu.match PRN     	    	[ns=1, ps=0, ms=0, pruned=[], opts=[<Sequence: [<Ref: SingleIdentifierGrammar>, <Ref: DotSegment>]>]]
INFO       [PD:3  MD:19]	...................SingleIdentifierGrammar        	OneOf.match PRN     	    	[ns=2, ps=0, ms=0, pruned=[], opts=[<Ref: NakedIdentifierSegment>, <Ref: QuotedIdentifierSegment>]]
DEBUG      [PD:3  MD:20]	....................SingleIdentifierGrammar       	Ref.match OUT       	+   	[match=<MatchResult 1/5: 'tbl'>, seg="'tbl.name ASC'"]
DEBUG      [PD:3  MD:20]	....................SingleIdentifierGrammar       	Ref.match OUT       	    	[match=<MatchResult 0/5: ''>, seg="'tbl.name ASC'"]
INFO       [PD:3  MD:19]	...................SingleIdentifierGrammar        	OneOf.match OUT     	+   	[match=<MatchResult 1/5: 'tbl'>, seg="'tbl.name ASC'"]
DEBUG      [PD:3  MD:19]	...................FunctionNameSegment            	Ref.match OUT       	+   	[match=<MatchResult 1/5: 'tbl'>, seg="'tbl.name ASC'"]
DEBUG      [PD:3  MD:19]	...................FunctionNameSegment            	Ref.match OUT       	+   	[match=<MatchResult 1/4: '.'>, seg="'.name ASC'"]
INFO       [PD:3  MD:18]	..................FunctionNameSegment             	Seque.match OUT     	+   	[match=<MatchResult 2/5: 'tbl.'>, seg="'tbl.name ASC'"]
INFO       [PD:3  MD:17]	.................FunctionNameSegment              	AnyNu.match PRN     	    	[ns=1, ps=0, ms=0, pruned=[], opts=[<Sequence: [<Ref: SingleIdentifierGrammar>, <Ref: DotSegment>]>]]
INFO       [PD:3  MD:19]	...................SingleIdentifierGrammar        	OneOf.match PRN     	    	[ns=2, ps=0, ms=0, pruned=[], opts=[<Ref: NakedIdentifierSegment>, <Ref: QuotedIdentifierSegment>]]
DEBUG      [PD:3  MD:20]	....................SingleIdentifierGrammar       	Ref.match OUT       	+   	[match=<MatchResult 1/3: 'name'>, seg="'name ASC'"]
DEBUG      [PD:3  MD:20]	....................SingleIdentifierGrammar       	Ref.match OUT       	    	[match=<MatchResult 0/3: ''>, seg="'name ASC'"]
INFO       [PD:3  MD:19]	...................SingleIdentifierGrammar        	OneOf.match OUT     	+   	[match=<MatchResult 1/3: 'name'>, seg="'name ASC'"]
DEBUG      [PD:3  MD:19]	...................FunctionNameSegment            	Ref.match OUT       	+   	[match=<MatchResult 1/3: 'name'>, seg="'name ASC'"]
DEBUG      [PD:3  MD:19]	...................FunctionNameSegment            	Ref.match OUT       	    	[match=<MatchResult 0/1: ''>, seg="'ASC'"]
INFO       [PD:3  MD:18]	..................FunctionNameSegment             	Seque.match OUT     	    	[match=<MatchResult 0/3: ''>, seg="'name ASC'"]
INFO       [PD:3  MD:17]	.................FunctionNameSegment              	AnyNu.match OUT     	+   	[match=<MatchResult 2/5: 'tbl.'>, seg="'tbl.name ASC'"]
INFO       [PD:3  MD:17]	.................FunctionNameSegment              	OneOf.match PRN     	    	[ns=2, ps=0, ms=0, pruned=[], opts=[<Ref: FunctionNameIdentifierSegment>, <Ref: QuotedIdentifierSegment>]]
DEBUG      [PD:3  MD:18]	..................FunctionNameSegment             	Ref.match OUT       	+   	[match=<MatchResult 1/3: 'name'>, seg="'name ASC'"]
DEBUG      [PD:3  MD:18]	..................FunctionNameSegment             	Ref.match OUT       	    	[match=<MatchResult 0/3: ''>, seg="'name ASC'"]
INFO       [PD:3  MD:17]	.................FunctionNameSegment              	OneOf.match OUT     	+   	[match=<MatchResult 1/3: 'name'>, seg="'name ASC'"]
INFO       [PD:3  MD:16]	................FunctionNameSegment               	Seque.match OUT     	+   	[match=<MatchResult 3/5: 'tbl.name'>, seg="'tbl.name ASC'"]
DEBUG      [PD:3  MD:15]	...............FunctionNameSegment                	Funct.match OUT     	+   	[match=<MatchResult 1/3: 'tbl.name'>, seg="'tbl.name ASC'"]
DEBUG      [PD:3  MD:15]	...............FunctionSegment                    	Ref.match OUT       	+   	[match=<MatchResult 1/3: 'tbl.name'>, seg="'tbl.name ASC'"]
INFO       [PD:3  MD:14]	..............FunctionSegment                     	AnyNu.match OUT     	+   	[match=<MatchResult 1/3: 'tbl.name'>, seg="'tbl.name ASC'"]
INFO       [PD:3  MD:14]	..............FunctionSegment                     	Brack.match OUT     	    	[match=<MatchResult 0/1: ''>, seg="'ASC'"]
INFO       [PD:3  MD:13]	.............FunctionSegment                      	Seque.match OUT     	    	[match=<MatchResult 0/5: ''>, seg="'tbl.name ASC'"]
INFO       [PD:3  MD:12]	............FunctionSegment                       	Seque.match OUT     	    	[match=<MatchResult 0/5: ''>, seg="'tbl.name ASC'"]
INFO       [PD:3  MD:11]	...........FunctionSegment                        	OneOf.match OUT     	    	[match=<MatchResult 0/5: ''>, seg="'tbl.name ASC'"]
DEBUG      [PD:3  MD:10]	..........FunctionSegment                         	Funct.match OUT     	    	[match=<MatchResult 0/5: ''>, seg="'tbl.name ASC'"]
DEBUG      [PD:3  MD:10]	..........Expression_D_Grammar                    	Ref.match OUT       	    	[match=<MatchResult 0/5: ''>, seg="'tbl.name ASC'"]
INFO       [PD:3  MD:10]	..........LiteralGrammar                          	OneOf.match PRN     	    	[ns=2, ps=4, ms=0, pruned=[<Ref: BooleanLiteralGrammar>, <Ref: QualifiedNumericLiteralSegment>, <Ref: NullLiteralSegment>, <Ref: DateTimeLiteralGrammar>], opts=[<Ref: QuotedLiteralSegment>, <Ref: NumericLiteralSegment>]]
DEBUG      [PD:3  MD:11]	...........LiteralGrammar                         	Ref.match OUT       	    	[match=<MatchResult 0/5: ''>, seg="'tbl.name ASC'"]
DEBUG      [PD:3  MD:11]	...........LiteralGrammar                         	Ref.match OUT       	    	[match=<MatchResult 0/5: ''>, seg="'tbl.name ASC'"]
INFO       [PD:3  MD:10]	..........LiteralGrammar                          	OneOf.match OUT     	    	[match=<MatchResult 0/5: ''>, seg="'tbl.name ASC'"]
DEBUG      [PD:3  MD:10]	..........Expression_D_Grammar                    	Ref.match OUT       	    	[match=<MatchResult 0/5: ''>, seg="'tbl.name ASC'"]
DEBUG      [PD:3  MD:12]	............ColumnReferenceSegment                	Delim._look_ahead_match IN	    	[ls=5, seg='tbl.name ASC']
DEBUG      [PD:3  MD:12]	............ColumnReferenceSegment                	Delim._look_ahead_match SI	    	[mq=[(<OneOf: [<Ref: DotSegment>, <Sequence: [<Ref: DotSegment>, <Ref: Dot...]>, 1, '.'), (<OneOf: [<Ref: DotSegment>, <Sequence: [<Ref: DotSegment>, <Ref: Dot...]>, 1, '.')], sb=['TBL', '.', 'NAME', '', 'ASC']]
INFO       [PD:3  MD:12]	............ColumnReferenceSegment                	OneOf.match PRN     	    	[ns=0, ps=0, ms=2, pruned=[], opts=[<Ref: DotSegment>, <Sequence: [<Ref: DotSegment>, <Ref: DotSegment>]>]]
DEBUG      [PD:3  MD:13]	.............ColumnReferenceSegment               	Ref.match OUT       	+   	[match=<MatchResult 1/4: '.'>, seg="'.name ASC'"]
DEBUG      [PD:3  MD:14]	..............ColumnReferenceSegment              	Ref.match OUT       	+   	[match=<MatchResult 1/4: '.'>, seg="'.name ASC'"]
DEBUG      [PD:3  MD:14]	..............ColumnReferenceSegment              	Ref.match OUT       	    	[match=<MatchResult 0/3: ''>, seg="'name ASC'"]
INFO       [PD:3  MD:13]	.............ColumnReferenceSegment               	Seque.match OUT     	    	[match=<MatchResult 0/4: ''>, seg="'.name ASC'"]
INFO       [PD:3  MD:12]	............ColumnReferenceSegment                	OneOf.match OUT     	+   	[match=<MatchResult 1/4: '.'>, seg="'.name ASC'"]
INFO       [PD:3  MD:12]	............ColumnReferenceSegment                	OneOf.match PRN     	    	[ns=0, ps=0, ms=2, pruned=[], opts=[<Ref: DotSegment>, <Sequence: [<Ref: DotSegment>, <Ref: DotSegment>]>]]
DEBUG      [PD:3  MD:13]	.............ColumnReferenceSegment               	Ref.match OUT       	+   	[match=<MatchResult 1/4: '.'>, seg="'.name ASC'"]
DEBUG      [PD:3  MD:14]	..............ColumnReferenceSegment              	Ref.match OUT       	+   	[match=<MatchResult 1/4: '.'>, seg="'.name ASC'"]
DEBUG      [PD:3  MD:14]	..............ColumnReferenceSegment              	Ref.match OUT       	    	[match=<MatchResult 0/3: ''>, seg="'name ASC'"]
INFO       [PD:3  MD:13]	.............ColumnReferenceSegment               	Seque.match OUT     	    	[match=<MatchResult 0/4: ''>, seg="'.name ASC'"]
INFO       [PD:3  MD:12]	............ColumnReferenceSegment                	OneOf.match OUT     	+   	[match=<MatchResult 1/4: '.'>, seg="'.name ASC'"]
INFO       [PD:3  MD:12]	............ColumnReferenceSegment                	OneOf.match PRN     	    	[ns=1, ps=10, ms=0, pruned=[<Ref: OnKeywordSegment>, <Ref: AsKeywordSegment>, <Ref: UsingKeywordSegment>, <Ref: CommaSegment>, <Ref: CastOperatorSegment>, <Ref: StartSquareBracketSegment>, <Ref: StartBracketSegment>, <Ref: ColonSegment>, <Ref: DelimiterSegment>, <class 'sqlfluff.core.parser.segments.base.BracketedSegment'>], opts=[<Ref: BinaryOperatorGrammar>]]
INFO       [PD:3  MD:13]	.............BinaryOperatorGrammar                	OneOf.match PRN     	    	[ns=1, ps=3, ms=0, pruned=[<Ref: ArithmeticBinaryOperatorGrammar>, <Ref: StringBinaryOperatorGrammar>, <Ref: BooleanBinaryOperatorGrammar>], opts=[<Ref: ComparisonOperatorGrammar>]]
INFO       [PD:3  MD:14]	..............ComparisonOperatorGrammar           	OneOf.match PRN     	    	[ns=1, ps=7, ms=0, pruned=[<Ref: EqualsSegment>, <Ref: GreaterThanSegment>, <Ref: LessThanSegment>, <Ref: GreaterThanOrEqualToSegment>, <Ref: LessThanOrEqualToSegment>, <Ref: NotEqualToSegment_a>, <Ref: NotEqualToSegment_b>], opts=[<Ref: LikeOperatorSegment>]]
DEBUG      [PD:3  MD:15]	...............ComparisonOperatorGrammar          	Ref.match OUT       	    	[match=<MatchResult 0/5: ''>, seg="'tbl.name ASC'"]
INFO       [PD:3  MD:14]	..............ComparisonOperatorGrammar           	OneOf.match OUT     	    	[match=<MatchResult 0/5: ''>, seg="'tbl.name ASC'"]
DEBUG      [PD:3  MD:14]	..............BinaryOperatorGrammar               	Ref.match OUT       	    	[match=<MatchResult 0/5: ''>, seg="'tbl.name ASC'"]
INFO       [PD:3  MD:13]	.............BinaryOperatorGrammar                	OneOf.match OUT     	    	[match=<MatchResult 0/5: ''>, seg="'tbl.name ASC'"]
DEBUG      [PD:3  MD:13]	.............ColumnReferenceSegment               	Ref.match OUT       	    	[match=<MatchResult 0/5: ''>, seg="'tbl.name ASC'"]
INFO       [PD:3  MD:12]	............ColumnReferenceSegment                	OneOf.match OUT     	    	[match=<MatchResult 0/5: ''>, seg="'tbl.name ASC'"]
DEBUG      [PD:3  MD:12]	............ColumnReferenceSegment                	NonCo.match OUT     	    	[match=<MatchResult 0/5: ''>, seg="'tbl.name ASC'"]
INFO       [PD:3  MD:12]	............ColumnReferenceSegment                	OneOf.match PRN     	    	[ns=1, ps=10, ms=0, pruned=[<Ref: OnKeywordSegment>, <Ref: AsKeywordSegment>, <Ref: UsingKeywordSegment>, <Ref: CommaSegment>, <Ref: CastOperatorSegment>, <Ref: StartSquareBracketSegment>, <Ref: StartBracketSegment>, <Ref: ColonSegment>, <Ref: DelimiterSegment>, <class 'sqlfluff.core.parser.segments.base.BracketedSegment'>], opts=[<Ref: BinaryOperatorGrammar>]]
INFO       [PD:3  MD:13]	.............BinaryOperatorGrammar                	OneOf.match PRN     	    	[ns=1, ps=3, ms=0, pruned=[<Ref: ArithmeticBinaryOperatorGrammar>, <Ref: StringBinaryOperatorGrammar>, <Ref: BooleanBinaryOperatorGrammar>], opts=[<Ref: ComparisonOperatorGrammar>]]
INFO       [PD:3  MD:14]	..............ComparisonOperatorGrammar           	OneOf.match PRN     	    	[ns=1, ps=7, ms=0, pruned=[<Ref: EqualsSegment>, <Ref: GreaterThanSegment>, <Ref: LessThanSegment>, <Ref: GreaterThanOrEqualToSegment>, <Ref: LessThanOrEqualToSegment>, <Ref: NotEqualToSegment_a>, <Ref: NotEqualToSegment_b>], opts=[<Ref: LikeOperatorSegment>]]
DEBUG      [PD:3  MD:15]	...............ComparisonOperatorGrammar          	Ref.match OUT       	    	[match=<MatchResult 0/4: ''>, seg="'.name ASC'"]
INFO       [PD:3  MD:14]	..............ComparisonOperatorGrammar           	OneOf.match OUT     	    	[match=<MatchResult 0/4: ''>, seg="'.name ASC'"]
DEBUG      [PD:3  MD:14]	..............BinaryOperatorGrammar               	Ref.match OUT       	    	[match=<MatchResult 0/4: ''>, seg="'.name ASC'"]
INFO       [PD:3  MD:13]	.............BinaryOperatorGrammar                	OneOf.match OUT     	    	[match=<MatchResult 0/4: ''>, seg="'.name ASC'"]
DEBUG      [PD:3  MD:13]	.............ColumnReferenceSegment               	Ref.match OUT       	    	[match=<MatchResult 0/4: ''>, seg="'.name ASC'"]
INFO       [PD:3  MD:12]	............ColumnReferenceSegment                	OneOf.match OUT     	    	[match=<MatchResult 0/4: ''>, seg="'.name ASC'"]
DEBUG      [PD:3  MD:12]	............ColumnReferenceSegment                	NonCo.match OUT     	    	[match=<MatchResult 0/4: ''>, seg="'.name ASC'"]
INFO       [PD:3  MD:12]	............SingleIdentifierGrammar               	OneOf.match PRN     	    	[ns=2, ps=0, ms=0, pruned=[], opts=[<Ref: NakedIdentifierSegment>, <Ref: QuotedIdentifierSegment>]]
DEBUG      [PD:3  MD:13]	.............SingleIdentifierGrammar              	Ref.match OUT       	++  	[match=<MatchResult 1/1: 'tbl'>, seg="'tbl'"]
INFO       [PD:3  MD:12]	............SingleIdentifierGrammar               	OneOf.match OUT     	++  	[match=<MatchResult 1/1: 'tbl'>, seg="'tbl'"]
DEBUG      [PD:3  MD:12]	............ColumnReferenceSegment                	Ref.match OUT       	++  	[match=<MatchResult 1/1: 'tbl'>, seg="'tbl'"]
DEBUG      [PD:3  MD:12]	............ColumnReferenceSegment                	Delim._look_ahead_match IN	    	[ls=3, seg='name ASC']
DEBUG      [PD:3  MD:12]	............ColumnReferenceSegment                	Delim._look_ahead_match SI	    	[mq=[], sb=['NAME', '', 'ASC']]
INFO       [PD:3  MD:12]	............ColumnReferenceSegment                	OneOf.match PRN     	    	[ns=1, ps=10, ms=0, pruned=[<Ref: OnKeywordSegment>, <Ref: AsKeywordSegment>, <Ref: UsingKeywordSegment>, <Ref: CommaSegment>, <Ref: CastOperatorSegment>, <Ref: StartSquareBracketSegment>, <Ref: StartBracketSegment>, <Ref: ColonSegment>, <Ref: DelimiterSegment>, <class 'sqlfluff.core.parser.segments.base.BracketedSegment'>], opts=[<Ref: BinaryOperatorGrammar>]]
INFO       [PD:3  MD:13]	.............BinaryOperatorGrammar                	OneOf.match PRN     	    	[ns=1, ps=3, ms=0, pruned=[<Ref: ArithmeticBinaryOperatorGrammar>, <Ref: StringBinaryOperatorGrammar>, <Ref: BooleanBinaryOperatorGrammar>], opts=[<Ref: ComparisonOperatorGrammar>]]
INFO       [PD:3  MD:14]	..............ComparisonOperatorGrammar           	OneOf.match PRN     	    	[ns=1, ps=7, ms=0, pruned=[<Ref: EqualsSegment>, <Ref: GreaterThanSegment>, <Ref: LessThanSegment>, <Ref: GreaterThanOrEqualToSegment>, <Ref: LessThanOrEqualToSegment>, <Ref: NotEqualToSegment_a>, <Ref: NotEqualToSegment_b>], opts=[<Ref: LikeOperatorSegment>]]
DEBUG      [PD:3  MD:15]	...............ComparisonOperatorGrammar          	Ref.match OUT       	    	[match=<MatchResult 0/3: ''>, seg="'name ASC'"]
INFO       [PD:3  MD:14]	..............ComparisonOperatorGrammar           	OneOf.match OUT     	    	[match=<MatchResult 0/3: ''>, seg="'name ASC'"]
DEBUG      [PD:3  MD:14]	..............BinaryOperatorGrammar               	Ref.match OUT       	    	[match=<MatchResult 0/3: ''>, seg="'name ASC'"]
INFO       [PD:3  MD:13]	.............BinaryOperatorGrammar                	OneOf.match OUT     	    	[match=<MatchResult 0/3: ''>, seg="'name ASC'"]
DEBUG      [PD:3  MD:13]	.............ColumnReferenceSegment               	Ref.match OUT       	    	[match=<MatchResult 0/3: ''>, seg="'name ASC'"]
INFO       [PD:3  MD:12]	............ColumnReferenceSegment                	OneOf.match OUT     	    	[match=<MatchResult 0/3: ''>, seg="'name ASC'"]
DEBUG      [PD:3  MD:12]	............ColumnReferenceSegment                	NonCo.match OUT     	    	[match=<MatchResult 0/3: ''>, seg="'name ASC'"]
INFO       [PD:3  MD:12]	............ColumnReferenceSegment                	OneOf.match PRN     	    	[ns=1, ps=10, ms=0, pruned=[<Ref: OnKeywordSegment>, <Ref: AsKeywordSegment>, <Ref: UsingKeywordSegment>, <Ref: CommaSegment>, <Ref: CastOperatorSegment>, <Ref: StartSquareBracketSegment>, <Ref: StartBracketSegment>, <Ref: ColonSegment>, <Ref: DelimiterSegment>, <class 'sqlfluff.core.parser.segments.base.BracketedSegment'>], opts=[<Ref: BinaryOperatorGrammar>]]
INFO       [PD:3  MD:13]	.............BinaryOperatorGrammar                	OneOf.match PRN     	    	[ns=1, ps=3, ms=0, pruned=[<Ref: ArithmeticBinaryOperatorGrammar>, <Ref: StringBinaryOperatorGrammar>, <Ref: BooleanBinaryOperatorGrammar>], opts=[<Ref: ComparisonOperatorGrammar>]]
INFO       [PD:3  MD:14]	..............ComparisonOperatorGrammar           	OneOf.match PRN     	    	[ns=1, ps=7, ms=0, pruned=[<Ref: EqualsSegment>, <Ref: GreaterThanSegment>, <Ref: LessThanSegment>, <Ref: GreaterThanOrEqualToSegment>, <Ref: LessThanOrEqualToSegment>, <Ref: NotEqualToSegment_a>, <Ref: NotEqualToSegment_b>], opts=[<Ref: LikeOperatorSegment>]]
DEBUG      [PD:3  MD:15]	...............ComparisonOperatorGrammar          	Ref.match OUT       	    	[match=<MatchResult 0/2: ''>, seg="' ASC'"]
INFO       [PD:3  MD:14]	..............ComparisonOperatorGrammar           	OneOf.match OUT     	    	[match=<MatchResult 0/2: ''>, seg="' ASC'"]
DEBUG      [PD:3  MD:14]	..............BinaryOperatorGrammar               	Ref.match OUT       	    	[match=<MatchResult 0/2: ''>, seg="' ASC'"]
INFO       [PD:3  MD:13]	.............BinaryOperatorGrammar                	OneOf.match OUT     	    	[match=<MatchResult 0/2: ''>, seg="' ASC'"]
DEBUG      [PD:3  MD:13]	.............ColumnReferenceSegment               	Ref.match OUT       	    	[match=<MatchResult 0/2: ''>, seg="' ASC'"]
INFO       [PD:3  MD:12]	............ColumnReferenceSegment                	OneOf.match OUT     	    	[match=<MatchResult 0/2: ''>, seg="' ASC'"]
DEBUG      [PD:3  MD:12]	............ColumnReferenceSegment                	NonCo.match OUT     	+   	[match=<MatchResult 1/2: ' '>, seg="' ASC'"]
INFO       [PD:3  MD:12]	............SingleIdentifierGrammar               	OneOf.match PRN     	    	[ns=2, ps=0, ms=0, pruned=[], opts=[<Ref: NakedIdentifierSegment>, <Ref: QuotedIdentifierSegment>]]
DEBUG      [PD:3  MD:13]	.............SingleIdentifierGrammar              	Ref.match OUT       	++  	[match=<MatchResult 1/1: 'name'>, seg="'name'"]
INFO       [PD:3  MD:12]	............SingleIdentifierGrammar               	OneOf.match OUT     	++  	[match=<MatchResult 1/1: 'name'>, seg="'name'"]
DEBUG      [PD:3  MD:12]	............ColumnReferenceSegment                	Ref.match OUT       	++  	[match=<MatchResult 1/1: 'name'>, seg="'name'"]
INFO       [PD:3  MD:11]	...........ColumnReferenceSegment                 	Delim.match OUT     	+   	[match=<MatchResult 3/5: 'tbl.name'>, seg="'tbl.name ASC'"]
DEBUG      [PD:3  MD:10]	..........ColumnReferenceSegment                  	Colum.match OUT     	+   	[match=<MatchResult 1/3: 'tbl.name'>, seg="'tbl.name ASC'"]
DEBUG      [PD:3  MD:10]	..........Expression_D_Grammar                    	Ref.match OUT       	+   	[match=<MatchResult 1/3: 'tbl.name'>, seg="'tbl.name ASC'"]
DEBUG      [PD:3  MD:11]	...........Expression_D_Grammar                   	Ref.match OUT       	    	[match=<MatchResult 0/5: ''>, seg="'tbl.name ASC'"]
INFO       [PD:3  MD:12]	............ArrayLiteralSegment                   	Brack.match OUT     	    	[match=<MatchResult 0/5: ''>, seg="'tbl.name ASC'"]
DEBUG      [PD:3  MD:11]	...........ArrayLiteralSegment                    	Array.match OUT     	    	[match=<MatchResult 0/5: ''>, seg="'tbl.name ASC'"]
DEBUG      [PD:3  MD:11]	...........Expression_D_Grammar                   	Ref.match OUT       	    	[match=<MatchResult 0/5: ''>, seg="'tbl.name ASC'"]
INFO       [PD:3  MD:10]	..........Expression_D_Grammar                    	Seque.match OUT     	    	[match=<MatchResult 0/5: ''>, seg="'tbl.name ASC'"]
INFO       [PD:3  MD:12]	............DatatypeSegment                       	OneOf.match PRN     	    	[ns=1, ps=2, ms=0, pruned=[<Sequence: [<OneOf: [<Ref: TimeKeywordSegment>, <Ref..., <Bracketed: [<Ref: NumericLiteralSegment..., <Sequence:...]>, <Sequence: [<Ref: DoubleKeywordSegment>, <Ref: PrecisionKeywordSegment>]>], opts=[<Sequence: [<OneOf: [<Sequence: [<OneOf: [<Ref: Char..., <Bracketed: [<OneOf: [<Delimited: [<Ref:..., <Ref: Char...]>]]
INFO       [PD:3  MD:14]	..............DatatypeSegment                     	OneOf.match PRN     	    	[ns=1, ps=1, ms=0, pruned=[<Sequence: [<OneOf: [<Ref: CharacterKeywordSegment>,..., <OneOf: [<Ref: VaryingKeywordSegment>, <...]>], opts=[<Sequence: [<Sequence: [<Ref: SingleIdentifierGramma..., <Ref: DatatypeIdentifierSegment>]>]]
INFO       [PD:3  MD:17]	.................SingleIdentifierGrammar          	OneOf.match PRN     	    	[ns=2, ps=0, ms=0, pruned=[], opts=[<Ref: NakedIdentifierSegment>, <Ref: QuotedIdentifierSegment>]]
DEBUG      [PD:3  MD:18]	..................SingleIdentifierGrammar         	Ref.match OUT       	+   	[match=<MatchResult 1/5: 'tbl'>, seg="'tbl.name ASC'"]
DEBUG      [PD:3  MD:18]	..................SingleIdentifierGrammar         	Ref.match OUT       	    	[match=<MatchResult 0/5: ''>, seg="'tbl.name ASC'"]
INFO       [PD:3  MD:17]	.................SingleIdentifierGrammar          	OneOf.match OUT     	+   	[match=<MatchResult 1/5: 'tbl'>, seg="'tbl.name ASC'"]
DEBUG      [PD:3  MD:17]	.................DatatypeSegment                  	Ref.match OUT       	+   	[match=<MatchResult 1/5: 'tbl'>, seg="'tbl.name ASC'"]
DEBUG      [PD:3  MD:17]	.................DatatypeSegment                  	Ref.match OUT       	+   	[match=<MatchResult 1/4: '.'>, seg="'.name ASC'"]
INFO       [PD:3  MD:16]	................DatatypeSegment                   	Seque.match OUT     	+   	[match=<MatchResult 2/5: 'tbl.'>, seg="'tbl.name ASC'"]
DEBUG      [PD:3  MD:16]	................DatatypeSegment                   	Ref.match OUT       	+   	[match=<MatchResult 1/3: 'name'>, seg="'name ASC'"]
INFO       [PD:3  MD:15]	...............DatatypeSegment                    	Seque.match OUT     	+   	[match=<MatchResult 3/5: 'tbl.name'>, seg="'tbl.name ASC'"]
INFO       [PD:3  MD:14]	..............DatatypeSegment                     	OneOf.match OUT     	+   	[match=<MatchResult 3/5: 'tbl.name'>, seg="'tbl.name ASC'"]
INFO       [PD:3  MD:14]	..............DatatypeSegment                     	Brack.match OUT     	    	[match=<MatchResult 0/1: ''>, seg="'ASC'"]
DEBUG      [PD:3  MD:14]	..............DatatypeSegment                     	Ref.match OUT       	    	[match=<MatchResult 0/1: ''>, seg="'ASC'"]
INFO       [PD:3  MD:13]	.............DatatypeSegment                      	Seque.match OUT     	+   	[match=<MatchResult 3/5: 'tbl.name'>, seg="'tbl.name ASC'"]
INFO       [PD:3  MD:12]	............DatatypeSegment                       	OneOf.match OUT     	+   	[match=<MatchResult 3/5: 'tbl.name'>, seg="'tbl.name ASC'"]
DEBUG      [PD:3  MD:11]	...........DatatypeSegment                        	Datat.match OUT     	+   	[match=<MatchResult 1/3: 'tbl.name'>, seg="'tbl.name ASC'"]
DEBUG      [PD:3  MD:11]	...........Expression_D_Grammar                   	Ref.match OUT       	+   	[match=<MatchResult 1/3: 'tbl.name'>, seg="'tbl.name ASC'"]
INFO       [PD:3  MD:11]	...........Expression_D_Grammar                   	OneOf.match PRN     	    	[ns=2, ps=3, ms=0, pruned=[<Ref: BooleanLiteralGrammar>, <Ref: NullLiteralSegment>, <Ref: DateTimeLiteralGrammar>], opts=[<Ref: QuotedLiteralSegment>, <Ref: NumericLiteralSegment>]]
DEBUG      [PD:3  MD:12]	............Expression_D_Grammar                  	Ref.match OUT       	    	[match=<MatchResult 0/1: ''>, seg="'ASC'"]
DEBUG      [PD:3  MD:12]	............Expression_D_Grammar                  	Ref.match OUT       	    	[match=<MatchResult 0/1: ''>, seg="'ASC'"]
INFO       [PD:3  MD:11]	...........Expression_D_Grammar                   	OneOf.match OUT     	    	[match=<MatchResult 0/1: ''>, seg="'ASC'"]
INFO       [PD:3  MD:10]	..........Expression_D_Grammar                    	Seque.match OUT     	    	[match=<MatchResult 0/5: ''>, seg="'tbl.name ASC'"]
INFO       [PD:3  MD:9 ]	.........Expression_D_Grammar                     	OneOf.match OUT     	+   	[match=<MatchResult 1/3: 'tbl.name'>, seg="'tbl.name ASC'"]
INFO       [PD:3  MD:9 ]	.........Accessor_Grammar                         	AnyNu.match PRN     	    	[ns=0, ps=1, ms=0, pruned=[<Ref: ArrayAccessorSegment>], opts='ALL']
INFO       [PD:3  MD:9 ]	.........Accessor_Grammar                         	AnyNu.match OUT     	    	[match=<MatchResult 0/1: ''>, seg="'ASC'"]
DEBUG      [PD:3  MD:9 ]	.........Expression_D_Grammar                     	Ref.match OUT       	    	[match=<MatchResult 0/1: ''>, seg="'ASC'"]
INFO       [PD:3  MD:9 ]	.........Expression_D_Grammar                     	AnyNu.match PRN     	    	[ns=0, ps=1, ms=0, pruned=[<Ref: ShorthandCastSegment>], opts='ALL']
INFO       [PD:3  MD:9 ]	.........Expression_D_Grammar                     	AnyNu.match OUT     	    	[match=<MatchResult 0/1: ''>, seg="'ASC'"]
INFO       [PD:3  MD:8 ]	........Expression_D_Grammar                      	Seque.match OUT     	+   	[match=<MatchResult 1/3: 'tbl.name'>, seg="'tbl.name ASC'"]
DEBUG      [PD:3  MD:8 ]	........Expression_C_Grammar                      	Ref.match OUT       	+   	[match=<MatchResult 1/3: 'tbl.name'>, seg="'tbl.name ASC'"]
INFO       [PD:3  MD:7 ]	.......Expression_C_Grammar                       	OneOf.match OUT     	+   	[match=<MatchResult 1/3: 'tbl.name'>, seg="'tbl.name ASC'"]
DEBUG      [PD:3  MD:7 ]	.......Expression_A_Grammar                       	Ref.match OUT       	+   	[match=<MatchResult 1/3: 'tbl.name'>, seg="'tbl.name ASC'"]
INFO       [PD:3  MD:6 ]	......Expression_A_Grammar                        	OneOf.match OUT     	+   	[match=<MatchResult 1/3: 'tbl.name'>, seg="'tbl.name ASC'"]
INFO       [PD:3  MD:6 ]	......Expression_A_Grammar                        	AnyNu.match PRN     	    	[ns=1, ps=0, ms=0, pruned=[], opts=[<OneOf: [<Sequence: [<OneOf: [<Sequence: [<Ref: N..., <Sequence: [<Ref: NotKeywordSegment [opt..., <Sequence:...]>]]
INFO       [PD:3  MD:7 ]	.......Expression_A_Grammar                       	OneOf.match PRN     	    	[ns=3, ps=5, ms=0, pruned=[<Sequence: [<Ref: NotKeywordSegment [opt]>, <Ref: InKeywordSegment>, <Bracketed: [<OneOf: [<Delimited: [<Ref:...]>, <Sequence: [<Ref: NotKeywordSegment [opt]>, <Ref: InKeywordSegment>, <Ref: FunctionSegment>]>, <Sequence: [<Ref: IsKeywordSegment>, <Ref: NotKeywordSegment [opt]>, <Ref: IsClauseGrammar>]>, <Sequence: [<Ref: NotKeywordSegment>, <Ref: Expression_C_Grammar>]>, <Sequence: [<Ref: NotKeywordSegment [opt]>, <Ref: BetweenKeywordSegment>, <Ref: Expression_C_Grammar>, <AnyNumbe...]>], opts=[<Sequence: [<OneOf: [<Sequence: [<Ref: NotKeywordSeg..., <Ref: Expression_C_Grammar>, <Sequence: [<Ref: EscapeKe...]>, <Ref: IsNullGrammar>, <Ref: NotNullGrammar>]]
INFO       [PD:3  MD:9 ]	.........Expression_A_Grammar                     	OneOf.match PRN     	    	[ns=1, ps=1, ms=0, pruned=[<Sequence: [<Ref: NotKeywordSegment [opt]>, <Ref: LikeGrammar>]>], opts=[<Sequence: [<Ref: BinaryOperatorGrammar>, <Ref: NotKeywordSegment [opt]>]>]]
INFO       [PD:3  MD:11]	...........BinaryOperatorGrammar                  	OneOf.match PRN     	    	[ns=1, ps=3, ms=0, pruned=[<Ref: ArithmeticBinaryOperatorGrammar>, <Ref: StringBinaryOperatorGrammar>, <Ref: BooleanBinaryOperatorGrammar>], opts=[<Ref: ComparisonOperatorGrammar>]]
INFO       [PD:3  MD:12]	............ComparisonOperatorGrammar             	OneOf.match PRN     	    	[ns=1, ps=7, ms=0, pruned=[<Ref: EqualsSegment>, <Ref: GreaterThanSegment>, <Ref: LessThanSegment>, <Ref: GreaterThanOrEqualToSegment>, <Ref: LessThanOrEqualToSegment>, <Ref: NotEqualToSegment_a>, <Ref: NotEqualToSegment_b>], opts=[<Ref: LikeOperatorSegment>]]
DEBUG      [PD:3  MD:13]	.............ComparisonOperatorGrammar            	Ref.match OUT       	    	[match=<MatchResult 0/1: ''>, seg="'ASC'"]
INFO       [PD:3  MD:12]	............ComparisonOperatorGrammar             	OneOf.match OUT     	    	[match=<MatchResult 0/1: ''>, seg="'ASC'"]
DEBUG      [PD:3  MD:12]	............BinaryOperatorGrammar                 	Ref.match OUT       	    	[match=<MatchResult 0/1: ''>, seg="'ASC'"]
INFO       [PD:3  MD:11]	...........BinaryOperatorGrammar                  	OneOf.match OUT     	    	[match=<MatchResult 0/1: ''>, seg="'ASC'"]
DEBUG      [PD:3  MD:11]	...........Expression_A_Grammar                   	Ref.match OUT       	    	[match=<MatchResult 0/1: ''>, seg="'ASC'"]
INFO       [PD:3  MD:10]	..........Expression_A_Grammar                    	Seque.match OUT     	    	[match=<MatchResult 0/1: ''>, seg="'ASC'"]
INFO       [PD:3  MD:9 ]	.........Expression_A_Grammar                     	OneOf.match OUT     	    	[match=<MatchResult 0/1: ''>, seg="'ASC'"]
INFO       [PD:3  MD:8 ]	........Expression_A_Grammar                      	Seque.match OUT     	    	[match=<MatchResult 0/1: ''>, seg="'ASC'"]
DEBUG      [PD:3  MD:8 ]	........Expression_A_Grammar                      	Ref.match OUT       	    	[match=<MatchResult 0/1: ''>, seg="'ASC'"]
DEBUG      [PD:3  MD:8 ]	........Expression_A_Grammar                      	Ref.match OUT       	    	[match=<MatchResult 0/1: ''>, seg="'ASC'"]
INFO       [PD:3  MD:7 ]	.......Expression_A_Grammar                       	OneOf.match OUT     	    	[match=<MatchResult 0/1: ''>, seg="'ASC'"]
INFO       [PD:3  MD:6 ]	......Expression_A_Grammar                        	AnyNu.match OUT     	    	[match=<MatchResult 0/1: ''>, seg="'ASC'"]
INFO       [PD:3  MD:5 ]	.....Expression_A_Grammar                         	Seque.match OUT     	+   	[match=<MatchResult 1/3: 'tbl.name'>, seg="'tbl.name ASC'"]
DEBUG      [PD:3  MD:5 ]	.....ExpressionSegment                            	Ref.match OUT       	+   	[match=<MatchResult 1/3: 'tbl.name'>, seg="'tbl.name ASC'"]
DEBUG      [PD:3  MD:4 ]	....ExpressionSegment                             	Expre.match OUT     	+   	[match=<MatchResult 1/3: 'tbl.name'>, seg="'tbl.name ASC'"]
DEBUG      [PD:3  MD:4 ]	....OrderByClauseSegment                          	Ref.match OUT       	+   	[match=<MatchResult 1/3: 'tbl.name'>, seg="'tbl.name ASC'"]
INFO       [PD:3  MD:3 ]	...OrderByClauseSegment                           	OneOf.match OUT     	+   	[match=<MatchResult 1/3: 'tbl.name'>, seg="'tbl.name ASC'"]
INFO       [PD:3  MD:3 ]	...OrderByClauseSegment                           	OneOf.match PRN     	    	[ns=0, ps=1, ms=1, pruned=[<Ref: DescKeywordSegment>], opts=[<Ref: AscKeywordSegment>]]
DEBUG      [PD:3  MD:4 ]	....OrderByClauseSegment                          	Ref.match OUT       	++  	[match=<MatchResult 1/1: 'ASC'>, seg="'ASC'"]
INFO       [PD:3  MD:3 ]	...OrderByClauseSegment                           	OneOf.match OUT     	++  	[match=<MatchResult 1/1: 'ASC'>, seg="'ASC'"]
INFO       [PD:3  MD:2 ]	..OrderByClauseSegment                            	Seque.match OUT     	++  	[match=<MatchResult 3/3: 'tbl.name ASC'>, seg="'tbl.name ASC'"]
INFO       [PD:3  MD:1 ]	.OrderByClauseSegment                             	Delim.match OUT     	++  	[match=<MatchResult 3/3: 'tbl.name ASC'>, seg="'tbl.name ASC'"]
INFO       [PD:3  MD:0 ]	OrderByClauseSegment                              	Seque.match OUT     	++  	[match=<MatchResult 9/9: 'ORDER BY tbl.name ASC'>, seg="'ORDER BY tbl.name AS...'"]
DEBUG      OrderByClauseSegment.parse: Done Parse. Plotting Recursion. Recurse=True
DEBUG      ###
#
# Beginning Parse Depth 4: OrderByClauseSegment
#
###
Initial Structure:
[L: 14, P:  1]      |orderby_clause:
[L: 14, P:  1]      |    keyword:                                                  'ORDER'
[L: 14, P:  6]      |    whitespace:                                               ' '
[L: 14, P:  7]      |    keyword:                                                  'BY'
[L: 14, P:  9]      |    [META] indent:
[L: 14, P:  9]      |    whitespace:                                               ' '
[L: 14, P: 10]      |    column_reference:
[L: 14, P: 10]      |        identifier:                                           'tbl'
[L: 14, P: 13]      |        dot:                                                  '.'
[L: 14, P: 14]      |        identifier:                                           'name'
[L: 14, P: 18]      |    whitespace:                                               ' '
[L: 14, P: 19]      |    keyword:                                                  'ASC'
[L: 14, P: 22]      |    [META] dedent:

INFO       [PD:4] Skipping expansion of <KeywordSegment: ([L: 14, P:  1]) 'ORDER'>...
INFO       [PD:4] Skipping expansion of <WhitespaceSegment: ([L: 14, P:  6]) ' '>...
INFO       [PD:4] Skipping expansion of <KeywordSegment: ([L: 14, P:  7]) 'BY'>...
INFO       [PD:4] Skipping expansion of <Indent: ([L: 14, P:  9]) ''>...
INFO       [PD:4] Skipping expansion of <WhitespaceSegment: ([L: 14, P:  9]) ' '>...
INFO       [PD:4] Skipping expansion of <ColumnReferenceSegment: ([L: 14, P: 10])>...
INFO       [PD:4] Skipping expansion of <WhitespaceSegment: ([L: 14, P: 18]) ' '>...
INFO       [PD:4] Skipping expansion of <KeywordSegment: ([L: 14, P: 19]) 'ASC'>...
INFO       [PD:4] Skipping expansion of <Dedent: ([L: 14, P: 22]) ''>...
INFO       [PD:1] Skipping expansion of <NewlineSegment: ([L: 14, P: 22]) '\n'>...
INFO       
###
#
# Parsed Tree:
#
###
INFO       
[L:  1, P:  1]      |file:
[L:  1, P:  1]      |    statement:
[L:  1, P:  1]      |        select_statement:
[L:  1, P:  1]      |            select_clause:
[L:  1, P:  1]      |                keyword:                                      'SELECT'
[L:  1, P:  7]      |                [META] indent:
[L:  1, P:  7]      |                newline:                                      '\n'
[L:  2, P:  1]      |                whitespace:                                   '    '
[L:  2, P:  5]      |                select_clause_element:
[L:  2, P:  5]      |                    column_reference:
[L:  2, P:  5]      |                        identifier:                           'tbl'
[L:  2, P:  8]      |                        dot:                                  '.'
[L:  2, P:  9]      |                        identifier:                           'name'
[L:  2, P: 13]      |                comma:                                        ','
[L:  2, P: 14]      |                newline:                                      '\n'
[L:  3, P:  1]      |                whitespace:                                   '    '
[L:  3, P:  5]      |                select_clause_element:
[L:  3, P:  5]      |                    column_reference:
[L:  3, P:  5]      |                        identifier:                           'b'
[L:  3, P:  6]      |                        dot:                                  '.'
[L:  3, P:  7]      |                        identifier:                           'value'
[L:  3, P: 12]      |                comma:                                        ','
[L:  3, P: 13]      |                newline:                                      '\n'
[L:  4, P:  1]      |                whitespace:                                   '    '
[L:  4, P:  5]      |                comment:                                      '/*'
[L:  4, P:  7]      |                newline:                                      '\n'
[L:  5, P:  1]      |                whitespace:                                   '    '
[L:  5, P:  5]      |                comment:                                      'This is a block comment'
[L:  5, P: 28]      |                newline:                                      '\n'
[L:  6, P:  1]      |                whitespace:                                   '    '
[L:  6, P:  5]      |                comment:                                      '*/'
[L:  6, P:  7]      |                newline:                                      '\n'
[L:  7, P:  1]      |                whitespace:                                   '    '
[L:  7, P:  5]      |                select_clause_element:
[L:  7, P:  5]      |                    column_reference:
[L:  7, P:  5]      |                        identifier:                           'd'
[L:  7, P:  6]      |                        dot:                                  '.'
[L:  7, P:  7]      |                        identifier:                           'something'
[L:  7, P: 16]      |                comma:                                        ','
[L:  7, P: 17]      |                whitespace:                                   '    '
[L:  7, P: 21]      |                comment:                                      '-- Which a comment after it'
[L:  7, P: 48]      |                newline:                                      '\n'
[L:  8, P:  1]      |                whitespace:                                   '    '
[L:  8, P:  5]      |                select_clause_element:
[L:  8, P:  5]      |                    column_reference:
[L:  8, P:  5]      |                        identifier:                           'tbl'
[L:  8, P:  8]      |                        dot:                                  '.'
[L:  8, P:  9]      |                        identifier:                           'foo'
[L:  8, P: 12]      |                comma:                                        ','
[L:  8, P: 13]      |                newline:                                      '\n'
[L:  9, P:  1]      |                whitespace:                                   '    '
[L:  9, P:  5]      |                select_clause_element:
[L:  9, P:  5]      |                    expression:
[L:  9, P:  5]      |                        column_reference:
[L:  9, P:  5]      |                            identifier:                       'c'
[L:  9, P:  6]      |                            dot:                              '.'
[L:  9, P:  7]      |                            identifier:                       'val'
[L:  9, P: 10]      |                        whitespace:                           ' '
[L:  9, P: 11]      |                        binary_operator:                      '+'
[L:  9, P: 12]      |                        whitespace:                           ' '
[L:  9, P: 13]      |                        column_reference:
[L:  9, P: 13]      |                            identifier:                       'b'
[L:  9, P: 14]      |                            dot:                              '.'
[L:  9, P: 15]      |                            identifier:                       'val'
[L:  9, P: 18]      |                        whitespace:                           ' '
[L:  9, P: 19]      |                        binary_operator:                      '/'
[L:  9, P: 20]      |                        whitespace:                           ' '
[L:  9, P: 21]      |                        numeric_literal:
[L:  9, P: 21]      |                            binary_operator:                  '-'
[L:  9, P: 22]      |                            literal:                          '2'
[L:  9, P: 23]      |                    whitespace:                               ' '
[L:  9, P: 24]      |                    alias_expression:
[L:  9, P: 24]      |                        keyword:                              'AS'
[L:  9, P: 26]      |                        whitespace:                           ' '
[L:  9, P: 27]      |                        identifier:                           'a_calculation'
[L:  9, P: 40]      |            newline:                                          '\n'
[L: 10, P:  1]      |            [META] dedent:
[L: 10, P:  1]      |            from_clause:
[L: 10, P:  1]      |                keyword:                                      'FROM'
[L: 10, P:  5]      |                whitespace:                                   ' '
[L: 10, P:  6]      |                from_expression:
[L: 10, P:  6]      |                    [META] indent:
[L: 10, P:  6]      |                    from_expression_element:
[L: 10, P:  6]      |                        table_expression:
[L: 10, P:  6]      |                            table_reference:
[L: 10, P:  6]      |                                identifier:                   'tbl'
[L: 10, P:  9]      |                    newline:                                  '\n'
[L: 11, P:  1]      |                    [META] dedent:
[L: 11, P:  1]      |                    join_clause:
[L: 11, P:  1]      |                        keyword:                              'INNER'
[L: 11, P:  6]      |                        whitespace:                           ' '
[L: 11, P:  7]      |                        keyword:                              'JOIN'
[L: 11, P: 11]      |                        [META] indent:
[L: 11, P: 11]      |                        whitespace:                           ' '
[L: 11, P: 12]      |                        from_expression_element:
[L: 11, P: 12]      |                            table_expression:
[L: 11, P: 12]      |                                table_reference:
[L: 11, P: 12]      |                                    identifier:               'b'
[L: 11, P: 13]      |                        whitespace:                           ' '
[L: 11, P: 14]      |                        join_on_condition:
[L: 11, P: 14]      |                            keyword:                          'ON'
[L: 11, P: 16]      |                            [META] indent:
[L: 11, P: 16]      |                            whitespace:                       ' '
[L: 11, P: 17]      |                            bracketed:
[L: 11, P: 17]      |                                start_bracket:                '('
[L: 11, P: 18]      |                                [META] indent:
[L: 11, P: 18]      |                                expression:
[L: 11, P: 18]      |                                    column_reference:
[L: 11, P: 18]      |                                        identifier:           'tbl'
[L: 11, P: 21]      |                                        dot:                  '.'
[L: 11, P: 22]      |                                        identifier:           'common_id'
[L: 11, P: 31]      |                                    whitespace:               ' '
[L: 11, P: 32]      |                                    comparison_operator:      '='
[L: 11, P: 33]      |                                    whitespace:               ' '
[L: 11, P: 34]      |                                    column_reference:
[L: 11, P: 34]      |                                        identifier:           'b'
[L: 11, P: 35]      |                                        dot:                  '.'
[L: 11, P: 36]      |                                        identifier:           'common_id'
[L: 11, P: 45]      |                                [META] dedent:
[L: 11, P: 45]      |                                end_bracket:                  ')'
[L: 11, P: 46]      |                            [META] dedent:
[L: 11, P: 46]      |                        [META] dedent:
[L: 11, P: 46]      |                    newline:                                  '\n'
[L: 12, P:  1]      |                    join_clause:
[L: 12, P:  1]      |                        keyword:                              'JOIN'
[L: 12, P:  5]      |                        [META] indent:
[L: 12, P:  5]      |                        whitespace:                           ' '
[L: 12, P:  6]      |                        from_expression_element:
[L: 12, P:  6]      |                            table_expression:
[L: 12, P:  6]      |                                table_reference:
[L: 12, P:  6]      |                                    identifier:               'c'
[L: 12, P:  7]      |                        whitespace:                           ' '
[L: 12, P:  8]      |                        join_on_condition:
[L: 12, P:  8]      |                            keyword:                          'ON'
[L: 12, P: 10]      |                            [META] indent:
[L: 12, P: 10]      |                            whitespace:                       ' '
[L: 12, P: 11]      |                            bracketed:
[L: 12, P: 11]      |                                start_bracket:                '('
[L: 12, P: 12]      |                                [META] indent:
[L: 12, P: 12]      |                                expression:
[L: 12, P: 12]      |                                    column_reference:
[L: 12, P: 12]      |                                        identifier:           'tbl'
[L: 12, P: 15]      |                                        dot:                  '.'
[L: 12, P: 16]      |                                        identifier:           'id'
[L: 12, P: 18]      |                                    whitespace:               ' '
[L: 12, P: 19]      |                                    comparison_operator:      '='
[L: 12, P: 20]      |                                    whitespace:               ' '
[L: 12, P: 21]      |                                    column_reference:
[L: 12, P: 21]      |                                        identifier:           'c'
[L: 12, P: 22]      |                                        dot:                  '.'
[L: 12, P: 23]      |                                        identifier:           'id'
[L: 12, P: 25]      |                                [META] dedent:
[L: 12, P: 25]      |                                end_bracket:                  ')'
[L: 12, P: 26]      |                            [META] dedent:
[L: 12, P: 26]      |                        [META] dedent:
[L: 12, P: 26]      |                    newline:                                  '\n'
[L: 13, P:  1]      |                    join_clause:
[L: 13, P:  1]      |                        keyword:                              'LEFT'
[L: 13, P:  5]      |                        whitespace:                           ' '
[L: 13, P:  6]      |                        keyword:                              'JOIN'
[L: 13, P: 10]      |                        [META] indent:
[L: 13, P: 10]      |                        whitespace:                           ' '
[L: 13, P: 11]      |                        from_expression_element:
[L: 13, P: 11]      |                            table_expression:
[L: 13, P: 11]      |                                table_reference:
[L: 13, P: 11]      |                                    identifier:               'd'
[L: 13, P: 12]      |                        whitespace:                           ' '
[L: 13, P: 13]      |                        join_on_condition:
[L: 13, P: 13]      |                            keyword:                          'ON'
[L: 13, P: 15]      |                            [META] indent:
[L: 13, P: 15]      |                            whitespace:                       ' '
[L: 13, P: 16]      |                            bracketed:
[L: 13, P: 16]      |                                start_bracket:                '('
[L: 13, P: 17]      |                                [META] indent:
[L: 13, P: 17]      |                                expression:
[L: 13, P: 17]      |                                    column_reference:
[L: 13, P: 17]      |                                        identifier:           'tbl'
[L: 13, P: 20]      |                                        dot:                  '.'
[L: 13, P: 21]      |                                        identifier:           'id'
[L: 13, P: 23]      |                                    whitespace:               ' '
[L: 13, P: 24]      |                                    comparison_operator:      '='
[L: 13, P: 25]      |                                    whitespace:               ' '
[L: 13, P: 26]      |                                    column_reference:
[L: 13, P: 26]      |                                        identifier:           'd'
[L: 13, P: 27]      |                                        dot:                  '.'
[L: 13, P: 28]      |                                        identifier:           'other_id'
[L: 13, P: 36]      |                                [META] dedent:
[L: 13, P: 36]      |                                end_bracket:                  ')'
[L: 13, P: 37]      |                            [META] dedent:
[L: 13, P: 37]      |                        [META] dedent:
[L: 13, P: 37]      |            newline:                                          '\n'
[L: 14, P:  1]      |            orderby_clause:
[L: 14, P:  1]      |                keyword:                                      'ORDER'
[L: 14, P:  6]      |                whitespace:                                   ' '
[L: 14, P:  7]      |                keyword:                                      'BY'
[L: 14, P:  9]      |                [META] indent:
[L: 14, P:  9]      |                whitespace:                                   ' '
[L: 14, P: 10]      |                column_reference:
[L: 14, P: 10]      |                    identifier:                               'tbl'
[L: 14, P: 13]      |                    dot:                                      '.'
[L: 14, P: 14]      |                    identifier:                               'name'
[L: 14, P: 18]      |                whitespace:                                   ' '
[L: 14, P: 19]      |                keyword:                                      'ASC'
[L: 14, P: 22]      |                [META] dedent:
[L: 14, P: 22]      |    newline:                                                  '\n'

[L:  1, P:  1]      |file:
[L:  1, P:  1]      |    statement:
[L:  1, P:  1]      |        select_statement:
[L:  1, P:  1]      |            select_clause:
[L:  1, P:  1]      |                keyword:                                      'SELECT'
[L:  1, P:  7]      |                [META] indent:
[L:  1, P:  7]      |                newline:                                      '\n'
[L:  2, P:  1]      |                whitespace:                                   '    '
[L:  2, P:  5]      |                select_clause_element:
[L:  2, P:  5]      |                    column_reference:
[L:  2, P:  5]      |                        identifier:                           'tbl'
[L:  2, P:  8]      |                        dot:                                  '.'
[L:  2, P:  9]      |                        identifier:                           'name'
[L:  2, P: 13]      |                comma:                                        ','
[L:  2, P: 14]      |                newline:                                      '\n'
[L:  3, P:  1]      |                whitespace:                                   '    '
[L:  3, P:  5]      |                select_clause_element:
[L:  3, P:  5]      |                    column_reference:
[L:  3, P:  5]      |                        identifier:                           'b'
[L:  3, P:  6]      |                        dot:                                  '.'
[L:  3, P:  7]      |                        identifier:                           'value'
[L:  3, P: 12]      |                comma:                                        ','
[L:  3, P: 13]      |                newline:                                      '\n'
[L:  4, P:  1]      |                whitespace:                                   '    '
[L:  4, P:  5]      |                comment:                                      '/*'
[L:  4, P:  7]      |                newline:                                      '\n'
[L:  5, P:  1]      |                whitespace:                                   '    '
[L:  5, P:  5]      |                comment:                                      'This is a block comment'
[L:  5, P: 28]      |                newline:                                      '\n'
[L:  6, P:  1]      |                whitespace:                                   '    '
[L:  6, P:  5]      |                comment:                                      '*/'
[L:  6, P:  7]      |                newline:                                      '\n'
[L:  7, P:  1]      |                whitespace:                                   '    '
[L:  7, P:  5]      |                select_clause_element:
[L:  7, P:  5]      |                    column_reference:
[L:  7, P:  5]      |                        identifier:                           'd'
[L:  7, P:  6]      |                        dot:                                  '.'
[L:  7, P:  7]      |                        identifier:                           'something'
[L:  7, P: 16]      |                comma:                                        ','
[L:  7, P: 17]      |                whitespace:                                   '    '
[L:  7, P: 21]      |                comment:                                      '-- Which a comment after it'
[L:  7, P: 48]      |                newline:                                      '\n'
[L:  8, P:  1]      |                whitespace:                                   '    '
[L:  8, P:  5]      |                select_clause_element:
[L:  8, P:  5]      |                    column_reference:
[L:  8, P:  5]      |                        identifier:                           'tbl'
[L:  8, P:  8]      |                        dot:                                  '.'
[L:  8, P:  9]      |                        identifier:                           'foo'
[L:  8, P: 12]      |                comma:                                        ','
[L:  8, P: 13]      |                newline:                                      '\n'
[L:  9, P:  1]      |                whitespace:                                   '    '
[L:  9, P:  5]      |                select_clause_element:
[L:  9, P:  5]      |                    expression:
[L:  9, P:  5]      |                        column_reference:
[L:  9, P:  5]      |                            identifier:                       'c'
[L:  9, P:  6]      |                            dot:                              '.'
[L:  9, P:  7]      |                            identifier:                       'val'
[L:  9, P: 10]      |                        whitespace:                           ' '
[L:  9, P: 11]      |                        binary_operator:                      '+'
[L:  9, P: 12]      |                        whitespace:                           ' '
[L:  9, P: 13]      |                        column_reference:
[L:  9, P: 13]      |                            identifier:                       'b'
[L:  9, P: 14]      |                            dot:                              '.'
[L:  9, P: 15]      |                            identifier:                       'val'
[L:  9, P: 18]      |                        whitespace:                           ' '
[L:  9, P: 19]      |                        binary_operator:                      '/'
[L:  9, P: 20]      |                        whitespace:                           ' '
[L:  9, P: 21]      |                        numeric_literal:
[L:  9, P: 21]      |                            binary_operator:                  '-'
[L:  9, P: 22]      |                            literal:                          '2'
[L:  9, P: 23]      |                    whitespace:                               ' '
[L:  9, P: 24]      |                    alias_expression:
[L:  9, P: 24]      |                        keyword:                              'AS'
[L:  9, P: 26]      |                        whitespace:                           ' '
[L:  9, P: 27]      |                        identifier:                           'a_calculation'
[L:  9, P: 40]      |            newline:                                          '\n'
[L: 10, P:  1]      |            [META] dedent:
[L: 10, P:  1]      |            from_clause:
[L: 10, P:  1]      |                keyword:                                      'FROM'
[L: 10, P:  5]      |                whitespace:                                   ' '
[L: 10, P:  6]      |                from_expression:
[L: 10, P:  6]      |                    [META] indent:
[L: 10, P:  6]      |                    from_expression_element:
[L: 10, P:  6]      |                        table_expression:
[L: 10, P:  6]      |                            table_reference:
[L: 10, P:  6]      |                                identifier:                   'tbl'
[L: 10, P:  9]      |                    newline:                                  '\n'
[L: 11, P:  1]      |                    [META] dedent:
[L: 11, P:  1]      |                    join_clause:
[L: 11, P:  1]      |                        keyword:                              'INNER'
[L: 11, P:  6]      |                        whitespace:                           ' '
[L: 11, P:  7]      |                        keyword:                              'JOIN'
[L: 11, P: 11]      |                        [META] indent:
[L: 11, P: 11]      |                        whitespace:                           ' '
[L: 11, P: 12]      |                        from_expression_element:
[L: 11, P: 12]      |                            table_expression:
[L: 11, P: 12]      |                                table_reference:
[L: 11, P: 12]      |                                    identifier:               'b'
[L: 11, P: 13]      |                        whitespace:                           ' '
[L: 11, P: 14]      |                        join_on_condition:
[L: 11, P: 14]      |                            keyword:                          'ON'
[L: 11, P: 16]      |                            [META] indent:
[L: 11, P: 16]      |                            whitespace:                       ' '
[L: 11, P: 17]      |                            bracketed:
[L: 11, P: 17]      |                                start_bracket:                '('
[L: 11, P: 18]      |                                [META] indent:
[L: 11, P: 18]      |                                expression:
[L: 11, P: 18]      |                                    column_reference:
[L: 11, P: 18]      |                                        identifier:           'tbl'
[L: 11, P: 21]      |                                        dot:                  '.'
[L: 11, P: 22]      |                                        identifier:           'common_id'
[L: 11, P: 31]      |                                    whitespace:               ' '
[L: 11, P: 32]      |                                    comparison_operator:      '='
[L: 11, P: 33]      |                                    whitespace:               ' '
[L: 11, P: 34]      |                                    column_reference:
[L: 11, P: 34]      |                                        identifier:           'b'
[L: 11, P: 35]      |                                        dot:                  '.'
[L: 11, P: 36]      |                                        identifier:           'common_id'
[L: 11, P: 45]      |                                [META] dedent:
[L: 11, P: 45]      |                                end_bracket:                  ')'
[L: 11, P: 46]      |                            [META] dedent:
[L: 11, P: 46]      |                        [META] dedent:
[L: 11, P: 46]      |                    newline:                                  '\n'
[L: 12, P:  1]      |                    join_clause:
[L: 12, P:  1]      |                        keyword:                              'JOIN'
[L: 12, P:  5]      |                        [META] indent:
[L: 12, P:  5]      |                        whitespace:                           ' '
[L: 12, P:  6]      |                        from_expression_element:
[L: 12, P:  6]      |                            table_expression:
[L: 12, P:  6]      |                                table_reference:
[L: 12, P:  6]      |                                    identifier:               'c'
[L: 12, P:  7]      |                        whitespace:                           ' '
[L: 12, P:  8]      |                        join_on_condition:
[L: 12, P:  8]      |                            keyword:                          'ON'
[L: 12, P: 10]      |                            [META] indent:
[L: 12, P: 10]      |                            whitespace:                       ' '
[L: 12, P: 11]      |                            bracketed:
[L: 12, P: 11]      |                                start_bracket:                '('
[L: 12, P: 12]      |                                [META] indent:
[L: 12, P: 12]      |                                expression:
[L: 12, P: 12]      |                                    column_reference:
[L: 12, P: 12]      |                                        identifier:           'tbl'
[L: 12, P: 15]      |                                        dot:                  '.'
[L: 12, P: 16]      |                                        identifier:           'id'
[L: 12, P: 18]      |                                    whitespace:               ' '
[L: 12, P: 19]      |                                    comparison_operator:      '='
[L: 12, P: 20]      |                                    whitespace:               ' '
[L: 12, P: 21]      |                                    column_reference:
[L: 12, P: 21]      |                                        identifier:           'c'
[L: 12, P: 22]      |                                        dot:                  '.'
[L: 12, P: 23]      |                                        identifier:           'id'
[L: 12, P: 25]      |                                [META] dedent:
[L: 12, P: 25]      |                                end_bracket:                  ')'
[L: 12, P: 26]      |                            [META] dedent:
[L: 12, P: 26]      |                        [META] dedent:
[L: 12, P: 26]      |                    newline:                                  '\n'
[L: 13, P:  1]      |                    join_clause:
[L: 13, P:  1]      |                        keyword:                              'LEFT'
[L: 13, P:  5]      |                        whitespace:                           ' '
[L: 13, P:  6]      |                        keyword:                              'JOIN'
[L: 13, P: 10]      |                        [META] indent:
[L: 13, P: 10]      |                        whitespace:                           ' '
[L: 13, P: 11]      |                        from_expression_element:
[L: 13, P: 11]      |                            table_expression:
[L: 13, P: 11]      |                                table_reference:
[L: 13, P: 11]      |                                    identifier:               'd'
[L: 13, P: 12]      |                        whitespace:                           ' '
[L: 13, P: 13]      |                        join_on_condition:
[L: 13, P: 13]      |                            keyword:                          'ON'
[L: 13, P: 15]      |                            [META] indent:
[L: 13, P: 15]      |                            whitespace:                       ' '
[L: 13, P: 16]      |                            bracketed:
[L: 13, P: 16]      |                                start_bracket:                '('
[L: 13, P: 17]      |                                [META] indent:
[L: 13, P: 17]      |                                expression:
[L: 13, P: 17]      |                                    column_reference:
[L: 13, P: 17]      |                                        identifier:           'tbl'
[L: 13, P: 20]      |                                        dot:                  '.'
[L: 13, P: 21]      |                                        identifier:           'id'
[L: 13, P: 23]      |                                    whitespace:               ' '
[L: 13, P: 24]      |                                    comparison_operator:      '='
[L: 13, P: 25]      |                                    whitespace:               ' '
[L: 13, P: 26]      |                                    column_reference:
[L: 13, P: 26]      |                                        identifier:           'd'
[L: 13, P: 27]      |                                        dot:                  '.'
[L: 13, P: 28]      |                                        identifier:           'other_id'
[L: 13, P: 36]      |                                [META] dedent:
[L: 13, P: 36]      |                                end_bracket:                  ')'
[L: 13, P: 37]      |                            [META] dedent:
[L: 13, P: 37]      |                        [META] dedent:
[L: 13, P: 37]      |            newline:                                          '\n'
[L: 14, P:  1]      |            orderby_clause:
[L: 14, P:  1]      |                keyword:                                      'ORDER'
[L: 14, P:  6]      |                whitespace:                                   ' '
[L: 14, P:  7]      |                keyword:                                      'BY'
[L: 14, P:  9]      |                [META] indent:
[L: 14, P:  9]      |                whitespace:                                   ' '
[L: 14, P: 10]      |                column_reference:
[L: 14, P: 10]      |                    identifier:                               'tbl'
[L: 14, P: 13]      |                    dot:                                      '.'
[L: 14, P: 14]      |                    identifier:                               'name'
[L: 14, P: 18]      |                whitespace:                                   ' '
[L: 14, P: 19]      |                keyword:                                      'ASC'
[L: 14, P: 22]      |                [META] dedent:
[L: 14, P: 22]      |    newline:                                                  '\n'

==== timings ====
templating:     0.01 lexing:         0.02
parsing:        1.04
==== overall timings ====
Clock time:     1.08
=== templating ===
cnt:               1 sum:            0.01
min:            0.01 max:            0.01
avg:            0.01
=== lexing ===
cnt:               1 sum:            0.02
min:            0.02 max:            0.02
avg:            0.02
=== parsing ===
cnt:               1 sum:            1.04
min:            1.04 max:            1.04
avg:            1.04

___________________ test__cli__command_lint_parse[command9] ____________________
----------------------------- Captured stdout call -----------------------------
[L:  1, P:  1]      |file:
[L:  1, P:  1]      |    statement:
[L:  1, P:  1]      |        select_statement:
[L:  1, P:  1]      |            select_clause:
[L:  1, P:  1]      |                keyword:                                      'SELECT'
[L:  2, P:  5]      |                select_clause_element:
[L:  2, P:  5]      |                    column_reference:
[L:  2, P:  5]      |                        identifier:                           'tbl'
[L:  2, P:  8]      |                        dot:                                  '.'
[L:  2, P:  9]      |                        identifier:                           'name'
[L:  2, P: 13]      |                comma:                                        ','
[L:  3, P:  5]      |                select_clause_element:
[L:  3, P:  5]      |                    column_reference:
[L:  3, P:  5]      |                        identifier:                           'b'
[L:  3, P:  6]      |                        dot:                                  '.'
[L:  3, P:  7]      |                        identifier:                           'value'
[L:  3, P: 12]      |                comma:                                        ','
[L:  7, P:  5]      |                select_clause_element:
[L:  7, P:  5]      |                    column_reference:
[L:  7, P:  5]      |                        identifier:                           'd'
[L:  7, P:  6]      |                        dot:                                  '.'
[L:  7, P:  7]      |                        identifier:                           'something'
[L:  7, P: 16]      |                comma:                                        ','
[L:  8, P:  5]      |                select_clause_element:
[L:  8, P:  5]      |                    column_reference:
[L:  8, P:  5]      |                        identifier:                           'tbl'
[L:  8, P:  8]      |                        dot:                                  '.'
[L:  8, P:  9]      |                        identifier:                           'foo'
[L:  8, P: 12]      |                comma:                                        ','
[L:  9, P:  5]      |                select_clause_element:
[L:  9, P:  5]      |                    expression:
[L:  9, P:  5]      |                        column_reference:
[L:  9, P:  5]      |                            identifier:                       'c'
[L:  9, P:  6]      |                            dot:                              '.'
[L:  9, P:  7]      |                            identifier:                       'val'
[L:  9, P: 11]      |                        binary_operator:                      '+'
[L:  9, P: 13]      |                        column_reference:
[L:  9, P: 13]      |                            identifier:                       'b'
[L:  9, P: 14]      |                            dot:                              '.'
[L:  9, P: 15]      |                            identifier:                       'val'
[L:  9, P: 19]      |                        binary_operator:                      '/'
[L:  9, P: 21]      |                        numeric_literal:
[L:  9, P: 21]      |                            binary_operator:                  '-'
[L:  9, P: 22]      |                            literal:                          '2'
[L:  9, P: 24]      |                    alias_expression:
[L:  9, P: 24]      |                        keyword:                              'AS'
[L:  9, P: 27]      |                        identifier:                           'a_calculation'
[L: 10, P:  1]      |            from_clause:
[L: 10, P:  1]      |                keyword:                                      'FROM'
[L: 10, P:  6]      |                from_expression:
[L: 10, P:  6]      |                    from_expression_element:
[L: 10, P:  6]      |                        table_expression:
[L: 10, P:  6]      |                            table_reference:
[L: 10, P:  6]      |                                identifier:                   'tbl'
[L: 11, P:  1]      |                    join_clause:
[L: 11, P:  1]      |                        keyword:                              'INNER'
[L: 11, P:  7]      |                        keyword:                              'JOIN'
[L: 11, P: 12]      |                        from_expression_element:
[L: 11, P: 12]      |                            table_expression:
[L: 11, P: 12]      |                                table_reference:
[L: 11, P: 12]      |                                    identifier:               'b'
[L: 11, P: 14]      |                        join_on_condition:
[L: 11, P: 14]      |                            keyword:                          'ON'
[L: 11, P: 17]      |                            bracketed:
[L: 11, P: 17]      |                                start_bracket:                '('
[L: 11, P: 18]      |                                expression:
[L: 11, P: 18]      |                                    column_reference:
[L: 11, P: 18]      |                                        identifier:           'tbl'
[L: 11, P: 21]      |                                        dot:                  '.'
[L: 11, P: 22]      |                                        identifier:           'common_id'
[L: 11, P: 32]      |                                    comparison_operator:      '='
[L: 11, P: 34]      |                                    column_reference:
[L: 11, P: 34]      |                                        identifier:           'b'
[L: 11, P: 35]      |                                        dot:                  '.'
[L: 11, P: 36]      |                                        identifier:           'common_id'
[L: 11, P: 45]      |                                end_bracket:                  ')'
[L: 12, P:  1]      |                    join_clause:
[L: 12, P:  1]      |                        keyword:                              'JOIN'
[L: 12, P:  6]      |                        from_expression_element:
[L: 12, P:  6]      |                            table_expression:
[L: 12, P:  6]      |                                table_reference:
[L: 12, P:  6]      |                                    identifier:               'c'
[L: 12, P:  8]      |                        join_on_condition:
[L: 12, P:  8]      |                            keyword:                          'ON'
[L: 12, P: 11]      |                            bracketed:
[L: 12, P: 11]      |                                start_bracket:                '('
[L: 12, P: 12]      |                                expression:
[L: 12, P: 12]      |                                    column_reference:
[L: 12, P: 12]      |                                        identifier:           'tbl'
[L: 12, P: 15]      |                                        dot:                  '.'
[L: 12, P: 16]      |                                        identifier:           'id'
[L: 12, P: 19]      |                                    comparison_operator:      '='
[L: 12, P: 21]      |                                    column_reference:
[L: 12, P: 21]      |                                        identifier:           'c'
[L: 12, P: 22]      |                                        dot:                  '.'
[L: 12, P: 23]      |                                        identifier:           'id'
[L: 12, P: 25]      |                                end_bracket:                  ')'
[L: 13, P:  1]      |                    join_clause:
[L: 13, P:  1]      |                        keyword:                              'LEFT'
[L: 13, P:  6]      |                        keyword:                              'JOIN'
[L: 13, P: 11]      |                        from_expression_element:
[L: 13, P: 11]      |                            table_expression:
[L: 13, P: 11]      |                                table_reference:
[L: 13, P: 11]      |                                    identifier:               'd'
[L: 13, P: 13]      |                        join_on_condition:
[L: 13, P: 13]      |                            keyword:                          'ON'
[L: 13, P: 16]      |                            bracketed:
[L: 13, P: 16]      |                                start_bracket:                '('
[L: 13, P: 17]      |                                expression:
[L: 13, P: 17]      |                                    column_reference:
[L: 13, P: 17]      |                                        identifier:           'tbl'
[L: 13, P: 20]      |                                        dot:                  '.'
[L: 13, P: 21]      |                                        identifier:           'id'
[L: 13, P: 24]      |                                    comparison_operator:      '='
[L: 13, P: 26]      |                                    column_reference:
[L: 13, P: 26]      |                                        identifier:           'd'
[L: 13, P: 27]      |                                        dot:                  '.'
[L: 13, P: 28]      |                                        identifier:           'other_id'
[L: 13, P: 36]      |                                end_bracket:                  ')'
[L: 14, P:  1]      |            orderby_clause:
[L: 14, P:  1]      |                keyword:                                      'ORDER'
[L: 14, P:  7]      |                keyword:                                      'BY'
[L: 14, P: 10]      |                column_reference:
[L: 14, P: 10]      |                    identifier:                               'tbl'
[L: 14, P: 13]      |                    dot:                                      '.'
[L: 14, P: 14]      |                    identifier:                               'name'
[L: 14, P: 19]      |                keyword:                                      'ASC'


___________________ test__cli__command_lint_parse[command10] ___________________
----------------------------- Captured stdout call -----------------------------
- filepath: test/fixtures/cli/passing_b.sql
  segments:
    file:
      statement:
        select_statement:
          select_clause:
          - keyword: SELECT
          - select_clause_element:
              column_reference:
              - identifier: tbl
              - dot: .
              - identifier: name
          - comma: ','
          - select_clause_element:
              column_reference:
              - identifier: b
              - dot: .
              - identifier: value
          - comma: ','
          - select_clause_element:
              column_reference:
              - identifier: d
              - dot: .
              - identifier: something
          - comma: ','
          - select_clause_element:
              column_reference:
              - identifier: tbl
              - dot: .
              - identifier: foo
          - comma: ','
          - select_clause_element:
              expression:
              - column_reference:
                - identifier: c
                - dot: .
                - identifier: val
              - binary_operator: +
              - column_reference:
                - identifier: b
                - dot: .
                - identifier: val
              - binary_operator: /
              - numeric_literal:
                  binary_operator: '-'
                  literal: '2'
              alias_expression:
                keyword: AS
                identifier: a_calculation
          from_clause:
            keyword: FROM
            from_expression:
            - from_expression_element:
                table_expression:
                  table_reference:
                    identifier: tbl
            - join_clause:
              - keyword: INNER
              - keyword: JOIN
              - from_expression_element:
                  table_expression:
                    table_reference:
                      identifier: b
              - join_on_condition:
                  keyword: 'ON'
                  bracketed:
                    start_bracket: (
                    expression:
                    - column_reference:
                      - identifier: tbl
                      - dot: .
                      - identifier: common_id
                    - comparison_operator: '='
                    - column_reference:
                      - identifier: b
                      - dot: .
                      - identifier: common_id
                    end_bracket: )
            - join_clause:
                keyword: JOIN
                from_expression_element:
                  table_expression:
                    table_reference:
                      identifier: c
                join_on_condition:
                  keyword: 'ON'
                  bracketed:
                    start_bracket: (
                    expression:
                    - column_reference:
                      - identifier: tbl
                      - dot: .
                      - identifier: id
                    - comparison_operator: '='
                    - column_reference:
                      - identifier: c
                      - dot: .
                      - identifier: id
                    end_bracket: )
            - join_clause:
              - keyword: LEFT
              - keyword: JOIN
              - from_expression_element:
                  table_expression:
                    table_reference:
                      identifier: d
              - join_on_condition:
                  keyword: 'ON'
                  bracketed:
                    start_bracket: (
                    expression:
                    - column_reference:
                      - identifier: tbl
                      - dot: .
                      - identifier: id
                    - comparison_operator: '='
                    - column_reference:
                      - identifier: d
                      - dot: .
                      - identifier: other_id
                    end_bracket: )
          orderby_clause:
          - keyword: ORDER
          - keyword: BY
          - column_reference:
            - identifier: tbl
            - dot: .
            - identifier: name
          - keyword: ASC


___________________ test__cli__command_lint_parse[command11] ___________________
----------------------------- Captured stdout call -----------------------------
- filepath: test/fixtures/cli/passing_b.sql
  segments:
    file:
      statement:
        select_statement:
        - select_clause:
          - keyword: SELECT
          - newline: "\n"
          - whitespace: '    '
          - select_clause_element:
              column_reference:
              - identifier: tbl
              - dot: .
              - identifier: name
          - comma: ','
          - newline: "\n"
          - whitespace: '    '
          - select_clause_element:
              column_reference:
              - identifier: b
              - dot: .
              - identifier: value
          - comma: ','
          - newline: "\n"
          - whitespace: '    '
          - comment: /*
          - newline: "\n"
          - whitespace: '    '
          - comment: This is a block comment
          - newline: "\n"
          - whitespace: '    '
          - comment: '*/'
          - newline: "\n"
          - whitespace: '    '
          - select_clause_element:
              column_reference:
              - identifier: d
              - dot: .
              - identifier: something
          - comma: ','
          - whitespace: '    '
          - comment: -- Which a comment after it
          - newline: "\n"
          - whitespace: '    '
          - select_clause_element:
              column_reference:
              - identifier: tbl
              - dot: .
              - identifier: foo
          - comma: ','
          - newline: "\n"
          - whitespace: '    '
          - select_clause_element:
              expression:
              - column_reference:
                - identifier: c
                - dot: .
                - identifier: val
              - whitespace: ' '
              - binary_operator: +
              - whitespace: ' '
              - column_reference:
                - identifier: b
                - dot: .
                - identifier: val
              - whitespace: ' '
              - binary_operator: /
              - whitespace: ' '
              - numeric_literal:
                  binary_operator: '-'
                  literal: '2'
              whitespace: ' '
              alias_expression:
                keyword: AS
                whitespace: ' '
                identifier: a_calculation
        - newline: "\n"
        - from_clause:
            keyword: FROM
            whitespace: ' '
            from_expression:
            - from_expression_element:
                table_expression:
                  table_reference:
                    identifier: tbl
            - newline: "\n"
            - join_clause:
              - keyword: INNER
              - whitespace: ' '
              - keyword: JOIN
              - whitespace: ' '
              - from_expression_element:
                  table_expression:
                    table_reference:
                      identifier: b
              - whitespace: ' '
              - join_on_condition:
                  keyword: 'ON'
                  whitespace: ' '
                  bracketed:
                    start_bracket: (
                    expression:
                    - column_reference:
                      - identifier: tbl
                      - dot: .
                      - identifier: common_id
                    - whitespace: ' '
                    - comparison_operator: '='
                    - whitespace: ' '
                    - column_reference:
                      - identifier: b
                      - dot: .
                      - identifier: common_id
                    end_bracket: )
            - newline: "\n"
            - join_clause:
              - keyword: JOIN
              - whitespace: ' '
              - from_expression_element:
                  table_expression:
                    table_reference:
                      identifier: c
              - whitespace: ' '
              - join_on_condition:
                  keyword: 'ON'
                  whitespace: ' '
                  bracketed:
                    start_bracket: (
                    expression:
                    - column_reference:
                      - identifier: tbl
                      - dot: .
                      - identifier: id
                    - whitespace: ' '
                    - comparison_operator: '='
                    - whitespace: ' '
                    - column_reference:
                      - identifier: c
                      - dot: .
                      - identifier: id
                    end_bracket: )
            - newline: "\n"
            - join_clause:
              - keyword: LEFT
              - whitespace: ' '
              - keyword: JOIN
              - whitespace: ' '
              - from_expression_element:
                  table_expression:
                    table_reference:
                      identifier: d
              - whitespace: ' '
              - join_on_condition:
                  keyword: 'ON'
                  whitespace: ' '
                  bracketed:
                    start_bracket: (
                    expression:
                    - column_reference:
                      - identifier: tbl
                      - dot: .
                      - identifier: id
                    - whitespace: ' '
                    - comparison_operator: '='
                    - whitespace: ' '
                    - column_reference:
                      - identifier: d
                      - dot: .
                      - identifier: other_id
                    end_bracket: )
        - newline: "\n"
        - orderby_clause:
          - keyword: ORDER
          - whitespace: ' '
          - keyword: BY
          - whitespace: ' '
          - column_reference:
            - identifier: tbl
            - dot: .
            - identifier: name
          - whitespace: ' '
          - keyword: ASC
      newline: "\n"


___________________ test__cli__command_lint_parse[command12] ___________________
----------------------------- Captured stdout call -----------------------------
[L:  1, P:  1]      |file:
[L:  1, P:  1]      |    statement:
[L:  1, P:  1]      |        select_statement:
[L:  1, P:  1]      |            select_clause:
[L:  1, P:  1]      |                keyword:                                      'SELECT'
[L:  1, P:  7]      |                [META] indent:
[L:  1, P:  7]      |                newline:                                      '\n'
[L:  2, P:  1]      |                whitespace:                                   '    '
[L:  2, P:  5]      |                select_clause_element:
[L:  2, P:  5]      |                    column_reference:
[L:  2, P:  5]      |                        identifier:                           'tbl'
[L:  2, P:  8]      |                        dot:                                  '.'
[L:  2, P:  9]      |                        identifier:                           'name'
[L:  2, P: 13]      |                comma:                                        ','
[L:  2, P: 14]      |                newline:                                      '\n'
[L:  3, P:  1]      |                whitespace:                                   '    '
[L:  3, P:  5]      |                select_clause_element:
[L:  3, P:  5]      |                    column_reference:
[L:  3, P:  5]      |                        identifier:                           'b'
[L:  3, P:  6]      |                        dot:                                  '.'
[L:  3, P:  7]      |                        identifier:                           'value'
[L:  3, P: 12]      |                comma:                                        ','
[L:  3, P: 13]      |                newline:                                      '\n'
[L:  4, P:  1]      |                whitespace:                                   '    '
[L:  4, P:  5]      |                comment:                                      '/*'
[L:  4, P:  7]      |                newline:                                      '\n'
[L:  5, P:  1]      |                whitespace:                                   '    '
[L:  5, P:  5]      |                comment:                                      'This is a block comment'
[L:  5, P: 28]      |                newline:                                      '\n'
[L:  6, P:  1]      |                whitespace:                                   '    '
[L:  6, P:  5]      |                comment:                                      '*/'
[L:  6, P:  7]      |                newline:                                      '\n'
[L:  7, P:  1]      |                whitespace:                                   '    '
[L:  7, P:  5]      |                select_clause_element:
[L:  7, P:  5]      |                    column_reference:
[L:  7, P:  5]      |                        identifier:                           'd'
[L:  7, P:  6]      |                        dot:                                  '.'
[L:  7, P:  7]      |                        identifier:                           'something'
[L:  7, P: 16]      |                comma:                                        ','
[L:  7, P: 17]      |                whitespace:                                   '    '
[L:  7, P: 21]      |                comment:                                      '-- Which a comment after it'
[L:  7, P: 48]      |                newline:                                      '\n'
[L:  8, P:  1]      |                whitespace:                                   '    '
[L:  8, P:  5]      |                select_clause_element:
[L:  8, P:  5]      |                    column_reference:
[L:  8, P:  5]      |                        identifier:                           'tbl'
[L:  8, P:  8]      |                        dot:                                  '.'
[L:  8, P:  9]      |                        identifier:                           'foo'
[L:  8, P: 12]      |                comma:                                        ','
[L:  8, P: 13]      |                newline:                                      '\n'
[L:  9, P:  1]      |                whitespace:                                   '    '
[L:  9, P:  5]      |                select_clause_element:
[L:  9, P:  5]      |                    expression:
[L:  9, P:  5]      |                        column_reference:
[L:  9, P:  5]      |                            identifier:                       'c'
[L:  9, P:  6]      |                            dot:                              '.'
[L:  9, P:  7]      |                            identifier:                       'val'
[L:  9, P: 10]      |                        whitespace:                           ' '
[L:  9, P: 11]      |                        binary_operator:                      '+'
[L:  9, P: 12]      |                        whitespace:                           ' '
[L:  9, P: 13]      |                        column_reference:
[L:  9, P: 13]      |                            identifier:                       'b'
[L:  9, P: 14]      |                            dot:                              '.'
[L:  9, P: 15]      |                            identifier:                       'val'
[L:  9, P: 18]      |                        whitespace:                           ' '
[L:  9, P: 19]      |                        binary_operator:                      '/'
[L:  9, P: 20]      |                        whitespace:                           ' '
[L:  9, P: 21]      |                        numeric_literal:
[L:  9, P: 21]      |                            binary_operator:                  '-'
[L:  9, P: 22]      |                            literal:                          '2'
[L:  9, P: 23]      |                    whitespace:                               ' '
[L:  9, P: 24]      |                    alias_expression:
[L:  9, P: 24]      |                        keyword:                              'AS'
[L:  9, P: 26]      |                        whitespace:                           ' '
[L:  9, P: 27]      |                        identifier:                           'a_calculation'
[L:  9, P: 40]      |            newline:                                          '\n'
[L: 10, P:  1]      |            [META] dedent:
[L: 10, P:  1]      |            from_clause:
[L: 10, P:  1]      |                keyword:                                      'FROM'
[L: 10, P:  5]      |                whitespace:                                   ' '
[L: 10, P:  6]      |                from_expression:
[L: 10, P:  6]      |                    [META] indent:
[L: 10, P:  6]      |                    from_expression_element:
[L: 10, P:  6]      |                        table_expression:
[L: 10, P:  6]      |                            table_reference:
[L: 10, P:  6]      |                                identifier:                   'tbl'
[L: 10, P:  9]      |                    newline:                                  '\n'
[L: 11, P:  1]      |                    [META] dedent:
[L: 11, P:  1]      |                    join_clause:
[L: 11, P:  1]      |                        keyword:                              'INNER'
[L: 11, P:  6]      |                        whitespace:                           ' '
[L: 11, P:  7]      |                        keyword:                              'JOIN'
[L: 11, P: 11]      |                        [META] indent:
[L: 11, P: 11]      |                        whitespace:                           ' '
[L: 11, P: 12]      |                        from_expression_element:
[L: 11, P: 12]      |                            table_expression:
[L: 11, P: 12]      |                                table_reference:
[L: 11, P: 12]      |                                    identifier:               'b'
[L: 11, P: 13]      |                        whitespace:                           ' '
[L: 11, P: 14]      |                        join_on_condition:
[L: 11, P: 14]      |                            keyword:                          'ON'
[L: 11, P: 16]      |                            [META] indent:
[L: 11, P: 16]      |                            whitespace:                       ' '
[L: 11, P: 17]      |                            bracketed:
[L: 11, P: 17]      |                                start_bracket:                '('
[L: 11, P: 18]      |                                [META] indent:
[L: 11, P: 18]      |                                expression:
[L: 11, P: 18]      |                                    column_reference:
[L: 11, P: 18]      |                                        identifier:           'tbl'
[L: 11, P: 21]      |                                        dot:                  '.'
[L: 11, P: 22]      |                                        identifier:           'common_id'
[L: 11, P: 31]      |                                    whitespace:               ' '
[L: 11, P: 32]      |                                    comparison_operator:      '='
[L: 11, P: 33]      |                                    whitespace:               ' '
[L: 11, P: 34]      |                                    column_reference:
[L: 11, P: 34]      |                                        identifier:           'b'
[L: 11, P: 35]      |                                        dot:                  '.'
[L: 11, P: 36]      |                                        identifier:           'common_id'
[L: 11, P: 45]      |                                [META] dedent:
[L: 11, P: 45]      |                                end_bracket:                  ')'
[L: 11, P: 46]      |                            [META] dedent:
[L: 11, P: 46]      |                        [META] dedent:
[L: 11, P: 46]      |                    newline:                                  '\n'
[L: 12, P:  1]      |                    join_clause:
[L: 12, P:  1]      |                        keyword:                              'JOIN'
[L: 12, P:  5]      |                        [META] indent:
[L: 12, P:  5]      |                        whitespace:                           ' '
[L: 12, P:  6]      |                        from_expression_element:
[L: 12, P:  6]      |                            table_expression:
[L: 12, P:  6]      |                                table_reference:
[L: 12, P:  6]      |                                    identifier:               'c'
[L: 12, P:  7]      |                        whitespace:                           ' '
[L: 12, P:  8]      |                        join_on_condition:
[L: 12, P:  8]      |                            keyword:                          'ON'
[L: 12, P: 10]      |                            [META] indent:
[L: 12, P: 10]      |                            whitespace:                       ' '
[L: 12, P: 11]      |                            bracketed:
[L: 12, P: 11]      |                                start_bracket:                '('
[L: 12, P: 12]      |                                [META] indent:
[L: 12, P: 12]      |                                expression:
[L: 12, P: 12]      |                                    column_reference:
[L: 12, P: 12]      |                                        identifier:           'tbl'
[L: 12, P: 15]      |                                        dot:                  '.'
[L: 12, P: 16]      |                                        identifier:           'id'
[L: 12, P: 18]      |                                    whitespace:               ' '
[L: 12, P: 19]      |                                    comparison_operator:      '='
[L: 12, P: 20]      |                                    whitespace:               ' '
[L: 12, P: 21]      |                                    column_reference:
[L: 12, P: 21]      |                                        identifier:           'c'
[L: 12, P: 22]      |                                        dot:                  '.'
[L: 12, P: 23]      |                                        identifier:           'id'
[L: 12, P: 25]      |                                [META] dedent:
[L: 12, P: 25]      |                                end_bracket:                  ')'
[L: 12, P: 26]      |                            [META] dedent:
[L: 12, P: 26]      |                        [META] dedent:
[L: 12, P: 26]      |                    newline:                                  '\n'
[L: 13, P:  1]      |                    join_clause:
[L: 13, P:  1]      |                        keyword:                              'LEFT'
[L: 13, P:  5]      |                        whitespace:                           ' '
[L: 13, P:  6]      |                        keyword:                              'JOIN'
[L: 13, P: 10]      |                        [META] indent:
[L: 13, P: 10]      |                        whitespace:                           ' '
[L: 13, P: 11]      |                        from_expression_element:
[L: 13, P: 11]      |                            table_expression:
[L: 13, P: 11]      |                                table_reference:
[L: 13, P: 11]      |                                    identifier:               'd'
[L: 13, P: 12]      |                        whitespace:                           ' '
[L: 13, P: 13]      |                        join_on_condition:
[L: 13, P: 13]      |                            keyword:                          'ON'
[L: 13, P: 15]      |                            [META] indent:
[L: 13, P: 15]      |                            whitespace:                       ' '
[L: 13, P: 16]      |                            bracketed:
[L: 13, P: 16]      |                                start_bracket:                '('
[L: 13, P: 17]      |                                [META] indent:
[L: 13, P: 17]      |                                expression:
[L: 13, P: 17]      |                                    column_reference:
[L: 13, P: 17]      |                                        identifier:           'tbl'
[L: 13, P: 20]      |                                        dot:                  '.'
[L: 13, P: 21]      |                                        identifier:           'id'
[L: 13, P: 23]      |                                    whitespace:               ' '
[L: 13, P: 24]      |                                    comparison_operator:      '='
[L: 13, P: 25]      |                                    whitespace:               ' '
[L: 13, P: 26]      |                                    column_reference:
[L: 13, P: 26]      |                                        identifier:           'd'
[L: 13, P: 27]      |                                        dot:                  '.'
[L: 13, P: 28]      |                                        identifier:           'other_id'
[L: 13, P: 36]      |                                [META] dedent:
[L: 13, P: 36]      |                                end_bracket:                  ')'
[L: 13, P: 37]      |                            [META] dedent:
[L: 13, P: 37]      |                        [META] dedent:
[L: 13, P: 37]      |            newline:                                          '\n'
[L: 14, P:  1]      |            orderby_clause:
[L: 14, P:  1]      |                keyword:                                      'ORDER'
[L: 14, P:  6]      |                whitespace:                                   ' '
[L: 14, P:  7]      |                keyword:                                      'BY'
[L: 14, P:  9]      |                [META] indent:
[L: 14, P:  9]      |                whitespace:                                   ' '
[L: 14, P: 10]      |                column_reference:
[L: 14, P: 10]      |                    identifier:                               'tbl'
[L: 14, P: 13]      |                    dot:                                      '.'
[L: 14, P: 14]      |                    identifier:                               'name'
[L: 14, P: 18]      |                whitespace:                                   ' '
[L: 14, P: 19]      |                keyword:                                      'ASC'
[L: 14, P: 22]      |                [META] dedent:
[L: 14, P: 22]      |    newline:                                                  '\n'

==== profiler stats ====
         336718 function calls (320158 primitive calls) in 0.132 seconds

   Ordered by: cumulative time

   ncalls  tottime  percall  cumtime  percall filename:lineno(function)
        2    0.000    0.000    0.132    0.066 /testbed/src/sqlfluff/core/linter/linter.py:854(parse_path)
        1    0.000    0.000    0.128    0.128 /testbed/src/sqlfluff/core/linter/linter.py:578(parse_string)
        1    0.000    0.000    0.123    0.123 /testbed/src/sqlfluff/core/linter/linter.py:293(parse_rendered)
        1    0.000    0.000    0.117    0.117 /testbed/src/sqlfluff/core/linter/linter.py:177(_parse_tokens)
        1    0.000    0.000    0.116    0.116 /testbed/src/sqlfluff/core/parser/parser.py:22(parse)
     20/1    0.000    0.000    0.116    0.116 /testbed/src/sqlfluff/core/parser/segments/base.py:752(parse)
     20/1    0.000    0.000    0.113    0.113 /testbed/src/sqlfluff/core/parser/segments/base.py:244(expand)
  2559/13    0.006    0.000    0.108    0.008 /testbed/src/sqlfluff/core/parser/match_wrapper.py:46(wrapped_match_method)
  2300/13    0.002    0.000    0.108    0.008 /testbed/src/sqlfluff/core/parser/segments/ephemeral.py:62(wrapped_match_method)
   360/16    0.003    0.000    0.103    0.006 /testbed/src/sqlfluff/core/parser/grammar/sequence.py:49(match)
  1215/31    0.006    0.000    0.103    0.003 /testbed/src/sqlfluff/core/parser/grammar/base.py:814(match)
   770/17    0.002    0.000    0.101    0.006 /testbed/src/sqlfluff/core/parser/grammar/base.py:187(_longest_trimmed_match)
   654/14    0.002    0.000    0.101    0.007 /testbed/src/sqlfluff/core/parser/grammar/anyof.py:151(match)
   679/16    0.002    0.000    0.101    0.006 /testbed/src/sqlfluff/core/parser/grammar/anyof.py:120(_match_once)
   181/38    0.001    0.000    0.099    0.003 /testbed/src/sqlfluff/core/parser/segments/base.py:422(match)
    30/12    0.000    0.000    0.078    0.006 /testbed/src/sqlfluff/core/parser/grammar/delimited.py:42(match)
    62/61    0.000    0.000    0.035    0.001 /testbed/src/sqlfluff/core/parser/grammar/base.py:446(_bracket_sensitive_look_ahead_match)
    68/67    0.001    0.000    0.034    0.001 /testbed/src/sqlfluff/core/parser/grammar/base.py:256(_look_ahead_match)
    33/22    0.000    0.000    0.032    0.001 /testbed/src/sqlfluff/core/parser/grammar/sequence.py:231(match)
      679    0.004    0.000    0.025    0.000 /testbed/src/sqlfluff/core/parser/grammar/anyof.py:51(_prune_options)
      679    0.003    0.000    0.010    0.000 /testbed/src/sqlfluff/core/parser/grammar/anyof.py:55(<listcomp>)
   261/22    0.001    0.000    0.009    0.000 /testbed/src/sqlfluff/core/parser/segments/base.py:548(stringify)
     2882    0.005    0.000    0.009    0.000 /testbed/src/sqlfluff/core/parser/context.py:127(_copy)
3296/2898    0.003    0.000    0.007    0.000 /testbed/src/sqlfluff/core/parser/grammar/base.py:56(wrapped_method)
     2559    0.003    0.000    0.007    0.000 /testbed/src/sqlfluff/core/parser/match_wrapper.py:14(__init__)
     1337    0.002    0.000    0.007    0.000 /testbed/src/sqlfluff/core/parser/segments/base.py:496(_preface)
    10485    0.003    0.000    0.006    0.000 /testbed/src/sqlfluff/core/parser/grammar/base.py:182(_iter_raw_segs)
        1    0.000    0.000    0.006    0.006 /testbed/src/sqlfluff/core/linter/linter.py:112(_lex_templated_file)
     1076    0.000    0.000    0.006    0.000 /testbed/src/sqlfluff/core/parser/segments/raw.py:146(stringify)
     1634    0.001    0.000    0.006    0.000 /testbed/src/sqlfluff/core/parser/context.py:146(deeper_match)
     3406    0.004    0.000    0.006    0.000 /testbed/src/sqlfluff/core/parser/match_logging.py:47(__init__)
        1    0.000    0.000    0.005    0.005 /testbed/src/sqlfluff/core/parser/lexer.py:275(lex)
     11/8    0.000    0.000    0.005    0.001 /testbed/src/sqlfluff/core/parser/grammar/greedy.py:172(match)
        1    0.000    0.000    0.005    0.005 /testbed/src/sqlfluff/core/linter/linter.py:534(render_string)
        1    0.000    0.000    0.005    0.005 /testbed/src/sqlfluff/core/templaters/jinja.py:175(process)
  372/132    0.002    0.000    0.005    0.000 /testbed/src/sqlfluff/core/parser/segments/base.py:286(_position_segments)
      705    0.001    0.000    0.005    0.000 /testbed/src/sqlfluff/core/parser/parsers.py:78(match)
      345    0.000    0.000    0.004    0.000 /testbed/src/sqlfluff/core/parser/helpers.py:22(check_still_complete)
        6    0.000    0.000    0.004    0.001 /opt/miniconda3/envs/testbed/lib/python3.9/site-packages/jinja2/environment.py:1089(from_string)
        6    0.000    0.000    0.004    0.001 /opt/miniconda3/envs/testbed/lib/python3.9/site-packages/jinja2/environment.py:728(compile)
        1    0.000    0.000    0.004    0.004 /testbed/src/sqlfluff/core/templaters/jinja.py:81(_extract_macros_from_config)
        5    0.000    0.000    0.004    0.001 /testbed/src/sqlfluff/core/templaters/jinja.py:33(_extract_macros_from_template)
      690    0.000    0.000    0.004    0.000 /testbed/src/sqlfluff/core/parser/helpers.py:12(join_segments_raw)
  915/834    0.001    0.000    0.004    0.000 {method 'join' of 'str' objects}
    11436    0.003    0.000    0.004    0.000 /testbed/src/sqlfluff/core/parser/context.py:116(__getattr__)

___________________ test__cli__command_lint_parse[command13] ___________________
----------------------------- Captured stdout call -----------------------------
[L:  1, P:  1]      |file:
[L:  1, P:  1]      |    statement:
[L:  1, P:  1]      |        select_statement:
[L:  1, P:  1]      |            select_clause:
[L:  1, P:  1]      |                keyword:                                      'SELECT'
[L:  1, P:  7]      |                [META] indent:
[L:  1, P:  7]      |                newline:                                      '\n'
[L:  2, P:  1]      |                whitespace:                                   '    '
[L:  2, P:  5]      |                select_clause_element:
[L:  2, P:  5]      |                    column_reference:
[L:  2, P:  5]      |                        identifier:                           'tbl'
[L:  2, P:  8]      |                        dot:                                  '.'
[L:  2, P:  9]      |                        identifier:                           'name'
[L:  2, P: 13]      |                comma:                                        ','
[L:  2, P: 14]      |                newline:                                      '\n'
[L:  3, P:  1]      |                whitespace:                                   '    '
[L:  3, P:  5]      |                select_clause_element:
[L:  3, P:  5]      |                    column_reference:
[L:  3, P:  5]      |                        identifier:                           'b'
[L:  3, P:  6]      |                        dot:                                  '.'
[L:  3, P:  7]      |                        identifier:                           'value'
[L:  3, P: 12]      |                comma:                                        ','
[L:  3, P: 13]      |                newline:                                      '\n'
[L:  4, P:  1]      |                whitespace:                                   '    '
[L:  4, P:  5]      |                comment:                                      '/*'
[L:  4, P:  7]      |                newline:                                      '\n'
[L:  5, P:  1]      |                whitespace:                                   '    '
[L:  5, P:  5]      |                comment:                                      'This is a block comment'
[L:  5, P: 28]      |                newline:                                      '\n'
[L:  6, P:  1]      |                whitespace:                                   '    '
[L:  6, P:  5]      |                comment:                                      '*/'
[L:  6, P:  7]      |                newline:                                      '\n'
[L:  7, P:  1]      |                whitespace:                                   '    '
[L:  7, P:  5]      |                select_clause_element:
[L:  7, P:  5]      |                    column_reference:
[L:  7, P:  5]      |                        identifier:                           'd'
[L:  7, P:  6]      |                        dot:                                  '.'
[L:  7, P:  7]      |                        identifier:                           'something'
[L:  7, P: 16]      |                comma:                                        ','
[L:  7, P: 17]      |                whitespace:                                   '    '
[L:  7, P: 21]      |                comment:                                      '-- Which a comment after it'
[L:  7, P: 48]      |                newline:                                      '\n'
[L:  8, P:  1]      |                whitespace:                                   '    '
[L:  8, P:  5]      |                select_clause_element:
[L:  8, P:  5]      |                    column_reference:
[L:  8, P:  5]      |                        identifier:                           'tbl'
[L:  8, P:  8]      |                        dot:                                  '.'
[L:  8, P:  9]      |                        identifier:                           'foo'
[L:  8, P: 12]      |                comma:                                        ','
[L:  8, P: 13]      |                newline:                                      '\n'
[L:  9, P:  1]      |                whitespace:                                   '    '
[L:  9, P:  5]      |                select_clause_element:
[L:  9, P:  5]      |                    expression:
[L:  9, P:  5]      |                        column_reference:
[L:  9, P:  5]      |                            identifier:                       'c'
[L:  9, P:  6]      |                            dot:                              '.'
[L:  9, P:  7]      |                            identifier:                       'val'
[L:  9, P: 10]      |                        whitespace:                           ' '
[L:  9, P: 11]      |                        binary_operator:                      '+'
[L:  9, P: 12]      |                        whitespace:                           ' '
[L:  9, P: 13]      |                        column_reference:
[L:  9, P: 13]      |                            identifier:                       'b'
[L:  9, P: 14]      |                            dot:                              '.'
[L:  9, P: 15]      |                            identifier:                       'val'
[L:  9, P: 18]      |                        whitespace:                           ' '
[L:  9, P: 19]      |                        binary_operator:                      '/'
[L:  9, P: 20]      |                        whitespace:                           ' '
[L:  9, P: 21]      |                        numeric_literal:
[L:  9, P: 21]      |                            binary_operator:                  '-'
[L:  9, P: 22]      |                            literal:                          '2'
[L:  9, P: 23]      |                    whitespace:                               ' '
[L:  9, P: 24]      |                    alias_expression:
[L:  9, P: 24]      |                        keyword:                              'AS'
[L:  9, P: 26]      |                        whitespace:                           ' '
[L:  9, P: 27]      |                        identifier:                           'a_calculation'
[L:  9, P: 40]      |            newline:                                          '\n'
[L: 10, P:  1]      |            [META] dedent:
[L: 10, P:  1]      |            from_clause:
[L: 10, P:  1]      |                keyword:                                      'FROM'
[L: 10, P:  5]      |                whitespace:                                   ' '
[L: 10, P:  6]      |                from_expression:
[L: 10, P:  6]      |                    [META] indent:
[L: 10, P:  6]      |                    from_expression_element:
[L: 10, P:  6]      |                        table_expression:
[L: 10, P:  6]      |                            table_reference:
[L: 10, P:  6]      |                                identifier:                   'tbl'
[L: 10, P:  9]      |                    newline:                                  '\n'
[L: 11, P:  1]      |                    [META] dedent:
[L: 11, P:  1]      |                    join_clause:
[L: 11, P:  1]      |                        keyword:                              'INNER'
[L: 11, P:  6]      |                        whitespace:                           ' '
[L: 11, P:  7]      |                        keyword:                              'JOIN'
[L: 11, P: 11]      |                        [META] indent:
[L: 11, P: 11]      |                        whitespace:                           ' '
[L: 11, P: 12]      |                        from_expression_element:
[L: 11, P: 12]      |                            table_expression:
[L: 11, P: 12]      |                                table_reference:
[L: 11, P: 12]      |                                    identifier:               'b'
[L: 11, P: 13]      |                        whitespace:                           ' '
[L: 11, P: 14]      |                        join_on_condition:
[L: 11, P: 14]      |                            keyword:                          'ON'
[L: 11, P: 16]      |                            [META] indent:
[L: 11, P: 16]      |                            whitespace:                       ' '
[L: 11, P: 17]      |                            bracketed:
[L: 11, P: 17]      |                                start_bracket:                '('
[L: 11, P: 18]      |                                [META] indent:
[L: 11, P: 18]      |                                expression:
[L: 11, P: 18]      |                                    column_reference:
[L: 11, P: 18]      |                                        identifier:           'tbl'
[L: 11, P: 21]      |                                        dot:                  '.'
[L: 11, P: 22]      |                                        identifier:           'common_id'
[L: 11, P: 31]      |                                    whitespace:               ' '
[L: 11, P: 32]      |                                    comparison_operator:      '='
[L: 11, P: 33]      |                                    whitespace:               ' '
[L: 11, P: 34]      |                                    column_reference:
[L: 11, P: 34]      |                                        identifier:           'b'
[L: 11, P: 35]      |                                        dot:                  '.'
[L: 11, P: 36]      |                                        identifier:           'common_id'
[L: 11, P: 45]      |                                [META] dedent:
[L: 11, P: 45]      |                                end_bracket:                  ')'
[L: 11, P: 46]      |                            [META] dedent:
[L: 11, P: 46]      |                        [META] dedent:
[L: 11, P: 46]      |                    newline:                                  '\n'
[L: 12, P:  1]      |                    join_clause:
[L: 12, P:  1]      |                        keyword:                              'JOIN'
[L: 12, P:  5]      |                        [META] indent:
[L: 12, P:  5]      |                        whitespace:                           ' '
[L: 12, P:  6]      |                        from_expression_element:
[L: 12, P:  6]      |                            table_expression:
[L: 12, P:  6]      |                                table_reference:
[L: 12, P:  6]      |                                    identifier:               'c'
[L: 12, P:  7]      |                        whitespace:                           ' '
[L: 12, P:  8]      |                        join_on_condition:
[L: 12, P:  8]      |                            keyword:                          'ON'
[L: 12, P: 10]      |                            [META] indent:
[L: 12, P: 10]      |                            whitespace:                       ' '
[L: 12, P: 11]      |                            bracketed:
[L: 12, P: 11]      |                                start_bracket:                '('
[L: 12, P: 12]      |                                [META] indent:
[L: 12, P: 12]      |                                expression:
[L: 12, P: 12]      |                                    column_reference:
[L: 12, P: 12]      |                                        identifier:           'tbl'
[L: 12, P: 15]      |                                        dot:                  '.'
[L: 12, P: 16]      |                                        identifier:           'id'
[L: 12, P: 18]      |                                    whitespace:               ' '
[L: 12, P: 19]      |                                    comparison_operator:      '='
[L: 12, P: 20]      |                                    whitespace:               ' '
[L: 12, P: 21]      |                                    column_reference:
[L: 12, P: 21]      |                                        identifier:           'c'
[L: 12, P: 22]      |                                        dot:                  '.'
[L: 12, P: 23]      |                                        identifier:           'id'
[L: 12, P: 25]      |                                [META] dedent:
[L: 12, P: 25]      |                                end_bracket:                  ')'
[L: 12, P: 26]      |                            [META] dedent:
[L: 12, P: 26]      |                        [META] dedent:
[L: 12, P: 26]      |                    newline:                                  '\n'
[L: 13, P:  1]      |                    join_clause:
[L: 13, P:  1]      |                        keyword:                              'LEFT'
[L: 13, P:  5]      |                        whitespace:                           ' '
[L: 13, P:  6]      |                        keyword:                              'JOIN'
[L: 13, P: 10]      |                        [META] indent:
[L: 13, P: 10]      |                        whitespace:                           ' '
[L: 13, P: 11]      |                        from_expression_element:
[L: 13, P: 11]      |                            table_expression:
[L: 13, P: 11]      |                                table_reference:
[L: 13, P: 11]      |                                    identifier:               'd'
[L: 13, P: 12]      |                        whitespace:                           ' '
[L: 13, P: 13]      |                        join_on_condition:
[L: 13, P: 13]      |                            keyword:                          'ON'
[L: 13, P: 15]      |                            [META] indent:
[L: 13, P: 15]      |                            whitespace:                       ' '
[L: 13, P: 16]      |                            bracketed:
[L: 13, P: 16]      |                                start_bracket:                '('
[L: 13, P: 17]      |                                [META] indent:
[L: 13, P: 17]      |                                expression:
[L: 13, P: 17]      |                                    column_reference:
[L: 13, P: 17]      |                                        identifier:           'tbl'
[L: 13, P: 20]      |                                        dot:                  '.'
[L: 13, P: 21]      |                                        identifier:           'id'
[L: 13, P: 23]      |                                    whitespace:               ' '
[L: 13, P: 24]      |                                    comparison_operator:      '='
[L: 13, P: 25]      |                                    whitespace:               ' '
[L: 13, P: 26]      |                                    column_reference:
[L: 13, P: 26]      |                                        identifier:           'd'
[L: 13, P: 27]      |                                        dot:                  '.'
[L: 13, P: 28]      |                                        identifier:           'other_id'
[L: 13, P: 36]      |                                [META] dedent:
[L: 13, P: 36]      |                                end_bracket:                  ')'
[L: 13, P: 37]      |                            [META] dedent:
[L: 13, P: 37]      |                        [META] dedent:
[L: 13, P: 37]      |            newline:                                          '\n'
[L: 14, P:  1]      |            orderby_clause:
[L: 14, P:  1]      |                keyword:                                      'ORDER'
[L: 14, P:  6]      |                whitespace:                                   ' '
[L: 14, P:  7]      |                keyword:                                      'BY'
[L: 14, P:  9]      |                [META] indent:
[L: 14, P:  9]      |                whitespace:                                   ' '
[L: 14, P: 10]      |                column_reference:
[L: 14, P: 10]      |                    identifier:                               'tbl'
[L: 14, P: 13]      |                    dot:                                      '.'
[L: 14, P: 14]      |                    identifier:                               'name'
[L: 14, P: 18]      |                whitespace:                                   ' '
[L: 14, P: 19]      |                keyword:                                      'ASC'
[L: 14, P: 22]      |                [META] dedent:
[L: 14, P: 22]      |    newline:                                                  '\n'

==== overall timings ====
Clock time:     0.06
=== templating ===
cnt:               1 sum:            0.00
min:            0.00 max:            0.00
avg:            0.00
=== lexing ===
cnt:               1 sum:            0.00
min:            0.00 max:            0.00
avg:            0.00
=== parsing ===
cnt:               1 sum:            0.05
min:            0.05 max:            0.05
avg:            0.05

___________________ test__cli__command_lint_parse[command14] ___________________
----------------------------- Captured stdout call -----------------------------
==== overall timings ====
Clock time:     0.15
=== templating ===
cnt:               1 sum:            0.00
min:            0.00 max:            0.00
avg:            0.00
=== lexing ===
cnt:               1 sum:            0.00
min:            0.00 max:            0.00
avg:            0.00
=== parsing ===
cnt:               1 sum:            0.05
min:            0.05 max:            0.05
avg:            0.05
=== linting ===
cnt:               1 sum:            0.09
min:            0.09 max:            0.09
avg:            0.09
All Finished!

___________________ test__cli__command_lint_parse[command15] ___________________
----------------------------- Captured stdout call -----------------------------
==== finding fixable violations ====
==== no fixable linting violations found ====
All Finished!
==== overall timings ====
Clock time:     0.17
=== templating ===
cnt:               1 sum:            0.00
min:            0.00 max:            0.00
avg:            0.00
=== lexing ===
cnt:               1 sum:            0.02
min:            0.02 max:            0.02
avg:            0.02
=== parsing ===
cnt:               1 sum:            0.05
min:            0.05 max:            0.05
avg:            0.05
=== linting ===
cnt:               1 sum:            0.09
min:            0.09 max:            0.09
avg:            0.09

___________________ test__cli__command_lint_parse[command16] ___________________
----------------------------- Captured stdout call -----------------------------
All Finished!

___________________ test__cli__command_lint_parse[command17] ___________________
----------------------------- Captured stdout call -----------------------------
All Finished!

___________________ test__cli__command_lint_parse[command18] ___________________
----------------------------- Captured stdout call -----------------------------
All Finished!

___________________ test__cli__command_lint_parse[command19] ___________________
----------------------------- Captured stdout call -----------------------------
All Finished!

___________________ test__cli__command_lint_parse[command20] ___________________
----------------------------- Captured stdout call -----------------------------
All Finished!

___________________ test__cli__command_lint_parse[command21] ___________________
----------------------------- Captured stdout call -----------------------------
== [test/fixtures/linter/parse_lex_error.sql] FAIL
L:   5 | P:   4 | L003 | Indentation not hanging or a multiple of 4 spaces
L:   8 | P:  19 |  PRS | Line 8, Position 19: Found unparsable section: 'SELECT'
L:   8 | P:  25 |  PRS | Line 8, Position 25: Found unparsable section: ' LIMIT
                       | WHERE BY ORDER'
L:   9 | P:   5 | L003 | Indentation not consistent with line #4
L:   9 | P:  22 |  LXR | Unable to lex characters: '\uf8ffü§∑‚Äç‚ôÄ...'
L:   9 | P:  22 |  PRS | Line 9, Position 22: Found unparsable section:
                       | '\uf8ffü§∑‚Äç‚ôÄÔ∏è'
L:  10 | P:  13 | L009 | Files must end with a trailing newline.
L:  10 | P:  13 | L031 | Avoid using aliases in join condition
WARNING: Parsing errors found and dialect is set to 'ansi'. Have you configured your dialect?

____________ test__cli__command_lint_parse_with_retcode[command0-1] ____________
----------------------------- Captured stdout call -----------------------------
==== sqlfluff ====
sqlfluff:              0.7.0a8 python:                 3.9.20
implementation:        cpython dialect:                  ansi
verbosity:                   7 templater:               jinja
rules:                               L001
== Raw Config:
core:                                   
    dialect:            ansi                
    encoding:           autodetect          
    ignore:             []                  
    ignore_templated_areas:True                
    nocolor:            False               
    output_line_length: 80                  
    recurse:            True                
    rules:              L001                
    runaway_limit:      10                  
    sql_file_exts:      .sql,.sql.j2,.dml,.ddl
    templater:          jinja               
    verbose:            7                   
indentation:                            
    indented_joins:     False               
    indented_using_on:  True                
    template_blocks_indent:True                
rules:                                  
    allow_scalar:       True                
    comma_style:        trailing            
    indent_unit:        space               
    max_line_length:    80                  
    single_table_references:consistent          
    tab_space_size:     4                   
    unquoted_identifiers_policy:all                 
    L007:                                   
        operator_new_lines: after               
    L010:                                   
        capitalisation_policy:consistent          
    L011:                                   
        aliasing:           explicit            
    L012:                                   
        aliasing:           explicit            
    L014:                                   
        extended_capitalisation_policy:consistent          
    L016:                                   
        ignore_comment_lines:False               
    L026:                                   
        force_enable:       False               
    L028:                                   
        force_enable:       False               
    L029:                                   
        unquoted_identifiers_policy:aliases             
    L030:                                   
        capitalisation_policy:consistent          
    L038:                                   
        select_clause_trailing_comma:forbid              
    L040:                                   
        capitalisation_policy:consistent          
    L042:                                   
        forbid_subquery_in: join                
    L047:                                   
        prefer_count_0:     False               
        prefer_count_1:     False               
templater:                              
    unwrap_wrapped_queries:True                
    jinja:                                  
        apply_dbt_builtins: True                
        macros:                                 
            dbt_config:         {% macro config() %}{% for k in kwargs %}{% endfor %}{% endmacro %}
            dbt_is_incremental: {% macro is_incremental() %}True{% endmacro %}
            dbt_ref:            {% macro ref(model_ref) %}{{model_ref}}{% endmacro %}
            dbt_source:         {% macro source(source_name, table) %}{{source_name}}_{{table}}{% endmacro %}
            dbt_var:            {% macro var(variable, default='') %}item{% endmacro %}

==== finding fixable violations ====
=== [ path: test/fixtures/cli/fail_many.sql ] ===

INFO       TEMPLATING RAW [jinja] (test/fixtures/cli/fail_many.sql)
INFO       Slicing File Template
DEBUG          Raw String: '-- File which fails on templating and lexing errors.\nSELECT\n    {{ something }} as trailing_space   ,\n    3 + FROM SELECT FROM\n'
DEBUG          Templated String: '-- File which fails on templating and lexing errors.\nSELECT\n     as trailing_space   ,\n    3 + FROM SELECT FROM\n'
DEBUG          Raw Sliced:
DEBUG              0: RawFileSlice(raw='-- File which fails on templating and lexing errors.\nSELECT\n    ', slice_type='literal', source_idx=0, slice_subtype=None)
DEBUG              1: RawFileSlice(raw='{{ something }}', slice_type='templated', source_idx=64, slice_subtype=None)
DEBUG              2: RawFileSlice(raw=' as trailing_space   ,\n    3 + FROM SELECT FROM\n', slice_type='literal', source_idx=79, slice_subtype=None)
DEBUG          Literals: ['-- File which fails on templating and lexing errors.\nSELECT\n    ', ' as trailing_space   ,\n    3 + FROM SELECT FROM\n']
DEBUG          # Slice Loop 0
DEBUG          Occurrences: Raw: {'-- File which fails on templating and lexing errors.\nSELECT\n    ': [0], ' as trailing_space   ,\n    3 + FROM SELECT FROM\n': [79]}, Templated: {'-- File which fails on templating and lexing errors.\nSELECT\n    ': [0], ' as trailing_space   ,\n    3 + FROM SELECT FROM\n': [64]}
DEBUG          Split Sliced:
DEBUG              0: IntermediateFileSlice(intermediate_type='invariant', source_slice=slice(0, 64, None), templated_slice=slice(0, 64, None), slice_buffer=[RawFileSlice(raw='-- File which fails on templating and lexing errors.\nSELECT\n    ', slice_type='literal', source_idx=0, slice_subtype=None)])
DEBUG              1: IntermediateFileSlice(intermediate_type='compound', source_slice=slice(64, 79, None), templated_slice=slice(64, 64, None), slice_buffer=[RawFileSlice(raw='{{ something }}', slice_type='templated', source_idx=64, slice_subtype=None)])
DEBUG              2: IntermediateFileSlice(intermediate_type='invariant', source_slice=slice(79, 127, None), templated_slice=slice(64, 112, None), slice_buffer=[RawFileSlice(raw=' as trailing_space   ,\n    3 + FROM SELECT FROM\n', slice_type='literal', source_idx=64, slice_subtype=None)])
DEBUG          _split_uniques_coalesce_rest: [IntermediateFileSlice(intermediate_type='invariant', source_slice=slice(0, 64, None), templated_slice=slice(0, 64, None), slice_buffer=[RawFileSlice(raw='-- File which fails on templating and lexing errors.\nSELECT\n    ', slice_type='literal', source_idx=0, slice_subtype=None)]), IntermediateFileSlice(intermediate_type='compound', source_slice=slice(64, 79, None), templated_slice=slice(64, 64, None), slice_buffer=[RawFileSlice(raw='{{ something }}', slice_type='templated', source_idx=64, slice_subtype=None)]), IntermediateFileSlice(intermediate_type='invariant', source_slice=slice(79, 127, None), templated_slice=slice(64, 112, None), slice_buffer=[RawFileSlice(raw=' as trailing_space   ,\n    3 + FROM SELECT FROM\n', slice_type='literal', source_idx=64, slice_subtype=None)])]
DEBUG              Yielding Simple: TemplatedFileSlice(slice_type='literal', source_slice=slice(0, 64, None), templated_slice=slice(0, 64, None))
DEBUG              Yielding Point Combination: TemplatedFileSlice(slice_type='templated', source_slice=slice(64, 79, None), templated_slice=slice(64, 64, None))
DEBUG              Yielding Simple: TemplatedFileSlice(slice_type='literal', source_slice=slice(79, 127, None), templated_slice=slice(64, 112, None))
DEBUG          Fully Sliced:
DEBUG              0: TemplatedFileSlice(slice_type='literal', source_slice=slice(0, 64, None), templated_slice=slice(0, 64, None))
DEBUG              1: TemplatedFileSlice(slice_type='templated', source_slice=slice(64, 79, None), templated_slice=slice(64, 64, None))
DEBUG              2: TemplatedFileSlice(slice_type='literal', source_slice=slice(79, 127, None), templated_slice=slice(64, 112, None))
INFO       [L001] No config_keywords defined for L001
INFO       LEXING RAW (test/fixtures/cli/fail_many.sql)
INFO       Elements to Segments.
INFO       Source-only slices: []
DEBUG        0, TemplateElement(raw='-- File which fails on templating and lexing errors.', template_slice=slice(0, 52, None), matcher=<RegexLexer: inline_comment>), slice(0, 52, None), '-- File which fails on templating and lexing errors.'
DEBUG        1, TemplateElement(raw='\n', template_slice=slice(52, 53, None), matcher=<RegexLexer: newline>), slice(52, 53, None), '\n'
DEBUG        2, TemplateElement(raw='SELECT', template_slice=slice(53, 59, None), matcher=<RegexLexer: code>), slice(53, 59, None), 'SELECT'
DEBUG        3, TemplateElement(raw='\n', template_slice=slice(59, 60, None), matcher=<RegexLexer: newline>), slice(59, 60, None), '\n'
DEBUG        4, TemplateElement(raw='     ', template_slice=slice(60, 65, None), matcher=<RegexLexer: whitespace>), slice(60, 80, None), '     '
DEBUG        5, TemplateElement(raw='as', template_slice=slice(65, 67, None), matcher=<RegexLexer: code>), slice(80, 82, None), 'as'
DEBUG        6, TemplateElement(raw=' ', template_slice=slice(67, 68, None), matcher=<RegexLexer: whitespace>), slice(82, 83, None), ' '
DEBUG        7, TemplateElement(raw='trailing_space', template_slice=slice(68, 82, None), matcher=<RegexLexer: code>), slice(83, 97, None), 'trailing_space'
DEBUG        8, TemplateElement(raw='   ', template_slice=slice(82, 85, None), matcher=<RegexLexer: whitespace>), slice(97, 100, None), '   '
DEBUG        9, TemplateElement(raw=',', template_slice=slice(85, 86, None), matcher=<StringLexer: comma>), slice(100, 101, None), ','
DEBUG        10, TemplateElement(raw='\n', template_slice=slice(86, 87, None), matcher=<RegexLexer: newline>), slice(101, 102, None), '\n'
DEBUG        11, TemplateElement(raw='    ', template_slice=slice(87, 91, None), matcher=<RegexLexer: whitespace>), slice(102, 106, None), '    '
DEBUG        12, TemplateElement(raw='3', template_slice=slice(91, 92, None), matcher=<RegexLexer: numeric_literal>), slice(106, 107, None), '3'
DEBUG        13, TemplateElement(raw=' ', template_slice=slice(92, 93, None), matcher=<RegexLexer: whitespace>), slice(107, 108, None), ' '
DEBUG        14, TemplateElement(raw='+', template_slice=slice(93, 94, None), matcher=<StringLexer: plus>), slice(108, 109, None), '+'
DEBUG        15, TemplateElement(raw=' ', template_slice=slice(94, 95, None), matcher=<RegexLexer: whitespace>), slice(109, 110, None), ' '
DEBUG        16, TemplateElement(raw='FROM', template_slice=slice(95, 99, None), matcher=<RegexLexer: code>), slice(110, 114, None), 'FROM'
DEBUG        17, TemplateElement(raw=' ', template_slice=slice(99, 100, None), matcher=<RegexLexer: whitespace>), slice(114, 115, None), ' '
DEBUG        18, TemplateElement(raw='SELECT', template_slice=slice(100, 106, None), matcher=<RegexLexer: code>), slice(115, 121, None), 'SELECT'
DEBUG        19, TemplateElement(raw=' ', template_slice=slice(106, 107, None), matcher=<RegexLexer: whitespace>), slice(121, 122, None), ' '
DEBUG        20, TemplateElement(raw='FROM', template_slice=slice(107, 111, None), matcher=<RegexLexer: code>), slice(122, 126, None), 'FROM'
DEBUG        21, TemplateElement(raw='\n', template_slice=slice(111, 112, None), matcher=<RegexLexer: newline>), slice(126, 127, None), '\n'
INFO       Lexed tokens: ['-- File which fails on templating and lexing errors.', '\n', 'SELECT', '\n', '     ', 'as', ' ', 'trailing_space', '   ', ',', '\n', '    ', '3', ' ', '+', ' ', 'FROM', ' ', 'SELECT', ' ', 'FROM', '\n']
INFO       PARSING (test/fixtures/cli/fail_many.sql)
DEBUG      [PD:0  MD:1 ]	.FileSegment                                      	Delim._look_ahead_match IN	    	[ls=19, seg='SELECT\n     as trail...']
DEBUG      [PD:0  MD:1 ]	.FileSegment                                      	Delim._look_ahead_match SI	    	[mq=[], sb=['SELECT', '', '', 'AS', '', 'TRAILING_SPACE', '', ',', '', '', '3', '', '+', '', 'FROM', '', 'SELECT', '', 'FROM']]
DEBUG      [PD:0  MD:1 ]	.FileSegment                                      	Delim._look_ahead_match SC	    	[bsm=None]
DEBUG      [PD:0  MD:3 ]	...StatementSegment                               	Greed._look_ahead_match IN	    	[ls=19, seg='SELECT\n     as trail...']
DEBUG      [PD:0  MD:3 ]	...StatementSegment                               	Greed._look_ahead_match SI	    	[mq=[], sb=['SELECT', '', '', 'AS', '', 'TRAILING_SPACE', '', ',', '', '', '3', '', '+', '', 'FROM', '', 'SELECT', '', 'FROM']]
DEBUG      [PD:0  MD:3 ]	...StatementSegment                               	Greed._look_ahead_match SC	    	[bsm=None]
INFO       [PD:0  MD:2 ]	..StatementSegment                                	Greed.match OUT     	++  	[match=<MatchResult 19/19: 'SELECT\n     as ...ROM SELECT FROM'>, seg="'SELECT\\n     as trail...'"]
DEBUG      [PD:0  MD:1 ]	.StatementSegment                                 	State.match OUT     	++  	[match=<MatchResult 1/1: 'SELECT\n     as ...ROM SELECT FROM'>, seg="'SELECT\\n     as trail...'"]
DEBUG      [PD:0  MD:1 ]	.FileSegment                                      	Ref.match OUT       	++  	[match=<MatchResult 1/1: 'SELECT\n     as ...ROM SELECT FROM'>, seg="'SELECT\\n     as trail...'"]
INFO       [PD:0  MD:0 ]	FileSegment                                       	Delim.match OUT     	++  	[match=<MatchResult 1/1: 'SELECT\n     as ...ROM SELECT FROM'>, seg="'SELECT\\n     as trail...'"]
DEBUG      FileSegment.parse: Done Parse. Plotting Recursion. Recurse=True
DEBUG      ###
#
# Beginning Parse Depth 1: FileSegment
#
###
Initial Structure:
[L:  1, P:  1]      |file:
[L:  1, P:  1]      |    comment:                                                  '-- File which fails on templating and lexing errors.'
[L:  1, P: 53]      |    newline:                                                  '\n'
[L:  2, P:  1]      |    statement:
[L:  2, P:  1]      |        raw:                                                  'SELECT'
[L:  2, P:  7]      |        newline:                                              '\n'
[L:  3, P:  1]      |        whitespace:                                           '     '
[L:  3, P: 21]      |        raw:                                                  'as'
[L:  3, P: 23]      |        whitespace:                                           ' '
[L:  3, P: 24]      |        raw:                                                  'trailing_space'
[L:  3, P: 38]      |        whitespace:                                           '   '
[L:  3, P: 41]      |        comma:                                                ','
[L:  3, P: 42]      |        newline:                                              '\n'
[L:  4, P:  1]      |        whitespace:                                           '    '
[L:  4, P:  5]      |        raw:                                                  '3'
[L:  4, P:  6]      |        whitespace:                                           ' '
[L:  4, P:  7]      |        raw:                                                  '+'
[L:  4, P:  8]      |        whitespace:                                           ' '
[L:  4, P:  9]      |        raw:                                                  'FROM'
[L:  4, P: 13]      |        whitespace:                                           ' '
[L:  4, P: 14]      |        raw:                                                  'SELECT'
[L:  4, P: 20]      |        whitespace:                                           ' '
[L:  4, P: 21]      |        raw:                                                  'FROM'
[L:  4, P: 25]      |    newline:                                                  '\n'

INFO       [PD:1] Skipping expansion of <CommentSegment: ([L:  1, P:  1]) '-- File which fails on templating and lexing errors.'>...
INFO       [PD:1] Skipping expansion of <NewlineSegment: ([L:  1, P: 53]) '\n'>...
INFO       
###
#
# Parse Depth 1. Expanding: StatementSegment: 'SELECT\n     as trailing_space   ,\n    3 ...'
#
###
INFO       [PD:1  MD:0 ]	StatementSegment                                  	OneOf.match PRN     	    	[ns=0, ps=28, ms=1, pruned=[<Ref: InsertStatementSegment>, <Ref: TransactionStatementSegment>, <Ref: DropStatementSegment>, <Ref: TruncateStatementSegment>, <Ref: AccessStatementSegment>, <Ref: CreateTableStatementSegment>, <Ref: CreateTypeStatementSegment>, <Ref: CreateRoleStatementSegment>, <Ref: AlterTableStatementSegment>, <Ref: CreateSchemaStatementSegment>, <Ref: SetSchemaStatementSegment>, <Ref: DropSchemaStatementSegment>, <Ref: CreateDatabaseStatementSegment>, <Ref: CreateExtensionStatementSegment>, <Ref: CreateIndexStatementSegment>, <Ref: DropIndexStatementSegment>, <Ref: CreateViewStatementSegment>, <Ref: DeleteStatementSegment>, <Ref: UpdateStatementSegment>, <Ref: CreateFunctionStatementSegment>, <Ref: CreateModelStatementSegment>, <Ref: DropModelStatementSegment>, <Ref: DescribeStatementSegment>, <Ref: UseStatementSegment>, <Ref: ExplainStatementSegment>, <Ref: CreateSequenceStatementSegment>, <Ref: AlterSequenceStatementSegment>, <Ref: DropSequenceStatementSegment>], opts=[<Ref: SelectableGrammar>]]
INFO       [PD:1  MD:1 ]	.SelectableGrammar                                	OneOf.match PRN     	    	[ns=0, ps=1, ms=1, pruned=[<Ref: WithCompoundStatementSegment>], opts=[<Ref: NonWithSelectableGrammar>]]
INFO       [PD:1  MD:2 ]	..NonWithSelectableGrammar                        	OneOf.match PRN     	    	[ns=0, ps=0, ms=3, pruned=[], opts=[<Ref: SetExpressionSegment>, <OptionallyBracketed: [<Bracketed: [<Ref: SelectStatementSegmen..., <Ref: SelectStatementSegment>]>, <Ref: NonSetSelectableGrammar>]]
INFO       [PD:1  MD:5 ]	.....NonSetSelectableGrammar                      	OneOf.match PRN     	    	[ns=0, ps=2, ms=1, pruned=[<Ref: ValuesClauseSegment>, <Bracketed: [<Ref: SelectStatementSegment>]>], opts=[<Ref: UnorderedSelectStatementSegment>]]
DEBUG      [PD:1  MD:11]	...........SelectClauseSegment                    	Ref.match OUT       	+   	[match=<MatchResult 1/19: 'SELECT'>, seg="'SELECT\\n     as trail...'"]
INFO       [PD:1  MD:15]	...............WildcardIdentifierSegment          	AnyNu.match PRN     	    	[ns=1, ps=0, ms=0, pruned=[], opts=[<Sequence: [<Ref: SingleIdentifierGrammar>, <Ref: DotSegment>]>]]
INFO       [PD:1  MD:17]	.................SingleIdentifierGrammar          	OneOf.match PRN     	    	[ns=2, ps=0, ms=0, pruned=[], opts=[<Ref: NakedIdentifierSegment>, <Ref: QuotedIdentifierSegment>]]
DEBUG      [PD:1  MD:18]	..................SingleIdentifierGrammar         	Ref.match OUT       	+   	[match=<MatchResult 1/16: 'as'>, seg="'as trailing_space   ...'"]
DEBUG      [PD:1  MD:18]	..................SingleIdentifierGrammar         	Ref.match OUT       	    	[match=<MatchResult 0/16: ''>, seg="'as trailing_space   ...'"]
INFO       [PD:1  MD:17]	.................SingleIdentifierGrammar          	OneOf.match OUT     	+   	[match=<MatchResult 1/16: 'as'>, seg="'as trailing_space   ...'"]
DEBUG      [PD:1  MD:17]	.................WildcardIdentifierSegment        	Ref.match OUT       	+   	[match=<MatchResult 1/16: 'as'>, seg="'as trailing_space   ...'"]
DEBUG      [PD:1  MD:17]	.................WildcardIdentifierSegment        	Ref.match OUT       	    	[match=<MatchResult 0/14: ''>, seg="'trailing_space   ,\\n ...'"]
INFO       [PD:1  MD:16]	................WildcardIdentifierSegment         	Seque.match OUT     	    	[match=<MatchResult 0/16: ''>, seg="'as trailing_space   ...'"]
INFO       [PD:1  MD:15]	...............WildcardIdentifierSegment          	AnyNu.match OUT     	    	[match=<MatchResult 0/16: ''>, seg="'as trailing_space   ...'"]
DEBUG      [PD:1  MD:15]	...............WildcardIdentifierSegment          	Ref.match OUT       	    	[match=<MatchResult 0/16: ''>, seg="'as trailing_space   ...'"]
INFO       [PD:1  MD:14]	..............WildcardIdentifierSegment           	Seque.match OUT     	    	[match=<MatchResult 0/16: ''>, seg="'as trailing_space   ...'"]
DEBUG      [PD:1  MD:13]	.............WildcardIdentifierSegment            	Wildc.match OUT     	    	[match=<MatchResult 0/16: ''>, seg="'as trailing_space   ...'"]
DEBUG      [PD:1  MD:13]	.............WildcardExpressionSegment            	Ref.match OUT       	    	[match=<MatchResult 0/16: ''>, seg="'as trailing_space   ...'"]
INFO       [PD:1  MD:12]	............WildcardExpressionSegment             	Seque.match OUT     	    	[match=<MatchResult 0/16: ''>, seg="'as trailing_space   ...'"]
DEBUG      [PD:1  MD:11]	...........WildcardExpressionSegment              	Wildc.match OUT     	    	[match=<MatchResult 0/16: ''>, seg="'as trailing_space   ...'"]
DEBUG      [PD:1  MD:11]	...........SelectClauseSegment                    	Ref.match OUT       	    	[match=<MatchResult 0/16: ''>, seg="'as trailing_space   ...'"]
INFO       [PD:1  MD:10]	..........SelectClauseSegment                     	Seque.match OUT     	+   	[match=<MatchResult 1/19: 'SELECT'>, seg="'SELECT\\n     as trail...'"]
DEBUG      [PD:1  MD:10]	..........SelectClauseSegment                     	Start._look_ahead_match IN	    	[ls=18, seg='\n     as trailing_sp...']
DEBUG      [PD:1  MD:10]	..........SelectClauseSegment                     	Start._look_ahead_match SI	    	[mq=[(<OneOf: [<Ref: FromKeywordSegment>, <Ref: WhereKeywordSegment>, <Ref: OrderKeywordSegment>, <Ref: LimitKeywor...]>, 13, 'FROM'), (<OneOf: [<Ref: FromKeywordSegment>, <Ref: WhereKeywordSegment>, <Ref: OrderKeywordSegment>, <Ref: LimitKeywor...]>, 17, 'FROM')], sb=['', '', 'AS', '', 'TRAILING_SPACE', '', ',', '', '', '3', '', '+', '', 'FROM', '', 'SELECT', '', 'FROM']]
INFO       [PD:1  MD:10]	..........SelectClauseSegment                     	OneOf.match PRN     	    	[ns=0, ps=5, ms=1, pruned=[<Ref: WhereKeywordSegment>, <Ref: OrderKeywordSegment>, <Ref: LimitKeywordSegment>, <Ref: OverlapsKeywordSegment>, <Ref: SetOperatorSegment>], opts=[<Ref: FromKeywordSegment>]]
DEBUG      [PD:1  MD:11]	...........SelectClauseSegment                    	Ref.match OUT       	++  	[match=<MatchResult 1/1: 'FROM'>, seg="'FROM'"]
INFO       [PD:1  MD:10]	..........SelectClauseSegment                     	OneOf.match OUT     	++  	[match=<MatchResult 1/1: 'FROM'>, seg="'FROM'"]
INFO       [PD:1  MD:10]	..........SelectClauseSegment                     	OneOf.match PRN     	    	[ns=0, ps=5, ms=1, pruned=[<Ref: WhereKeywordSegment>, <Ref: OrderKeywordSegment>, <Ref: LimitKeywordSegment>, <Ref: OverlapsKeywordSegment>, <Ref: SetOperatorSegment>], opts=[<Ref: FromKeywordSegment>]]
DEBUG      [PD:1  MD:11]	...........SelectClauseSegment                    	Ref.match OUT       	+   	[match=<MatchResult 1/5: 'FROM'>, seg="'FROM SELECT FROM'"]
INFO       [PD:1  MD:10]	..........SelectClauseSegment                     	OneOf.match OUT     	+   	[match=<MatchResult 1/5: 'FROM'>, seg="'FROM SELECT FROM'"]
DEBUG      [PD:1  MD:10]	..........SelectClauseSegment                     	Start._look_ahead_match SC	    	[bsm=(13, 1, <OneOf: [<Ref: FromKeywordSegment>, <Ref: WhereKeywordSegment>, <Ref: OrderKeywordSegment>, <Ref: LimitKeywor...]>)]
INFO       [PD:1  MD:9 ]	.........SelectClauseSegment                      	Start.match OUT     	+   	[match=<MatchResult 13/19: 'SELECT\n     as ...ace   ,\n    3 +'>, seg="'SELECT\\n     as trail...'"]
DEBUG      [PD:1  MD:8 ]	........SelectClauseSegment                       	Selec.match OUT     	+   	[match=<MatchResult 1/7: 'SELECT\n     as ...ace   ,\n    3 +'>, seg="'SELECT\\n     as trail...'"]
DEBUG      [PD:1  MD:8 ]	........UnorderedSelectStatementSegment           	Ref.match OUT       	+   	[match=<MatchResult 1/7: 'SELECT\n     as ...ace   ,\n    3 +'>, seg="'SELECT\\n     as trail...'"]
DEBUG      [PD:1  MD:8 ]	........UnorderedSelectStatementSegment           	Start._look_ahead_match IN	    	[ls=6, seg=' FROM SELECT FROM']
DEBUG      [PD:1  MD:8 ]	........UnorderedSelectStatementSegment           	Start._look_ahead_match SI	    	[mq=[], sb=['', 'FROM', '', 'SELECT', '', 'FROM']]
DEBUG      [PD:1  MD:8 ]	........UnorderedSelectStatementSegment           	Start._look_ahead_match SC	    	[bsm=None]
INFO       [PD:1  MD:7 ]	.......UnorderedSelectStatementSegment            	Start.match OUT     	++  	[match=<MatchResult 7/7: 'SELECT\n     as ...ROM SELECT FROM'>, seg="'SELECT\\n     as trail...'"]
DEBUG      [PD:1  MD:6 ]	......UnorderedSelectStatementSegment             	Unord.match OUT     	++  	[match=<MatchResult 1/1: 'SELECT\n     as ...ROM SELECT FROM'>, seg="'SELECT\\n     as trail...'"]
DEBUG      [PD:1  MD:6 ]	......NonSetSelectableGrammar                     	Ref.match OUT       	++  	[match=<MatchResult 1/1: 'SELECT\n     as ...ROM SELECT FROM'>, seg="'SELECT\\n     as trail...'"]
INFO       [PD:1  MD:5 ]	.....NonSetSelectableGrammar                      	OneOf.match OUT     	++  	[match=<MatchResult 1/1: 'SELECT\n     as ...ROM SELECT FROM'>, seg="'SELECT\\n     as trail...'"]
DEBUG      [PD:1  MD:5 ]	.....SetExpressionSegment                         	Ref.match OUT       	++  	[match=<MatchResult 1/1: 'SELECT\n     as ...ROM SELECT FROM'>, seg="'SELECT\\n     as trail...'"]
INFO       [PD:1  MD:4 ]	....SetExpressionSegment                          	Seque.match OUT     	    	[match=<MatchResult 0/19: ''>, seg="'SELECT\\n     as trail...'"]
DEBUG      [PD:1  MD:3 ]	...SetExpressionSegment                           	SetEx.match OUT     	    	[match=<MatchResult 0/19: ''>, seg="'SELECT\\n     as trail...'"]
DEBUG      [PD:1  MD:3 ]	...NonWithSelectableGrammar                       	Ref.match OUT       	    	[match=<MatchResult 0/19: ''>, seg="'SELECT\\n     as trail...'"]
INFO       [PD:1  MD:3 ]	...NonWithSelectableGrammar                       	Optio.match PRN     	    	[ns=0, ps=1, ms=1, pruned=[<Bracketed: [<Ref: SelectStatementSegment>]>], opts=[<Ref: SelectStatementSegment>]]
DEBUG      [PD:1  MD:9 ]	.........SelectClauseSegment                      	Ref.match OUT       	+   	[match=<MatchResult 1/19: 'SELECT'>, seg="'SELECT\\n     as trail...'"]
INFO       [PD:1  MD:13]	.............WildcardIdentifierSegment            	AnyNu.match PRN     	    	[ns=1, ps=0, ms=0, pruned=[], opts=[<Sequence: [<Ref: SingleIdentifierGrammar>, <Ref: DotSegment>]>]]
INFO       [PD:1  MD:15]	...............SingleIdentifierGrammar            	OneOf.match PRN     	    	[ns=2, ps=0, ms=0, pruned=[], opts=[<Ref: NakedIdentifierSegment>, <Ref: QuotedIdentifierSegment>]]
DEBUG      [PD:1  MD:16]	................SingleIdentifierGrammar           	Ref.match OUT       	+   	[match=<MatchResult 1/16: 'as'>, seg="'as trailing_space   ...'"]
DEBUG      [PD:1  MD:16]	................SingleIdentifierGrammar           	Ref.match OUT       	    	[match=<MatchResult 0/16: ''>, seg="'as trailing_space   ...'"]
INFO       [PD:1  MD:15]	...............SingleIdentifierGrammar            	OneOf.match OUT     	+   	[match=<MatchResult 1/16: 'as'>, seg="'as trailing_space   ...'"]
DEBUG      [PD:1  MD:15]	...............WildcardIdentifierSegment          	Ref.match OUT       	+   	[match=<MatchResult 1/16: 'as'>, seg="'as trailing_space   ...'"]
DEBUG      [PD:1  MD:15]	...............WildcardIdentifierSegment          	Ref.match OUT       	    	[match=<MatchResult 0/14: ''>, seg="'trailing_space   ,\\n ...'"]
INFO       [PD:1  MD:14]	..............WildcardIdentifierSegment           	Seque.match OUT     	    	[match=<MatchResult 0/16: ''>, seg="'as trailing_space   ...'"]
INFO       [PD:1  MD:13]	.............WildcardIdentifierSegment            	AnyNu.match OUT     	    	[match=<MatchResult 0/16: ''>, seg="'as trailing_space   ...'"]
DEBUG      [PD:1  MD:13]	.............WildcardIdentifierSegment            	Ref.match OUT       	    	[match=<MatchResult 0/16: ''>, seg="'as trailing_space   ...'"]
INFO       [PD:1  MD:12]	............WildcardIdentifierSegment             	Seque.match OUT     	    	[match=<MatchResult 0/16: ''>, seg="'as trailing_space   ...'"]
DEBUG      [PD:1  MD:11]	...........WildcardIdentifierSegment              	Wildc.match OUT     	    	[match=<MatchResult 0/16: ''>, seg="'as trailing_space   ...'"]
DEBUG      [PD:1  MD:11]	...........WildcardExpressionSegment              	Ref.match OUT       	    	[match=<MatchResult 0/16: ''>, seg="'as trailing_space   ...'"]
INFO       [PD:1  MD:10]	..........WildcardExpressionSegment               	Seque.match OUT     	    	[match=<MatchResult 0/16: ''>, seg="'as trailing_space   ...'"]
DEBUG      [PD:1  MD:9 ]	.........WildcardExpressionSegment                	Wildc.match OUT     	    	[match=<MatchResult 0/16: ''>, seg="'as trailing_space   ...'"]
DEBUG      [PD:1  MD:9 ]	.........SelectClauseSegment                      	Ref.match OUT       	    	[match=<MatchResult 0/16: ''>, seg="'as trailing_space   ...'"]
INFO       [PD:1  MD:8 ]	........SelectClauseSegment                       	Seque.match OUT     	+   	[match=<MatchResult 1/19: 'SELECT'>, seg="'SELECT\\n     as trail...'"]
DEBUG      [PD:1  MD:8 ]	........SelectClauseSegment                       	Start._look_ahead_match IN	    	[ls=18, seg='\n     as trailing_sp...']
DEBUG      [PD:1  MD:8 ]	........SelectClauseSegment                       	Start._look_ahead_match SI	    	[mq=[(<OneOf: [<Ref: FromKeywordSegment>, <Ref: WhereKeywordSegment>, <Ref: OrderKeywordSegment>, <Ref: LimitKeywor...]>, 13, 'FROM'), (<OneOf: [<Ref: FromKeywordSegment>, <Ref: WhereKeywordSegment>, <Ref: OrderKeywordSegment>, <Ref: LimitKeywor...]>, 17, 'FROM')], sb=['', '', 'AS', '', 'TRAILING_SPACE', '', ',', '', '', '3', '', '+', '', 'FROM', '', 'SELECT', '', 'FROM']]
INFO       [PD:1  MD:8 ]	........SelectClauseSegment                       	OneOf.match PRN     	    	[ns=0, ps=5, ms=1, pruned=[<Ref: WhereKeywordSegment>, <Ref: OrderKeywordSegment>, <Ref: LimitKeywordSegment>, <Ref: OverlapsKeywordSegment>, <Ref: SetOperatorSegment>], opts=[<Ref: FromKeywordSegment>]]
DEBUG      [PD:1  MD:9 ]	.........SelectClauseSegment                      	Ref.match OUT       	++  	[match=<MatchResult 1/1: 'FROM'>, seg="'FROM'"]
INFO       [PD:1  MD:8 ]	........SelectClauseSegment                       	OneOf.match OUT     	++  	[match=<MatchResult 1/1: 'FROM'>, seg="'FROM'"]
INFO       [PD:1  MD:8 ]	........SelectClauseSegment                       	OneOf.match PRN     	    	[ns=0, ps=5, ms=1, pruned=[<Ref: WhereKeywordSegment>, <Ref: OrderKeywordSegment>, <Ref: LimitKeywordSegment>, <Ref: OverlapsKeywordSegment>, <Ref: SetOperatorSegment>], opts=[<Ref: FromKeywordSegment>]]
DEBUG      [PD:1  MD:9 ]	.........SelectClauseSegment                      	Ref.match OUT       	+   	[match=<MatchResult 1/5: 'FROM'>, seg="'FROM SELECT FROM'"]
INFO       [PD:1  MD:8 ]	........SelectClauseSegment                       	OneOf.match OUT     	+   	[match=<MatchResult 1/5: 'FROM'>, seg="'FROM SELECT FROM'"]
DEBUG      [PD:1  MD:8 ]	........SelectClauseSegment                       	Start._look_ahead_match SC	    	[bsm=(13, 1, <OneOf: [<Ref: FromKeywordSegment>, <Ref: WhereKeywordSegment>, <Ref: OrderKeywordSegment>, <Ref: LimitKeywor...]>)]
INFO       [PD:1  MD:7 ]	.......SelectClauseSegment                        	Start.match OUT     	+   	[match=<MatchResult 13/19: 'SELECT\n     as ...ace   ,\n    3 +'>, seg="'SELECT\\n     as trail...'"]
DEBUG      [PD:1  MD:6 ]	......SelectClauseSegment                         	Selec.match OUT     	+   	[match=<MatchResult 1/7: 'SELECT\n     as ...ace   ,\n    3 +'>, seg="'SELECT\\n     as trail...'"]
DEBUG      [PD:1  MD:6 ]	......SelectStatementSegment                      	Ref.match OUT       	+   	[match=<MatchResult 1/7: 'SELECT\n     as ...ace   ,\n    3 +'>, seg="'SELECT\\n     as trail...'"]
DEBUG      [PD:1  MD:6 ]	......SelectStatementSegment                      	Start._look_ahead_match IN	    	[ls=6, seg=' FROM SELECT FROM']
DEBUG      [PD:1  MD:6 ]	......SelectStatementSegment                      	Start._look_ahead_match SI	    	[mq=[], sb=['', 'FROM', '', 'SELECT', '', 'FROM']]
DEBUG      [PD:1  MD:6 ]	......SelectStatementSegment                      	Start._look_ahead_match SC	    	[bsm=None]
INFO       [PD:1  MD:5 ]	.....SelectStatementSegment                       	Start.match OUT     	++  	[match=<MatchResult 7/7: 'SELECT\n     as ...ROM SELECT FROM'>, seg="'SELECT\\n     as trail...'"]
DEBUG      [PD:1  MD:4 ]	....SelectStatementSegment                        	Selec.match OUT     	++  	[match=<MatchResult 1/1: 'SELECT\n     as ...ROM SELECT FROM'>, seg="'SELECT\\n     as trail...'"]
DEBUG      [PD:1  MD:4 ]	....NonWithSelectableGrammar                      	Ref.match OUT       	++  	[match=<MatchResult 1/1: 'SELECT\n     as ...ROM SELECT FROM'>, seg="'SELECT\\n     as trail...'"]
INFO       [PD:1  MD:3 ]	...NonWithSelectableGrammar                       	Optio.match OUT     	++  	[match=<MatchResult 1/1: 'SELECT\n     as ...ROM SELECT FROM'>, seg="'SELECT\\n     as trail...'"]
INFO       [PD:1  MD:2 ]	..NonWithSelectableGrammar                        	OneOf.match OUT     	++  	[match=<MatchResult 1/1: 'SELECT\n     as ...ROM SELECT FROM'>, seg="'SELECT\\n     as trail...'"]
DEBUG      [PD:1  MD:2 ]	..SelectableGrammar                               	Ref.match OUT       	++  	[match=<MatchResult 1/1: 'SELECT\n     as ...ROM SELECT FROM'>, seg="'SELECT\\n     as trail...'"]
INFO       [PD:1  MD:1 ]	.SelectableGrammar                                	OneOf.match OUT     	++  	[match=<MatchResult 1/1: 'SELECT\n     as ...ROM SELECT FROM'>, seg="'SELECT\\n     as trail...'"]
DEBUG      [PD:1  MD:1 ]	.StatementSegment                                 	Ref.match OUT       	++  	[match=<MatchResult 1/1: 'SELECT\n     as ...ROM SELECT FROM'>, seg="'SELECT\\n     as trail...'"]
INFO       [PD:1  MD:0 ]	StatementSegment                                  	OneOf.match OUT     	++  	[match=<MatchResult 1/1: 'SELECT\n     as ...ROM SELECT FROM'>, seg="'SELECT\\n     as trail...'"]
DEBUG      StatementSegment.parse: Done Parse. Plotting Recursion. Recurse=True
DEBUG      ###
#
# Beginning Parse Depth 2: StatementSegment
#
###
Initial Structure:
[L:  2, P:  1]      |statement:
[L:  2, P:  1]      |    select_statement:
[L:  2, P:  1]      |        select_clause:
[L:  2, P:  1]      |            keyword:                                          'SELECT'
[L:  2, P:  7]      |            newline:                                          '\n'
[L:  3, P:  1]      |            whitespace:                                       '     '
[L:  3, P: 21]      |            raw:                                              'as'
[L:  3, P: 23]      |            whitespace:                                       ' '
[L:  3, P: 24]      |            raw:                                              'trailing_space'
[L:  3, P: 38]      |            whitespace:                                       '   '
[L:  3, P: 41]      |            comma:                                            ','
[L:  3, P: 42]      |            newline:                                          '\n'
[L:  4, P:  1]      |            whitespace:                                       '    '
[L:  4, P:  5]      |            raw:                                              '3'
[L:  4, P:  6]      |            whitespace:                                       ' '
[L:  4, P:  7]      |            raw:                                              '+'
[L:  4, P:  8]      |        whitespace:                                           ' '
[L:  4, P:  9]      |        keyword:                                              'FROM'
[L:  4, P: 13]      |        whitespace:                                           ' '
[L:  4, P: 14]      |        raw:                                                  'SELECT'
[L:  4, P: 20]      |        whitespace:                                           ' '
[L:  4, P: 21]      |        raw:                                                  'FROM'

INFO       
###
#
# Parse Depth 2. Expanding: SelectStatementSegment: 'SELECT\n     as trailing_space   ,\n    3 ...'
#
###
INFO       [PD:2  MD:1 ]	.SelectClauseSegment                              	Selec._match SELF   	    
DEBUG      [PD:2  MD:1 ]	.SelectClauseSegment                              	Selec.match OUT     	+   	[match=<MatchResult 1/7: 'SELECT\n     as ...ace   ,\n    3 +'>, seg="'SELECT\\n     as trail...'"]
DEBUG      [PD:2  MD:1 ]	.SelectStatementSegment                           	Ref.match OUT       	+   	[match=<MatchResult 1/7: 'SELECT\n     as ...ace   ,\n    3 +'>, seg="'SELECT\\n     as trail...'"]
DEBUG      [PD:2  MD:3 ]	...FromClauseSegment                              	Ref.match OUT       	+   	[match=<MatchResult 1/5: 'FROM'>, seg="'FROM SELECT FROM'"]
DEBUG      [PD:2  MD:3 ]	...FromClauseSegment                              	Start._look_ahead_match IN	    	[ls=4, seg=' SELECT FROM']
DEBUG      [PD:2  MD:3 ]	...FromClauseSegment                              	Start._look_ahead_match SI	    	[mq=[], sb=['', 'SELECT', '', 'FROM']]
DEBUG      [PD:2  MD:3 ]	...FromClauseSegment                              	Start._look_ahead_match SC	    	[bsm=None]
INFO       [PD:2  MD:2 ]	..FromClauseSegment                               	Start.match OUT     	++  	[match=<MatchResult 5/5: 'FROM SELECT FROM'>, seg="'FROM SELECT FROM'"]
DEBUG      [PD:2  MD:1 ]	.FromClauseSegment                                	FromC.match OUT     	++  	[match=<MatchResult 1/1: 'FROM SELECT FROM'>, seg="'FROM SELECT FROM'"]
DEBUG      [PD:2  MD:1 ]	.SelectStatementSegment                           	Ref.match OUT       	++  	[match=<MatchResult 1/1: 'FROM SELECT FROM'>, seg="'FROM SELECT FROM'"]
INFO       [PD:2  MD:0 ]	SelectStatementSegment                            	Seque.match OUT     	++  	[match=<MatchResult 4/4: 'SELECT\n     as ...ROM SELECT FROM'>, seg="'SELECT\\n     as trail...'"]
DEBUG      SelectStatementSegment.parse: Done Parse. Plotting Recursion. Recurse=True
DEBUG      ###
#
# Beginning Parse Depth 3: SelectStatementSegment
#
###
Initial Structure:
[L:  2, P:  1]      |select_statement:
[L:  2, P:  1]      |    select_clause:
[L:  2, P:  1]      |        keyword:                                              'SELECT'
[L:  2, P:  7]      |        newline:                                              '\n'
[L:  3, P:  1]      |        whitespace:                                           '     '
[L:  3, P: 21]      |        raw:                                                  'as'
[L:  3, P: 23]      |        whitespace:                                           ' '
[L:  3, P: 24]      |        raw:                                                  'trailing_space'
[L:  3, P: 38]      |        whitespace:                                           '   '
[L:  3, P: 41]      |        comma:                                                ','
[L:  3, P: 42]      |        newline:                                              '\n'
[L:  4, P:  1]      |        whitespace:                                           '    '
[L:  4, P:  5]      |        raw:                                                  '3'
[L:  4, P:  6]      |        whitespace:                                           ' '
[L:  4, P:  7]      |        raw:                                                  '+'
[L:  4, P:  8]      |    whitespace:                                               ' '
[L:  4, P:  9]      |    [META] dedent:
[L:  4, P:  9]      |    from_clause:
[L:  4, P:  9]      |        keyword:                                              'FROM'
[L:  4, P: 13]      |        whitespace:                                           ' '
[L:  4, P: 14]      |        raw:                                                  'SELECT'
[L:  4, P: 20]      |        whitespace:                                           ' '
[L:  4, P: 21]      |        raw:                                                  'FROM'

INFO       
###
#
# Parse Depth 3. Expanding: SelectClauseSegment: 'SELECT\n     as trailing_space   ,\n    3 ...'
#
###
DEBUG      [PD:3  MD:1 ]	.SelectClauseSegmentGrammar                       	Ref.match OUT       	+   	[match=<MatchResult 1/13: 'SELECT'>, seg="'SELECT\\n     as trail...'"]
INFO       [PD:3  MD:2 ]	..SelectClauseModifierSegment                     	OneOf.match PRN     	    	[ns=0, ps=2, ms=0, pruned=[<Ref: DistinctKeywordSegment>, <Ref: AllKeywordSegment>], opts='ALL']
INFO       [PD:3  MD:2 ]	..SelectClauseModifierSegment                     	OneOf.match OUT     	    	[match=<MatchResult 0/10: ''>, seg="'as trailing_space   ...'"]
DEBUG      [PD:3  MD:1 ]	.SelectClauseModifierSegment                      	Selec.match OUT     	    	[match=<MatchResult 0/10: ''>, seg="'as trailing_space   ...'"]
DEBUG      [PD:3  MD:1 ]	.SelectClauseSegmentGrammar                       	Ref.match OUT       	    	[match=<MatchResult 0/10: ''>, seg="'as trailing_space   ...'"]
DEBUG      [PD:3  MD:2 ]	..SelectClauseSegmentGrammar                      	Delim._look_ahead_match IN	    	[ls=10, seg='as trailing_space   ...']
DEBUG      [PD:3  MD:2 ]	..SelectClauseSegmentGrammar                      	Delim._look_ahead_match SI	    	[mq=[(<Ref: CommaSegment>, 4, ',')], sb=['AS', '', 'TRAILING_SPACE', '', ',', '', '', '3', '', '+']]
DEBUG      [PD:3  MD:2 ]	..SelectClauseSegmentGrammar                      	Ref.match OUT       	+   	[match=<MatchResult 1/6: ','>, seg="',\\n    3 +'"]
DEBUG      [PD:3  MD:2 ]	..SelectClauseSegmentGrammar                      	Delim._look_ahead_match SC	    	[bsm=(4, 1, <Ref: CommaSegment>)]
DEBUG      [PD:3  MD:4 ]	....SelectClauseElementSegment                    	Greed._look_ahead_match IN	    	[ls=3, seg='as trailing_space']
DEBUG      [PD:3  MD:4 ]	....SelectClauseElementSegment                    	Greed._look_ahead_match SI	    	[mq=[], sb=['AS', '', 'TRAILING_SPACE']]
DEBUG      [PD:3  MD:4 ]	....SelectClauseElementSegment                    	Greed._look_ahead_match SC	    	[bsm=None]
INFO       [PD:3  MD:3 ]	...SelectClauseElementSegment                     	Greed.match OUT     	++  	[match=<MatchResult 3/3: 'as trailing_space'>, seg="'as trailing_space'"]
DEBUG      [PD:3  MD:2 ]	..SelectClauseElementSegment                      	Selec.match OUT     	++  	[match=<MatchResult 1/1: 'as trailing_space'>, seg="'as trailing_space'"]
DEBUG      [PD:3  MD:2 ]	..SelectClauseSegmentGrammar                      	Ref.match OUT       	++  	[match=<MatchResult 1/1: 'as trailing_space'>, seg="'as trailing_space'"]
DEBUG      [PD:3  MD:2 ]	..SelectClauseSegmentGrammar                      	Delim._look_ahead_match IN	    	[ls=5, seg='\n    3 +']
DEBUG      [PD:3  MD:2 ]	..SelectClauseSegmentGrammar                      	Delim._look_ahead_match SI	    	[mq=[], sb=['', '', '3', '', '+']]
DEBUG      [PD:3  MD:2 ]	..SelectClauseSegmentGrammar                      	Delim._look_ahead_match SC	    	[bsm=None]
DEBUG      [PD:3  MD:4 ]	....SelectClauseElementSegment                    	Greed._look_ahead_match IN	    	[ls=3, seg='3 +']
DEBUG      [PD:3  MD:4 ]	....SelectClauseElementSegment                    	Greed._look_ahead_match SI	    	[mq=[], sb=['3', '', '+']]
DEBUG      [PD:3  MD:4 ]	....SelectClauseElementSegment                    	Greed._look_ahead_match SC	    	[bsm=None]
INFO       [PD:3  MD:3 ]	...SelectClauseElementSegment                     	Greed.match OUT     	++  	[match=<MatchResult 3/3: '3 +'>, seg="'3 +'"]
DEBUG      [PD:3  MD:2 ]	..SelectClauseElementSegment                      	Selec.match OUT     	++  	[match=<MatchResult 1/1: '3 +'>, seg="'3 +'"]
DEBUG      [PD:3  MD:2 ]	..SelectClauseSegmentGrammar                      	Ref.match OUT       	++  	[match=<MatchResult 1/1: '3 +'>, seg="'3 +'"]
INFO       [PD:3  MD:1 ]	.SelectClauseSegmentGrammar                       	Delim.match OUT     	++  	[match=<MatchResult 6/6: 'as trailing_space   ,\n    3 +'>, seg="'as trailing_space   ...'"]
INFO       [PD:3  MD:0 ]	SelectClauseSegmentGrammar                        	Seque.match OUT     	++  	[match=<MatchResult 10/10: 'SELECT\n     as ...ace   ,\n    3 +'>, seg="'SELECT\\n     as trail...'"]
DEBUG      [PD:3  MD:0 ]	SelectClauseSegment                               	Ref.match OUT       	++  	[match=<MatchResult 10/10: 'SELECT\n     as ...ace   ,\n    3 +'>, seg="'SELECT\\n     as trail...'"]
DEBUG      SelectClauseSegment.parse: Done Parse. Plotting Recursion. Recurse=True
DEBUG      ###
#
# Beginning Parse Depth 4: SelectClauseSegment
#
###
Initial Structure:
[L:  2, P:  1]      |select_clause:
[L:  2, P:  1]      |    keyword:                                                  'SELECT'
[L:  2, P:  7]      |    [META] indent:
[L:  2, P:  7]      |    newline:                                                  '\n'
[L:  3, P:  1]      |    whitespace:                                               '     '
[L:  3, P: 21]      |    select_clause_element:
[L:  3, P: 21]      |        raw:                                                  'as'
[L:  3, P: 23]      |        whitespace:                                           ' '
[L:  3, P: 24]      |        raw:                                                  'trailing_space'
[L:  3, P: 38]      |    whitespace:                                               '   '
[L:  3, P: 41]      |    comma:                                                    ','
[L:  3, P: 42]      |    newline:                                                  '\n'
[L:  4, P:  1]      |    whitespace:                                               '    '
[L:  4, P:  5]      |    select_clause_element:
[L:  4, P:  5]      |        raw:                                                  '3'
[L:  4, P:  6]      |        whitespace:                                           ' '
[L:  4, P:  7]      |        raw:                                                  '+'

INFO       [PD:4] Skipping expansion of <KeywordSegment: ([L:  2, P:  1]) 'SELECT'>...
INFO       [PD:4] Skipping expansion of <Indent: ([L:  2, P:  7]) ''>...
INFO       [PD:4] Skipping expansion of <NewlineSegment: ([L:  2, P:  7]) '\n'>...
INFO       [PD:4] Skipping expansion of <WhitespaceSegment: ([L:  3, P:  1]) '     '>...
INFO       
###
#
# Parse Depth 4. Expanding: SelectClauseElementSegment: 'as trailing_space'
#
###
INFO       [PD:4  MD:0 ]	SelectClauseElementSegment                        	OneOf.match PRN     	    	[ns=2, ps=0, ms=0, pruned=[], opts=[<Ref: WildcardExpressionSegment>, <Sequence: [<Ref: BaseExpressionElementGrammar>, <Ref: AliasExpressionSegment [opt]>]>]]
INFO       [PD:4  MD:5 ]	.....WildcardIdentifierSegment                    	AnyNu.match PRN     	    	[ns=1, ps=0, ms=0, pruned=[], opts=[<Sequence: [<Ref: SingleIdentifierGrammar>, <Ref: DotSegment>]>]]
INFO       [PD:4  MD:7 ]	.......SingleIdentifierGrammar                    	OneOf.match PRN     	    	[ns=2, ps=0, ms=0, pruned=[], opts=[<Ref: NakedIdentifierSegment>, <Ref: QuotedIdentifierSegment>]]
DEBUG      [PD:4  MD:8 ]	........SingleIdentifierGrammar                   	Ref.match OUT       	+   	[match=<MatchResult 1/3: 'as'>, seg="'as trailing_space'"]
DEBUG      [PD:4  MD:8 ]	........SingleIdentifierGrammar                   	Ref.match OUT       	    	[match=<MatchResult 0/3: ''>, seg="'as trailing_space'"]
INFO       [PD:4  MD:7 ]	.......SingleIdentifierGrammar                    	OneOf.match OUT     	+   	[match=<MatchResult 1/3: 'as'>, seg="'as trailing_space'"]
DEBUG      [PD:4  MD:7 ]	.......WildcardIdentifierSegment                  	Ref.match OUT       	+   	[match=<MatchResult 1/3: 'as'>, seg="'as trailing_space'"]
DEBUG      [PD:4  MD:7 ]	.......WildcardIdentifierSegment                  	Ref.match OUT       	    	[match=<MatchResult 0/1: ''>, seg="'trailing_space'"]
INFO       [PD:4  MD:6 ]	......WildcardIdentifierSegment                   	Seque.match OUT     	    	[match=<MatchResult 0/3: ''>, seg="'as trailing_space'"]
INFO       [PD:4  MD:5 ]	.....WildcardIdentifierSegment                    	AnyNu.match OUT     	    	[match=<MatchResult 0/3: ''>, seg="'as trailing_space'"]
DEBUG      [PD:4  MD:5 ]	.....WildcardIdentifierSegment                    	Ref.match OUT       	    	[match=<MatchResult 0/3: ''>, seg="'as trailing_space'"]
INFO       [PD:4  MD:4 ]	....WildcardIdentifierSegment                     	Seque.match OUT     	    	[match=<MatchResult 0/3: ''>, seg="'as trailing_space'"]
DEBUG      [PD:4  MD:3 ]	...WildcardIdentifierSegment                      	Wildc.match OUT     	    	[match=<MatchResult 0/3: ''>, seg="'as trailing_space'"]
DEBUG      [PD:4  MD:3 ]	...WildcardExpressionSegment                      	Ref.match OUT       	    	[match=<MatchResult 0/3: ''>, seg="'as trailing_space'"]
INFO       [PD:4  MD:2 ]	..WildcardExpressionSegment                       	Seque.match OUT     	    	[match=<MatchResult 0/3: ''>, seg="'as trailing_space'"]
DEBUG      [PD:4  MD:1 ]	.WildcardExpressionSegment                        	Wildc.match OUT     	    	[match=<MatchResult 0/3: ''>, seg="'as trailing_space'"]
DEBUG      [PD:4  MD:1 ]	.SelectClauseElementSegment                       	Ref.match OUT       	    	[match=<MatchResult 0/3: ''>, seg="'as trailing_space'"]
INFO       [PD:4  MD:2 ]	..BaseExpressionElementGrammar                    	OneOf.match PRN     	    	[ns=5, ps=1, ms=0, pruned=[<Ref: IntervalExpressionSegment>], opts=[<Ref: LiteralGrammar>, <Ref: BareFunctionSegment>, <Ref: FunctionSegment>, <Ref: ColumnReferenceSegment>, <Ref: ExpressionSegment>]]
INFO       [PD:4  MD:3 ]	...LiteralGrammar                                 	OneOf.match PRN     	    	[ns=2, ps=4, ms=0, pruned=[<Ref: BooleanLiteralGrammar>, <Ref: QualifiedNumericLiteralSegment>, <Ref: NullLiteralSegment>, <Ref: DateTimeLiteralGrammar>], opts=[<Ref: QuotedLiteralSegment>, <Ref: NumericLiteralSegment>]]
DEBUG      [PD:4  MD:4 ]	....LiteralGrammar                                	Ref.match OUT       	    	[match=<MatchResult 0/3: ''>, seg="'as trailing_space'"]
DEBUG      [PD:4  MD:4 ]	....LiteralGrammar                                	Ref.match OUT       	    	[match=<MatchResult 0/3: ''>, seg="'as trailing_space'"]
INFO       [PD:4  MD:3 ]	...LiteralGrammar                                 	OneOf.match OUT     	    	[match=<MatchResult 0/3: ''>, seg="'as trailing_space'"]
DEBUG      [PD:4  MD:3 ]	...BaseExpressionElementGrammar                   	Ref.match OUT       	    	[match=<MatchResult 0/3: ''>, seg="'as trailing_space'"]
DEBUG      [PD:4  MD:3 ]	...BaseExpressionElementGrammar                   	Ref.match OUT       	    	[match=<MatchResult 0/3: ''>, seg="'as trailing_space'"]
INFO       [PD:4  MD:4 ]	....FunctionSegment                               	OneOf.match PRN     	    	[ns=1, ps=1, ms=0, pruned=[<Sequence: [<Sequence: [<Ref: DateAddFunctionNameSeg...]>], opts=[<Sequence: [<Sequence: [<AnyNumberOf: [<Ref: Functio..., <Ref: PostFunctionGrammar [opt]>]>]]
DEBUG      [PD:4  MD:10]	..........DateAddFunctionNameSegment              	Ref.match OUT       	    	[match=<MatchResult 0/3: ''>, seg="'as trailing_space'"]
INFO       [PD:4  MD:9 ]	.........DateAddFunctionNameSegment               	Seque.match OUT     	    	[match=<MatchResult 0/3: ''>, seg="'as trailing_space'"]
DEBUG      [PD:4  MD:8 ]	........DateAddFunctionNameSegment                	DateA.match OUT     	    	[match=<MatchResult 0/3: ''>, seg="'as trailing_space'"]
DEBUG      [PD:4  MD:8 ]	........FunctionSegment                           	Ref.match OUT       	    	[match=<MatchResult 0/3: ''>, seg="'as trailing_space'"]
INFO       [PD:4  MD:7 ]	.......FunctionSegment                            	AnyNu.match PRN     	    	[ns=1, ps=0, ms=0, pruned=[], opts=[<Ref: FunctionNameSegment>]]
INFO       [PD:4  MD:10]	..........FunctionNameSegment                     	AnyNu.match PRN     	    	[ns=1, ps=0, ms=0, pruned=[], opts=[<Sequence: [<Ref: SingleIdentifierGrammar>, <Ref: DotSegment>]>]]
INFO       [PD:4  MD:12]	............SingleIdentifierGrammar               	OneOf.match PRN     	    	[ns=2, ps=0, ms=0, pruned=[], opts=[<Ref: NakedIdentifierSegment>, <Ref: QuotedIdentifierSegment>]]
DEBUG      [PD:4  MD:13]	.............SingleIdentifierGrammar              	Ref.match OUT       	+   	[match=<MatchResult 1/3: 'as'>, seg="'as trailing_space'"]
DEBUG      [PD:4  MD:13]	.............SingleIdentifierGrammar              	Ref.match OUT       	    	[match=<MatchResult 0/3: ''>, seg="'as trailing_space'"]
INFO       [PD:4  MD:12]	............SingleIdentifierGrammar               	OneOf.match OUT     	+   	[match=<MatchResult 1/3: 'as'>, seg="'as trailing_space'"]
DEBUG      [PD:4  MD:12]	............FunctionNameSegment                   	Ref.match OUT       	+   	[match=<MatchResult 1/3: 'as'>, seg="'as trailing_space'"]
DEBUG      [PD:4  MD:12]	............FunctionNameSegment                   	Ref.match OUT       	    	[match=<MatchResult 0/1: ''>, seg="'trailing_space'"]
INFO       [PD:4  MD:11]	...........FunctionNameSegment                    	Seque.match OUT     	    	[match=<MatchResult 0/3: ''>, seg="'as trailing_space'"]
INFO       [PD:4  MD:10]	..........FunctionNameSegment                     	AnyNu.match OUT     	    	[match=<MatchResult 0/3: ''>, seg="'as trailing_space'"]
INFO       [PD:4  MD:10]	..........FunctionNameSegment                     	OneOf.match PRN     	    	[ns=2, ps=0, ms=0, pruned=[], opts=[<Ref: FunctionNameIdentifierSegment>, <Ref: QuotedIdentifierSegment>]]
DEBUG      [PD:4  MD:11]	...........FunctionNameSegment                    	Ref.match OUT       	+   	[match=<MatchResult 1/3: 'as'>, seg="'as trailing_space'"]
DEBUG      [PD:4  MD:11]	...........FunctionNameSegment                    	Ref.match OUT       	    	[match=<MatchResult 0/3: ''>, seg="'as trailing_space'"]
INFO       [PD:4  MD:10]	..........FunctionNameSegment                     	OneOf.match OUT     	+   	[match=<MatchResult 1/3: 'as'>, seg="'as trailing_space'"]
INFO       [PD:4  MD:9 ]	.........FunctionNameSegment                      	Seque.match OUT     	+   	[match=<MatchResult 1/3: 'as'>, seg="'as trailing_space'"]
DEBUG      [PD:4  MD:8 ]	........FunctionNameSegment                       	Funct.match OUT     	+   	[match=<MatchResult 1/3: 'as'>, seg="'as trailing_space'"]
DEBUG      [PD:4  MD:8 ]	........FunctionSegment                           	Ref.match OUT       	+   	[match=<MatchResult 1/3: 'as'>, seg="'as trailing_space'"]
INFO       [PD:4  MD:7 ]	.......FunctionSegment                            	AnyNu.match OUT     	+   	[match=<MatchResult 1/3: 'as'>, seg="'as trailing_space'"]
INFO       [PD:4  MD:7 ]	.......FunctionSegment                            	Brack.match OUT     	    	[match=<MatchResult 0/1: ''>, seg="'trailing_space'"]
INFO       [PD:4  MD:6 ]	......FunctionSegment                             	Seque.match OUT     	    	[match=<MatchResult 0/3: ''>, seg="'as trailing_space'"]
INFO       [PD:4  MD:5 ]	.....FunctionSegment                              	Seque.match OUT     	    	[match=<MatchResult 0/3: ''>, seg="'as trailing_space'"]
INFO       [PD:4  MD:4 ]	....FunctionSegment                               	OneOf.match OUT     	    	[match=<MatchResult 0/3: ''>, seg="'as trailing_space'"]
DEBUG      [PD:4  MD:3 ]	...FunctionSegment                                	Funct.match OUT     	    	[match=<MatchResult 0/3: ''>, seg="'as trailing_space'"]
DEBUG      [PD:4  MD:3 ]	...BaseExpressionElementGrammar                   	Ref.match OUT       	    	[match=<MatchResult 0/3: ''>, seg="'as trailing_space'"]
DEBUG      [PD:4  MD:5 ]	.....ColumnReferenceSegment                       	Delim._look_ahead_match IN	    	[ls=3, seg='as trailing_space']
DEBUG      [PD:4  MD:5 ]	.....ColumnReferenceSegment                       	Delim._look_ahead_match SI	    	[mq=[], sb=['AS', '', 'TRAILING_SPACE']]
INFO       [PD:4  MD:5 ]	.....ColumnReferenceSegment                       	OneOf.match PRN     	    	[ns=1, ps=9, ms=1, pruned=[<Ref: OnKeywordSegment>, <Ref: UsingKeywordSegment>, <Ref: CommaSegment>, <Ref: CastOperatorSegment>, <Ref: StartSquareBracketSegment>, <Ref: StartBracketSegment>, <Ref: ColonSegment>, <Ref: DelimiterSegment>, <class 'sqlfluff.core.parser.segments.base.BracketedSegment'>], opts=[<Ref: AsKeywordSegment>, <Ref: BinaryOperatorGrammar>]]
DEBUG      [PD:4  MD:6 ]	......ColumnReferenceSegment                      	Ref.match OUT       	+   	[match=<MatchResult 1/3: 'as'>, seg="'as trailing_space'"]
INFO       [PD:4  MD:6 ]	......BinaryOperatorGrammar                       	OneOf.match PRN     	    	[ns=1, ps=3, ms=0, pruned=[<Ref: ArithmeticBinaryOperatorGrammar>, <Ref: StringBinaryOperatorGrammar>, <Ref: BooleanBinaryOperatorGrammar>], opts=[<Ref: ComparisonOperatorGrammar>]]
INFO       [PD:4  MD:7 ]	.......ComparisonOperatorGrammar                  	OneOf.match PRN     	    	[ns=1, ps=7, ms=0, pruned=[<Ref: EqualsSegment>, <Ref: GreaterThanSegment>, <Ref: LessThanSegment>, <Ref: GreaterThanOrEqualToSegment>, <Ref: LessThanOrEqualToSegment>, <Ref: NotEqualToSegment_a>, <Ref: NotEqualToSegment_b>], opts=[<Ref: LikeOperatorSegment>]]
DEBUG      [PD:4  MD:8 ]	........ComparisonOperatorGrammar                 	Ref.match OUT       	    	[match=<MatchResult 0/3: ''>, seg="'as trailing_space'"]
INFO       [PD:4  MD:7 ]	.......ComparisonOperatorGrammar                  	OneOf.match OUT     	    	[match=<MatchResult 0/3: ''>, seg="'as trailing_space'"]
DEBUG      [PD:4  MD:7 ]	.......BinaryOperatorGrammar                      	Ref.match OUT       	    	[match=<MatchResult 0/3: ''>, seg="'as trailing_space'"]
INFO       [PD:4  MD:6 ]	......BinaryOperatorGrammar                       	OneOf.match OUT     	    	[match=<MatchResult 0/3: ''>, seg="'as trailing_space'"]
DEBUG      [PD:4  MD:6 ]	......ColumnReferenceSegment                      	Ref.match OUT       	    	[match=<MatchResult 0/3: ''>, seg="'as trailing_space'"]
INFO       [PD:4  MD:5 ]	.....ColumnReferenceSegment                       	OneOf.match OUT     	+   	[match=<MatchResult 1/3: 'as'>, seg="'as trailing_space'"]
DEBUG      [PD:4  MD:5 ]	.....ColumnReferenceSegment                       	NonCo.match OUT     	    	[match=<MatchResult 0/3: ''>, seg="'as trailing_space'"]
INFO       [PD:4  MD:4 ]	....ColumnReferenceSegment                        	Delim.match OUT     	    	[match=<MatchResult 0/3: ''>, seg="'as trailing_space'"]
DEBUG      [PD:4  MD:3 ]	...ColumnReferenceSegment                         	Colum.match OUT     	    	[match=<MatchResult 0/3: ''>, seg="'as trailing_space'"]
DEBUG      [PD:4  MD:3 ]	...BaseExpressionElementGrammar                   	Ref.match OUT       	    	[match=<MatchResult 0/3: ''>, seg="'as trailing_space'"]
INFO       [PD:4  MD:5 ]	.....Expression_A_Grammar                         	OneOf.match PRN     	    	[ns=1, ps=1, ms=0, pruned=[<Sequence: [<OneOf: [<Ref: PositiveSegment>, <Ref: N..., <Ref: Expression_C_Grammar>]>], opts=[<Ref: Expression_C_Grammar>]]
INFO       [PD:4  MD:6 ]	......Expression_C_Grammar                        	OneOf.match PRN     	    	[ns=1, ps=2, ms=0, pruned=[<Sequence: [<Ref: ExistsKeywordSegment>, <Bracketed: [<Ref: SelectStatementSegmen...]>, <Ref: CaseExpressionSegment>], opts=[<Ref: Expression_D_Grammar>]]
INFO       [PD:4  MD:8 ]	........Expression_D_Grammar                      	OneOf.match PRN     	    	[ns=6, ps=3, ms=0, pruned=[<Bracketed: [<OneOf: [<Ref: ExpressionSegment>, <Ref:...]>, <Ref: SelectStatementSegment>, <Ref: IntervalExpressionSegment>], opts=[<Ref: BareFunctionSegment>, <Ref: FunctionSegment>, <Ref: LiteralGrammar>, <Ref: ColumnReferenceSegment>, <Sequence: [<Ref: SimpleArrayTypeGrammar [opt]>, <Ref: ArrayLiteralSegment>]>, <Sequence: [<Ref: DatatypeSegment>, <OneOf: [<Ref: QuotedLiteralSegment>, <R...]>]]
DEBUG      [PD:4  MD:9 ]	.........Expression_D_Grammar                     	Ref.match OUT       	    	[match=<MatchResult 0/3: ''>, seg="'as trailing_space'"]
INFO       [PD:4  MD:10]	..........FunctionSegment                         	OneOf.match PRN     	    	[ns=1, ps=1, ms=0, pruned=[<Sequence: [<Sequence: [<Ref: DateAddFunctionNameSeg...]>], opts=[<Sequence: [<Sequence: [<AnyNumberOf: [<Ref: Functio..., <Ref: PostFunctionGrammar [opt]>]>]]
DEBUG      [PD:4  MD:16]	................DateAddFunctionNameSegment        	Ref.match OUT       	    	[match=<MatchResult 0/3: ''>, seg="'as trailing_space'"]
INFO       [PD:4  MD:15]	...............DateAddFunctionNameSegment         	Seque.match OUT     	    	[match=<MatchResult 0/3: ''>, seg="'as trailing_space'"]
DEBUG      [PD:4  MD:14]	..............DateAddFunctionNameSegment          	DateA.match OUT     	    	[match=<MatchResult 0/3: ''>, seg="'as trailing_space'"]
DEBUG      [PD:4  MD:14]	..............FunctionSegment                     	Ref.match OUT       	    	[match=<MatchResult 0/3: ''>, seg="'as trailing_space'"]
INFO       [PD:4  MD:13]	.............FunctionSegment                      	AnyNu.match PRN     	    	[ns=1, ps=0, ms=0, pruned=[], opts=[<Ref: FunctionNameSegment>]]
INFO       [PD:4  MD:16]	................FunctionNameSegment               	AnyNu.match PRN     	    	[ns=1, ps=0, ms=0, pruned=[], opts=[<Sequence: [<Ref: SingleIdentifierGrammar>, <Ref: DotSegment>]>]]
INFO       [PD:4  MD:18]	..................SingleIdentifierGrammar         	OneOf.match PRN     	    	[ns=2, ps=0, ms=0, pruned=[], opts=[<Ref: NakedIdentifierSegment>, <Ref: QuotedIdentifierSegment>]]
DEBUG      [PD:4  MD:19]	...................SingleIdentifierGrammar        	Ref.match OUT       	+   	[match=<MatchResult 1/3: 'as'>, seg="'as trailing_space'"]
DEBUG      [PD:4  MD:19]	...................SingleIdentifierGrammar        	Ref.match OUT       	    	[match=<MatchResult 0/3: ''>, seg="'as trailing_space'"]
INFO       [PD:4  MD:18]	..................SingleIdentifierGrammar         	OneOf.match OUT     	+   	[match=<MatchResult 1/3: 'as'>, seg="'as trailing_space'"]
DEBUG      [PD:4  MD:18]	..................FunctionNameSegment             	Ref.match OUT       	+   	[match=<MatchResult 1/3: 'as'>, seg="'as trailing_space'"]
DEBUG      [PD:4  MD:18]	..................FunctionNameSegment             	Ref.match OUT       	    	[match=<MatchResult 0/1: ''>, seg="'trailing_space'"]
INFO       [PD:4  MD:17]	.................FunctionNameSegment              	Seque.match OUT     	    	[match=<MatchResult 0/3: ''>, seg="'as trailing_space'"]
INFO       [PD:4  MD:16]	................FunctionNameSegment               	AnyNu.match OUT     	    	[match=<MatchResult 0/3: ''>, seg="'as trailing_space'"]
INFO       [PD:4  MD:16]	................FunctionNameSegment               	OneOf.match PRN     	    	[ns=2, ps=0, ms=0, pruned=[], opts=[<Ref: FunctionNameIdentifierSegment>, <Ref: QuotedIdentifierSegment>]]
DEBUG      [PD:4  MD:17]	.................FunctionNameSegment              	Ref.match OUT       	+   	[match=<MatchResult 1/3: 'as'>, seg="'as trailing_space'"]
DEBUG      [PD:4  MD:17]	.................FunctionNameSegment              	Ref.match OUT       	    	[match=<MatchResult 0/3: ''>, seg="'as trailing_space'"]
INFO       [PD:4  MD:16]	................FunctionNameSegment               	OneOf.match OUT     	+   	[match=<MatchResult 1/3: 'as'>, seg="'as trailing_space'"]
INFO       [PD:4  MD:15]	...............FunctionNameSegment                	Seque.match OUT     	+   	[match=<MatchResult 1/3: 'as'>, seg="'as trailing_space'"]
DEBUG      [PD:4  MD:14]	..............FunctionNameSegment                 	Funct.match OUT     	+   	[match=<MatchResult 1/3: 'as'>, seg="'as trailing_space'"]
DEBUG      [PD:4  MD:14]	..............FunctionSegment                     	Ref.match OUT       	+   	[match=<MatchResult 1/3: 'as'>, seg="'as trailing_space'"]
INFO       [PD:4  MD:13]	.............FunctionSegment                      	AnyNu.match OUT     	+   	[match=<MatchResult 1/3: 'as'>, seg="'as trailing_space'"]
INFO       [PD:4  MD:13]	.............FunctionSegment                      	Brack.match OUT     	    	[match=<MatchResult 0/1: ''>, seg="'trailing_space'"]
INFO       [PD:4  MD:12]	............FunctionSegment                       	Seque.match OUT     	    	[match=<MatchResult 0/3: ''>, seg="'as trailing_space'"]
INFO       [PD:4  MD:11]	...........FunctionSegment                        	Seque.match OUT     	    	[match=<MatchResult 0/3: ''>, seg="'as trailing_space'"]
INFO       [PD:4  MD:10]	..........FunctionSegment                         	OneOf.match OUT     	    	[match=<MatchResult 0/3: ''>, seg="'as trailing_space'"]
DEBUG      [PD:4  MD:9 ]	.........FunctionSegment                          	Funct.match OUT     	    	[match=<MatchResult 0/3: ''>, seg="'as trailing_space'"]
DEBUG      [PD:4  MD:9 ]	.........Expression_D_Grammar                     	Ref.match OUT       	    	[match=<MatchResult 0/3: ''>, seg="'as trailing_space'"]
INFO       [PD:4  MD:9 ]	.........LiteralGrammar                           	OneOf.match PRN     	    	[ns=2, ps=4, ms=0, pruned=[<Ref: BooleanLiteralGrammar>, <Ref: QualifiedNumericLiteralSegment>, <Ref: NullLiteralSegment>, <Ref: DateTimeLiteralGrammar>], opts=[<Ref: QuotedLiteralSegment>, <Ref: NumericLiteralSegment>]]
DEBUG      [PD:4  MD:10]	..........LiteralGrammar                          	Ref.match OUT       	    	[match=<MatchResult 0/3: ''>, seg="'as trailing_space'"]
DEBUG      [PD:4  MD:10]	..........LiteralGrammar                          	Ref.match OUT       	    	[match=<MatchResult 0/3: ''>, seg="'as trailing_space'"]
INFO       [PD:4  MD:9 ]	.........LiteralGrammar                           	OneOf.match OUT     	    	[match=<MatchResult 0/3: ''>, seg="'as trailing_space'"]
DEBUG      [PD:4  MD:9 ]	.........Expression_D_Grammar                     	Ref.match OUT       	    	[match=<MatchResult 0/3: ''>, seg="'as trailing_space'"]
DEBUG      [PD:4  MD:11]	...........ColumnReferenceSegment                 	Delim._look_ahead_match IN	    	[ls=3, seg='as trailing_space']
DEBUG      [PD:4  MD:11]	...........ColumnReferenceSegment                 	Delim._look_ahead_match SI	    	[mq=[], sb=['AS', '', 'TRAILING_SPACE']]
INFO       [PD:4  MD:11]	...........ColumnReferenceSegment                 	OneOf.match PRN     	    	[ns=1, ps=9, ms=1, pruned=[<Ref: OnKeywordSegment>, <Ref: UsingKeywordSegment>, <Ref: CommaSegment>, <Ref: CastOperatorSegment>, <Ref: StartSquareBracketSegment>, <Ref: StartBracketSegment>, <Ref: ColonSegment>, <Ref: DelimiterSegment>, <class 'sqlfluff.core.parser.segments.base.BracketedSegment'>], opts=[<Ref: AsKeywordSegment>, <Ref: BinaryOperatorGrammar>]]
DEBUG      [PD:4  MD:12]	............ColumnReferenceSegment                	Ref.match OUT       	+   	[match=<MatchResult 1/3: 'as'>, seg="'as trailing_space'"]
INFO       [PD:4  MD:12]	............BinaryOperatorGrammar                 	OneOf.match PRN     	    	[ns=1, ps=3, ms=0, pruned=[<Ref: ArithmeticBinaryOperatorGrammar>, <Ref: StringBinaryOperatorGrammar>, <Ref: BooleanBinaryOperatorGrammar>], opts=[<Ref: ComparisonOperatorGrammar>]]
INFO       [PD:4  MD:13]	.............ComparisonOperatorGrammar            	OneOf.match PRN     	    	[ns=1, ps=7, ms=0, pruned=[<Ref: EqualsSegment>, <Ref: GreaterThanSegment>, <Ref: LessThanSegment>, <Ref: GreaterThanOrEqualToSegment>, <Ref: LessThanOrEqualToSegment>, <Ref: NotEqualToSegment_a>, <Ref: NotEqualToSegment_b>], opts=[<Ref: LikeOperatorSegment>]]
DEBUG      [PD:4  MD:14]	..............ComparisonOperatorGrammar           	Ref.match OUT       	    	[match=<MatchResult 0/3: ''>, seg="'as trailing_space'"]
INFO       [PD:4  MD:13]	.............ComparisonOperatorGrammar            	OneOf.match OUT     	    	[match=<MatchResult 0/3: ''>, seg="'as trailing_space'"]
DEBUG      [PD:4  MD:13]	.............BinaryOperatorGrammar                	Ref.match OUT       	    	[match=<MatchResult 0/3: ''>, seg="'as trailing_space'"]
INFO       [PD:4  MD:12]	............BinaryOperatorGrammar                 	OneOf.match OUT     	    	[match=<MatchResult 0/3: ''>, seg="'as trailing_space'"]
DEBUG      [PD:4  MD:12]	............ColumnReferenceSegment                	Ref.match OUT       	    	[match=<MatchResult 0/3: ''>, seg="'as trailing_space'"]
INFO       [PD:4  MD:11]	...........ColumnReferenceSegment                 	OneOf.match OUT     	+   	[match=<MatchResult 1/3: 'as'>, seg="'as trailing_space'"]
DEBUG      [PD:4  MD:11]	...........ColumnReferenceSegment                 	NonCo.match OUT     	    	[match=<MatchResult 0/3: ''>, seg="'as trailing_space'"]
INFO       [PD:4  MD:10]	..........ColumnReferenceSegment                  	Delim.match OUT     	    	[match=<MatchResult 0/3: ''>, seg="'as trailing_space'"]
DEBUG      [PD:4  MD:9 ]	.........ColumnReferenceSegment                   	Colum.match OUT     	    	[match=<MatchResult 0/3: ''>, seg="'as trailing_space'"]
DEBUG      [PD:4  MD:9 ]	.........Expression_D_Grammar                     	Ref.match OUT       	    	[match=<MatchResult 0/3: ''>, seg="'as trailing_space'"]
DEBUG      [PD:4  MD:10]	..........Expression_D_Grammar                    	Ref.match OUT       	    	[match=<MatchResult 0/3: ''>, seg="'as trailing_space'"]
INFO       [PD:4  MD:11]	...........ArrayLiteralSegment                    	Brack.match OUT     	    	[match=<MatchResult 0/3: ''>, seg="'as trailing_space'"]
DEBUG      [PD:4  MD:10]	..........ArrayLiteralSegment                     	Array.match OUT     	    	[match=<MatchResult 0/3: ''>, seg="'as trailing_space'"]
DEBUG      [PD:4  MD:10]	..........Expression_D_Grammar                    	Ref.match OUT       	    	[match=<MatchResult 0/3: ''>, seg="'as trailing_space'"]
INFO       [PD:4  MD:9 ]	.........Expression_D_Grammar                     	Seque.match OUT     	    	[match=<MatchResult 0/3: ''>, seg="'as trailing_space'"]
INFO       [PD:4  MD:11]	...........DatatypeSegment                        	OneOf.match PRN     	    	[ns=1, ps=2, ms=0, pruned=[<Sequence: [<OneOf: [<Ref: TimeKeywordSegment>, <Ref..., <Bracketed: [<Ref: NumericLiteralSegment..., <Sequence:...]>, <Sequence: [<Ref: DoubleKeywordSegment>, <Ref: PrecisionKeywordSegment>]>], opts=[<Sequence: [<OneOf: [<Sequence: [<OneOf: [<Ref: Char..., <Bracketed: [<OneOf: [<Delimited: [<Ref:..., <Ref: Char...]>]]
INFO       [PD:4  MD:13]	.............DatatypeSegment                      	OneOf.match PRN     	    	[ns=1, ps=1, ms=0, pruned=[<Sequence: [<OneOf: [<Ref: CharacterKeywordSegment>,..., <OneOf: [<Ref: VaryingKeywordSegment>, <...]>], opts=[<Sequence: [<Sequence: [<Ref: SingleIdentifierGramma..., <Ref: DatatypeIdentifierSegment>]>]]
INFO       [PD:4  MD:16]	................SingleIdentifierGrammar           	OneOf.match PRN     	    	[ns=2, ps=0, ms=0, pruned=[], opts=[<Ref: NakedIdentifierSegment>, <Ref: QuotedIdentifierSegment>]]
DEBUG      [PD:4  MD:17]	.................SingleIdentifierGrammar          	Ref.match OUT       	+   	[match=<MatchResult 1/3: 'as'>, seg="'as trailing_space'"]
DEBUG      [PD:4  MD:17]	.................SingleIdentifierGrammar          	Ref.match OUT       	    	[match=<MatchResult 0/3: ''>, seg="'as trailing_space'"]
INFO       [PD:4  MD:16]	................SingleIdentifierGrammar           	OneOf.match OUT     	+   	[match=<MatchResult 1/3: 'as'>, seg="'as trailing_space'"]
DEBUG      [PD:4  MD:16]	................DatatypeSegment                   	Ref.match OUT       	+   	[match=<MatchResult 1/3: 'as'>, seg="'as trailing_space'"]
DEBUG      [PD:4  MD:16]	................DatatypeSegment                   	Ref.match OUT       	    	[match=<MatchResult 0/2: ''>, seg="' trailing_space'"]
INFO       [PD:4  MD:15]	...............DatatypeSegment                    	Seque.match OUT     	    	[match=<MatchResult 0/3: ''>, seg="'as trailing_space'"]
DEBUG      [PD:4  MD:15]	...............DatatypeSegment                    	Ref.match OUT       	+   	[match=<MatchResult 1/3: 'as'>, seg="'as trailing_space'"]
INFO       [PD:4  MD:14]	..............DatatypeSegment                     	Seque.match OUT     	+   	[match=<MatchResult 1/3: 'as'>, seg="'as trailing_space'"]
INFO       [PD:4  MD:13]	.............DatatypeSegment                      	OneOf.match OUT     	+   	[match=<MatchResult 1/3: 'as'>, seg="'as trailing_space'"]
INFO       [PD:4  MD:13]	.............DatatypeSegment                      	Brack.match OUT     	    	[match=<MatchResult 0/1: ''>, seg="'trailing_space'"]
DEBUG      [PD:4  MD:13]	.............DatatypeSegment                      	Ref.match OUT       	    	[match=<MatchResult 0/1: ''>, seg="'trailing_space'"]
INFO       [PD:4  MD:12]	............DatatypeSegment                       	Seque.match OUT     	+   	[match=<MatchResult 1/3: 'as'>, seg="'as trailing_space'"]
INFO       [PD:4  MD:11]	...........DatatypeSegment                        	OneOf.match OUT     	+   	[match=<MatchResult 1/3: 'as'>, seg="'as trailing_space'"]
DEBUG      [PD:4  MD:10]	..........DatatypeSegment                         	Datat.match OUT     	+   	[match=<MatchResult 1/3: 'as'>, seg="'as trailing_space'"]
DEBUG      [PD:4  MD:10]	..........Expression_D_Grammar                    	Ref.match OUT       	+   	[match=<MatchResult 1/3: 'as'>, seg="'as trailing_space'"]
INFO       [PD:4  MD:10]	..........Expression_D_Grammar                    	OneOf.match PRN     	    	[ns=2, ps=3, ms=0, pruned=[<Ref: BooleanLiteralGrammar>, <Ref: NullLiteralSegment>, <Ref: DateTimeLiteralGrammar>], opts=[<Ref: QuotedLiteralSegment>, <Ref: NumericLiteralSegment>]]
DEBUG      [PD:4  MD:11]	...........Expression_D_Grammar                   	Ref.match OUT       	    	[match=<MatchResult 0/1: ''>, seg="'trailing_space'"]
DEBUG      [PD:4  MD:11]	...........Expression_D_Grammar                   	Ref.match OUT       	    	[match=<MatchResult 0/1: ''>, seg="'trailing_space'"]
INFO       [PD:4  MD:10]	..........Expression_D_Grammar                    	OneOf.match OUT     	    	[match=<MatchResult 0/1: ''>, seg="'trailing_space'"]
INFO       [PD:4  MD:9 ]	.........Expression_D_Grammar                     	Seque.match OUT     	    	[match=<MatchResult 0/3: ''>, seg="'as trailing_space'"]
INFO       [PD:4  MD:8 ]	........Expression_D_Grammar                      	OneOf.match OUT     	    	[match=<MatchResult 0/3: ''>, seg="'as trailing_space'"]
INFO       [PD:4  MD:7 ]	.......Expression_D_Grammar                       	Seque.match OUT     	    	[match=<MatchResult 0/3: ''>, seg="'as trailing_space'"]
DEBUG      [PD:4  MD:7 ]	.......Expression_C_Grammar                       	Ref.match OUT       	    	[match=<MatchResult 0/3: ''>, seg="'as trailing_space'"]
INFO       [PD:4  MD:6 ]	......Expression_C_Grammar                        	OneOf.match OUT     	    	[match=<MatchResult 0/3: ''>, seg="'as trailing_space'"]
DEBUG      [PD:4  MD:6 ]	......Expression_A_Grammar                        	Ref.match OUT       	    	[match=<MatchResult 0/3: ''>, seg="'as trailing_space'"]
INFO       [PD:4  MD:5 ]	.....Expression_A_Grammar                         	OneOf.match OUT     	    	[match=<MatchResult 0/3: ''>, seg="'as trailing_space'"]
INFO       [PD:4  MD:4 ]	....Expression_A_Grammar                          	Seque.match OUT     	    	[match=<MatchResult 0/3: ''>, seg="'as trailing_space'"]
DEBUG      [PD:4  MD:4 ]	....ExpressionSegment                             	Ref.match OUT       	    	[match=<MatchResult 0/3: ''>, seg="'as trailing_space'"]
DEBUG      [PD:4  MD:3 ]	...ExpressionSegment                              	Expre.match OUT     	    	[match=<MatchResult 0/3: ''>, seg="'as trailing_space'"]
DEBUG      [PD:4  MD:3 ]	...BaseExpressionElementGrammar                   	Ref.match OUT       	    	[match=<MatchResult 0/3: ''>, seg="'as trailing_space'"]
INFO       [PD:4  MD:2 ]	..BaseExpressionElementGrammar                    	OneOf.match OUT     	    	[match=<MatchResult 0/3: ''>, seg="'as trailing_space'"]
DEBUG      [PD:4  MD:2 ]	..SelectClauseElementSegment                      	Ref.match OUT       	    	[match=<MatchResult 0/3: ''>, seg="'as trailing_space'"]
INFO       [PD:4  MD:1 ]	.SelectClauseElementSegment                       	Seque.match OUT     	    	[match=<MatchResult 0/3: ''>, seg="'as trailing_space'"]
INFO       [PD:4  MD:0 ]	SelectClauseElementSegment                        	OneOf.match OUT     	    	[match=<MatchResult 0/3: ''>, seg="'as trailing_space'"]
DEBUG      SelectClauseElementSegment.parse: Done Parse. Plotting Recursion. Recurse=True
DEBUG      ###
#
# Beginning Parse Depth 5: SelectClauseElementSegment
#
###
Initial Structure:
[L:  3, P: 21]      |select_clause_element:
[L:  3, P: 21]      |    unparsable:                                               !! Expected: 'SelectClauseElementSegment'
[L:  3, P: 21]      |        raw:                                                  'as'
[L:  3, P: 23]      |        whitespace:                                           ' '
[L:  3, P: 24]      |        raw:                                                  'trailing_space'

INFO       [PD:5] Skipping expansion of <UnparsableSegment: ([L:  3, P: 21])>...
INFO       [PD:4] Skipping expansion of <WhitespaceSegment: ([L:  3, P: 38]) '   '>...
INFO       [PD:4] Skipping expansion of <SymbolSegment: ([L:  3, P: 41]) ','>...
INFO       [PD:4] Skipping expansion of <NewlineSegment: ([L:  3, P: 42]) '\n'>...
INFO       [PD:4] Skipping expansion of <WhitespaceSegment: ([L:  4, P:  1]) '    '>...
INFO       
###
#
# Parse Depth 4. Expanding: SelectClauseElementSegment: '3 +'
#
###
INFO       [PD:4  MD:0 ]	SelectClauseElementSegment                        	OneOf.match PRN     	    	[ns=2, ps=0, ms=0, pruned=[], opts=[<Ref: WildcardExpressionSegment>, <Sequence: [<Ref: BaseExpressionElementGrammar>, <Ref: AliasExpressionSegment [opt]>]>]]
INFO       [PD:4  MD:5 ]	.....WildcardIdentifierSegment                    	AnyNu.match PRN     	    	[ns=1, ps=0, ms=0, pruned=[], opts=[<Sequence: [<Ref: SingleIdentifierGrammar>, <Ref: DotSegment>]>]]
INFO       [PD:4  MD:7 ]	.......SingleIdentifierGrammar                    	OneOf.match PRN     	    	[ns=2, ps=0, ms=0, pruned=[], opts=[<Ref: NakedIdentifierSegment>, <Ref: QuotedIdentifierSegment>]]
DEBUG      [PD:4  MD:8 ]	........SingleIdentifierGrammar                   	Ref.match OUT       	    	[match=<MatchResult 0/3: ''>, seg="'3 +'"]
DEBUG      [PD:4  MD:8 ]	........SingleIdentifierGrammar                   	Ref.match OUT       	    	[match=<MatchResult 0/3: ''>, seg="'3 +'"]
INFO       [PD:4  MD:7 ]	.......SingleIdentifierGrammar                    	OneOf.match OUT     	    	[match=<MatchResult 0/3: ''>, seg="'3 +'"]
DEBUG      [PD:4  MD:7 ]	.......WildcardIdentifierSegment                  	Ref.match OUT       	    	[match=<MatchResult 0/3: ''>, seg="'3 +'"]
INFO       [PD:4  MD:6 ]	......WildcardIdentifierSegment                   	Seque.match OUT     	    	[match=<MatchResult 0/3: ''>, seg="'3 +'"]
INFO       [PD:4  MD:5 ]	.....WildcardIdentifierSegment                    	AnyNu.match OUT     	    	[match=<MatchResult 0/3: ''>, seg="'3 +'"]
DEBUG      [PD:4  MD:5 ]	.....WildcardIdentifierSegment                    	Ref.match OUT       	    	[match=<MatchResult 0/3: ''>, seg="'3 +'"]
INFO       [PD:4  MD:4 ]	....WildcardIdentifierSegment                     	Seque.match OUT     	    	[match=<MatchResult 0/3: ''>, seg="'3 +'"]
DEBUG      [PD:4  MD:3 ]	...WildcardIdentifierSegment                      	Wildc.match OUT     	    	[match=<MatchResult 0/3: ''>, seg="'3 +'"]
DEBUG      [PD:4  MD:3 ]	...WildcardExpressionSegment                      	Ref.match OUT       	    	[match=<MatchResult 0/3: ''>, seg="'3 +'"]
INFO       [PD:4  MD:2 ]	..WildcardExpressionSegment                       	Seque.match OUT     	    	[match=<MatchResult 0/3: ''>, seg="'3 +'"]
DEBUG      [PD:4  MD:1 ]	.WildcardExpressionSegment                        	Wildc.match OUT     	    	[match=<MatchResult 0/3: ''>, seg="'3 +'"]
DEBUG      [PD:4  MD:1 ]	.SelectClauseElementSegment                       	Ref.match OUT       	    	[match=<MatchResult 0/3: ''>, seg="'3 +'"]
INFO       [PD:4  MD:2 ]	..BaseExpressionElementGrammar                    	OneOf.match PRN     	    	[ns=5, ps=1, ms=0, pruned=[<Ref: IntervalExpressionSegment>], opts=[<Ref: LiteralGrammar>, <Ref: BareFunctionSegment>, <Ref: FunctionSegment>, <Ref: ColumnReferenceSegment>, <Ref: ExpressionSegment>]]
INFO       [PD:4  MD:3 ]	...LiteralGrammar                                 	OneOf.match PRN     	    	[ns=2, ps=4, ms=0, pruned=[<Ref: BooleanLiteralGrammar>, <Ref: QualifiedNumericLiteralSegment>, <Ref: NullLiteralSegment>, <Ref: DateTimeLiteralGrammar>], opts=[<Ref: QuotedLiteralSegment>, <Ref: NumericLiteralSegment>]]
DEBUG      [PD:4  MD:4 ]	....LiteralGrammar                                	Ref.match OUT       	    	[match=<MatchResult 0/3: ''>, seg="'3 +'"]
DEBUG      [PD:4  MD:4 ]	....LiteralGrammar                                	Ref.match OUT       	+   	[match=<MatchResult 1/3: '3'>, seg="'3 +'"]
INFO       [PD:4  MD:3 ]	...LiteralGrammar                                 	OneOf.match OUT     	+   	[match=<MatchResult 1/3: '3'>, seg="'3 +'"]
DEBUG      [PD:4  MD:3 ]	...BaseExpressionElementGrammar                   	Ref.match OUT       	+   	[match=<MatchResult 1/3: '3'>, seg="'3 +'"]
DEBUG      [PD:4  MD:3 ]	...BaseExpressionElementGrammar                   	Ref.match OUT       	    	[match=<MatchResult 0/3: ''>, seg="'3 +'"]
INFO       [PD:4  MD:4 ]	....FunctionSegment                               	OneOf.match PRN     	    	[ns=1, ps=1, ms=0, pruned=[<Sequence: [<Sequence: [<Ref: DateAddFunctionNameSeg...]>], opts=[<Sequence: [<Sequence: [<AnyNumberOf: [<Ref: Functio..., <Ref: PostFunctionGrammar [opt]>]>]]
DEBUG      [PD:4  MD:10]	..........DateAddFunctionNameSegment              	Ref.match OUT       	    	[match=<MatchResult 0/3: ''>, seg="'3 +'"]
INFO       [PD:4  MD:9 ]	.........DateAddFunctionNameSegment               	Seque.match OUT     	    	[match=<MatchResult 0/3: ''>, seg="'3 +'"]
DEBUG      [PD:4  MD:8 ]	........DateAddFunctionNameSegment                	DateA.match OUT     	    	[match=<MatchResult 0/3: ''>, seg="'3 +'"]
DEBUG      [PD:4  MD:8 ]	........FunctionSegment                           	Ref.match OUT       	    	[match=<MatchResult 0/3: ''>, seg="'3 +'"]
INFO       [PD:4  MD:7 ]	.......FunctionSegment                            	AnyNu.match PRN     	    	[ns=1, ps=0, ms=0, pruned=[], opts=[<Ref: FunctionNameSegment>]]
INFO       [PD:4  MD:10]	..........FunctionNameSegment                     	AnyNu.match PRN     	    	[ns=1, ps=0, ms=0, pruned=[], opts=[<Sequence: [<Ref: SingleIdentifierGrammar>, <Ref: DotSegment>]>]]
INFO       [PD:4  MD:12]	............SingleIdentifierGrammar               	OneOf.match PRN     	    	[ns=2, ps=0, ms=0, pruned=[], opts=[<Ref: NakedIdentifierSegment>, <Ref: QuotedIdentifierSegment>]]
DEBUG      [PD:4  MD:13]	.............SingleIdentifierGrammar              	Ref.match OUT       	    	[match=<MatchResult 0/3: ''>, seg="'3 +'"]
DEBUG      [PD:4  MD:13]	.............SingleIdentifierGrammar              	Ref.match OUT       	    	[match=<MatchResult 0/3: ''>, seg="'3 +'"]
INFO       [PD:4  MD:12]	............SingleIdentifierGrammar               	OneOf.match OUT     	    	[match=<MatchResult 0/3: ''>, seg="'3 +'"]
DEBUG      [PD:4  MD:12]	............FunctionNameSegment                   	Ref.match OUT       	    	[match=<MatchResult 0/3: ''>, seg="'3 +'"]
INFO       [PD:4  MD:11]	...........FunctionNameSegment                    	Seque.match OUT     	    	[match=<MatchResult 0/3: ''>, seg="'3 +'"]
INFO       [PD:4  MD:10]	..........FunctionNameSegment                     	AnyNu.match OUT     	    	[match=<MatchResult 0/3: ''>, seg="'3 +'"]
INFO       [PD:4  MD:10]	..........FunctionNameSegment                     	OneOf.match PRN     	    	[ns=2, ps=0, ms=0, pruned=[], opts=[<Ref: FunctionNameIdentifierSegment>, <Ref: QuotedIdentifierSegment>]]
DEBUG      [PD:4  MD:11]	...........FunctionNameSegment                    	Ref.match OUT       	    	[match=<MatchResult 0/3: ''>, seg="'3 +'"]
DEBUG      [PD:4  MD:11]	...........FunctionNameSegment                    	Ref.match OUT       	    	[match=<MatchResult 0/3: ''>, seg="'3 +'"]
INFO       [PD:4  MD:10]	..........FunctionNameSegment                     	OneOf.match OUT     	    	[match=<MatchResult 0/3: ''>, seg="'3 +'"]
INFO       [PD:4  MD:9 ]	.........FunctionNameSegment                      	Seque.match OUT     	    	[match=<MatchResult 0/3: ''>, seg="'3 +'"]
DEBUG      [PD:4  MD:8 ]	........FunctionNameSegment                       	Funct.match OUT     	    	[match=<MatchResult 0/3: ''>, seg="'3 +'"]
DEBUG      [PD:4  MD:8 ]	........FunctionSegment                           	Ref.match OUT       	    	[match=<MatchResult 0/3: ''>, seg="'3 +'"]
INFO       [PD:4  MD:7 ]	.......FunctionSegment                            	AnyNu.match OUT     	    	[match=<MatchResult 0/3: ''>, seg="'3 +'"]
INFO       [PD:4  MD:6 ]	......FunctionSegment                             	Seque.match OUT     	    	[match=<MatchResult 0/3: ''>, seg="'3 +'"]
INFO       [PD:4  MD:5 ]	.....FunctionSegment                              	Seque.match OUT     	    	[match=<MatchResult 0/3: ''>, seg="'3 +'"]
INFO       [PD:4  MD:4 ]	....FunctionSegment                               	OneOf.match OUT     	    	[match=<MatchResult 0/3: ''>, seg="'3 +'"]
DEBUG      [PD:4  MD:3 ]	...FunctionSegment                                	Funct.match OUT     	    	[match=<MatchResult 0/3: ''>, seg="'3 +'"]
DEBUG      [PD:4  MD:3 ]	...BaseExpressionElementGrammar                   	Ref.match OUT       	    	[match=<MatchResult 0/3: ''>, seg="'3 +'"]
DEBUG      [PD:4  MD:5 ]	.....ColumnReferenceSegment                       	Delim._look_ahead_match IN	    	[ls=3, seg='3 +']
DEBUG      [PD:4  MD:5 ]	.....ColumnReferenceSegment                       	Delim._look_ahead_match SI	    	[mq=[], sb=['3', '', '+']]
INFO       [PD:4  MD:5 ]	.....ColumnReferenceSegment                       	OneOf.match PRN     	    	[ns=1, ps=10, ms=0, pruned=[<Ref: OnKeywordSegment>, <Ref: AsKeywordSegment>, <Ref: UsingKeywordSegment>, <Ref: CommaSegment>, <Ref: CastOperatorSegment>, <Ref: StartSquareBracketSegment>, <Ref: StartBracketSegment>, <Ref: ColonSegment>, <Ref: DelimiterSegment>, <class 'sqlfluff.core.parser.segments.base.BracketedSegment'>], opts=[<Ref: BinaryOperatorGrammar>]]
INFO       [PD:4  MD:6 ]	......BinaryOperatorGrammar                       	OneOf.match PRN     	    	[ns=1, ps=3, ms=0, pruned=[<Ref: ArithmeticBinaryOperatorGrammar>, <Ref: StringBinaryOperatorGrammar>, <Ref: BooleanBinaryOperatorGrammar>], opts=[<Ref: ComparisonOperatorGrammar>]]
INFO       [PD:4  MD:7 ]	.......ComparisonOperatorGrammar                  	OneOf.match PRN     	    	[ns=1, ps=7, ms=0, pruned=[<Ref: EqualsSegment>, <Ref: GreaterThanSegment>, <Ref: LessThanSegment>, <Ref: GreaterThanOrEqualToSegment>, <Ref: LessThanOrEqualToSegment>, <Ref: NotEqualToSegment_a>, <Ref: NotEqualToSegment_b>], opts=[<Ref: LikeOperatorSegment>]]
DEBUG      [PD:4  MD:8 ]	........ComparisonOperatorGrammar                 	Ref.match OUT       	    	[match=<MatchResult 0/3: ''>, seg="'3 +'"]
INFO       [PD:4  MD:7 ]	.......ComparisonOperatorGrammar                  	OneOf.match OUT     	    	[match=<MatchResult 0/3: ''>, seg="'3 +'"]
DEBUG      [PD:4  MD:7 ]	.......BinaryOperatorGrammar                      	Ref.match OUT       	    	[match=<MatchResult 0/3: ''>, seg="'3 +'"]
INFO       [PD:4  MD:6 ]	......BinaryOperatorGrammar                       	OneOf.match OUT     	    	[match=<MatchResult 0/3: ''>, seg="'3 +'"]
DEBUG      [PD:4  MD:6 ]	......ColumnReferenceSegment                      	Ref.match OUT       	    	[match=<MatchResult 0/3: ''>, seg="'3 +'"]
INFO       [PD:4  MD:5 ]	.....ColumnReferenceSegment                       	OneOf.match OUT     	    	[match=<MatchResult 0/3: ''>, seg="'3 +'"]
DEBUG      [PD:4  MD:5 ]	.....ColumnReferenceSegment                       	NonCo.match OUT     	    	[match=<MatchResult 0/3: ''>, seg="'3 +'"]
INFO       [PD:4  MD:5 ]	.....ColumnReferenceSegment                       	OneOf.match PRN     	    	[ns=1, ps=10, ms=0, pruned=[<Ref: OnKeywordSegment>, <Ref: AsKeywordSegment>, <Ref: UsingKeywordSegment>, <Ref: CommaSegment>, <Ref: CastOperatorSegment>, <Ref: StartSquareBracketSegment>, <Ref: StartBracketSegment>, <Ref: ColonSegment>, <Ref: DelimiterSegment>, <class 'sqlfluff.core.parser.segments.base.BracketedSegment'>], opts=[<Ref: BinaryOperatorGrammar>]]
INFO       [PD:4  MD:6 ]	......BinaryOperatorGrammar                       	OneOf.match PRN     	    	[ns=1, ps=2, ms=1, pruned=[<Ref: StringBinaryOperatorGrammar>, <Ref: BooleanBinaryOperatorGrammar>], opts=[<Ref: ArithmeticBinaryOperatorGrammar>, <Ref: ComparisonOperatorGrammar>]]
INFO       [PD:4  MD:7 ]	.......ArithmeticBinaryOperatorGrammar            	OneOf.match PRN     	    	[ns=0, ps=9, ms=1, pruned=[<Ref: MinusSegment>, <Ref: DivideSegment>, <Ref: MultiplySegment>, <Ref: ModuloSegment>, <Ref: BitwiseAndSegment>, <Ref: BitwiseOrSegment>, <Ref: BitwiseXorSegment>, <Ref: BitwiseLShiftSegment>, <Ref: BitwiseRShiftSegment>], opts=[<Ref: PlusSegment>]]
DEBUG      [PD:4  MD:8 ]	........ArithmeticBinaryOperatorGrammar           	Ref.match OUT       	    	[match=<MatchResult 0/2: ''>, seg="' +'"]
INFO       [PD:4  MD:7 ]	.......ArithmeticBinaryOperatorGrammar            	OneOf.match OUT     	    	[match=<MatchResult 0/2: ''>, seg="' +'"]
DEBUG      [PD:4  MD:7 ]	.......BinaryOperatorGrammar                      	Ref.match OUT       	    	[match=<MatchResult 0/2: ''>, seg="' +'"]
INFO       [PD:4  MD:7 ]	.......ComparisonOperatorGrammar                  	OneOf.match PRN     	    	[ns=1, ps=7, ms=0, pruned=[<Ref: EqualsSegment>, <Ref: GreaterThanSegment>, <Ref: LessThanSegment>, <Ref: GreaterThanOrEqualToSegment>, <Ref: LessThanOrEqualToSegment>, <Ref: NotEqualToSegment_a>, <Ref: NotEqualToSegment_b>], opts=[<Ref: LikeOperatorSegment>]]
DEBUG      [PD:4  MD:8 ]	........ComparisonOperatorGrammar                 	Ref.match OUT       	    	[match=<MatchResult 0/2: ''>, seg="' +'"]
INFO       [PD:4  MD:7 ]	.......ComparisonOperatorGrammar                  	OneOf.match OUT     	    	[match=<MatchResult 0/2: ''>, seg="' +'"]
DEBUG      [PD:4  MD:7 ]	.......BinaryOperatorGrammar                      	Ref.match OUT       	    	[match=<MatchResult 0/2: ''>, seg="' +'"]
INFO       [PD:4  MD:6 ]	......BinaryOperatorGrammar                       	OneOf.match OUT     	    	[match=<MatchResult 0/2: ''>, seg="' +'"]
DEBUG      [PD:4  MD:6 ]	......ColumnReferenceSegment                      	Ref.match OUT       	    	[match=<MatchResult 0/2: ''>, seg="' +'"]
INFO       [PD:4  MD:5 ]	.....ColumnReferenceSegment                       	OneOf.match OUT     	    	[match=<MatchResult 0/2: ''>, seg="' +'"]
DEBUG      [PD:4  MD:5 ]	.....ColumnReferenceSegment                       	NonCo.match OUT     	+   	[match=<MatchResult 1/2: ' '>, seg="' +'"]
INFO       [PD:4  MD:5 ]	.....SingleIdentifierGrammar                      	OneOf.match PRN     	    	[ns=2, ps=0, ms=0, pruned=[], opts=[<Ref: NakedIdentifierSegment>, <Ref: QuotedIdentifierSegment>]]
DEBUG      [PD:4  MD:6 ]	......SingleIdentifierGrammar                     	Ref.match OUT       	    	[match=<MatchResult 0/1: ''>, seg="'3'"]
DEBUG      [PD:4  MD:6 ]	......SingleIdentifierGrammar                     	Ref.match OUT       	    	[match=<MatchResult 0/1: ''>, seg="'3'"]
INFO       [PD:4  MD:5 ]	.....SingleIdentifierGrammar                      	OneOf.match OUT     	    	[match=<MatchResult 0/1: ''>, seg="'3'"]
DEBUG      [PD:4  MD:5 ]	.....ColumnReferenceSegment                       	Ref.match OUT       	    	[match=<MatchResult 0/1: ''>, seg="'3'"]
INFO       [PD:4  MD:4 ]	....ColumnReferenceSegment                        	Delim.match OUT     	    	[match=<MatchResult 0/3: ''>, seg="'3 +'"]
DEBUG      [PD:4  MD:3 ]	...ColumnReferenceSegment                         	Colum.match OUT     	    	[match=<MatchResult 0/3: ''>, seg="'3 +'"]
DEBUG      [PD:4  MD:3 ]	...BaseExpressionElementGrammar                   	Ref.match OUT       	    	[match=<MatchResult 0/3: ''>, seg="'3 +'"]
INFO       [PD:4  MD:5 ]	.....Expression_A_Grammar                         	OneOf.match PRN     	    	[ns=1, ps=1, ms=0, pruned=[<Sequence: [<OneOf: [<Ref: PositiveSegment>, <Ref: N..., <Ref: Expression_C_Grammar>]>], opts=[<Ref: Expression_C_Grammar>]]
INFO       [PD:4  MD:6 ]	......Expression_C_Grammar                        	OneOf.match PRN     	    	[ns=1, ps=2, ms=0, pruned=[<Sequence: [<Ref: ExistsKeywordSegment>, <Bracketed: [<Ref: SelectStatementSegmen...]>, <Ref: CaseExpressionSegment>], opts=[<Ref: Expression_D_Grammar>]]
INFO       [PD:4  MD:8 ]	........Expression_D_Grammar                      	OneOf.match PRN     	    	[ns=6, ps=3, ms=0, pruned=[<Bracketed: [<OneOf: [<Ref: ExpressionSegment>, <Ref:...]>, <Ref: SelectStatementSegment>, <Ref: IntervalExpressionSegment>], opts=[<Ref: BareFunctionSegment>, <Ref: FunctionSegment>, <Ref: LiteralGrammar>, <Ref: ColumnReferenceSegment>, <Sequence: [<Ref: SimpleArrayTypeGrammar [opt]>, <Ref: ArrayLiteralSegment>]>, <Sequence: [<Ref: DatatypeSegment>, <OneOf: [<Ref: QuotedLiteralSegment>, <R...]>]]
DEBUG      [PD:4  MD:9 ]	.........Expression_D_Grammar                     	Ref.match OUT       	    	[match=<MatchResult 0/3: ''>, seg="'3 +'"]
INFO       [PD:4  MD:10]	..........FunctionSegment                         	OneOf.match PRN     	    	[ns=1, ps=1, ms=0, pruned=[<Sequence: [<Sequence: [<Ref: DateAddFunctionNameSeg...]>], opts=[<Sequence: [<Sequence: [<AnyNumberOf: [<Ref: Functio..., <Ref: PostFunctionGrammar [opt]>]>]]
DEBUG      [PD:4  MD:16]	................DateAddFunctionNameSegment        	Ref.match OUT       	    	[match=<MatchResult 0/3: ''>, seg="'3 +'"]
INFO       [PD:4  MD:15]	...............DateAddFunctionNameSegment         	Seque.match OUT     	    	[match=<MatchResult 0/3: ''>, seg="'3 +'"]
DEBUG      [PD:4  MD:14]	..............DateAddFunctionNameSegment          	DateA.match OUT     	    	[match=<MatchResult 0/3: ''>, seg="'3 +'"]
DEBUG      [PD:4  MD:14]	..............FunctionSegment                     	Ref.match OUT       	    	[match=<MatchResult 0/3: ''>, seg="'3 +'"]
INFO       [PD:4  MD:13]	.............FunctionSegment                      	AnyNu.match PRN     	    	[ns=1, ps=0, ms=0, pruned=[], opts=[<Ref: FunctionNameSegment>]]
INFO       [PD:4  MD:16]	................FunctionNameSegment               	AnyNu.match PRN     	    	[ns=1, ps=0, ms=0, pruned=[], opts=[<Sequence: [<Ref: SingleIdentifierGrammar>, <Ref: DotSegment>]>]]
INFO       [PD:4  MD:18]	..................SingleIdentifierGrammar         	OneOf.match PRN     	    	[ns=2, ps=0, ms=0, pruned=[], opts=[<Ref: NakedIdentifierSegment>, <Ref: QuotedIdentifierSegment>]]
DEBUG      [PD:4  MD:19]	...................SingleIdentifierGrammar        	Ref.match OUT       	    	[match=<MatchResult 0/3: ''>, seg="'3 +'"]
DEBUG      [PD:4  MD:19]	...................SingleIdentifierGrammar        	Ref.match OUT       	    	[match=<MatchResult 0/3: ''>, seg="'3 +'"]
INFO       [PD:4  MD:18]	..................SingleIdentifierGrammar         	OneOf.match OUT     	    	[match=<MatchResult 0/3: ''>, seg="'3 +'"]
DEBUG      [PD:4  MD:18]	..................FunctionNameSegment             	Ref.match OUT       	    	[match=<MatchResult 0/3: ''>, seg="'3 +'"]
INFO       [PD:4  MD:17]	.................FunctionNameSegment              	Seque.match OUT     	    	[match=<MatchResult 0/3: ''>, seg="'3 +'"]
INFO       [PD:4  MD:16]	................FunctionNameSegment               	AnyNu.match OUT     	    	[match=<MatchResult 0/3: ''>, seg="'3 +'"]
INFO       [PD:4  MD:16]	................FunctionNameSegment               	OneOf.match PRN     	    	[ns=2, ps=0, ms=0, pruned=[], opts=[<Ref: FunctionNameIdentifierSegment>, <Ref: QuotedIdentifierSegment>]]
DEBUG      [PD:4  MD:17]	.................FunctionNameSegment              	Ref.match OUT       	    	[match=<MatchResult 0/3: ''>, seg="'3 +'"]
DEBUG      [PD:4  MD:17]	.................FunctionNameSegment              	Ref.match OUT       	    	[match=<MatchResult 0/3: ''>, seg="'3 +'"]
INFO       [PD:4  MD:16]	................FunctionNameSegment               	OneOf.match OUT     	    	[match=<MatchResult 0/3: ''>, seg="'3 +'"]
INFO       [PD:4  MD:15]	...............FunctionNameSegment                	Seque.match OUT     	    	[match=<MatchResult 0/3: ''>, seg="'3 +'"]
DEBUG      [PD:4  MD:14]	..............FunctionNameSegment                 	Funct.match OUT     	    	[match=<MatchResult 0/3: ''>, seg="'3 +'"]
DEBUG      [PD:4  MD:14]	..............FunctionSegment                     	Ref.match OUT       	    	[match=<MatchResult 0/3: ''>, seg="'3 +'"]
INFO       [PD:4  MD:13]	.............FunctionSegment                      	AnyNu.match OUT     	    	[match=<MatchResult 0/3: ''>, seg="'3 +'"]
INFO       [PD:4  MD:12]	............FunctionSegment                       	Seque.match OUT     	    	[match=<MatchResult 0/3: ''>, seg="'3 +'"]
INFO       [PD:4  MD:11]	...........FunctionSegment                        	Seque.match OUT     	    	[match=<MatchResult 0/3: ''>, seg="'3 +'"]
INFO       [PD:4  MD:10]	..........FunctionSegment                         	OneOf.match OUT     	    	[match=<MatchResult 0/3: ''>, seg="'3 +'"]
DEBUG      [PD:4  MD:9 ]	.........FunctionSegment                          	Funct.match OUT     	    	[match=<MatchResult 0/3: ''>, seg="'3 +'"]
DEBUG      [PD:4  MD:9 ]	.........Expression_D_Grammar                     	Ref.match OUT       	    	[match=<MatchResult 0/3: ''>, seg="'3 +'"]
INFO       [PD:4  MD:9 ]	.........LiteralGrammar                           	OneOf.match PRN     	    	[ns=2, ps=4, ms=0, pruned=[<Ref: BooleanLiteralGrammar>, <Ref: QualifiedNumericLiteralSegment>, <Ref: NullLiteralSegment>, <Ref: DateTimeLiteralGrammar>], opts=[<Ref: QuotedLiteralSegment>, <Ref: NumericLiteralSegment>]]
DEBUG      [PD:4  MD:10]	..........LiteralGrammar                          	Ref.match OUT       	    	[match=<MatchResult 0/3: ''>, seg="'3 +'"]
DEBUG      [PD:4  MD:10]	..........LiteralGrammar                          	Ref.match OUT       	+   	[match=<MatchResult 1/3: '3'>, seg="'3 +'"]
INFO       [PD:4  MD:9 ]	.........LiteralGrammar                           	OneOf.match OUT     	+   	[match=<MatchResult 1/3: '3'>, seg="'3 +'"]
DEBUG      [PD:4  MD:9 ]	.........Expression_D_Grammar                     	Ref.match OUT       	+   	[match=<MatchResult 1/3: '3'>, seg="'3 +'"]
DEBUG      [PD:4  MD:11]	...........ColumnReferenceSegment                 	Delim._look_ahead_match IN	    	[ls=3, seg='3 +']
DEBUG      [PD:4  MD:11]	...........ColumnReferenceSegment                 	Delim._look_ahead_match SI	    	[mq=[], sb=['3', '', '+']]
INFO       [PD:4  MD:11]	...........ColumnReferenceSegment                 	OneOf.match PRN     	    	[ns=1, ps=10, ms=0, pruned=[<Ref: OnKeywordSegment>, <Ref: AsKeywordSegment>, <Ref: UsingKeywordSegment>, <Ref: CommaSegment>, <Ref: CastOperatorSegment>, <Ref: StartSquareBracketSegment>, <Ref: StartBracketSegment>, <Ref: ColonSegment>, <Ref: DelimiterSegment>, <class 'sqlfluff.core.parser.segments.base.BracketedSegment'>], opts=[<Ref: BinaryOperatorGrammar>]]
INFO       [PD:4  MD:12]	............BinaryOperatorGrammar                 	OneOf.match PRN     	    	[ns=1, ps=3, ms=0, pruned=[<Ref: ArithmeticBinaryOperatorGrammar>, <Ref: StringBinaryOperatorGrammar>, <Ref: BooleanBinaryOperatorGrammar>], opts=[<Ref: ComparisonOperatorGrammar>]]
INFO       [PD:4  MD:13]	.............ComparisonOperatorGrammar            	OneOf.match PRN     	    	[ns=1, ps=7, ms=0, pruned=[<Ref: EqualsSegment>, <Ref: GreaterThanSegment>, <Ref: LessThanSegment>, <Ref: GreaterThanOrEqualToSegment>, <Ref: LessThanOrEqualToSegment>, <Ref: NotEqualToSegment_a>, <Ref: NotEqualToSegment_b>], opts=[<Ref: LikeOperatorSegment>]]
DEBUG      [PD:4  MD:14]	..............ComparisonOperatorGrammar           	Ref.match OUT       	    	[match=<MatchResult 0/3: ''>, seg="'3 +'"]
INFO       [PD:4  MD:13]	.............ComparisonOperatorGrammar            	OneOf.match OUT     	    	[match=<MatchResult 0/3: ''>, seg="'3 +'"]
DEBUG      [PD:4  MD:13]	.............BinaryOperatorGrammar                	Ref.match OUT       	    	[match=<MatchResult 0/3: ''>, seg="'3 +'"]
INFO       [PD:4  MD:12]	............BinaryOperatorGrammar                 	OneOf.match OUT     	    	[match=<MatchResult 0/3: ''>, seg="'3 +'"]
DEBUG      [PD:4  MD:12]	............ColumnReferenceSegment                	Ref.match OUT       	    	[match=<MatchResult 0/3: ''>, seg="'3 +'"]
INFO       [PD:4  MD:11]	...........ColumnReferenceSegment                 	OneOf.match OUT     	    	[match=<MatchResult 0/3: ''>, seg="'3 +'"]
DEBUG      [PD:4  MD:11]	...........ColumnReferenceSegment                 	NonCo.match OUT     	    	[match=<MatchResult 0/3: ''>, seg="'3 +'"]
INFO       [PD:4  MD:11]	...........ColumnReferenceSegment                 	OneOf.match PRN     	    	[ns=1, ps=10, ms=0, pruned=[<Ref: OnKeywordSegment>, <Ref: AsKeywordSegment>, <Ref: UsingKeywordSegment>, <Ref: CommaSegment>, <Ref: CastOperatorSegment>, <Ref: StartSquareBracketSegment>, <Ref: StartBracketSegment>, <Ref: ColonSegment>, <Ref: DelimiterSegment>, <class 'sqlfluff.core.parser.segments.base.BracketedSegment'>], opts=[<Ref: BinaryOperatorGrammar>]]
INFO       [PD:4  MD:12]	............BinaryOperatorGrammar                 	OneOf.match PRN     	    	[ns=1, ps=2, ms=1, pruned=[<Ref: StringBinaryOperatorGrammar>, <Ref: BooleanBinaryOperatorGrammar>], opts=[<Ref: ArithmeticBinaryOperatorGrammar>, <Ref: ComparisonOperatorGrammar>]]
INFO       [PD:4  MD:13]	.............ArithmeticBinaryOperatorGrammar      	OneOf.match PRN     	    	[ns=0, ps=9, ms=1, pruned=[<Ref: MinusSegment>, <Ref: DivideSegment>, <Ref: MultiplySegment>, <Ref: ModuloSegment>, <Ref: BitwiseAndSegment>, <Ref: BitwiseOrSegment>, <Ref: BitwiseXorSegment>, <Ref: BitwiseLShiftSegment>, <Ref: BitwiseRShiftSegment>], opts=[<Ref: PlusSegment>]]
DEBUG      [PD:4  MD:14]	..............ArithmeticBinaryOperatorGrammar     	Ref.match OUT       	    	[match=<MatchResult 0/2: ''>, seg="' +'"]
INFO       [PD:4  MD:13]	.............ArithmeticBinaryOperatorGrammar      	OneOf.match OUT     	    	[match=<MatchResult 0/2: ''>, seg="' +'"]
DEBUG      [PD:4  MD:13]	.............BinaryOperatorGrammar                	Ref.match OUT       	    	[match=<MatchResult 0/2: ''>, seg="' +'"]
INFO       [PD:4  MD:13]	.............ComparisonOperatorGrammar            	OneOf.match PRN     	    	[ns=1, ps=7, ms=0, pruned=[<Ref: EqualsSegment>, <Ref: GreaterThanSegment>, <Ref: LessThanSegment>, <Ref: GreaterThanOrEqualToSegment>, <Ref: LessThanOrEqualToSegment>, <Ref: NotEqualToSegment_a>, <Ref: NotEqualToSegment_b>], opts=[<Ref: LikeOperatorSegment>]]
DEBUG      [PD:4  MD:14]	..............ComparisonOperatorGrammar           	Ref.match OUT       	    	[match=<MatchResult 0/2: ''>, seg="' +'"]
INFO       [PD:4  MD:13]	.............ComparisonOperatorGrammar            	OneOf.match OUT     	    	[match=<MatchResult 0/2: ''>, seg="' +'"]
DEBUG      [PD:4  MD:13]	.............BinaryOperatorGrammar                	Ref.match OUT       	    	[match=<MatchResult 0/2: ''>, seg="' +'"]
INFO       [PD:4  MD:12]	............BinaryOperatorGrammar                 	OneOf.match OUT     	    	[match=<MatchResult 0/2: ''>, seg="' +'"]
DEBUG      [PD:4  MD:12]	............ColumnReferenceSegment                	Ref.match OUT       	    	[match=<MatchResult 0/2: ''>, seg="' +'"]
INFO       [PD:4  MD:11]	...........ColumnReferenceSegment                 	OneOf.match OUT     	    	[match=<MatchResult 0/2: ''>, seg="' +'"]
DEBUG      [PD:4  MD:11]	...........ColumnReferenceSegment                 	NonCo.match OUT     	+   	[match=<MatchResult 1/2: ' '>, seg="' +'"]
INFO       [PD:4  MD:11]	...........SingleIdentifierGrammar                	OneOf.match PRN     	    	[ns=2, ps=0, ms=0, pruned=[], opts=[<Ref: NakedIdentifierSegment>, <Ref: QuotedIdentifierSegment>]]
DEBUG      [PD:4  MD:12]	............SingleIdentifierGrammar               	Ref.match OUT       	    	[match=<MatchResult 0/1: ''>, seg="'3'"]
DEBUG      [PD:4  MD:12]	............SingleIdentifierGrammar               	Ref.match OUT       	    	[match=<MatchResult 0/1: ''>, seg="'3'"]
INFO       [PD:4  MD:11]	...........SingleIdentifierGrammar                	OneOf.match OUT     	    	[match=<MatchResult 0/1: ''>, seg="'3'"]
DEBUG      [PD:4  MD:11]	...........ColumnReferenceSegment                 	Ref.match OUT       	    	[match=<MatchResult 0/1: ''>, seg="'3'"]
INFO       [PD:4  MD:10]	..........ColumnReferenceSegment                  	Delim.match OUT     	    	[match=<MatchResult 0/3: ''>, seg="'3 +'"]
DEBUG      [PD:4  MD:9 ]	.........ColumnReferenceSegment                   	Colum.match OUT     	    	[match=<MatchResult 0/3: ''>, seg="'3 +'"]
DEBUG      [PD:4  MD:9 ]	.........Expression_D_Grammar                     	Ref.match OUT       	    	[match=<MatchResult 0/3: ''>, seg="'3 +'"]
DEBUG      [PD:4  MD:10]	..........Expression_D_Grammar                    	Ref.match OUT       	    	[match=<MatchResult 0/3: ''>, seg="'3 +'"]
INFO       [PD:4  MD:11]	...........ArrayLiteralSegment                    	Brack.match OUT     	    	[match=<MatchResult 0/3: ''>, seg="'3 +'"]
DEBUG      [PD:4  MD:10]	..........ArrayLiteralSegment                     	Array.match OUT     	    	[match=<MatchResult 0/3: ''>, seg="'3 +'"]
DEBUG      [PD:4  MD:10]	..........Expression_D_Grammar                    	Ref.match OUT       	    	[match=<MatchResult 0/3: ''>, seg="'3 +'"]
INFO       [PD:4  MD:9 ]	.........Expression_D_Grammar                     	Seque.match OUT     	    	[match=<MatchResult 0/3: ''>, seg="'3 +'"]
INFO       [PD:4  MD:11]	...........DatatypeSegment                        	OneOf.match PRN     	    	[ns=1, ps=2, ms=0, pruned=[<Sequence: [<OneOf: [<Ref: TimeKeywordSegment>, <Ref..., <Bracketed: [<Ref: NumericLiteralSegment..., <Sequence:...]>, <Sequence: [<Ref: DoubleKeywordSegment>, <Ref: PrecisionKeywordSegment>]>], opts=[<Sequence: [<OneOf: [<Sequence: [<OneOf: [<Ref: Char..., <Bracketed: [<OneOf: [<Delimited: [<Ref:..., <Ref: Char...]>]]
INFO       [PD:4  MD:13]	.............DatatypeSegment                      	OneOf.match PRN     	    	[ns=1, ps=1, ms=0, pruned=[<Sequence: [<OneOf: [<Ref: CharacterKeywordSegment>,..., <OneOf: [<Ref: VaryingKeywordSegment>, <...]>], opts=[<Sequence: [<Sequence: [<Ref: SingleIdentifierGramma..., <Ref: DatatypeIdentifierSegment>]>]]
INFO       [PD:4  MD:16]	................SingleIdentifierGrammar           	OneOf.match PRN     	    	[ns=2, ps=0, ms=0, pruned=[], opts=[<Ref: NakedIdentifierSegment>, <Ref: QuotedIdentifierSegment>]]
DEBUG      [PD:4  MD:17]	.................SingleIdentifierGrammar          	Ref.match OUT       	    	[match=<MatchResult 0/3: ''>, seg="'3 +'"]
DEBUG      [PD:4  MD:17]	.................SingleIdentifierGrammar          	Ref.match OUT       	    	[match=<MatchResult 0/3: ''>, seg="'3 +'"]
INFO       [PD:4  MD:16]	................SingleIdentifierGrammar           	OneOf.match OUT     	    	[match=<MatchResult 0/3: ''>, seg="'3 +'"]
DEBUG      [PD:4  MD:16]	................DatatypeSegment                   	Ref.match OUT       	    	[match=<MatchResult 0/3: ''>, seg="'3 +'"]
INFO       [PD:4  MD:15]	...............DatatypeSegment                    	Seque.match OUT     	    	[match=<MatchResult 0/3: ''>, seg="'3 +'"]
DEBUG      [PD:4  MD:15]	...............DatatypeSegment                    	Ref.match OUT       	    	[match=<MatchResult 0/3: ''>, seg="'3 +'"]
INFO       [PD:4  MD:14]	..............DatatypeSegment                     	Seque.match OUT     	    	[match=<MatchResult 0/3: ''>, seg="'3 +'"]
INFO       [PD:4  MD:13]	.............DatatypeSegment                      	OneOf.match OUT     	    	[match=<MatchResult 0/3: ''>, seg="'3 +'"]
INFO       [PD:4  MD:12]	............DatatypeSegment                       	Seque.match OUT     	    	[match=<MatchResult 0/3: ''>, seg="'3 +'"]
INFO       [PD:4  MD:11]	...........DatatypeSegment                        	OneOf.match OUT     	    	[match=<MatchResult 0/3: ''>, seg="'3 +'"]
DEBUG      [PD:4  MD:10]	..........DatatypeSegment                         	Datat.match OUT     	    	[match=<MatchResult 0/3: ''>, seg="'3 +'"]
DEBUG      [PD:4  MD:10]	..........Expression_D_Grammar                    	Ref.match OUT       	    	[match=<MatchResult 0/3: ''>, seg="'3 +'"]
INFO       [PD:4  MD:9 ]	.........Expression_D_Grammar                     	Seque.match OUT     	    	[match=<MatchResult 0/3: ''>, seg="'3 +'"]
INFO       [PD:4  MD:8 ]	........Expression_D_Grammar                      	OneOf.match OUT     	+   	[match=<MatchResult 1/3: '3'>, seg="'3 +'"]
INFO       [PD:4  MD:8 ]	........Accessor_Grammar                          	AnyNu.match PRN     	    	[ns=0, ps=1, ms=0, pruned=[<Ref: ArrayAccessorSegment>], opts='ALL']
INFO       [PD:4  MD:8 ]	........Accessor_Grammar                          	AnyNu.match OUT     	    	[match=<MatchResult 0/1: ''>, seg="'+'"]
DEBUG      [PD:4  MD:8 ]	........Expression_D_Grammar                      	Ref.match OUT       	    	[match=<MatchResult 0/1: ''>, seg="'+'"]
INFO       [PD:4  MD:8 ]	........Expression_D_Grammar                      	AnyNu.match PRN     	    	[ns=0, ps=1, ms=0, pruned=[<Ref: ShorthandCastSegment>], opts='ALL']
INFO       [PD:4  MD:8 ]	........Expression_D_Grammar                      	AnyNu.match OUT     	    	[match=<MatchResult 0/1: ''>, seg="'+'"]
INFO       [PD:4  MD:7 ]	.......Expression_D_Grammar                       	Seque.match OUT     	+   	[match=<MatchResult 1/3: '3'>, seg="'3 +'"]
DEBUG      [PD:4  MD:7 ]	.......Expression_C_Grammar                       	Ref.match OUT       	+   	[match=<MatchResult 1/3: '3'>, seg="'3 +'"]
INFO       [PD:4  MD:6 ]	......Expression_C_Grammar                        	OneOf.match OUT     	+   	[match=<MatchResult 1/3: '3'>, seg="'3 +'"]
DEBUG      [PD:4  MD:6 ]	......Expression_A_Grammar                        	Ref.match OUT       	+   	[match=<MatchResult 1/3: '3'>, seg="'3 +'"]
INFO       [PD:4  MD:5 ]	.....Expression_A_Grammar                         	OneOf.match OUT     	+   	[match=<MatchResult 1/3: '3'>, seg="'3 +'"]
INFO       [PD:4  MD:5 ]	.....Expression_A_Grammar                         	AnyNu.match PRN     	    	[ns=1, ps=0, ms=0, pruned=[], opts=[<OneOf: [<Sequence: [<OneOf: [<Sequence: [<Ref: N..., <Sequence: [<Ref: NotKeywordSegment [opt..., <Sequence:...]>]]
INFO       [PD:4  MD:6 ]	......Expression_A_Grammar                        	OneOf.match PRN     	    	[ns=3, ps=5, ms=0, pruned=[<Sequence: [<Ref: NotKeywordSegment [opt]>, <Ref: InKeywordSegment>, <Bracketed: [<OneOf: [<Delimited: [<Ref:...]>, <Sequence: [<Ref: NotKeywordSegment [opt]>, <Ref: InKeywordSegment>, <Ref: FunctionSegment>]>, <Sequence: [<Ref: IsKeywordSegment>, <Ref: NotKeywordSegment [opt]>, <Ref: IsClauseGrammar>]>, <Sequence: [<Ref: NotKeywordSegment>, <Ref: Expression_C_Grammar>]>, <Sequence: [<Ref: NotKeywordSegment [opt]>, <Ref: BetweenKeywordSegment>, <Ref: Expression_C_Grammar>, <AnyNumbe...]>], opts=[<Sequence: [<OneOf: [<Sequence: [<Ref: NotKeywordSeg..., <Ref: Expression_C_Grammar>, <Sequence: [<Ref: EscapeKe...]>, <Ref: IsNullGrammar>, <Ref: NotNullGrammar>]]
INFO       [PD:4  MD:8 ]	........Expression_A_Grammar                      	OneOf.match PRN     	    	[ns=1, ps=1, ms=0, pruned=[<Sequence: [<Ref: NotKeywordSegment [opt]>, <Ref: LikeGrammar>]>], opts=[<Sequence: [<Ref: BinaryOperatorGrammar>, <Ref: NotKeywordSegment [opt]>]>]]
INFO       [PD:4  MD:10]	..........BinaryOperatorGrammar                   	OneOf.match PRN     	    	[ns=1, ps=2, ms=1, pruned=[<Ref: StringBinaryOperatorGrammar>, <Ref: BooleanBinaryOperatorGrammar>], opts=[<Ref: ArithmeticBinaryOperatorGrammar>, <Ref: ComparisonOperatorGrammar>]]
INFO       [PD:4  MD:11]	...........ArithmeticBinaryOperatorGrammar        	OneOf.match PRN     	    	[ns=0, ps=9, ms=1, pruned=[<Ref: MinusSegment>, <Ref: DivideSegment>, <Ref: MultiplySegment>, <Ref: ModuloSegment>, <Ref: BitwiseAndSegment>, <Ref: BitwiseOrSegment>, <Ref: BitwiseXorSegment>, <Ref: BitwiseLShiftSegment>, <Ref: BitwiseRShiftSegment>], opts=[<Ref: PlusSegment>]]
DEBUG      [PD:4  MD:12]	............ArithmeticBinaryOperatorGrammar       	Ref.match OUT       	++  	[match=<MatchResult 1/1: '+'>, seg="'+'"]
INFO       [PD:4  MD:11]	...........ArithmeticBinaryOperatorGrammar        	OneOf.match OUT     	++  	[match=<MatchResult 1/1: '+'>, seg="'+'"]
DEBUG      [PD:4  MD:11]	...........BinaryOperatorGrammar                  	Ref.match OUT       	++  	[match=<MatchResult 1/1: '+'>, seg="'+'"]
INFO       [PD:4  MD:10]	..........BinaryOperatorGrammar                   	OneOf.match OUT     	++  	[match=<MatchResult 1/1: '+'>, seg="'+'"]
DEBUG      [PD:4  MD:10]	..........Expression_A_Grammar                    	Ref.match OUT       	++  	[match=<MatchResult 1/1: '+'>, seg="'+'"]
INFO       [PD:4  MD:9 ]	.........Expression_A_Grammar                     	Seque.match OUT     	++  	[match=<MatchResult 1/1: '+'>, seg="'+'"]
INFO       [PD:4  MD:8 ]	........Expression_A_Grammar                      	OneOf.match OUT     	++  	[match=<MatchResult 1/1: '+'>, seg="'+'"]
INFO       [PD:4  MD:7 ]	.......Expression_A_Grammar                       	Seque.match OUT     	    	[match=<MatchResult 0/1: ''>, seg="'+'"]
DEBUG      [PD:4  MD:7 ]	.......Expression_A_Grammar                       	Ref.match OUT       	    	[match=<MatchResult 0/1: ''>, seg="'+'"]
DEBUG      [PD:4  MD:7 ]	.......Expression_A_Grammar                       	Ref.match OUT       	    	[match=<MatchResult 0/1: ''>, seg="'+'"]
INFO       [PD:4  MD:6 ]	......Expression_A_Grammar                        	OneOf.match OUT     	    	[match=<MatchResult 0/1: ''>, seg="'+'"]
INFO       [PD:4  MD:5 ]	.....Expression_A_Grammar                         	AnyNu.match OUT     	    	[match=<MatchResult 0/1: ''>, seg="'+'"]
INFO       [PD:4  MD:4 ]	....Expression_A_Grammar                          	Seque.match OUT     	+   	[match=<MatchResult 1/3: '3'>, seg="'3 +'"]
DEBUG      [PD:4  MD:4 ]	....ExpressionSegment                             	Ref.match OUT       	+   	[match=<MatchResult 1/3: '3'>, seg="'3 +'"]
DEBUG      [PD:4  MD:3 ]	...ExpressionSegment                              	Expre.match OUT     	+   	[match=<MatchResult 1/3: '3'>, seg="'3 +'"]
DEBUG      [PD:4  MD:3 ]	...BaseExpressionElementGrammar                   	Ref.match OUT       	+   	[match=<MatchResult 1/3: '3'>, seg="'3 +'"]
INFO       [PD:4  MD:2 ]	..BaseExpressionElementGrammar                    	OneOf.match OUT     	+   	[match=<MatchResult 1/3: '3'>, seg="'3 +'"]
DEBUG      [PD:4  MD:2 ]	..SelectClauseElementSegment                      	Ref.match OUT       	+   	[match=<MatchResult 1/3: '3'>, seg="'3 +'"]
DEBUG      [PD:4  MD:4 ]	....AliasExpressionSegment                        	Ref.match OUT       	    	[match=<MatchResult 0/1: ''>, seg="'+'"]
INFO       [PD:4  MD:4 ]	....AliasExpressionSegment                        	OneOf.match PRN     	    	[ns=2, ps=0, ms=0, pruned=[], opts=[<Sequence: [<Ref: SingleIdentifierGrammar>, <Bracketed: [<Ref: SingleIdentifierListS...]>, <Ref: QuotedLiteralSegment>]]
INFO       [PD:4  MD:6 ]	......SingleIdentifierGrammar                     	OneOf.match PRN     	    	[ns=2, ps=0, ms=0, pruned=[], opts=[<Ref: NakedIdentifierSegment>, <Ref: QuotedIdentifierSegment>]]
DEBUG      [PD:4  MD:7 ]	.......SingleIdentifierGrammar                    	Ref.match OUT       	    	[match=<MatchResult 0/1: ''>, seg="'+'"]
DEBUG      [PD:4  MD:7 ]	.......SingleIdentifierGrammar                    	Ref.match OUT       	    	[match=<MatchResult 0/1: ''>, seg="'+'"]
INFO       [PD:4  MD:6 ]	......SingleIdentifierGrammar                     	OneOf.match OUT     	    	[match=<MatchResult 0/1: ''>, seg="'+'"]
DEBUG      [PD:4  MD:6 ]	......AliasExpressionSegment                      	Ref.match OUT       	    	[match=<MatchResult 0/1: ''>, seg="'+'"]
INFO       [PD:4  MD:5 ]	.....AliasExpressionSegment                       	Seque.match OUT     	    	[match=<MatchResult 0/1: ''>, seg="'+'"]
DEBUG      [PD:4  MD:5 ]	.....AliasExpressionSegment                       	Ref.match OUT       	    	[match=<MatchResult 0/1: ''>, seg="'+'"]
INFO       [PD:4  MD:4 ]	....AliasExpressionSegment                        	OneOf.match OUT     	    	[match=<MatchResult 0/1: ''>, seg="'+'"]
INFO       [PD:4  MD:3 ]	...AliasExpressionSegment                         	Seque.match OUT     	    	[match=<MatchResult 0/1: ''>, seg="'+'"]
DEBUG      [PD:4  MD:2 ]	..AliasExpressionSegment                          	Alias.match OUT     	    	[match=<MatchResult 0/1: ''>, seg="'+'"]
DEBUG      [PD:4  MD:2 ]	..SelectClauseElementSegment                      	Ref.match OUT       	    	[match=<MatchResult 0/1: ''>, seg="'+'"]
INFO       [PD:4  MD:1 ]	.SelectClauseElementSegment                       	Seque.match OUT     	+   	[match=<MatchResult 1/3: '3'>, seg="'3 +'"]
INFO       [PD:4  MD:0 ]	SelectClauseElementSegment                        	OneOf.match OUT     	+   	[match=<MatchResult 1/3: '3'>, seg="'3 +'"]
DEBUG      SelectClauseElementSegment.parse: Done Parse. Plotting Recursion. Recurse=True
DEBUG      ###
#
# Beginning Parse Depth 5: SelectClauseElementSegment
#
###
Initial Structure:
[L:  4, P:  5]      |select_clause_element:
[L:  4, P:  5]      |    literal:                                                  '3'
[L:  4, P:  6]      |    unparsable:                                               !! Expected: 'Nothing...'
[L:  4, P:  6]      |        whitespace:                                           ' '
[L:  4, P:  7]      |        raw:                                                  '+'

INFO       [PD:5] Skipping expansion of <CodeSegment: ([L:  4, P:  5]) '3'>...
INFO       [PD:5] Skipping expansion of <UnparsableSegment: ([L:  4, P:  6])>...
INFO       [PD:3] Skipping expansion of <WhitespaceSegment: ([L:  4, P:  8]) ' '>...
INFO       [PD:3] Skipping expansion of <Dedent: ([L:  4, P:  9]) ''>...
INFO       
###
#
# Parse Depth 3. Expanding: FromClauseSegment: 'FROM SELECT FROM'
#
###
DEBUG      [PD:3  MD:1 ]	.FromClauseSegment                                	Ref.match OUT       	+   	[match=<MatchResult 1/5: 'FROM'>, seg="'FROM SELECT FROM'"]
DEBUG      [PD:3  MD:2 ]	..FromClauseSegment                               	Delim._look_ahead_match IN	    	[ls=3, seg='SELECT FROM']
DEBUG      [PD:3  MD:2 ]	..FromClauseSegment                               	Delim._look_ahead_match SI	    	[mq=[], sb=['SELECT', '', 'FROM']]
DEBUG      [PD:3  MD:2 ]	..FromClauseSegment                               	Delim._look_ahead_match SC	    	[bsm=None]
INFO       [PD:3  MD:4 ]	....FromExpressionSegment                         	OneOf.match PRN     	    	[ns=1, ps=1, ms=0, pruned=[<Ref: MLTableExpressionSegment>], opts=[<Ref: FromExpressionElementSegment>]]
DEBUG      [PD:3  MD:7 ]	.......FromExpressionElementSegment               	Ref.match OUT       	    	[match=<MatchResult 0/3: ''>, seg="'SELECT FROM'"]
INFO       [PD:3  MD:7 ]	.......FromExpressionElementSegment               	Optio.match PRN     	    	[ns=1, ps=1, ms=0, pruned=[<Bracketed: [<Ref: TableExpressionSegment>]>], opts=[<Ref: TableExpressionSegment>]]
INFO       [PD:3  MD:9 ]	.........TableExpressionSegment                   	OneOf.match PRN     	    	[ns=3, ps=1, ms=0, pruned=[<Bracketed: [<Ref: SelectableGrammar>]>], opts=[<Ref: BareFunctionSegment>, <Ref: FunctionSegment>, <Ref: TableReferenceSegment>]]
DEBUG      [PD:3  MD:10]	..........TableExpressionSegment                  	Ref.match OUT       	    	[match=<MatchResult 0/3: ''>, seg="'SELECT FROM'"]
INFO       [PD:3  MD:11]	...........FunctionSegment                        	OneOf.match PRN     	    	[ns=1, ps=1, ms=0, pruned=[<Sequence: [<Sequence: [<Ref: DateAddFunctionNameSeg...]>], opts=[<Sequence: [<Sequence: [<AnyNumberOf: [<Ref: Functio..., <Ref: PostFunctionGrammar [opt]>]>]]
DEBUG      [PD:3  MD:17]	.................DateAddFunctionNameSegment       	Ref.match OUT       	    	[match=<MatchResult 0/3: ''>, seg="'SELECT FROM'"]
INFO       [PD:3  MD:16]	................DateAddFunctionNameSegment        	Seque.match OUT     	    	[match=<MatchResult 0/3: ''>, seg="'SELECT FROM'"]
DEBUG      [PD:3  MD:15]	...............DateAddFunctionNameSegment         	DateA.match OUT     	    	[match=<MatchResult 0/3: ''>, seg="'SELECT FROM'"]
DEBUG      [PD:3  MD:15]	...............FunctionSegment                    	Ref.match OUT       	    	[match=<MatchResult 0/3: ''>, seg="'SELECT FROM'"]
INFO       [PD:3  MD:14]	..............FunctionSegment                     	AnyNu.match PRN     	    	[ns=1, ps=0, ms=0, pruned=[], opts=[<Ref: FunctionNameSegment>]]
INFO       [PD:3  MD:17]	.................FunctionNameSegment              	AnyNu.match PRN     	    	[ns=1, ps=0, ms=0, pruned=[], opts=[<Sequence: [<Ref: SingleIdentifierGrammar>, <Ref: DotSegment>]>]]
INFO       [PD:3  MD:19]	...................SingleIdentifierGrammar        	OneOf.match PRN     	    	[ns=2, ps=0, ms=0, pruned=[], opts=[<Ref: NakedIdentifierSegment>, <Ref: QuotedIdentifierSegment>]]
DEBUG      [PD:3  MD:20]	....................SingleIdentifierGrammar       	Ref.match OUT       	    	[match=<MatchResult 0/3: ''>, seg="'SELECT FROM'"]
DEBUG      [PD:3  MD:20]	....................SingleIdentifierGrammar       	Ref.match OUT       	    	[match=<MatchResult 0/3: ''>, seg="'SELECT FROM'"]
INFO       [PD:3  MD:19]	...................SingleIdentifierGrammar        	OneOf.match OUT     	    	[match=<MatchResult 0/3: ''>, seg="'SELECT FROM'"]
DEBUG      [PD:3  MD:19]	...................FunctionNameSegment            	Ref.match OUT       	    	[match=<MatchResult 0/3: ''>, seg="'SELECT FROM'"]
INFO       [PD:3  MD:18]	..................FunctionNameSegment             	Seque.match OUT     	    	[match=<MatchResult 0/3: ''>, seg="'SELECT FROM'"]
INFO       [PD:3  MD:17]	.................FunctionNameSegment              	AnyNu.match OUT     	    	[match=<MatchResult 0/3: ''>, seg="'SELECT FROM'"]
INFO       [PD:3  MD:17]	.................FunctionNameSegment              	OneOf.match PRN     	    	[ns=2, ps=0, ms=0, pruned=[], opts=[<Ref: FunctionNameIdentifierSegment>, <Ref: QuotedIdentifierSegment>]]
DEBUG      [PD:3  MD:18]	..................FunctionNameSegment             	Ref.match OUT       	+   	[match=<MatchResult 1/3: 'SELECT'>, seg="'SELECT FROM'"]
DEBUG      [PD:3  MD:18]	..................FunctionNameSegment             	Ref.match OUT       	    	[match=<MatchResult 0/3: ''>, seg="'SELECT FROM'"]
INFO       [PD:3  MD:17]	.................FunctionNameSegment              	OneOf.match OUT     	+   	[match=<MatchResult 1/3: 'SELECT'>, seg="'SELECT FROM'"]
INFO       [PD:3  MD:16]	................FunctionNameSegment               	Seque.match OUT     	+   	[match=<MatchResult 1/3: 'SELECT'>, seg="'SELECT FROM'"]
DEBUG      [PD:3  MD:15]	...............FunctionNameSegment                	Funct.match OUT     	+   	[match=<MatchResult 1/3: 'SELECT'>, seg="'SELECT FROM'"]
DEBUG      [PD:3  MD:15]	...............FunctionSegment                    	Ref.match OUT       	+   	[match=<MatchResult 1/3: 'SELECT'>, seg="'SELECT FROM'"]
INFO       [PD:3  MD:14]	..............FunctionSegment                     	AnyNu.match OUT     	+   	[match=<MatchResult 1/3: 'SELECT'>, seg="'SELECT FROM'"]
INFO       [PD:3  MD:14]	..............FunctionSegment                     	Brack.match OUT     	    	[match=<MatchResult 0/1: ''>, seg="'FROM'"]
INFO       [PD:3  MD:13]	.............FunctionSegment                      	Seque.match OUT     	    	[match=<MatchResult 0/3: ''>, seg="'SELECT FROM'"]
INFO       [PD:3  MD:12]	............FunctionSegment                       	Seque.match OUT     	    	[match=<MatchResult 0/3: ''>, seg="'SELECT FROM'"]
INFO       [PD:3  MD:11]	...........FunctionSegment                        	OneOf.match OUT     	    	[match=<MatchResult 0/3: ''>, seg="'SELECT FROM'"]
DEBUG      [PD:3  MD:10]	..........FunctionSegment                         	Funct.match OUT     	    	[match=<MatchResult 0/3: ''>, seg="'SELECT FROM'"]
DEBUG      [PD:3  MD:10]	..........TableExpressionSegment                  	Ref.match OUT       	    	[match=<MatchResult 0/3: ''>, seg="'SELECT FROM'"]
DEBUG      [PD:3  MD:12]	............TableReferenceSegment                 	Delim._look_ahead_match IN	    	[ls=3, seg='SELECT FROM']
DEBUG      [PD:3  MD:12]	............TableReferenceSegment                 	Delim._look_ahead_match SI	    	[mq=[], sb=['SELECT', '', 'FROM']]
INFO       [PD:3  MD:12]	............TableReferenceSegment                 	OneOf.match PRN     	    	[ns=1, ps=10, ms=0, pruned=[<Ref: OnKeywordSegment>, <Ref: AsKeywordSegment>, <Ref: UsingKeywordSegment>, <Ref: CommaSegment>, <Ref: CastOperatorSegment>, <Ref: StartSquareBracketSegment>, <Ref: StartBracketSegment>, <Ref: ColonSegment>, <Ref: DelimiterSegment>, <class 'sqlfluff.core.parser.segments.base.BracketedSegment'>], opts=[<Ref: BinaryOperatorGrammar>]]
INFO       [PD:3  MD:13]	.............BinaryOperatorGrammar                	OneOf.match PRN     	    	[ns=1, ps=3, ms=0, pruned=[<Ref: ArithmeticBinaryOperatorGrammar>, <Ref: StringBinaryOperatorGrammar>, <Ref: BooleanBinaryOperatorGrammar>], opts=[<Ref: ComparisonOperatorGrammar>]]
INFO       [PD:3  MD:14]	..............ComparisonOperatorGrammar           	OneOf.match PRN     	    	[ns=1, ps=7, ms=0, pruned=[<Ref: EqualsSegment>, <Ref: GreaterThanSegment>, <Ref: LessThanSegment>, <Ref: GreaterThanOrEqualToSegment>, <Ref: LessThanOrEqualToSegment>, <Ref: NotEqualToSegment_a>, <Ref: NotEqualToSegment_b>], opts=[<Ref: LikeOperatorSegment>]]
DEBUG      [PD:3  MD:15]	...............ComparisonOperatorGrammar          	Ref.match OUT       	    	[match=<MatchResult 0/3: ''>, seg="'SELECT FROM'"]
INFO       [PD:3  MD:14]	..............ComparisonOperatorGrammar           	OneOf.match OUT     	    	[match=<MatchResult 0/3: ''>, seg="'SELECT FROM'"]
DEBUG      [PD:3  MD:14]	..............BinaryOperatorGrammar               	Ref.match OUT       	    	[match=<MatchResult 0/3: ''>, seg="'SELECT FROM'"]
INFO       [PD:3  MD:13]	.............BinaryOperatorGrammar                	OneOf.match OUT     	    	[match=<MatchResult 0/3: ''>, seg="'SELECT FROM'"]
DEBUG      [PD:3  MD:13]	.............TableReferenceSegment                	Ref.match OUT       	    	[match=<MatchResult 0/3: ''>, seg="'SELECT FROM'"]
INFO       [PD:3  MD:12]	............TableReferenceSegment                 	OneOf.match OUT     	    	[match=<MatchResult 0/3: ''>, seg="'SELECT FROM'"]
DEBUG      [PD:3  MD:12]	............TableReferenceSegment                 	NonCo.match OUT     	    	[match=<MatchResult 0/3: ''>, seg="'SELECT FROM'"]
INFO       [PD:3  MD:12]	............TableReferenceSegment                 	OneOf.match PRN     	    	[ns=1, ps=10, ms=0, pruned=[<Ref: OnKeywordSegment>, <Ref: AsKeywordSegment>, <Ref: UsingKeywordSegment>, <Ref: CommaSegment>, <Ref: CastOperatorSegment>, <Ref: StartSquareBracketSegment>, <Ref: StartBracketSegment>, <Ref: ColonSegment>, <Ref: DelimiterSegment>, <class 'sqlfluff.core.parser.segments.base.BracketedSegment'>], opts=[<Ref: BinaryOperatorGrammar>]]
INFO       [PD:3  MD:13]	.............BinaryOperatorGrammar                	OneOf.match PRN     	    	[ns=1, ps=3, ms=0, pruned=[<Ref: ArithmeticBinaryOperatorGrammar>, <Ref: StringBinaryOperatorGrammar>, <Ref: BooleanBinaryOperatorGrammar>], opts=[<Ref: ComparisonOperatorGrammar>]]
INFO       [PD:3  MD:14]	..............ComparisonOperatorGrammar           	OneOf.match PRN     	    	[ns=1, ps=7, ms=0, pruned=[<Ref: EqualsSegment>, <Ref: GreaterThanSegment>, <Ref: LessThanSegment>, <Ref: GreaterThanOrEqualToSegment>, <Ref: LessThanOrEqualToSegment>, <Ref: NotEqualToSegment_a>, <Ref: NotEqualToSegment_b>], opts=[<Ref: LikeOperatorSegment>]]
DEBUG      [PD:3  MD:15]	...............ComparisonOperatorGrammar          	Ref.match OUT       	    	[match=<MatchResult 0/2: ''>, seg="' FROM'"]
INFO       [PD:3  MD:14]	..............ComparisonOperatorGrammar           	OneOf.match OUT     	    	[match=<MatchResult 0/2: ''>, seg="' FROM'"]
DEBUG      [PD:3  MD:14]	..............BinaryOperatorGrammar               	Ref.match OUT       	    	[match=<MatchResult 0/2: ''>, seg="' FROM'"]
INFO       [PD:3  MD:13]	.............BinaryOperatorGrammar                	OneOf.match OUT     	    	[match=<MatchResult 0/2: ''>, seg="' FROM'"]
DEBUG      [PD:3  MD:13]	.............TableReferenceSegment                	Ref.match OUT       	    	[match=<MatchResult 0/2: ''>, seg="' FROM'"]
INFO       [PD:3  MD:12]	............TableReferenceSegment                 	OneOf.match OUT     	    	[match=<MatchResult 0/2: ''>, seg="' FROM'"]
DEBUG      [PD:3  MD:12]	............TableReferenceSegment                 	NonCo.match OUT     	+   	[match=<MatchResult 1/2: ' '>, seg="' FROM'"]
INFO       [PD:3  MD:12]	............SingleIdentifierGrammar               	OneOf.match PRN     	    	[ns=2, ps=0, ms=0, pruned=[], opts=[<Ref: NakedIdentifierSegment>, <Ref: QuotedIdentifierSegment>]]
DEBUG      [PD:3  MD:13]	.............SingleIdentifierGrammar              	Ref.match OUT       	    	[match=<MatchResult 0/1: ''>, seg="'SELECT'"]
DEBUG      [PD:3  MD:13]	.............SingleIdentifierGrammar              	Ref.match OUT       	    	[match=<MatchResult 0/1: ''>, seg="'SELECT'"]
INFO       [PD:3  MD:12]	............SingleIdentifierGrammar               	OneOf.match OUT     	    	[match=<MatchResult 0/1: ''>, seg="'SELECT'"]
DEBUG      [PD:3  MD:12]	............TableReferenceSegment                 	Ref.match OUT       	    	[match=<MatchResult 0/1: ''>, seg="'SELECT'"]
INFO       [PD:3  MD:11]	...........TableReferenceSegment                  	Delim.match OUT     	    	[match=<MatchResult 0/3: ''>, seg="'SELECT FROM'"]
DEBUG      [PD:3  MD:10]	..........TableReferenceSegment                   	Table.match OUT     	    	[match=<MatchResult 0/3: ''>, seg="'SELECT FROM'"]
DEBUG      [PD:3  MD:10]	..........TableExpressionSegment                  	Ref.match OUT       	    	[match=<MatchResult 0/3: ''>, seg="'SELECT FROM'"]
INFO       [PD:3  MD:9 ]	.........TableExpressionSegment                   	OneOf.match OUT     	    	[match=<MatchResult 0/3: ''>, seg="'SELECT FROM'"]
DEBUG      [PD:3  MD:8 ]	........TableExpressionSegment                    	Table.match OUT     	    	[match=<MatchResult 0/3: ''>, seg="'SELECT FROM'"]
DEBUG      [PD:3  MD:8 ]	........FromExpressionElementSegment              	Ref.match OUT       	    	[match=<MatchResult 0/3: ''>, seg="'SELECT FROM'"]
INFO       [PD:3  MD:7 ]	.......FromExpressionElementSegment               	Optio.match OUT     	    	[match=<MatchResult 0/3: ''>, seg="'SELECT FROM'"]
INFO       [PD:3  MD:6 ]	......FromExpressionElementSegment                	Seque.match OUT     	    	[match=<MatchResult 0/3: ''>, seg="'SELECT FROM'"]
DEBUG      [PD:3  MD:5 ]	.....FromExpressionElementSegment                 	FromE.match OUT     	    	[match=<MatchResult 0/3: ''>, seg="'SELECT FROM'"]
DEBUG      [PD:3  MD:5 ]	.....FromExpressionSegment                        	Ref.match OUT       	    	[match=<MatchResult 0/3: ''>, seg="'SELECT FROM'"]
INFO       [PD:3  MD:4 ]	....FromExpressionSegment                         	OneOf.match OUT     	    	[match=<MatchResult 0/3: ''>, seg="'SELECT FROM'"]
INFO       [PD:3  MD:3 ]	...FromExpressionSegment                          	Seque.match OUT     	    	[match=<MatchResult 0/3: ''>, seg="'SELECT FROM'"]
DEBUG      [PD:3  MD:2 ]	..FromExpressionSegment                           	FromE.match OUT     	    	[match=<MatchResult 0/3: ''>, seg="'SELECT FROM'"]
DEBUG      [PD:3  MD:2 ]	..FromClauseSegment                               	Ref.match OUT       	    	[match=<MatchResult 0/3: ''>, seg="'SELECT FROM'"]
INFO       [PD:3  MD:1 ]	.FromClauseSegment                                	Delim.match OUT     	    	[match=<MatchResult 0/3: ''>, seg="'SELECT FROM'"]
INFO       [PD:3  MD:0 ]	FromClauseSegment                                 	Seque.match OUT     	    	[match=<MatchResult 0/5: ''>, seg="'FROM SELECT FROM'"]
DEBUG      FromClauseSegment.parse: Done Parse. Plotting Recursion. Recurse=True
DEBUG      ###
#
# Beginning Parse Depth 4: FromClauseSegment
#
###
Initial Structure:
[L:  4, P:  9]      |from_clause:
[L:  4, P:  9]      |    unparsable:                                               !! Expected: 'FromClauseSegment'
[L:  4, P:  9]      |        keyword:                                              'FROM'
[L:  4, P: 13]      |        whitespace:                                           ' '
[L:  4, P: 14]      |        raw:                                                  'SELECT'
[L:  4, P: 20]      |        whitespace:                                           ' '
[L:  4, P: 21]      |        raw:                                                  'FROM'

INFO       [PD:4] Skipping expansion of <UnparsableSegment: ([L:  4, P:  9])>...
INFO       [PD:1] Skipping expansion of <NewlineSegment: ([L:  4, P: 25]) '\n'>...
INFO       
###
#
# Parsed Tree:
#
###
INFO       
[L:  1, P:  1]      |file:
[L:  1, P:  1]      |    comment:                                                  '-- File which fails on templating and lexing errors.'
[L:  1, P: 53]      |    newline:                                                  '\n'
[L:  2, P:  1]      |    statement:
[L:  2, P:  1]      |        select_statement:
[L:  2, P:  1]      |            select_clause:
[L:  2, P:  1]      |                keyword:                                      'SELECT'
[L:  2, P:  7]      |                [META] indent:
[L:  2, P:  7]      |                newline:                                      '\n'
[L:  3, P:  1]      |                whitespace:                                   '     '
[L:  3, P: 21]      |                select_clause_element:
[L:  3, P: 21]      |                    unparsable:                               !! Expected: 'SelectClauseElementSegment'
[L:  3, P: 21]      |                        raw:                                  'as'
[L:  3, P: 23]      |                        whitespace:                           ' '
[L:  3, P: 24]      |                        raw:                                  'trailing_space'
[L:  3, P: 38]      |                whitespace:                                   '   '
[L:  3, P: 41]      |                comma:                                        ','
[L:  3, P: 42]      |                newline:                                      '\n'
[L:  4, P:  1]      |                whitespace:                                   '    '
[L:  4, P:  5]      |                select_clause_element:
[L:  4, P:  5]      |                    literal:                                  '3'
[L:  4, P:  6]      |                    unparsable:                               !! Expected: 'Nothing...'
[L:  4, P:  6]      |                        whitespace:                           ' '
[L:  4, P:  7]      |                        raw:                                  '+'
[L:  4, P:  8]      |            whitespace:                                       ' '
[L:  4, P:  9]      |            [META] dedent:
[L:  4, P:  9]      |            from_clause:
[L:  4, P:  9]      |                unparsable:                                   !! Expected: 'FromClauseSegment'
[L:  4, P:  9]      |                    keyword:                                  'FROM'
[L:  4, P: 13]      |                    whitespace:                               ' '
[L:  4, P: 14]      |                    raw:                                      'SELECT'
[L:  4, P: 20]      |                    whitespace:                               ' '
[L:  4, P: 21]      |                    raw:                                      'FROM'
[L:  4, P: 25]      |    newline:                                                  '\n'

INFO       Found unparsable segment...
INFO       [L:  3, P: 21]      |unparsable:                                                   !! Expected: 'SelectClauseElementSegment'
[L:  3, P: 21]      |    raw:                                                      'as'
[L:  3, P: 23]      |    whitespace:                                               ' '
[L:  3, P: 24]      |    raw:                                                      'trailing_space'

INFO       Found unparsable segment...
INFO       [L:  4, P:  6]      |unparsable:                                                   !! Expected: 'Nothing...'
[L:  4, P:  6]      |    whitespace:                                               ' '
[L:  4, P:  7]      |    raw:                                                      '+'

INFO       Found unparsable segment...
INFO       [L:  4, P:  9]      |unparsable:                                                   !! Expected: 'FromClauseSegment'
[L:  4, P:  9]      |    keyword:                                                  'FROM'
[L:  4, P: 13]      |    whitespace:                                               ' '
[L:  4, P: 14]      |    raw:                                                      'SELECT'
[L:  4, P: 20]      |    whitespace:                                               ' '
[L:  4, P: 21]      |    raw:                                                      'FROM'

INFO       LINTING (test/fixtures/cli/fail_many.sql)
== [test/fixtures/cli/fail_many.sql] LINTING
INFO       Fix loop complete. Stability achieved after 0/10 loops.
== [test/fixtures/cli/fail_many.sql] PASS
==== no fixable linting violations found ====
All Finished 📜 🎉!
  [1 templating errors found]

____________ test__cli__command_lint_parse_with_retcode[command1-1] ____________
----------------------------- Captured stdout call -----------------------------
==== finding fixable violations ====
==== no fixable linting violations found ====
All Finished 📜 🎉!
  [1 templating errors found]

____________ test__cli__command_lint_parse_with_retcode[command2-1] ____________
----------------------------- Captured stdout call -----------------------------
==== finding fixable violations ====
== [test/fixtures/cli/fail_many.sql] FAIL
L:   3 | P:  41 | L003 | Line over-indented compared to line #2
L:   3 | P:  41 | L019 | Found leading comma. Expected only trailing.
==== fixing violations ====
2 fixable linting violations found
Are you sure you wish to attempt to fix these? [Y/n] ...
Attempting fixes...
Persisting Changes...
== [test/fixtures/cli/fail_many.sql] PASS
Done. Please check your files to confirm.
All Finished 📜 🎉!
  [2 unfixable linting violations found]
  [1 templating errors found]

___________________________ test__cli__command_rules ___________________________
----------------------------- Captured stdout call -----------------------------
==== sqlfluff - rules ====
L001: Unnecessary trailing whitespace.                                          
L002: Mixed Tabs and Spaces in single whitespace.                               
L003: Indentation not consistent with previous lines.                           
L004: Incorrect indentation type.                                               
L005: Commas should not have whitespace directly before them.                   
L006: Operators should be surrounded by a single whitespace.                    
L007: Operators should follow a standard for being before/after newlines.       
L008: Commas should be followed by a single whitespace unless followed by a     
      comment.                                                                  
L009: Files must end with a trailing newline.                                   
L010: Inconsistent capitalisation of keywords.                                  
L011: Implicit/explicit aliasing of table.                                      
L012: Implicit/explicit aliasing of columns.                                    
L013: Column expression without alias. Use explicit `AS` clause.                
L014: Inconsistent capitalisation of unquoted identifiers.                      
L015: DISTINCT used with parentheses.                                           
L016: Line is too long                                                          
L017: Function name not immediately followed by bracket.                        
L018: WITH clause closing bracket should be aligned with WITH keyword.          
L019: Leading/Trailing comma enforcement.                                       
L020: Table aliases should be unique within each clause.                        
L021: Ambiguous use of DISTINCT in select statement with GROUP BY.              
L022: Blank line expected but not found after CTE closing bracket.              
L023: Single whitespace expected after AS in WITH clause.                       
L024: Single whitespace expected after USING in JOIN clause.                    
L025: Tables should not be aliased if that alias is not used.                   
L026: References cannot reference objects not present in FROM clause.           
L027: References should be qualified if select has more than one referenced     
      table/view.                                                               
L028: References should be consistent in statements with a single table.        
L029: Keywords should not be used as identifiers.                               
L030: Inconsistent capitalisation of function names.                            
L031: Avoid table aliases in from clauses and join conditions.                  
L032: Prefer specifying join keys instead of using "USING".                     
L033: UNION [DISTINCT|ALL] is preferred over just UNION.                        
L034: Use wildcards then simple targets before calculations and aggregates in   
      select statements.                                                        
L035: Do not specify "else null" in a case when statement (redundant).          
L036: Select targets should be on a new line unless there is only one select    
      target.                                                                   
L037: Ambiguous ordering directions for columns in order by clause.             
L038: Trailing commas within select clause.                                     
L039: Unnecessary whitespace found.                                             
L040: Inconsistent capitalisation of boolean/null literal.                      
L041: SELECT clause modifiers such as DISTINCT must be on the same line as      
      SELECT.                                                                   
L042: Join/From clauses should not contain subqueries. Use CTEs instead.        
L043: Unnecessary case when statement. Use the "when" condition itself.         
L044: Query produces an unknown number of result columns.                       
L045: Query defines a CTE (common-table expression) but does not use it.        
L046: Jinja tags should have a single whitespace on either side.                
L047: Use consistent syntax to express "count number of rows".                  
L048: Quoted literals should be surrounded by a single whitespace.              
L049: Comparisons with NULL should use "IS" or "IS NOT".                        

_________________________ test__cli__command_dialects __________________________
----------------------------- Captured stdout call -----------------------------
==== sqlfluff - dialects ====
ansi:                 ansi dialect [inherits from 'nothing']
bigquery:            bigquery dialect [inherits from 'ansi']
exasol:                exasol dialect [inherits from 'ansi']
hive:                    hive dialect [inherits from 'ansi']
mysql:                  mysql dialect [inherits from 'ansi']
postgres:            postgres dialect [inherits from 'ansi']
snowflake:          snowflake dialect [inherits from 'ansi']
sqlite:                sqlite dialect [inherits from 'ansi']
teradata:            teradata dialect [inherits from 'ansi']
tsql:                    tsql dialect [inherits from 'ansi']

__ test__cli__command__fix[L001-test/fixtures/linter/indentation_errors.sql] ___
----------------------------- Captured stdout call -----------------------------
== [/tmp/tmp4nzgoftm/testing.sql] FAIL
L:   4 | P:  24 | L001 | Unnecessary trailing whitespace.
All Finished 📜 🎉!

==== finding fixable violations ====
== [/tmp/tmp4nzgoftm/testing.sql] FAIL
L:   4 | P:  24 | L001 | Unnecessary trailing whitespace.
==== fixing violations ====
1 fixable linting violations found
FORCE MODE: Attempting fixes...
Persisting Changes...
== [/tmp/tmp4nzgoftm/testing.sql] PASS
Done. Please check your files to confirm.

All Finished 📜 🎉!

___ test__cli__command__fix[L008-test/fixtures/linter/whitespace_errors.sql] ___
----------------------------- Captured stdout call -----------------------------
== [/tmp/tmpjrrezsp3/testing.sql] FAIL
L:   3 | P:  12 | L008 | Commas should be followed by a single whitespace unless
                       | followed by a comment.
L:   3 | P:  12 | L008 | Commas should be followed by a single whitespace unless
                       | followed by a comment.
L:   3 | P:  12 | L008 | Commas should be followed by a single whitespace unless
                       | followed by a comment.
All Finished 📜 🎉!

==== finding fixable violations ====
== [/tmp/tmpjrrezsp3/testing.sql] FAIL
L:   3 | P:  12 | L008 | Commas should be followed by a single whitespace unless
                       | followed by a comment.
L:   3 | P:  12 | L008 | Commas should be followed by a single whitespace unless
                       | followed by a comment.
L:   3 | P:  12 | L008 | Commas should be followed by a single whitespace unless
                       | followed by a comment.
==== fixing violations ====
3 fixable linting violations found
FORCE MODE: Attempting fixes...
Persisting Changes...
== [/tmp/tmpjrrezsp3/testing.sql] PASS
Done. Please check your files to confirm.

All Finished 📜 🎉!

__ test__cli__command__fix[L008-test/fixtures/linter/indentation_errors.sql] ___
----------------------------- Captured stdout call -----------------------------
== [/tmp/tmphfs0xa2e/testing.sql] FAIL
L:   4 | P:  24 | L008 | Commas should be followed by a single whitespace unless
                       | followed by a comment.
All Finished 📜 🎉!

==== finding fixable violations ====
== [/tmp/tmphfs0xa2e/testing.sql] FAIL
L:   4 | P:  24 | L008 | Commas should be followed by a single whitespace unless
                       | followed by a comment.
==== fixing violations ====
1 fixable linting violations found
FORCE MODE: Attempting fixes...
Persisting Changes...
== [/tmp/tmphfs0xa2e/testing.sql] PASS
Done. Please check your files to confirm.

All Finished 📜 🎉!

_ test__cli__command__fix[L003-test/fixtures/linter/indentation_error_hard.sql] _
----------------------------- Captured stdout call -----------------------------
== [/tmp/tmpz2_qqitk/testing.sql] FAIL
L:   2 | P:   4 | L003 | Indentation not hanging or a multiple of 4 spaces
L:   6 | P:   5 | L003 | Indent expected and not found compared to line #5
L:   9 | P:  13 | L003 | Line over-indented compared to line #8
L:  14 | P:  14 | L003 | Indentation not hanging or a multiple of 4 spaces
L:  19 | P:   5 | L003 | Indentation not consistent with line #18
L:  20 | P:   6 | L003 | Indentation not consistent with line #18
All Finished 📜 🎉!

==== finding fixable violations ====
== [/tmp/tmpz2_qqitk/testing.sql] FAIL
L:   2 | P:   4 | L003 | Indentation not hanging or a multiple of 4 spaces
L:   6 | P:   5 | L003 | Indent expected and not found compared to line #5
L:   9 | P:  13 | L003 | Line over-indented compared to line #8
L:  14 | P:  14 | L003 | Indentation not hanging or a multiple of 4 spaces
L:  19 | P:   5 | L003 | Indentation not consistent with line #18
L:  20 | P:   6 | L003 | Indentation not consistent with line #18
==== fixing violations ====
6 fixable linting violations found
FORCE MODE: Attempting fixes...
Persisting Changes...
== [/tmp/tmpz2_qqitk/testing.sql] PASS
Done. Please check your files to confirm.

All Finished 📜 🎉!

______ test__cli__command_fix_stdin[select * from t-L003-select * from t] ______
----------------------------- Captured stdout call -----------------------------
select * from t
_____ test__cli__command_fix_stdin[ select * from t-L003-select * from t] ______
----------------------------- Captured stdout call -----------------------------
select * from t
_ test__cli__command_fix_stdin[SELECT u.id, c.first_name, c.last_name, COUNT(o.user_id) FROM users as u JOIN customers as c on u.id = c.user_id JOIN orders as o on u.id = o.user_id;-L031-SELECT users.id, customers.first_name, customers.last_name, COUNT(orders.user_id) FROM users JOIN customers on users.id = customers.user_id JOIN orders on users.id = orders.user_id;] _
----------------------------- Captured stdout call -----------------------------
SELECT users.id, customers.first_name, customers.last_name, COUNT(orders.user_id) FROM users JOIN customers on users.id = customers.user_id JOIN orders on users.id = orders.user_id;
________________ test__cli__command_fix_stdin_logging_to_stderr ________________
----------------------------- Captured stdout call -----------------------------
select col from table
_____________________ test__cli__command_fix_stdin_safety ______________________
----------------------------- Captured stdout call -----------------------------
select col from table

_ test__cli__command_fix_stdin_error_exit_code[create TABLE {{ params.dsfsdfds }}.t (a int)-1--v-Fix aborted due to unparseable template variables.] _
----------------------------- Captured stdout call -----------------------------
Fix aborted due to unparseable template variables.
Use '--ignore templating' to attempt to fix anyway.
create TABLE {{ params.dsfsdfds }}.t (a int)
__ test__cli__command_fix_stdin_error_exit_code[create TABLE a.t (a int)-0--] __
----------------------------- Captured stdout call -----------------------------
create table a.t (a int)

__ test__cli__command_fix_stdin_error_exit_code[create table a.t (a int)-0--] __
----------------------------- Captured stdout call -----------------------------
create table a.t (a int)

_ test__cli__command_fix_stdin_error_exit_code[select col from a join b using (c)-1--v-Unfixable violations detected.] _
----------------------------- Captured stdout call -----------------------------
Unfixable violations detected.
select col from a join b using (c)

_ test__cli__command__fix_no_force[L001-test/fixtures/linter/indentation_errors.sql-y-0-0] _
----------------------------- Captured stdout call -----------------------------
== [/tmp/tmp_j86ens9/testing.sql] FAIL
L:   4 | P:  24 | L001 | Unnecessary trailing whitespace.
All Finished 📜 🎉!

==== finding fixable violations ====
== [/tmp/tmp_j86ens9/testing.sql] FAIL
L:   4 | P:  24 | L001 | Unnecessary trailing whitespace.
==== fixing violations ====
1 fixable linting violations found
Are you sure you wish to attempt to fix these? [Y/n] ...
Attempting fixes...
Persisting Changes...
== [/tmp/tmp_j86ens9/testing.sql] PASS
Done. Please check your files to confirm.
All Finished 📜 🎉!

All Finished 📜 🎉!

_ test__cli__command__fix_no_force[L001-test/fixtures/linter/indentation_errors.sql-n-65-1] _
----------------------------- Captured stdout call -----------------------------
== [/tmp/tmp00thxssd/testing.sql] FAIL
L:   4 | P:  24 | L001 | Unnecessary trailing whitespace.
All Finished 📜 🎉!

==== finding fixable violations ====
== [/tmp/tmp00thxssd/testing.sql] FAIL
L:   4 | P:  24 | L001 | Unnecessary trailing whitespace.
==== fixing violations ====
1 fixable linting violations found
Are you sure you wish to attempt to fix these? [Y/n] ...
Aborting...

== [/tmp/tmp00thxssd/testing.sql] FAIL
L:   4 | P:  24 | L001 | Unnecessary trailing whitespace.
All Finished 📜 🎉!

_____________ test__cli__command_parse_serialize_from_stdin[yaml] ______________
----------------------------- Captured stdout call -----------------------------
- filepath: stdin
  segments:
    file:
      statement:
        select_statement:
          select_clause:
            keyword: select
            whitespace: ' '
            select_clause_element:
              wildcard_expression:
                wildcard_identifier:
                  star: '*'
          whitespace: ' '
          from_clause:
            keyword: from
            whitespace: ' '
            from_expression:
              from_expression_element:
                table_expression:
                  table_reference:
                    identifier: tbl


_____________ test__cli__command_parse_serialize_from_stdin[json] ______________
----------------------------- Captured stdout call -----------------------------
[{"filepath": "stdin", "segments": {"file": {"statement": {"select_statement": {"select_clause": {"keyword": "select", "whitespace": " ", "select_clause_element": {"wildcard_expression": {"wildcard_identifier": {"star": "*"}}}}, "whitespace": " ", "from_clause": {"keyword": "from", "whitespace": " ", "from_expression": {"from_expression_element": {"table_expression": {"table_reference": {"identifier": "tbl"}}}}}}}}}}]

_ test__cli__command_lint_serialize_from_stdin[select * from tbl-expected0-0-yaml] _
----------------------------- Captured stdout call -----------------------------
[]


_ test__cli__command_lint_serialize_from_stdin[select * from tbl-expected0-0-json] _
----------------------------- Captured stdout call -----------------------------
[]

_ test__cli__command_lint_serialize_from_stdin[SElect * from tbl-expected1-65-yaml] _
----------------------------- Captured stdout call -----------------------------
- filepath: stdin
  violations:
  - line_no: 1
    line_pos: 1
    code: L010
    description: Keywords must be consistently upper case.
  - line_no: 1
    line_pos: 10
    code: L010
    description: Keywords must be consistently upper case.


_ test__cli__command_lint_serialize_from_stdin[SElect * from tbl-expected1-65-json] _
----------------------------- Captured stdout call -----------------------------
[{"filepath": "stdin", "violations": [{"line_no": 1, "line_pos": 1, "code": "L010", "description": "Keywords must be consistently upper case."}, {"line_no": 1, "line_pos": 10, "code": "L010", "description": "Keywords must be consistently upper case."}]}]

_______________ test__cli__command_fail_nice_not_found[command0] _______________
----------------------------- Captured stdout call -----------------------------
The path(s) '('this_file_does_not_exist.sql',)' could not be accessed. Check it/they exist(s).

_______________ test__cli__command_fail_nice_not_found[command1] _______________
----------------------------- Captured stdout call -----------------------------
==== finding fixable violations ====
The path(s) '('this_file_does_not_exist.sql',)' could not be accessed. Check it/they exist(s).

____________ test__cli__command_lint_serialize_multiple_files[yaml] ____________
----------------------------- Captured stdout call -----------------------------
- filepath: test/fixtures/linter/indentation_errors.sql
  violations:
  - line_no: 2
    line_pos: 4
    code: L003
    description: Indentation not hanging or a multiple of 4 spaces
  - line_no: 3
    line_pos: 1
    code: L002
    description: Mixed Tabs and Spaces in single whitespace.
  - line_no: 3
    line_pos: 1
    code: L004
    description: Incorrect indentation type found in file.
  - line_no: 3
    line_pos: 4
    code: L003
    description: Indentation not hanging or a multiple of 4 spaces
  - line_no: 4
    line_pos: 1
    code: L002
    description: Mixed Tabs and Spaces in single whitespace.
  - line_no: 4
    line_pos: 1
    code: L004
    description: Incorrect indentation type found in file.
  - line_no: 4
    line_pos: 6
    code: L003
    description: 'Line over-indented compared to line #1'
  - line_no: 4
    line_pos: 24
    code: L001
    description: Unnecessary trailing whitespace.
  - line_no: 4
    line_pos: 24
    code: L008
    description: Commas should be followed by a single whitespace unless followed
      by a comment.
  - line_no: 5
    line_pos: 1
    code: L004
    description: Incorrect indentation type found in file.
  - line_no: 6
    line_pos: 10
    code: L010
    description: Keywords must be consistently upper case.
  - line_no: 6
    line_pos: 13
    code: L031
    description: Avoid using aliases in join condition
- filepath: test/fixtures/linter/indentation_errors.sql
  violations:
  - line_no: 2
    line_pos: 4
    code: L003
    description: Indentation not hanging or a multiple of 4 spaces
  - line_no: 3
    line_pos: 1
    code: L002
    description: Mixed Tabs and Spaces in single whitespace.
  - line_no: 3
    line_pos: 1
    code: L004
    description: Incorrect indentation type found in file.
  - line_no: 3
    line_pos: 4
    code: L003
    description: Indentation not hanging or a multiple of 4 spaces
  - line_no: 4
    line_pos: 1
    code: L002
    description: Mixed Tabs and Spaces in single whitespace.
  - line_no: 4
    line_pos: 1
    code: L004
    description: Incorrect indentation type found in file.
  - line_no: 4
    line_pos: 6
    code: L003
    description: 'Line over-indented compared to line #1'
  - line_no: 4
    line_pos: 24
    code: L001
    description: Unnecessary trailing whitespace.
  - line_no: 4
    line_pos: 24
    code: L008
    description: Commas should be followed by a single whitespace unless followed
      by a comment.
  - line_no: 5
    line_pos: 1
    code: L004
    description: Incorrect indentation type found in file.
  - line_no: 6
    line_pos: 10
    code: L010
    description: Keywords must be consistently upper case.
  - line_no: 6
    line_pos: 13
    code: L031
    description: Avoid using aliases in join condition


____________ test__cli__command_lint_serialize_multiple_files[json] ____________
----------------------------- Captured stdout call -----------------------------
[{"filepath": "test/fixtures/linter/indentation_errors.sql", "violations": [{"line_no": 2, "line_pos": 4, "code": "L003", "description": "Indentation not hanging or a multiple of 4 spaces"}, {"line_no": 3, "line_pos": 1, "code": "L002", "description": "Mixed Tabs and Spaces in single whitespace."}, {"line_no": 3, "line_pos": 1, "code": "L004", "description": "Incorrect indentation type found in file."}, {"line_no": 3, "line_pos": 4, "code": "L003", "description": "Indentation not hanging or a multiple of 4 spaces"}, {"line_no": 4, "line_pos": 1, "code": "L002", "description": "Mixed Tabs and Spaces in single whitespace."}, {"line_no": 4, "line_pos": 1, "code": "L004", "description": "Incorrect indentation type found in file."}, {"line_no": 4, "line_pos": 6, "code": "L003", "description": "Line over-indented compared to line #1"}, {"line_no": 4, "line_pos": 24, "code": "L001", "description": "Unnecessary trailing whitespace."}, {"line_no": 4, "line_pos": 24, "code": "L008", "description": "Commas should be followed by a single whitespace unless followed by a comment."}, {"line_no": 5, "line_pos": 1, "code": "L004", "description": "Incorrect indentation type found in file."}, {"line_no": 6, "line_pos": 10, "code": "L010", "description": "Keywords must be consistently upper case."}, {"line_no": 6, "line_pos": 13, "code": "L031", "description": "Avoid using aliases in join condition"}]}, {"filepath": "test/fixtures/linter/indentation_errors.sql", "violations": [{"line_no": 2, "line_pos": 4, "code": "L003", "description": "Indentation not hanging or a multiple of 4 spaces"}, {"line_no": 3, "line_pos": 1, "code": "L002", "description": "Mixed Tabs and Spaces in single whitespace."}, {"line_no": 3, "line_pos": 1, "code": "L004", "description": "Incorrect indentation type found in file."}, {"line_no": 3, "line_pos": 4, "code": "L003", "description": "Indentation not hanging or a multiple of 4 spaces"}, {"line_no": 4, "line_pos": 1, "code": "L002", "description": "Mixed Tabs and Spaces in single whitespace."}, {"line_no": 4, "line_pos": 1, "code": "L004", "description": "Incorrect indentation type found in file."}, {"line_no": 4, "line_pos": 6, "code": "L003", "description": "Line over-indented compared to line #1"}, {"line_no": 4, "line_pos": 24, "code": "L001", "description": "Unnecessary trailing whitespace."}, {"line_no": 4, "line_pos": 24, "code": "L008", "description": "Commas should be followed by a single whitespace unless followed by a comment."}, {"line_no": 5, "line_pos": 1, "code": "L004", "description": "Incorrect indentation type found in file."}, {"line_no": 6, "line_pos": 10, "code": "L010", "description": "Keywords must be consistently upper case."}, {"line_no": 6, "line_pos": 13, "code": "L031", "description": "Avoid using aliases in join condition"}]}]

_____ test__cli__command_lint_serialize_multiple_files[github-annotation] ______
----------------------------- Captured stdout call -----------------------------
[{"file": "test/fixtures/linter/indentation_errors.sql", "line": 2, "start_column": 4, "end_column": 4, "title": "SQLFluff", "message": "L003: Indentation not hanging or a multiple of 4 spaces", "annotation_level": "notice"}, {"file": "test/fixtures/linter/indentation_errors.sql", "line": 3, "start_column": 1, "end_column": 1, "title": "SQLFluff", "message": "L002: Mixed Tabs and Spaces in single whitespace.", "annotation_level": "notice"}, {"file": "test/fixtures/linter/indentation_errors.sql", "line": 3, "start_column": 1, "end_column": 1, "title": "SQLFluff", "message": "L004: Incorrect indentation type found in file.", "annotation_level": "notice"}, {"file": "test/fixtures/linter/indentation_errors.sql", "line": 3, "start_column": 4, "end_column": 4, "title": "SQLFluff", "message": "L003: Indentation not hanging or a multiple of 4 spaces", "annotation_level": "notice"}, {"file": "test/fixtures/linter/indentation_errors.sql", "line": 4, "start_column": 1, "end_column": 1, "title": "SQLFluff", "message": "L002: Mixed Tabs and Spaces in single whitespace.", "annotation_level": "notice"}, {"file": "test/fixtures/linter/indentation_errors.sql", "line": 4, "start_column": 1, "end_column": 1, "title": "SQLFluff", "message": "L004: Incorrect indentation type found in file.", "annotation_level": "notice"}, {"file": "test/fixtures/linter/indentation_errors.sql", "line": 4, "start_column": 6, "end_column": 6, "title": "SQLFluff", "message": "L003: Line over-indented compared to line #1", "annotation_level": "notice"}, {"file": "test/fixtures/linter/indentation_errors.sql", "line": 4, "start_column": 24, "end_column": 24, "title": "SQLFluff", "message": "L001: Unnecessary trailing whitespace.", "annotation_level": "notice"}, {"file": "test/fixtures/linter/indentation_errors.sql", "line": 4, "start_column": 24, "end_column": 24, "title": "SQLFluff", "message": "L008: Commas should be followed by a single whitespace unless followed by a comment.", "annotation_level": "notice"}, {"file": "test/fixtures/linter/indentation_errors.sql", "line": 5, "start_column": 1, "end_column": 1, "title": "SQLFluff", "message": "L004: Incorrect indentation type found in file.", "annotation_level": "notice"}, {"file": "test/fixtures/linter/indentation_errors.sql", "line": 6, "start_column": 10, "end_column": 10, "title": "SQLFluff", "message": "L010: Keywords must be consistently upper case.", "annotation_level": "notice"}, {"file": "test/fixtures/linter/indentation_errors.sql", "line": 6, "start_column": 13, "end_column": 13, "title": "SQLFluff", "message": "L031: Avoid using aliases in join condition", "annotation_level": "notice"}, {"file": "test/fixtures/linter/indentation_errors.sql", "line": 2, "start_column": 4, "end_column": 4, "title": "SQLFluff", "message": "L003: Indentation not hanging or a multiple of 4 spaces", "annotation_level": "notice"}, {"file": "test/fixtures/linter/indentation_errors.sql", "line": 3, "start_column": 1, "end_column": 1, "title": "SQLFluff", "message": "L002: Mixed Tabs and Spaces in single whitespace.", "annotation_level": "notice"}, {"file": "test/fixtures/linter/indentation_errors.sql", "line": 3, "start_column": 1, "end_column": 1, "title": "SQLFluff", "message": "L004: Incorrect indentation type found in file.", "annotation_level": "notice"}, {"file": "test/fixtures/linter/indentation_errors.sql", "line": 3, "start_column": 4, "end_column": 4, "title": "SQLFluff", "message": "L003: Indentation not hanging or a multiple of 4 spaces", "annotation_level": "notice"}, {"file": "test/fixtures/linter/indentation_errors.sql", "line": 4, "start_column": 1, "end_column": 1, "title": "SQLFluff", "message": "L002: Mixed Tabs and Spaces in single whitespace.", "annotation_level": "notice"}, {"file": "test/fixtures/linter/indentation_errors.sql", "line": 4, "start_column": 1, "end_column": 1, "title": "SQLFluff", "message": "L004: Incorrect indentation type found in file.", "annotation_level": "notice"}, {"file": "test/fixtures/linter/indentation_errors.sql", "line": 4, "start_column": 6, "end_column": 6, "title": "SQLFluff", "message": "L003: Line over-indented compared to line #1", "annotation_level": "notice"}, {"file": "test/fixtures/linter/indentation_errors.sql", "line": 4, "start_column": 24, "end_column": 24, "title": "SQLFluff", "message": "L001: Unnecessary trailing whitespace.", "annotation_level": "notice"}, {"file": "test/fixtures/linter/indentation_errors.sql", "line": 4, "start_column": 24, "end_column": 24, "title": "SQLFluff", "message": "L008: Commas should be followed by a single whitespace unless followed by a comment.", "annotation_level": "notice"}, {"file": "test/fixtures/linter/indentation_errors.sql", "line": 5, "start_column": 1, "end_column": 1, "title": "SQLFluff", "message": "L004: Incorrect indentation type found in file.", "annotation_level": "notice"}, {"file": "test/fixtures/linter/indentation_errors.sql", "line": 6, "start_column": 10, "end_column": 10, "title": "SQLFluff", "message": "L010: Keywords must be consistently upper case.", "annotation_level": "notice"}, {"file": "test/fixtures/linter/indentation_errors.sql", "line": 6, "start_column": 13, "end_column": 13, "title": "SQLFluff", "message": "L031: Avoid using aliases in join condition", "annotation_level": "notice"}]

_____________ test__cli__command_lint_serialize_github_annotation ______________
----------------------------- Captured stdout call -----------------------------
[{"file": "test/fixtures/linter/identifier_capitalisation.sql", "line": 1, "start_column": 1, "end_column": 1, "title": "SQLFluff", "message": "L036: Select targets should be on a new line unless there is only one select target.", "annotation_level": "warning"}, {"file": "test/fixtures/linter/identifier_capitalisation.sql", "line": 2, "start_column": 5, "end_column": 5, "title": "SQLFluff", "message": "L027: Unqualified reference 'foo' found in select with more than one referenced table/view.", "annotation_level": "warning"}, {"file": "test/fixtures/linter/identifier_capitalisation.sql", "line": 3, "start_column": 5, "end_column": 5, "title": "SQLFluff", "message": "L012: Implicit/explicit aliasing of columns.", "annotation_level": "warning"}, {"file": "test/fixtures/linter/identifier_capitalisation.sql", "line": 3, "start_column": 5, "end_column": 5, "title": "SQLFluff", "message": "L014: Unquoted identifiers must be consistently lower case.", "annotation_level": "warning"}, {"file": "test/fixtures/linter/identifier_capitalisation.sql", "line": 4, "start_column": 1, "end_column": 1, "title": "SQLFluff", "message": "L010: Keywords must be consistently lower case.", "annotation_level": "warning"}, {"file": "test/fixtures/linter/identifier_capitalisation.sql", "line": 4, "start_column": 12, "end_column": 12, "title": "SQLFluff", "message": "L014: Unquoted identifiers must be consistently lower case.", "annotation_level": "warning"}, {"file": "test/fixtures/linter/identifier_capitalisation.sql", "line": 4, "start_column": 18, "end_column": 18, "title": "SQLFluff", "message": "L014: Unquoted identifiers must be consistently lower case.", "annotation_level": "warning"}]

__________________________ test_encoding[utf-8-ascii] __________________________
----------------------------- Captured stdout call -----------------------------
== [/tmp/tmphh695u09/testing.sql] FAIL
L:   4 | P:  24 | L001 | Unnecessary trailing whitespace.
All Finished 📜 🎉!

==== finding fixable violations ====
== [/tmp/tmphh695u09/testing.sql] FAIL
L:   4 | P:  24 | L001 | Unnecessary trailing whitespace.
==== fixing violations ====
1 fixable linting violations found
FORCE MODE: Attempting fixes...
Persisting Changes...
== [/tmp/tmphh695u09/testing.sql] PASS
Done. Please check your files to confirm.

All Finished 📜 🎉!

______________________ test_encoding[utf-8-sig-UTF-8-SIG] ______________________
----------------------------- Captured stdout call -----------------------------
== [/tmp/tmp1pecklbf/testing.sql] FAIL
L:   4 | P:  24 | L001 | Unnecessary trailing whitespace.
All Finished 📜 🎉!

==== finding fixable violations ====
== [/tmp/tmp1pecklbf/testing.sql] FAIL
L:   4 | P:  24 | L001 | Unnecessary trailing whitespace.
==== fixing violations ====
1 fixable linting violations found
FORCE MODE: Attempting fixes...
Persisting Changes...
== [/tmp/tmp1pecklbf/testing.sql] PASS
Done. Please check your files to confirm.

All Finished 📜 🎉!

_________________________ test_encoding[utf-32-UTF-32] _________________________
----------------------------- Captured stdout call -----------------------------
== [/tmp/tmpad5rh1cd/testing.sql] FAIL
L:   4 | P:  24 | L001 | Unnecessary trailing whitespace.
All Finished 📜 🎉!

==== finding fixable violations ====
== [/tmp/tmpad5rh1cd/testing.sql] FAIL
L:   4 | P:  24 | L001 | Unnecessary trailing whitespace.
==== fixing violations ====
1 fixable linting violations found
FORCE MODE: Attempting fixes...
Persisting Changes...
== [/tmp/tmpad5rh1cd/testing.sql] PASS
Done. Please check your files to confirm.

All Finished 📜 🎉!

=========================== short test summary info ============================
PASSED test/cli/commands_test.py::test__cli__command_dialect
PASSED test/cli/commands_test.py::test__cli__command_dialect_legacy
PASSED test/cli/commands_test.py::test__cli__command_lint_stdin[command0]
PASSED test/cli/commands_test.py::test__cli__command_lint_stdin[command1]
PASSED test/cli/commands_test.py::test__cli__command_lint_stdin[command2]
PASSED test/cli/commands_test.py::test__cli__command_lint_stdin[command3]
PASSED test/cli/commands_test.py::test__cli__command_lint_parse[command0]
PASSED test/cli/commands_test.py::test__cli__command_lint_parse[command1]
PASSED test/cli/commands_test.py::test__cli__command_lint_parse[command2]
PASSED test/cli/commands_test.py::test__cli__command_lint_parse[command3]
PASSED test/cli/commands_test.py::test__cli__command_lint_parse[command4]
PASSED test/cli/commands_test.py::test__cli__command_lint_parse[command5]
PASSED test/cli/commands_test.py::test__cli__command_lint_parse[command6]
PASSED test/cli/commands_test.py::test__cli__command_lint_parse[command7]
PASSED test/cli/commands_test.py::test__cli__command_lint_parse[command8]
PASSED test/cli/commands_test.py::test__cli__command_lint_parse[command9]
PASSED test/cli/commands_test.py::test__cli__command_lint_parse[command10]
PASSED test/cli/commands_test.py::test__cli__command_lint_parse[command11]
PASSED test/cli/commands_test.py::test__cli__command_lint_parse[command12]
PASSED test/cli/commands_test.py::test__cli__command_lint_parse[command13]
PASSED test/cli/commands_test.py::test__cli__command_lint_parse[command14]
PASSED test/cli/commands_test.py::test__cli__command_lint_parse[command15]
PASSED test/cli/commands_test.py::test__cli__command_lint_parse[command16]
PASSED test/cli/commands_test.py::test__cli__command_lint_parse[command17]
PASSED test/cli/commands_test.py::test__cli__command_lint_parse[command18]
PASSED test/cli/commands_test.py::test__cli__command_lint_parse[command19]
PASSED test/cli/commands_test.py::test__cli__command_lint_parse[command20]
PASSED test/cli/commands_test.py::test__cli__command_lint_parse[command21]
PASSED test/cli/commands_test.py::test__cli__command_lint_parse_with_retcode[command0-1]
PASSED test/cli/commands_test.py::test__cli__command_lint_parse_with_retcode[command1-1]
PASSED test/cli/commands_test.py::test__cli__command_lint_parse_with_retcode[command2-1]
PASSED test/cli/commands_test.py::test__cli__command_lint_warning_explicit_file_ignored
PASSED test/cli/commands_test.py::test__cli__command_lint_skip_ignore_files
PASSED test/cli/commands_test.py::test__cli__command_versioning
PASSED test/cli/commands_test.py::test__cli__command_version
PASSED test/cli/commands_test.py::test__cli__command_rules
PASSED test/cli/commands_test.py::test__cli__command_dialects
PASSED test/cli/commands_test.py::test__cli__command__fix[L001-test/fixtures/linter/indentation_errors.sql]
PASSED test/cli/commands_test.py::test__cli__command__fix[L008-test/fixtures/linter/whitespace_errors.sql]
PASSED test/cli/commands_test.py::test__cli__command__fix[L008-test/fixtures/linter/indentation_errors.sql]
PASSED test/cli/commands_test.py::test__cli__command__fix[L003-test/fixtures/linter/indentation_error_hard.sql]
PASSED test/cli/commands_test.py::test__cli__command_fix_stdin[select * from t-L003-select * from t]
PASSED test/cli/commands_test.py::test__cli__command_fix_stdin[ select * from t-L003-select * from t]
PASSED test/cli/commands_test.py::test__cli__command_fix_stdin[SELECT u.id, c.first_name, c.last_name, COUNT(o.user_id) FROM users as u JOIN customers as c on u.id = c.user_id JOIN orders as o on u.id = o.user_id;-L031-SELECT users.id, customers.first_name, customers.last_name, COUNT(orders.user_id) FROM users JOIN customers on users.id = customers.user_id JOIN orders on users.id = orders.user_id;]
PASSED test/cli/commands_test.py::test__cli__command_fix_stdin_logging_to_stderr
PASSED test/cli/commands_test.py::test__cli__command_fix_stdin_safety
PASSED test/cli/commands_test.py::test__cli__command_fix_stdin_error_exit_code[create TABLE {{ params.dsfsdfds }}.t (a int)-1--v-Fix aborted due to unparseable template variables.]
PASSED test/cli/commands_test.py::test__cli__command_fix_stdin_error_exit_code[create TABLE a.t (a int)-0--]
PASSED test/cli/commands_test.py::test__cli__command_fix_stdin_error_exit_code[create table a.t (a int)-0--]
PASSED test/cli/commands_test.py::test__cli__command_fix_stdin_error_exit_code[select col from a join b using (c)-1--v-Unfixable violations detected.]
PASSED test/cli/commands_test.py::test__cli__command__fix_no_force[L001-test/fixtures/linter/indentation_errors.sql-y-0-0]
PASSED test/cli/commands_test.py::test__cli__command__fix_no_force[L001-test/fixtures/linter/indentation_errors.sql-n-65-1]
PASSED test/cli/commands_test.py::test__cli__command_parse_serialize_from_stdin[yaml]
PASSED test/cli/commands_test.py::test__cli__command_parse_serialize_from_stdin[json]
PASSED test/cli/commands_test.py::test__cli__command_lint_serialize_from_stdin[select * from tbl-expected0-0-yaml]
PASSED test/cli/commands_test.py::test__cli__command_lint_serialize_from_stdin[select * from tbl-expected0-0-json]
PASSED test/cli/commands_test.py::test__cli__command_lint_serialize_from_stdin[SElect * from tbl-expected1-65-yaml]
PASSED test/cli/commands_test.py::test__cli__command_lint_serialize_from_stdin[SElect * from tbl-expected1-65-json]
PASSED test/cli/commands_test.py::test__cli__command_fail_nice_not_found[command0]
PASSED test/cli/commands_test.py::test__cli__command_fail_nice_not_found[command1]
PASSED test/cli/commands_test.py::test__cli__command_lint_serialize_multiple_files[yaml]
PASSED test/cli/commands_test.py::test__cli__command_lint_serialize_multiple_files[json]
PASSED test/cli/commands_test.py::test__cli__command_lint_serialize_multiple_files[github-annotation]
PASSED test/cli/commands_test.py::test__cli__command_lint_serialize_github_annotation
PASSED test/cli/commands_test.py::test___main___help
PASSED test/cli/commands_test.py::test_encoding[utf-8-ascii]
PASSED test/cli/commands_test.py::test_encoding[utf-8-sig-UTF-8-SIG]
PASSED test/cli/commands_test.py::test_encoding[utf-32-UTF-32]
FAILED test/cli/commands_test.py::test__cli__command_directed - AssertionErro...
=================== 1 failed, 68 passed, 1 warning in 9.09s ====================
+ git checkout 14e1a23a3166b9a645a16de96f694c77a5d4abb7 test/cli/commands_test.py
Updated 1 path from dd86467b8
