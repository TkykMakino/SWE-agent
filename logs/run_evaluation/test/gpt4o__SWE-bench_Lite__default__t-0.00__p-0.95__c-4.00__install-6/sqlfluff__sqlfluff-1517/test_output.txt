+ source /opt/miniconda3/bin/activate
++ _CONDA_ROOT=/opt/miniconda3
++ . /opt/miniconda3/etc/profile.d/conda.sh
+++ export CONDA_EXE=/opt/miniconda3/bin/conda
+++ CONDA_EXE=/opt/miniconda3/bin/conda
+++ export _CE_M=
+++ _CE_M=
+++ export _CE_CONDA=
+++ _CE_CONDA=
+++ export CONDA_PYTHON_EXE=/opt/miniconda3/bin/python
+++ CONDA_PYTHON_EXE=/opt/miniconda3/bin/python
+++ '[' -z '' ']'
+++ export CONDA_SHLVL=0
+++ CONDA_SHLVL=0
+++ '[' -n '' ']'
+++++ dirname /opt/miniconda3/bin/conda
++++ dirname /opt/miniconda3/bin
+++ PATH=/opt/miniconda3/condabin:/opt/miniconda3/bin:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin
+++ export PATH
+++ '[' -z '' ']'
+++ PS1=
++ conda activate
++ local cmd=activate
++ case "$cmd" in
++ __conda_activate activate
++ '[' -n '' ']'
++ local ask_conda
+++ PS1=
+++ __conda_exe shell.posix activate
+++ /opt/miniconda3/bin/conda shell.posix activate
++ ask_conda='PS1='\''(base) '\''
export PATH='\''/opt/miniconda3/bin:/opt/miniconda3/condabin:/opt/miniconda3/bin:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin'\''
export CONDA_PREFIX='\''/opt/miniconda3'\''
export CONDA_SHLVL='\''1'\''
export CONDA_DEFAULT_ENV='\''base'\''
export CONDA_PROMPT_MODIFIER='\''(base) '\''
export CONDA_EXE='\''/opt/miniconda3/bin/conda'\''
export _CE_M='\'''\''
export _CE_CONDA='\'''\''
export CONDA_PYTHON_EXE='\''/opt/miniconda3/bin/python'\'''
++ eval 'PS1='\''(base) '\''
export PATH='\''/opt/miniconda3/bin:/opt/miniconda3/condabin:/opt/miniconda3/bin:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin'\''
export CONDA_PREFIX='\''/opt/miniconda3'\''
export CONDA_SHLVL='\''1'\''
export CONDA_DEFAULT_ENV='\''base'\''
export CONDA_PROMPT_MODIFIER='\''(base) '\''
export CONDA_EXE='\''/opt/miniconda3/bin/conda'\''
export _CE_M='\'''\''
export _CE_CONDA='\'''\''
export CONDA_PYTHON_EXE='\''/opt/miniconda3/bin/python'\'''
+++ PS1='(base) '
+++ export PATH=/opt/miniconda3/bin:/opt/miniconda3/condabin:/opt/miniconda3/bin:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin
+++ PATH=/opt/miniconda3/bin:/opt/miniconda3/condabin:/opt/miniconda3/bin:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin
+++ export CONDA_PREFIX=/opt/miniconda3
+++ CONDA_PREFIX=/opt/miniconda3
+++ export CONDA_SHLVL=1
+++ CONDA_SHLVL=1
+++ export CONDA_DEFAULT_ENV=base
+++ CONDA_DEFAULT_ENV=base
+++ export 'CONDA_PROMPT_MODIFIER=(base) '
+++ CONDA_PROMPT_MODIFIER='(base) '
+++ export CONDA_EXE=/opt/miniconda3/bin/conda
+++ CONDA_EXE=/opt/miniconda3/bin/conda
+++ export _CE_M=
+++ _CE_M=
+++ export _CE_CONDA=
+++ _CE_CONDA=
+++ export CONDA_PYTHON_EXE=/opt/miniconda3/bin/python
+++ CONDA_PYTHON_EXE=/opt/miniconda3/bin/python
++ __conda_hashr
++ '[' -n '' ']'
++ '[' -n '' ']'
++ hash -r
+ conda activate testbed
+ local cmd=activate
+ case "$cmd" in
+ __conda_activate activate testbed
+ '[' -n '' ']'
+ local ask_conda
++ PS1='(base) '
++ __conda_exe shell.posix activate testbed
++ /opt/miniconda3/bin/conda shell.posix activate testbed
+ ask_conda='PS1='\''(testbed) '\''
export PATH='\''/opt/miniconda3/envs/testbed/bin:/opt/miniconda3/condabin:/opt/miniconda3/bin:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin'\''
export CONDA_PREFIX='\''/opt/miniconda3/envs/testbed'\''
export CONDA_SHLVL='\''2'\''
export CONDA_DEFAULT_ENV='\''testbed'\''
export CONDA_PROMPT_MODIFIER='\''(testbed) '\''
export CONDA_PREFIX_1='\''/opt/miniconda3'\''
export CONDA_EXE='\''/opt/miniconda3/bin/conda'\''
export _CE_M='\'''\''
export _CE_CONDA='\'''\''
export CONDA_PYTHON_EXE='\''/opt/miniconda3/bin/python'\'''
+ eval 'PS1='\''(testbed) '\''
export PATH='\''/opt/miniconda3/envs/testbed/bin:/opt/miniconda3/condabin:/opt/miniconda3/bin:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin'\''
export CONDA_PREFIX='\''/opt/miniconda3/envs/testbed'\''
export CONDA_SHLVL='\''2'\''
export CONDA_DEFAULT_ENV='\''testbed'\''
export CONDA_PROMPT_MODIFIER='\''(testbed) '\''
export CONDA_PREFIX_1='\''/opt/miniconda3'\''
export CONDA_EXE='\''/opt/miniconda3/bin/conda'\''
export _CE_M='\'''\''
export _CE_CONDA='\'''\''
export CONDA_PYTHON_EXE='\''/opt/miniconda3/bin/python'\'''
++ PS1='(testbed) '
++ export PATH=/opt/miniconda3/envs/testbed/bin:/opt/miniconda3/condabin:/opt/miniconda3/bin:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin
++ PATH=/opt/miniconda3/envs/testbed/bin:/opt/miniconda3/condabin:/opt/miniconda3/bin:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin
++ export CONDA_PREFIX=/opt/miniconda3/envs/testbed
++ CONDA_PREFIX=/opt/miniconda3/envs/testbed
++ export CONDA_SHLVL=2
++ CONDA_SHLVL=2
++ export CONDA_DEFAULT_ENV=testbed
++ CONDA_DEFAULT_ENV=testbed
++ export 'CONDA_PROMPT_MODIFIER=(testbed) '
++ CONDA_PROMPT_MODIFIER='(testbed) '
++ export CONDA_PREFIX_1=/opt/miniconda3
++ CONDA_PREFIX_1=/opt/miniconda3
++ export CONDA_EXE=/opt/miniconda3/bin/conda
++ CONDA_EXE=/opt/miniconda3/bin/conda
++ export _CE_M=
++ _CE_M=
++ export _CE_CONDA=
++ _CE_CONDA=
++ export CONDA_PYTHON_EXE=/opt/miniconda3/bin/python
++ CONDA_PYTHON_EXE=/opt/miniconda3/bin/python
+ __conda_hashr
+ '[' -n '' ']'
+ '[' -n '' ']'
+ hash -r
+ cd /testbed
+ git config --global --add safe.directory /testbed
+ cd /testbed
+ git status
On branch main
Changes not staged for commit:
  (use "git add <file>..." to update what will be committed)
  (use "git restore <file>..." to discard changes in working directory)
	modified:   src/sqlfluff/core/parser/grammar/sequence.py

no changes added to commit (use "git add" and/or "git commit -a")
+ git show
commit 304a197829f98e7425a46d872ada73176137e5ae
Author: Barry Pollard <barry@tunetheweb.com>
Date:   Thu Oct 7 20:03:09 2021 +0100

    Support Group and Groups as table names (#1546)

diff --git a/src/sqlfluff/dialects/dialect_ansi.py b/src/sqlfluff/dialects/dialect_ansi.py
index f237e857a..18555e005 100644
--- a/src/sqlfluff/dialects/dialect_ansi.py
+++ b/src/sqlfluff/dialects/dialect_ansi.py
@@ -439,8 +439,8 @@ ansi_dialect.add(
     FromClauseTerminatorGrammar=OneOf(
         "WHERE",
         "LIMIT",
-        "GROUP",
-        "ORDER",
+        Sequence("GROUP", "BY"),
+        Sequence("ORDER", "BY"),
         "HAVING",
         "QUALIFY",
         "WINDOW",
@@ -448,7 +448,13 @@ ansi_dialect.add(
         Ref("WithNoSchemaBindingClauseSegment"),
     ),
     WhereClauseTerminatorGrammar=OneOf(
-        "LIMIT", "GROUP", "ORDER", "HAVING", "QUALIFY", "WINDOW", "OVERLAPS"
+        "LIMIT",
+        Sequence("GROUP", "BY"),
+        Sequence("ORDER", "BY"),
+        "HAVING",
+        "QUALIFY",
+        "WINDOW",
+        "OVERLAPS",
     ),
     PrimaryKeyGrammar=Sequence("PRIMARY", "KEY"),
     ForeignKeyGrammar=Sequence("FOREIGN", "KEY"),
diff --git a/src/sqlfluff/dialects/dialect_exasol.py b/src/sqlfluff/dialects/dialect_exasol.py
index 2144fd069..c5b34f3eb 100644
--- a/src/sqlfluff/dialects/dialect_exasol.py
+++ b/src/sqlfluff/dialects/dialect_exasol.py
@@ -225,8 +225,8 @@ exasol_dialect.replace(
         "START",
         "PREFERRING",
         "LIMIT",
-        "GROUP",
-        "ORDER",
+        Sequence("GROUP", "BY"),
+        Sequence("ORDER", "BY"),
         "HAVING",
         "QUALIFY",
         Ref("SetOperatorSegment"),
@@ -236,8 +236,8 @@ exasol_dialect.replace(
         "START",
         "PREFERRING",
         "LIMIT",
-        "GROUP",
-        "ORDER",
+        Sequence("GROUP", "BY"),
+        Sequence("ORDER", "BY"),
         "HAVING",
         "QUALIFY",
         Ref("SetOperatorSegment"),
@@ -459,9 +459,9 @@ class ConnectByClauseSegment(BaseSegment):
         ),
         terminator=OneOf(
             "PREFERRING",
-            "GROUP",
+            Sequence("GROUP", "BY"),
             "QUALIFY",
-            "ORDER",
+            Sequence("ORDER", "BY"),
             "LIMIT",
             Ref("SetOperatorSegment"),
         ),
diff --git a/src/sqlfluff/dialects/dialect_tsql.py b/src/sqlfluff/dialects/dialect_tsql.py
index ab6b2d124..2fada2a91 100644
--- a/src/sqlfluff/dialects/dialect_tsql.py
+++ b/src/sqlfluff/dialects/dialect_tsql.py
@@ -102,8 +102,8 @@ tsql_dialect.replace(
     FromClauseTerminatorGrammar=OneOf(
         "WHERE",
         "LIMIT",
-        "GROUP",
-        "ORDER",
+        Sequence("GROUP", "BY"),
+        Sequence("ORDER", "BY"),
         "HAVING",
         "PIVOT",
         "UNPIVOT",
diff --git a/test/fixtures/parser/ansi/select_table_named_group.sql b/test/fixtures/parser/ansi/select_table_named_group.sql
new file mode 100644
index 000000000..b12095621
--- /dev/null
+++ b/test/fixtures/parser/ansi/select_table_named_group.sql
@@ -0,0 +1,2 @@
+select 1 from group;
+select 1 from groups;
diff --git a/test/fixtures/parser/ansi/select_table_named_group.yml b/test/fixtures/parser/ansi/select_table_named_group.yml
new file mode 100644
index 000000000..9fec72a29
--- /dev/null
+++ b/test/fixtures/parser/ansi/select_table_named_group.yml
@@ -0,0 +1,35 @@
+# YML test files are auto-generated from SQL files and should not be edited by
+# hand. To help enforce this, the "hash" field in the file must match a hash
+# computed by SQLFluff when running the tests. Please run
+# `python test/generate_parse_fixture_yml.py`  to generate them after adding or
+# altering SQL files.
+_hash: 58494049fb071ce5281906efd48106c55382e70443878f28a66451a872b1d765
+file:
+- statement:
+    select_statement:
+      select_clause:
+        keyword: select
+        select_clause_element:
+          literal: '1'
+      from_clause:
+        keyword: from
+        from_expression:
+          from_expression_element:
+            table_expression:
+              table_reference:
+                identifier: group
+- statement_terminator: ;
+- statement:
+    select_statement:
+      select_clause:
+        keyword: select
+        select_clause_element:
+          literal: '1'
+      from_clause:
+        keyword: from
+        from_expression:
+          from_expression_element:
+            table_expression:
+              table_reference:
+                identifier: groups
+- statement_terminator: ;
+ git diff 304a197829f98e7425a46d872ada73176137e5ae
diff --git a/src/sqlfluff/core/parser/grammar/sequence.py b/src/sqlfluff/core/parser/grammar/sequence.py
index 580156fee..f1320b276 100644
--- a/src/sqlfluff/core/parser/grammar/sequence.py
+++ b/src/sqlfluff/core/parser/grammar/sequence.py
@@ -66,8 +66,11 @@ class Sequence(BaseGrammar):
             if early_break:
                 break
 
-            while True:
-                # Consume non-code if appropriate
+            # Handle doubled semicolons
+            if len(unmatched_segments) > 1 and unmatched_segments[0].raw == ";" and unmatched_segments[1].raw == ";":
+                matched_segments += (unmatched_segments[0],)
+                unmatched_segments = unmatched_segments[2:]
+                continue
                 if self.allow_gaps:
                     pre_nc, mid_seg, post_nc = trim_non_code_segments(
                         unmatched_segments
+ source /opt/miniconda3/bin/activate
++ _CONDA_ROOT=/opt/miniconda3
++ . /opt/miniconda3/etc/profile.d/conda.sh
+++ export CONDA_EXE=/opt/miniconda3/bin/conda
+++ CONDA_EXE=/opt/miniconda3/bin/conda
+++ export _CE_M=
+++ _CE_M=
+++ export _CE_CONDA=
+++ _CE_CONDA=
+++ export CONDA_PYTHON_EXE=/opt/miniconda3/bin/python
+++ CONDA_PYTHON_EXE=/opt/miniconda3/bin/python
+++ '[' -z x ']'
++ conda activate
++ local cmd=activate
++ case "$cmd" in
++ __conda_activate activate
++ '[' -n '' ']'
++ local ask_conda
+++ PS1='(testbed) '
+++ __conda_exe shell.posix activate
+++ /opt/miniconda3/bin/conda shell.posix activate
++ ask_conda='PS1='\''(base) '\''
export PATH='\''/opt/miniconda3/bin:/opt/miniconda3/condabin:/opt/miniconda3/bin:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin'\''
export CONDA_PREFIX='\''/opt/miniconda3'\''
export CONDA_SHLVL='\''3'\''
export CONDA_DEFAULT_ENV='\''base'\''
export CONDA_PROMPT_MODIFIER='\''(base) '\''
export CONDA_PREFIX_2='\''/opt/miniconda3/envs/testbed'\''
export CONDA_EXE='\''/opt/miniconda3/bin/conda'\''
export _CE_M='\'''\''
export _CE_CONDA='\'''\''
export CONDA_PYTHON_EXE='\''/opt/miniconda3/bin/python'\'''
++ eval 'PS1='\''(base) '\''
export PATH='\''/opt/miniconda3/bin:/opt/miniconda3/condabin:/opt/miniconda3/bin:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin'\''
export CONDA_PREFIX='\''/opt/miniconda3'\''
export CONDA_SHLVL='\''3'\''
export CONDA_DEFAULT_ENV='\''base'\''
export CONDA_PROMPT_MODIFIER='\''(base) '\''
export CONDA_PREFIX_2='\''/opt/miniconda3/envs/testbed'\''
export CONDA_EXE='\''/opt/miniconda3/bin/conda'\''
export _CE_M='\'''\''
export _CE_CONDA='\'''\''
export CONDA_PYTHON_EXE='\''/opt/miniconda3/bin/python'\'''
+++ PS1='(base) '
+++ export PATH=/opt/miniconda3/bin:/opt/miniconda3/condabin:/opt/miniconda3/bin:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin
+++ PATH=/opt/miniconda3/bin:/opt/miniconda3/condabin:/opt/miniconda3/bin:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin
+++ export CONDA_PREFIX=/opt/miniconda3
+++ CONDA_PREFIX=/opt/miniconda3
+++ export CONDA_SHLVL=3
+++ CONDA_SHLVL=3
+++ export CONDA_DEFAULT_ENV=base
+++ CONDA_DEFAULT_ENV=base
+++ export 'CONDA_PROMPT_MODIFIER=(base) '
+++ CONDA_PROMPT_MODIFIER='(base) '
+++ export CONDA_PREFIX_2=/opt/miniconda3/envs/testbed
+++ CONDA_PREFIX_2=/opt/miniconda3/envs/testbed
+++ export CONDA_EXE=/opt/miniconda3/bin/conda
+++ CONDA_EXE=/opt/miniconda3/bin/conda
+++ export _CE_M=
+++ _CE_M=
+++ export _CE_CONDA=
+++ _CE_CONDA=
+++ export CONDA_PYTHON_EXE=/opt/miniconda3/bin/python
+++ CONDA_PYTHON_EXE=/opt/miniconda3/bin/python
++ __conda_hashr
++ '[' -n '' ']'
++ '[' -n '' ']'
++ hash -r
+ conda activate testbed
+ local cmd=activate
+ case "$cmd" in
+ __conda_activate activate testbed
+ '[' -n '' ']'
+ local ask_conda
++ PS1='(base) '
++ __conda_exe shell.posix activate testbed
++ /opt/miniconda3/bin/conda shell.posix activate testbed
+ ask_conda='PS1='\''(testbed) '\''
export PATH='\''/opt/miniconda3/envs/testbed/bin:/opt/miniconda3/condabin:/opt/miniconda3/bin:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin'\''
export CONDA_PREFIX='\''/opt/miniconda3/envs/testbed'\''
export CONDA_SHLVL='\''4'\''
export CONDA_DEFAULT_ENV='\''testbed'\''
export CONDA_PROMPT_MODIFIER='\''(testbed) '\''
export CONDA_PREFIX_3='\''/opt/miniconda3'\''
export CONDA_EXE='\''/opt/miniconda3/bin/conda'\''
export _CE_M='\'''\''
export _CE_CONDA='\'''\''
export CONDA_PYTHON_EXE='\''/opt/miniconda3/bin/python'\'''
+ eval 'PS1='\''(testbed) '\''
export PATH='\''/opt/miniconda3/envs/testbed/bin:/opt/miniconda3/condabin:/opt/miniconda3/bin:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin'\''
export CONDA_PREFIX='\''/opt/miniconda3/envs/testbed'\''
export CONDA_SHLVL='\''4'\''
export CONDA_DEFAULT_ENV='\''testbed'\''
export CONDA_PROMPT_MODIFIER='\''(testbed) '\''
export CONDA_PREFIX_3='\''/opt/miniconda3'\''
export CONDA_EXE='\''/opt/miniconda3/bin/conda'\''
export _CE_M='\'''\''
export _CE_CONDA='\'''\''
export CONDA_PYTHON_EXE='\''/opt/miniconda3/bin/python'\'''
++ PS1='(testbed) '
++ export PATH=/opt/miniconda3/envs/testbed/bin:/opt/miniconda3/condabin:/opt/miniconda3/bin:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin
++ PATH=/opt/miniconda3/envs/testbed/bin:/opt/miniconda3/condabin:/opt/miniconda3/bin:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin
++ export CONDA_PREFIX=/opt/miniconda3/envs/testbed
++ CONDA_PREFIX=/opt/miniconda3/envs/testbed
++ export CONDA_SHLVL=4
++ CONDA_SHLVL=4
++ export CONDA_DEFAULT_ENV=testbed
++ CONDA_DEFAULT_ENV=testbed
++ export 'CONDA_PROMPT_MODIFIER=(testbed) '
++ CONDA_PROMPT_MODIFIER='(testbed) '
++ export CONDA_PREFIX_3=/opt/miniconda3
++ CONDA_PREFIX_3=/opt/miniconda3
++ export CONDA_EXE=/opt/miniconda3/bin/conda
++ CONDA_EXE=/opt/miniconda3/bin/conda
++ export _CE_M=
++ _CE_M=
++ export _CE_CONDA=
++ _CE_CONDA=
++ export CONDA_PYTHON_EXE=/opt/miniconda3/bin/python
++ CONDA_PYTHON_EXE=/opt/miniconda3/bin/python
+ __conda_hashr
+ '[' -n '' ']'
+ '[' -n '' ']'
+ hash -r
+ python -m pip install -e .
Obtaining file:///testbed
  Preparing metadata (setup.py): started
  Preparing metadata (setup.py): finished with status 'done'
Requirement already satisfied: click>=7.1 in /opt/miniconda3/envs/testbed/lib/python3.9/site-packages (from sqlfluff==0.6.8) (8.1.7)
Requirement already satisfied: colorama>=0.3 in /opt/miniconda3/envs/testbed/lib/python3.9/site-packages (from sqlfluff==0.6.8) (0.4.6)
Requirement already satisfied: configparser in /opt/miniconda3/envs/testbed/lib/python3.9/site-packages (from sqlfluff==0.6.8) (7.1.0)
Requirement already satisfied: oyaml in /opt/miniconda3/envs/testbed/lib/python3.9/site-packages (from sqlfluff==0.6.8) (1.0)
Requirement already satisfied: Jinja2 in /opt/miniconda3/envs/testbed/lib/python3.9/site-packages (from sqlfluff==0.6.8) (3.1.4)
Requirement already satisfied: diff-cover>=2.5.0 in /opt/miniconda3/envs/testbed/lib/python3.9/site-packages (from sqlfluff==0.6.8) (9.2.0)
Requirement already satisfied: pathspec in /opt/miniconda3/envs/testbed/lib/python3.9/site-packages (from sqlfluff==0.6.8) (0.12.1)
Requirement already satisfied: appdirs in /opt/miniconda3/envs/testbed/lib/python3.9/site-packages (from sqlfluff==0.6.8) (1.4.4)
Requirement already satisfied: cached-property in /opt/miniconda3/envs/testbed/lib/python3.9/site-packages (from sqlfluff==0.6.8) (2.0.1)
Requirement already satisfied: typing_extensions in /opt/miniconda3/envs/testbed/lib/python3.9/site-packages (from sqlfluff==0.6.8) (4.12.2)
Requirement already satisfied: pytest in /opt/miniconda3/envs/testbed/lib/python3.9/site-packages (from sqlfluff==0.6.8) (8.3.3)
Requirement already satisfied: toml in /opt/miniconda3/envs/testbed/lib/python3.9/site-packages (from sqlfluff==0.6.8) (0.10.2)
Requirement already satisfied: tblib in /opt/miniconda3/envs/testbed/lib/python3.9/site-packages (from sqlfluff==0.6.8) (3.0.0)
Requirement already satisfied: Pygments<3.0.0,>=2.9.0 in /opt/miniconda3/envs/testbed/lib/python3.9/site-packages (from diff-cover>=2.5.0->sqlfluff==0.6.8) (2.18.0)
Requirement already satisfied: chardet>=3.0.0 in /opt/miniconda3/envs/testbed/lib/python3.9/site-packages (from diff-cover>=2.5.0->sqlfluff==0.6.8) (5.2.0)
Requirement already satisfied: pluggy<2,>=0.13.1 in /opt/miniconda3/envs/testbed/lib/python3.9/site-packages (from diff-cover>=2.5.0->sqlfluff==0.6.8) (1.5.0)
Requirement already satisfied: MarkupSafe>=2.0 in /opt/miniconda3/envs/testbed/lib/python3.9/site-packages (from Jinja2->sqlfluff==0.6.8) (3.0.2)
Requirement already satisfied: pyyaml in /opt/miniconda3/envs/testbed/lib/python3.9/site-packages (from oyaml->sqlfluff==0.6.8) (6.0.2)
Requirement already satisfied: iniconfig in /opt/miniconda3/envs/testbed/lib/python3.9/site-packages (from pytest->sqlfluff==0.6.8) (2.0.0)
Requirement already satisfied: packaging in /opt/miniconda3/envs/testbed/lib/python3.9/site-packages (from pytest->sqlfluff==0.6.8) (24.1)
Requirement already satisfied: exceptiongroup>=1.0.0rc8 in /opt/miniconda3/envs/testbed/lib/python3.9/site-packages (from pytest->sqlfluff==0.6.8) (1.2.2)
Requirement already satisfied: tomli>=1 in /opt/miniconda3/envs/testbed/lib/python3.9/site-packages (from pytest->sqlfluff==0.6.8) (2.0.2)
Installing collected packages: sqlfluff
  Attempting uninstall: sqlfluff
    Found existing installation: sqlfluff 0.6.8
    Uninstalling sqlfluff-0.6.8:
      Successfully uninstalled sqlfluff-0.6.8
  DEPRECATION: Legacy editable install of sqlfluff==0.6.8 from file:///testbed (setup.py develop) is deprecated. pip 25.0 will enforce this behaviour change. A possible replacement is to add a pyproject.toml or enable --use-pep517, and use setuptools >= 64. If the resulting installation is not behaving as expected, try using --config-settings editable_mode=compat. Please consult the setuptools documentation for more information. Discussion can be found at https://github.com/pypa/pip/issues/11457
  Running setup.py develop for sqlfluff
Successfully installed sqlfluff
WARNING: Running pip as the 'root' user can result in broken permissions and conflicting behaviour with the system package manager, possibly rendering your system unusable.It is recommended to use a virtual environment instead: https://pip.pypa.io/warnings/venv. Use the --root-user-action option if you know what you are doing and want to suppress this warning.
+ git checkout 304a197829f98e7425a46d872ada73176137e5ae test/dialects/ansi_test.py
Updated 0 paths from c2e0eb73a
+ git apply -v -
Checking patch test/dialects/ansi_test.py...
Applied patch test/dialects/ansi_test.py cleanly.
+ pytest -rA test/dialects/ansi_test.py
============================= test session starts ==============================
platform linux -- Python 3.9.20, pytest-8.3.3, pluggy-1.5.0
rootdir: /testbed
configfile: pytest.ini
plugins: cov-6.0.0, hypothesis-6.115.6, sugar-1.0.0
collected 59 items

test/dialects/ansi_test.py ..............F......F.FFFFFFFF.FF...FF.F.... [ 76%]
FFF.FFFF.FFFFF                                                           [100%]

=================================== FAILURES ===================================
_ test__dialect__ansi_specific_segment_parses[SelectClauseElementSegment-MIN (test.id) AS min_test_id] _

segmentref = 'SelectClauseElementSegment', raw = 'MIN (test.id) AS min_test_id'
caplog = <_pytest.logging.LogCaptureFixture object at 0x7a10854a3fa0>
dialect_specific_segment_parses = <function _dialect_specific_segment_parses at 0x7a1085546dc0>

    @pytest.mark.parametrize(
        "segmentref,raw",
        [
            ("SelectKeywordSegment", "select"),
            ("NakedIdentifierSegment", "online_sales"),
            ("BareFunctionSegment", "current_timestamp"),
            ("FunctionSegment", "current_timestamp()"),
            ("NumericLiteralSegment", "1000.0"),
            ("ExpressionSegment", "online_sales / 1000.0"),
            ("IntervalExpressionSegment", "INTERVAL 1 YEAR"),
            ("ExpressionSegment", "CASE WHEN id = 1 THEN 'nothing' ELSE 'test' END"),
            # Nested Case Expressions
            # https://github.com/sqlfluff/sqlfluff/issues/172
            (
                "ExpressionSegment",
                (
                    "CASE WHEN id = 1 THEN CASE WHEN true THEN 'something' "
                    "ELSE 'nothing' END ELSE 'test' END"
                ),
            ),
            # Casting expressions
            # https://github.com/sqlfluff/sqlfluff/issues/161
            ("ExpressionSegment", "CAST(ROUND(online_sales / 1000.0) AS varchar)"),
            # Like expressions
            # https://github.com/sqlfluff/sqlfluff/issues/170
            ("ExpressionSegment", "name NOT LIKE '%y'"),
            # Functions with a space
            # https://github.com/sqlfluff/sqlfluff/issues/171
            ("SelectClauseElementSegment", "MIN (test.id) AS min_test_id"),
            # Interval literals
            # https://github.com/sqlfluff/sqlfluff/issues/148
            (
                "ExpressionSegment",
                "DATE_ADD(CURRENT_DATE('America/New_York'), INTERVAL 1 year)",
            ),
            # Array accessors
            ("ExpressionSegment", "my_array[1]"),
            ("ExpressionSegment", "my_array[OFFSET(1)]"),
            ("ExpressionSegment", "my_array[5:8]"),
            ("ExpressionSegment", "4 + my_array[OFFSET(1)]"),
            ("ExpressionSegment", "bits[OFFSET(0)] + 7"),
            (
                "SelectClauseElementSegment",
                (
                    "(count_18_24 * bits[OFFSET(0)])"
                    " / audience_size AS relative_abundance"
                ),
            ),
            ("ExpressionSegment", "count_18_24 * bits[OFFSET(0)] + count_25_34"),
            (
                "SelectClauseElementSegment",
                (
                    "(count_18_24 * bits[OFFSET(0)] + count_25_34)"
                    " / audience_size AS relative_abundance"
                ),
            ),
            # Dense math expressions
            # https://github.com/sqlfluff/sqlfluff/issues/178
            # https://github.com/sqlfluff/sqlfluff/issues/179
            ("SelectStatementSegment", "SELECT t.val/t.id FROM test WHERE id*1.0/id > 0.8"),
            ("SelectClauseElementSegment", "t.val/t.id"),
            # Issue with casting raise as part of PR #177
            ("SelectClauseElementSegment", "CAST(num AS INT64)"),
            # Casting as datatype with arguments
            ("SelectClauseElementSegment", "CAST(num AS numeric(8,4))"),
            # Wildcard field selection
            ("SelectClauseElementSegment", "a.*"),
            ("SelectClauseElementSegment", "a.b.*"),
            ("SelectClauseElementSegment", "a.b.c.*"),
            # Default Element Syntax
            ("ObjectReferenceSegment", "a..c.*"),
            # Negative Elements
            ("SelectClauseElementSegment", "-some_variable"),
            ("SelectClauseElementSegment", "- some_variable"),
            # Complex Functions
            (
                "ExpressionSegment",
                "concat(left(uaid, 2), '|', right(concat('0000000', SPLIT_PART(uaid, '|', 4)), 10), '|', '00000000')",
            ),
            # Notnull and Isnull
            ("ExpressionSegment", "c is null"),
            ("ExpressionSegment", "c is not null"),
            ("SelectClauseElementSegment", "c is null as c_isnull"),
            ("SelectClauseElementSegment", "c is not null as c_notnull"),
            # Shorthand casting
            ("ExpressionSegment", "NULL::INT"),
            ("SelectClauseElementSegment", "NULL::INT AS user_id"),
            ("TruncateStatementSegment", "TRUNCATE TABLE test"),
            ("TruncateStatementSegment", "TRUNCATE test"),
        ],
    )
    def test__dialect__ansi_specific_segment_parses(
        segmentref, raw, caplog, dialect_specific_segment_parses
    ):
        """Test that specific segments parse as expected.
    
        NB: We're testing the PARSE function not the MATCH function
        although this will be a recursive parse and so the match
        function of SUBSECTIONS will be tested if present. The match
        function of the parent will not be tested.
        """
>       dialect_specific_segment_parses("ansi", segmentref, raw, caplog)

test/dialects/ansi_test.py:132: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

dialect = 'ansi', segmentref = 'SelectClauseElementSegment'
raw = 'MIN (test.id) AS min_test_id'
caplog = <_pytest.logging.LogCaptureFixture object at 0x7a10854a3fa0>

    def _dialect_specific_segment_parses(dialect, segmentref, raw, caplog):
        """Test that specific segments parse as expected.
    
        NB: We're testing the PARSE function not the MATCH function
        although this will be a recursive parse and so the match
        function of SUBSECTIONS will be tested if present. The match
        function of the parent will not be tested.
        """
        config = FluffConfig(overrides=dict(dialect=dialect))
        seg_list = lex(raw, config=config)
        Seg = validate_segment(segmentref, config=config)
    
        # This test is different if we're working with RawSegment
        # derivatives or not.
        if isinstance(Seg, StringParser) or issubclass(Seg, RawSegment):
            print("Raw/Parser route...")
            with RootParseContext.from_config(config) as ctx:
                with caplog.at_level(logging.DEBUG):
                    parsed = Seg.match(segments=seg_list, parse_context=ctx)
            assert isinstance(parsed, MatchResult)
            assert len(parsed.matched_segments) == 1
            print(parsed)
            parsed = parsed.matched_segments[0]
            print(parsed)
        else:
            print("Base route...")
            # Construct an unparsed segment
            seg = Seg(seg_list, pos_marker=seg_list[0].pos_marker)
            # Perform the match (THIS IS THE MEAT OF THE TEST)
            with RootParseContext.from_config(config) as ctx:
                with caplog.at_level(logging.DEBUG):
                    parsed = seg.parse(parse_context=ctx)
            print(parsed)
            assert isinstance(parsed, Seg)
    
        # Check we get a good response
        print(parsed)
        print(type(parsed))
        # print(type(parsed._reconstruct()))
        print(type(parsed.raw))
        # Check we're all there.
        assert parsed.raw == raw
        # Check that there's nothing un parsable
        typs = parsed.type_set()
>       assert "unparsable" not in typs
E       AssertionError: assert 'unparsable' not in {'raw', 'select_clause_element', 'unparsable', 'whitespace'}

test/dialects/conftest.py:89: AssertionError
----------------------------- Captured stdout call -----------------------------
(<CodeSegment: ([L:  1, P:  1]) 'MIN'>, <WhitespaceSegment: ([L:  1, P:  4]) ' '>, <CodeSegment: ([L:  1, P:  5]) '('>, <CodeSegment: ([L:  1, P:  6]) 'test'>, <CodeSegment: ([L:  1, P: 10]) '.'>, <CodeSegment: ([L:  1, P: 11]) 'id'>, <CodeSegment: ([L:  1, P: 13]) ')'>, <WhitespaceSegment: ([L:  1, P: 14]) ' '>, <CodeSegment: ([L:  1, P: 15]) 'AS'>, <WhitespaceSegment: ([L:  1, P: 17]) ' '>, <CodeSegment: ([L:  1, P: 18]) 'min_test_id'>)
Base route...
<SelectClauseElementSegment: ([L:  1, P:  1])>
<SelectClauseElementSegment: ([L:  1, P:  1])>
<class 'sqlfluff.dialects.dialect_ansi.SelectClauseElementSegment'>
<class 'str'>
------------------------------ Captured log call -------------------------------
INFO     sqlfluff.parser:match_logging.py:28 [PD:0  MD:0 ]	SelectClauseElementSegment                        	OneOf.match PRN     	    	[ns=2, ps=0, ms=0, pruned=[], opts=[<Ref: WildcardExpressionSegment>, <Sequence: [<Ref: BaseExpressionElementGrammar>, <Ref: AliasExpressionSegment [opt]>]>]]
INFO     sqlfluff.parser:match_logging.py:28 [PD:0  MD:2 ]	..WildcardExpressionSegment                       	Seque.match OUT     	    	[match=<MatchResult 0/11: ''>, seg="'MIN (test.id) AS min...'"]
DEBUG    sqlfluff.parser:match_logging.py:30 [PD:0  MD:1 ]	.WildcardExpressionSegment                        	Wildc.match OUT     	    	[match=<MatchResult 0/11: ''>, seg="'MIN (test.id) AS min...'"]
DEBUG    sqlfluff.parser:match_logging.py:30 [PD:0  MD:1 ]	.SelectClauseElementSegment                       	Ref.match OUT       	    	[match=<MatchResult 0/11: ''>, seg="'MIN (test.id) AS min...'"]
INFO     sqlfluff.parser:match_logging.py:28 [PD:0  MD:1 ]	.SelectClauseElementSegment                       	Seque.match OUT     	    	[match=<MatchResult 0/11: ''>, seg="'MIN (test.id) AS min...'"]
INFO     sqlfluff.parser:match_logging.py:28 [PD:0  MD:0 ]	SelectClauseElementSegment                        	OneOf.match OUT     	    	[match=<MatchResult 0/11: ''>, seg="'MIN (test.id) AS min...'"]
DEBUG    sqlfluff.parser:base.py:859 SelectClauseElementSegment.parse: Done Parse. Plotting Recursion. Recurse=True
DEBUG    sqlfluff.parser:base.py:868 ###
#
# Beginning Parse Depth 1: SelectClauseElementSegment
#
###
Initial Structure:
[L:  1, P:  1]      |select_clause_element:
[L:  1, P:  1]      |    unparsable:                                               !! Expected: 'SelectClauseElementSegment'
[L:  1, P:  1]      |        raw:                                                  'MIN'
[L:  1, P:  4]      |        whitespace:                                           ' '
[L:  1, P:  5]      |        raw:                                                  '('
[L:  1, P:  6]      |        raw:                                                  'test'
[L:  1, P: 10]      |        raw:                                                  '.'
[L:  1, P: 11]      |        raw:                                                  'id'
[L:  1, P: 13]      |        raw:                                                  ')'
[L:  1, P: 14]      |        whitespace:                                           ' '
[L:  1, P: 15]      |        raw:                                                  'AS'
[L:  1, P: 17]      |        whitespace:                                           ' '
[L:  1, P: 18]      |        raw:                                                  'min_test_id'

INFO     sqlfluff.parser:base.py:251 [PD:1] Skipping expansion of <UnparsableSegment: ([L:  1, P:  1])>...
_ test__dialect__ansi_specific_segment_parses[SelectClauseElementSegment-(count_18_24 * bits[OFFSET(0)]) / audience_size AS relative_abundance] _

segmentref = 'SelectClauseElementSegment'
raw = '(count_18_24 * bits[OFFSET(0)]) / audience_size AS relative_abundance'
caplog = <_pytest.logging.LogCaptureFixture object at 0x7a1085415d90>
dialect_specific_segment_parses = <function _dialect_specific_segment_parses at 0x7a1085546dc0>

    @pytest.mark.parametrize(
        "segmentref,raw",
        [
            ("SelectKeywordSegment", "select"),
            ("NakedIdentifierSegment", "online_sales"),
            ("BareFunctionSegment", "current_timestamp"),
            ("FunctionSegment", "current_timestamp()"),
            ("NumericLiteralSegment", "1000.0"),
            ("ExpressionSegment", "online_sales / 1000.0"),
            ("IntervalExpressionSegment", "INTERVAL 1 YEAR"),
            ("ExpressionSegment", "CASE WHEN id = 1 THEN 'nothing' ELSE 'test' END"),
            # Nested Case Expressions
            # https://github.com/sqlfluff/sqlfluff/issues/172
            (
                "ExpressionSegment",
                (
                    "CASE WHEN id = 1 THEN CASE WHEN true THEN 'something' "
                    "ELSE 'nothing' END ELSE 'test' END"
                ),
            ),
            # Casting expressions
            # https://github.com/sqlfluff/sqlfluff/issues/161
            ("ExpressionSegment", "CAST(ROUND(online_sales / 1000.0) AS varchar)"),
            # Like expressions
            # https://github.com/sqlfluff/sqlfluff/issues/170
            ("ExpressionSegment", "name NOT LIKE '%y'"),
            # Functions with a space
            # https://github.com/sqlfluff/sqlfluff/issues/171
            ("SelectClauseElementSegment", "MIN (test.id) AS min_test_id"),
            # Interval literals
            # https://github.com/sqlfluff/sqlfluff/issues/148
            (
                "ExpressionSegment",
                "DATE_ADD(CURRENT_DATE('America/New_York'), INTERVAL 1 year)",
            ),
            # Array accessors
            ("ExpressionSegment", "my_array[1]"),
            ("ExpressionSegment", "my_array[OFFSET(1)]"),
            ("ExpressionSegment", "my_array[5:8]"),
            ("ExpressionSegment", "4 + my_array[OFFSET(1)]"),
            ("ExpressionSegment", "bits[OFFSET(0)] + 7"),
            (
                "SelectClauseElementSegment",
                (
                    "(count_18_24 * bits[OFFSET(0)])"
                    " / audience_size AS relative_abundance"
                ),
            ),
            ("ExpressionSegment", "count_18_24 * bits[OFFSET(0)] + count_25_34"),
            (
                "SelectClauseElementSegment",
                (
                    "(count_18_24 * bits[OFFSET(0)] + count_25_34)"
                    " / audience_size AS relative_abundance"
                ),
            ),
            # Dense math expressions
            # https://github.com/sqlfluff/sqlfluff/issues/178
            # https://github.com/sqlfluff/sqlfluff/issues/179
            ("SelectStatementSegment", "SELECT t.val/t.id FROM test WHERE id*1.0/id > 0.8"),
            ("SelectClauseElementSegment", "t.val/t.id"),
            # Issue with casting raise as part of PR #177
            ("SelectClauseElementSegment", "CAST(num AS INT64)"),
            # Casting as datatype with arguments
            ("SelectClauseElementSegment", "CAST(num AS numeric(8,4))"),
            # Wildcard field selection
            ("SelectClauseElementSegment", "a.*"),
            ("SelectClauseElementSegment", "a.b.*"),
            ("SelectClauseElementSegment", "a.b.c.*"),
            # Default Element Syntax
            ("ObjectReferenceSegment", "a..c.*"),
            # Negative Elements
            ("SelectClauseElementSegment", "-some_variable"),
            ("SelectClauseElementSegment", "- some_variable"),
            # Complex Functions
            (
                "ExpressionSegment",
                "concat(left(uaid, 2), '|', right(concat('0000000', SPLIT_PART(uaid, '|', 4)), 10), '|', '00000000')",
            ),
            # Notnull and Isnull
            ("ExpressionSegment", "c is null"),
            ("ExpressionSegment", "c is not null"),
            ("SelectClauseElementSegment", "c is null as c_isnull"),
            ("SelectClauseElementSegment", "c is not null as c_notnull"),
            # Shorthand casting
            ("ExpressionSegment", "NULL::INT"),
            ("SelectClauseElementSegment", "NULL::INT AS user_id"),
            ("TruncateStatementSegment", "TRUNCATE TABLE test"),
            ("TruncateStatementSegment", "TRUNCATE test"),
        ],
    )
    def test__dialect__ansi_specific_segment_parses(
        segmentref, raw, caplog, dialect_specific_segment_parses
    ):
        """Test that specific segments parse as expected.
    
        NB: We're testing the PARSE function not the MATCH function
        although this will be a recursive parse and so the match
        function of SUBSECTIONS will be tested if present. The match
        function of the parent will not be tested.
        """
>       dialect_specific_segment_parses("ansi", segmentref, raw, caplog)

test/dialects/ansi_test.py:132: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

dialect = 'ansi', segmentref = 'SelectClauseElementSegment'
raw = '(count_18_24 * bits[OFFSET(0)]) / audience_size AS relative_abundance'
caplog = <_pytest.logging.LogCaptureFixture object at 0x7a1085415d90>

    def _dialect_specific_segment_parses(dialect, segmentref, raw, caplog):
        """Test that specific segments parse as expected.
    
        NB: We're testing the PARSE function not the MATCH function
        although this will be a recursive parse and so the match
        function of SUBSECTIONS will be tested if present. The match
        function of the parent will not be tested.
        """
        config = FluffConfig(overrides=dict(dialect=dialect))
        seg_list = lex(raw, config=config)
        Seg = validate_segment(segmentref, config=config)
    
        # This test is different if we're working with RawSegment
        # derivatives or not.
        if isinstance(Seg, StringParser) or issubclass(Seg, RawSegment):
            print("Raw/Parser route...")
            with RootParseContext.from_config(config) as ctx:
                with caplog.at_level(logging.DEBUG):
                    parsed = Seg.match(segments=seg_list, parse_context=ctx)
            assert isinstance(parsed, MatchResult)
            assert len(parsed.matched_segments) == 1
            print(parsed)
            parsed = parsed.matched_segments[0]
            print(parsed)
        else:
            print("Base route...")
            # Construct an unparsed segment
            seg = Seg(seg_list, pos_marker=seg_list[0].pos_marker)
            # Perform the match (THIS IS THE MEAT OF THE TEST)
            with RootParseContext.from_config(config) as ctx:
                with caplog.at_level(logging.DEBUG):
                    parsed = seg.parse(parse_context=ctx)
            print(parsed)
            assert isinstance(parsed, Seg)
    
        # Check we get a good response
        print(parsed)
        print(type(parsed))
        # print(type(parsed._reconstruct()))
        print(type(parsed.raw))
        # Check we're all there.
        assert parsed.raw == raw
        # Check that there's nothing un parsable
        typs = parsed.type_set()
>       assert "unparsable" not in typs
E       AssertionError: assert 'unparsable' not in {'raw', 'select_clause_element', 'unparsable', 'whitespace'}

test/dialects/conftest.py:89: AssertionError
----------------------------- Captured stdout call -----------------------------
(<CodeSegment: ([L:  1, P:  1]) '('>, <CodeSegment: ([L:  1, P:  2]) 'count_18_24'>, <WhitespaceSegment: ([L:  1, P: 13]) ' '>, <CodeSegment: ([L:  1, P: 14]) '*'>, <WhitespaceSegment: ([L:  1, P: 15]) ' '>, <CodeSegment: ([L:  1, P: 16]) 'bits'>, <CodeSegment: ([L:  1, P: 20]) '['>, <CodeSegment: ([L:  1, P: 21]) 'OFFSET'>, <CodeSegment: ([L:  1, P: 27]) '('>, <CodeSegment: ([L:  1, P: 28]) '0'>, <CodeSegment: ([L:  1, P: 29]) ')'>, <CodeSegment: ([L:  1, P: 30]) ']'>, <CodeSegment: ([L:  1, P: 31]) ')'>, <WhitespaceSegment: ([L:  1, P: 32]) ' '>, <CodeSegment: ([L:  1, P: 33]) '/'>, <WhitespaceSegment: ([L:  1, P: 34]) ' '>, <CodeSegment: ([L:  1, P: 35]) 'audience_size'>, <WhitespaceSegment: ([L:  1, P: 48]) ' '>, <CodeSegment: ([L:  1, P: 49]) 'AS'>, <WhitespaceSegment: ([L:  1, P: 51]) ' '>, <CodeSegment: ([L:  1, P: 52]) 'relative_abundance'>)
Base route...
<SelectClauseElementSegment: ([L:  1, P:  1])>
<SelectClauseElementSegment: ([L:  1, P:  1])>
<class 'sqlfluff.dialects.dialect_ansi.SelectClauseElementSegment'>
<class 'str'>
------------------------------ Captured log call -------------------------------
INFO     sqlfluff.parser:match_logging.py:28 [PD:0  MD:0 ]	SelectClauseElementSegment                        	OneOf.match PRN     	    	[ns=2, ps=0, ms=0, pruned=[], opts=[<Ref: WildcardExpressionSegment>, <Sequence: [<Ref: BaseExpressionElementGrammar>, <Ref: AliasExpressionSegment [opt]>]>]]
INFO     sqlfluff.parser:match_logging.py:28 [PD:0  MD:2 ]	..WildcardExpressionSegment                       	Seque.match OUT     	    	[match=<MatchResult 0/21: ''>, seg="'(count_18_24 * bits[...'"]
DEBUG    sqlfluff.parser:match_logging.py:30 [PD:0  MD:1 ]	.WildcardExpressionSegment                        	Wildc.match OUT     	    	[match=<MatchResult 0/21: ''>, seg="'(count_18_24 * bits[...'"]
DEBUG    sqlfluff.parser:match_logging.py:30 [PD:0  MD:1 ]	.SelectClauseElementSegment                       	Ref.match OUT       	    	[match=<MatchResult 0/21: ''>, seg="'(count_18_24 * bits[...'"]
INFO     sqlfluff.parser:match_logging.py:28 [PD:0  MD:1 ]	.SelectClauseElementSegment                       	Seque.match OUT     	    	[match=<MatchResult 0/21: ''>, seg="'(count_18_24 * bits[...'"]
INFO     sqlfluff.parser:match_logging.py:28 [PD:0  MD:0 ]	SelectClauseElementSegment                        	OneOf.match OUT     	    	[match=<MatchResult 0/21: ''>, seg="'(count_18_24 * bits[...'"]
DEBUG    sqlfluff.parser:base.py:859 SelectClauseElementSegment.parse: Done Parse. Plotting Recursion. Recurse=True
DEBUG    sqlfluff.parser:base.py:868 ###
#
# Beginning Parse Depth 1: SelectClauseElementSegment
#
###
Initial Structure:
[L:  1, P:  1]      |select_clause_element:
[L:  1, P:  1]      |    unparsable:                                               !! Expected: 'SelectClauseElementSegment'
[L:  1, P:  1]      |        raw:                                                  '('
[L:  1, P:  2]      |        raw:                                                  'count_18_24'
[L:  1, P: 13]      |        whitespace:                                           ' '
[L:  1, P: 14]      |        raw:                                                  '*'
[L:  1, P: 15]      |        whitespace:                                           ' '
[L:  1, P: 16]      |        raw:                                                  'bits'
[L:  1, P: 20]      |        raw:                                                  '['
[L:  1, P: 21]      |        raw:                                                  'OFFSET'
[L:  1, P: 27]      |        raw:                                                  '('
[L:  1, P: 28]      |        raw:                                                  '0'
[L:  1, P: 29]      |        raw:                                                  ')'
[L:  1, P: 30]      |        raw:                                                  ']'
[L:  1, P: 31]      |        raw:                                                  ')'
[L:  1, P: 32]      |        whitespace:                                           ' '
[L:  1, P: 33]      |        raw:                                                  '/'
[L:  1, P: 34]      |        whitespace:                                           ' '
[L:  1, P: 35]      |        raw:                                                  'audience_size'
[L:  1, P: 48]      |        whitespace:                                           ' '
[L:  1, P: 49]      |        raw:                                                  'AS'
[L:  1, P: 51]      |        whitespace:                                           ' '
[L:  1, P: 52]      |        raw:                                                  'relative_abundance'

INFO     sqlfluff.parser:base.py:251 [PD:1] Skipping expansion of <UnparsableSegment: ([L:  1, P:  1])>...
_ test__dialect__ansi_specific_segment_parses[SelectClauseElementSegment-(count_18_24 * bits[OFFSET(0)] + count_25_34) / audience_size AS relative_abundance] _

segmentref = 'SelectClauseElementSegment'
raw = '(count_18_24 * bits[OFFSET(0)] + count_25_34) / audience_size AS relative_abundance'
caplog = <_pytest.logging.LogCaptureFixture object at 0x7a1085373be0>
dialect_specific_segment_parses = <function _dialect_specific_segment_parses at 0x7a1085546dc0>

    @pytest.mark.parametrize(
        "segmentref,raw",
        [
            ("SelectKeywordSegment", "select"),
            ("NakedIdentifierSegment", "online_sales"),
            ("BareFunctionSegment", "current_timestamp"),
            ("FunctionSegment", "current_timestamp()"),
            ("NumericLiteralSegment", "1000.0"),
            ("ExpressionSegment", "online_sales / 1000.0"),
            ("IntervalExpressionSegment", "INTERVAL 1 YEAR"),
            ("ExpressionSegment", "CASE WHEN id = 1 THEN 'nothing' ELSE 'test' END"),
            # Nested Case Expressions
            # https://github.com/sqlfluff/sqlfluff/issues/172
            (
                "ExpressionSegment",
                (
                    "CASE WHEN id = 1 THEN CASE WHEN true THEN 'something' "
                    "ELSE 'nothing' END ELSE 'test' END"
                ),
            ),
            # Casting expressions
            # https://github.com/sqlfluff/sqlfluff/issues/161
            ("ExpressionSegment", "CAST(ROUND(online_sales / 1000.0) AS varchar)"),
            # Like expressions
            # https://github.com/sqlfluff/sqlfluff/issues/170
            ("ExpressionSegment", "name NOT LIKE '%y'"),
            # Functions with a space
            # https://github.com/sqlfluff/sqlfluff/issues/171
            ("SelectClauseElementSegment", "MIN (test.id) AS min_test_id"),
            # Interval literals
            # https://github.com/sqlfluff/sqlfluff/issues/148
            (
                "ExpressionSegment",
                "DATE_ADD(CURRENT_DATE('America/New_York'), INTERVAL 1 year)",
            ),
            # Array accessors
            ("ExpressionSegment", "my_array[1]"),
            ("ExpressionSegment", "my_array[OFFSET(1)]"),
            ("ExpressionSegment", "my_array[5:8]"),
            ("ExpressionSegment", "4 + my_array[OFFSET(1)]"),
            ("ExpressionSegment", "bits[OFFSET(0)] + 7"),
            (
                "SelectClauseElementSegment",
                (
                    "(count_18_24 * bits[OFFSET(0)])"
                    " / audience_size AS relative_abundance"
                ),
            ),
            ("ExpressionSegment", "count_18_24 * bits[OFFSET(0)] + count_25_34"),
            (
                "SelectClauseElementSegment",
                (
                    "(count_18_24 * bits[OFFSET(0)] + count_25_34)"
                    " / audience_size AS relative_abundance"
                ),
            ),
            # Dense math expressions
            # https://github.com/sqlfluff/sqlfluff/issues/178
            # https://github.com/sqlfluff/sqlfluff/issues/179
            ("SelectStatementSegment", "SELECT t.val/t.id FROM test WHERE id*1.0/id > 0.8"),
            ("SelectClauseElementSegment", "t.val/t.id"),
            # Issue with casting raise as part of PR #177
            ("SelectClauseElementSegment", "CAST(num AS INT64)"),
            # Casting as datatype with arguments
            ("SelectClauseElementSegment", "CAST(num AS numeric(8,4))"),
            # Wildcard field selection
            ("SelectClauseElementSegment", "a.*"),
            ("SelectClauseElementSegment", "a.b.*"),
            ("SelectClauseElementSegment", "a.b.c.*"),
            # Default Element Syntax
            ("ObjectReferenceSegment", "a..c.*"),
            # Negative Elements
            ("SelectClauseElementSegment", "-some_variable"),
            ("SelectClauseElementSegment", "- some_variable"),
            # Complex Functions
            (
                "ExpressionSegment",
                "concat(left(uaid, 2), '|', right(concat('0000000', SPLIT_PART(uaid, '|', 4)), 10), '|', '00000000')",
            ),
            # Notnull and Isnull
            ("ExpressionSegment", "c is null"),
            ("ExpressionSegment", "c is not null"),
            ("SelectClauseElementSegment", "c is null as c_isnull"),
            ("SelectClauseElementSegment", "c is not null as c_notnull"),
            # Shorthand casting
            ("ExpressionSegment", "NULL::INT"),
            ("SelectClauseElementSegment", "NULL::INT AS user_id"),
            ("TruncateStatementSegment", "TRUNCATE TABLE test"),
            ("TruncateStatementSegment", "TRUNCATE test"),
        ],
    )
    def test__dialect__ansi_specific_segment_parses(
        segmentref, raw, caplog, dialect_specific_segment_parses
    ):
        """Test that specific segments parse as expected.
    
        NB: We're testing the PARSE function not the MATCH function
        although this will be a recursive parse and so the match
        function of SUBSECTIONS will be tested if present. The match
        function of the parent will not be tested.
        """
>       dialect_specific_segment_parses("ansi", segmentref, raw, caplog)

test/dialects/ansi_test.py:132: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

dialect = 'ansi', segmentref = 'SelectClauseElementSegment'
raw = '(count_18_24 * bits[OFFSET(0)] + count_25_34) / audience_size AS relative_abundance'
caplog = <_pytest.logging.LogCaptureFixture object at 0x7a1085373be0>

    def _dialect_specific_segment_parses(dialect, segmentref, raw, caplog):
        """Test that specific segments parse as expected.
    
        NB: We're testing the PARSE function not the MATCH function
        although this will be a recursive parse and so the match
        function of SUBSECTIONS will be tested if present. The match
        function of the parent will not be tested.
        """
        config = FluffConfig(overrides=dict(dialect=dialect))
        seg_list = lex(raw, config=config)
        Seg = validate_segment(segmentref, config=config)
    
        # This test is different if we're working with RawSegment
        # derivatives or not.
        if isinstance(Seg, StringParser) or issubclass(Seg, RawSegment):
            print("Raw/Parser route...")
            with RootParseContext.from_config(config) as ctx:
                with caplog.at_level(logging.DEBUG):
                    parsed = Seg.match(segments=seg_list, parse_context=ctx)
            assert isinstance(parsed, MatchResult)
            assert len(parsed.matched_segments) == 1
            print(parsed)
            parsed = parsed.matched_segments[0]
            print(parsed)
        else:
            print("Base route...")
            # Construct an unparsed segment
            seg = Seg(seg_list, pos_marker=seg_list[0].pos_marker)
            # Perform the match (THIS IS THE MEAT OF THE TEST)
            with RootParseContext.from_config(config) as ctx:
                with caplog.at_level(logging.DEBUG):
                    parsed = seg.parse(parse_context=ctx)
            print(parsed)
            assert isinstance(parsed, Seg)
    
        # Check we get a good response
        print(parsed)
        print(type(parsed))
        # print(type(parsed._reconstruct()))
        print(type(parsed.raw))
        # Check we're all there.
        assert parsed.raw == raw
        # Check that there's nothing un parsable
        typs = parsed.type_set()
>       assert "unparsable" not in typs
E       AssertionError: assert 'unparsable' not in {'raw', 'select_clause_element', 'unparsable', 'whitespace'}

test/dialects/conftest.py:89: AssertionError
----------------------------- Captured stdout call -----------------------------
(<CodeSegment: ([L:  1, P:  1]) '('>, <CodeSegment: ([L:  1, P:  2]) 'count_18_24'>, <WhitespaceSegment: ([L:  1, P: 13]) ' '>, <CodeSegment: ([L:  1, P: 14]) '*'>, <WhitespaceSegment: ([L:  1, P: 15]) ' '>, <CodeSegment: ([L:  1, P: 16]) 'bits'>, <CodeSegment: ([L:  1, P: 20]) '['>, <CodeSegment: ([L:  1, P: 21]) 'OFFSET'>, <CodeSegment: ([L:  1, P: 27]) '('>, <CodeSegment: ([L:  1, P: 28]) '0'>, <CodeSegment: ([L:  1, P: 29]) ')'>, <CodeSegment: ([L:  1, P: 30]) ']'>, <WhitespaceSegment: ([L:  1, P: 31]) ' '>, <CodeSegment: ([L:  1, P: 32]) '+'>, <WhitespaceSegment: ([L:  1, P: 33]) ' '>, <CodeSegment: ([L:  1, P: 34]) 'count_25_34'>, <CodeSegment: ([L:  1, P: 45]) ')'>, <WhitespaceSegment: ([L:  1, P: 46]) ' '>, <CodeSegment: ([L:  1, P: 47]) '/'>, <WhitespaceSegment: ([L:  1, P: 48]) ' '>, <CodeSegment: ([L:  1, P: 49]) 'audience_size'>, <WhitespaceSegment: ([L:  1, P: 62]) ' '>, <CodeSegment: ([L:  1, P: 63]) 'AS'>, <WhitespaceSegment: ([L:  1, P: 65]) ' '>, <CodeSegment: ([L:  1, P: 66]) 'relative_abundance'>)
Base route...
<SelectClauseElementSegment: ([L:  1, P:  1])>
<SelectClauseElementSegment: ([L:  1, P:  1])>
<class 'sqlfluff.dialects.dialect_ansi.SelectClauseElementSegment'>
<class 'str'>
------------------------------ Captured log call -------------------------------
INFO     sqlfluff.parser:match_logging.py:28 [PD:0  MD:0 ]	SelectClauseElementSegment                        	OneOf.match PRN     	    	[ns=2, ps=0, ms=0, pruned=[], opts=[<Ref: WildcardExpressionSegment>, <Sequence: [<Ref: BaseExpressionElementGrammar>, <Ref: AliasExpressionSegment [opt]>]>]]
INFO     sqlfluff.parser:match_logging.py:28 [PD:0  MD:2 ]	..WildcardExpressionSegment                       	Seque.match OUT     	    	[match=<MatchResult 0/25: ''>, seg="'(count_18_24 * bits[...'"]
DEBUG    sqlfluff.parser:match_logging.py:30 [PD:0  MD:1 ]	.WildcardExpressionSegment                        	Wildc.match OUT     	    	[match=<MatchResult 0/25: ''>, seg="'(count_18_24 * bits[...'"]
DEBUG    sqlfluff.parser:match_logging.py:30 [PD:0  MD:1 ]	.SelectClauseElementSegment                       	Ref.match OUT       	    	[match=<MatchResult 0/25: ''>, seg="'(count_18_24 * bits[...'"]
INFO     sqlfluff.parser:match_logging.py:28 [PD:0  MD:1 ]	.SelectClauseElementSegment                       	Seque.match OUT     	    	[match=<MatchResult 0/25: ''>, seg="'(count_18_24 * bits[...'"]
INFO     sqlfluff.parser:match_logging.py:28 [PD:0  MD:0 ]	SelectClauseElementSegment                        	OneOf.match OUT     	    	[match=<MatchResult 0/25: ''>, seg="'(count_18_24 * bits[...'"]
DEBUG    sqlfluff.parser:base.py:859 SelectClauseElementSegment.parse: Done Parse. Plotting Recursion. Recurse=True
DEBUG    sqlfluff.parser:base.py:868 ###
#
# Beginning Parse Depth 1: SelectClauseElementSegment
#
###
Initial Structure:
[L:  1, P:  1]      |select_clause_element:
[L:  1, P:  1]      |    unparsable:                                               !! Expected: 'SelectClauseElementSegment'
[L:  1, P:  1]      |        raw:                                                  '('
[L:  1, P:  2]      |        raw:                                                  'count_18_24'
[L:  1, P: 13]      |        whitespace:                                           ' '
[L:  1, P: 14]      |        raw:                                                  '*'
[L:  1, P: 15]      |        whitespace:                                           ' '
[L:  1, P: 16]      |        raw:                                                  'bits'
[L:  1, P: 20]      |        raw:                                                  '['
[L:  1, P: 21]      |        raw:                                                  'OFFSET'
[L:  1, P: 27]      |        raw:                                                  '('
[L:  1, P: 28]      |        raw:                                                  '0'
[L:  1, P: 29]      |        raw:                                                  ')'
[L:  1, P: 30]      |        raw:                                                  ']'
[L:  1, P: 31]      |        whitespace:                                           ' '
[L:  1, P: 32]      |        raw:                                                  '+'
[L:  1, P: 33]      |        whitespace:                                           ' '
[L:  1, P: 34]      |        raw:                                                  'count_25_34'
[L:  1, P: 45]      |        raw:                                                  ')'
[L:  1, P: 46]      |        whitespace:                                           ' '
[L:  1, P: 47]      |        raw:                                                  '/'
[L:  1, P: 48]      |        whitespace:                                           ' '
[L:  1, P: 49]      |        raw:                                                  'audience_size'
[L:  1, P: 62]      |        whitespace:                                           ' '
[L:  1, P: 63]      |        raw:                                                  'AS'
[L:  1, P: 65]      |        whitespace:                                           ' '
[L:  1, P: 66]      |        raw:                                                  'relative_abundance'

INFO     sqlfluff.parser:base.py:251 [PD:1] Skipping expansion of <UnparsableSegment: ([L:  1, P:  1])>...
_ test__dialect__ansi_specific_segment_parses[SelectStatementSegment-SELECT t.val/t.id FROM test WHERE id*1.0/id > 0.8] _

segmentref = 'SelectStatementSegment'
raw = 'SELECT t.val/t.id FROM test WHERE id*1.0/id > 0.8'
caplog = <_pytest.logging.LogCaptureFixture object at 0x7a10853a53d0>
dialect_specific_segment_parses = <function _dialect_specific_segment_parses at 0x7a1085546dc0>

    @pytest.mark.parametrize(
        "segmentref,raw",
        [
            ("SelectKeywordSegment", "select"),
            ("NakedIdentifierSegment", "online_sales"),
            ("BareFunctionSegment", "current_timestamp"),
            ("FunctionSegment", "current_timestamp()"),
            ("NumericLiteralSegment", "1000.0"),
            ("ExpressionSegment", "online_sales / 1000.0"),
            ("IntervalExpressionSegment", "INTERVAL 1 YEAR"),
            ("ExpressionSegment", "CASE WHEN id = 1 THEN 'nothing' ELSE 'test' END"),
            # Nested Case Expressions
            # https://github.com/sqlfluff/sqlfluff/issues/172
            (
                "ExpressionSegment",
                (
                    "CASE WHEN id = 1 THEN CASE WHEN true THEN 'something' "
                    "ELSE 'nothing' END ELSE 'test' END"
                ),
            ),
            # Casting expressions
            # https://github.com/sqlfluff/sqlfluff/issues/161
            ("ExpressionSegment", "CAST(ROUND(online_sales / 1000.0) AS varchar)"),
            # Like expressions
            # https://github.com/sqlfluff/sqlfluff/issues/170
            ("ExpressionSegment", "name NOT LIKE '%y'"),
            # Functions with a space
            # https://github.com/sqlfluff/sqlfluff/issues/171
            ("SelectClauseElementSegment", "MIN (test.id) AS min_test_id"),
            # Interval literals
            # https://github.com/sqlfluff/sqlfluff/issues/148
            (
                "ExpressionSegment",
                "DATE_ADD(CURRENT_DATE('America/New_York'), INTERVAL 1 year)",
            ),
            # Array accessors
            ("ExpressionSegment", "my_array[1]"),
            ("ExpressionSegment", "my_array[OFFSET(1)]"),
            ("ExpressionSegment", "my_array[5:8]"),
            ("ExpressionSegment", "4 + my_array[OFFSET(1)]"),
            ("ExpressionSegment", "bits[OFFSET(0)] + 7"),
            (
                "SelectClauseElementSegment",
                (
                    "(count_18_24 * bits[OFFSET(0)])"
                    " / audience_size AS relative_abundance"
                ),
            ),
            ("ExpressionSegment", "count_18_24 * bits[OFFSET(0)] + count_25_34"),
            (
                "SelectClauseElementSegment",
                (
                    "(count_18_24 * bits[OFFSET(0)] + count_25_34)"
                    " / audience_size AS relative_abundance"
                ),
            ),
            # Dense math expressions
            # https://github.com/sqlfluff/sqlfluff/issues/178
            # https://github.com/sqlfluff/sqlfluff/issues/179
            ("SelectStatementSegment", "SELECT t.val/t.id FROM test WHERE id*1.0/id > 0.8"),
            ("SelectClauseElementSegment", "t.val/t.id"),
            # Issue with casting raise as part of PR #177
            ("SelectClauseElementSegment", "CAST(num AS INT64)"),
            # Casting as datatype with arguments
            ("SelectClauseElementSegment", "CAST(num AS numeric(8,4))"),
            # Wildcard field selection
            ("SelectClauseElementSegment", "a.*"),
            ("SelectClauseElementSegment", "a.b.*"),
            ("SelectClauseElementSegment", "a.b.c.*"),
            # Default Element Syntax
            ("ObjectReferenceSegment", "a..c.*"),
            # Negative Elements
            ("SelectClauseElementSegment", "-some_variable"),
            ("SelectClauseElementSegment", "- some_variable"),
            # Complex Functions
            (
                "ExpressionSegment",
                "concat(left(uaid, 2), '|', right(concat('0000000', SPLIT_PART(uaid, '|', 4)), 10), '|', '00000000')",
            ),
            # Notnull and Isnull
            ("ExpressionSegment", "c is null"),
            ("ExpressionSegment", "c is not null"),
            ("SelectClauseElementSegment", "c is null as c_isnull"),
            ("SelectClauseElementSegment", "c is not null as c_notnull"),
            # Shorthand casting
            ("ExpressionSegment", "NULL::INT"),
            ("SelectClauseElementSegment", "NULL::INT AS user_id"),
            ("TruncateStatementSegment", "TRUNCATE TABLE test"),
            ("TruncateStatementSegment", "TRUNCATE test"),
        ],
    )
    def test__dialect__ansi_specific_segment_parses(
        segmentref, raw, caplog, dialect_specific_segment_parses
    ):
        """Test that specific segments parse as expected.
    
        NB: We're testing the PARSE function not the MATCH function
        although this will be a recursive parse and so the match
        function of SUBSECTIONS will be tested if present. The match
        function of the parent will not be tested.
        """
>       dialect_specific_segment_parses("ansi", segmentref, raw, caplog)

test/dialects/ansi_test.py:132: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

dialect = 'ansi', segmentref = 'SelectStatementSegment'
raw = 'SELECT t.val/t.id FROM test WHERE id*1.0/id > 0.8'
caplog = <_pytest.logging.LogCaptureFixture object at 0x7a10853a53d0>

    def _dialect_specific_segment_parses(dialect, segmentref, raw, caplog):
        """Test that specific segments parse as expected.
    
        NB: We're testing the PARSE function not the MATCH function
        although this will be a recursive parse and so the match
        function of SUBSECTIONS will be tested if present. The match
        function of the parent will not be tested.
        """
        config = FluffConfig(overrides=dict(dialect=dialect))
        seg_list = lex(raw, config=config)
        Seg = validate_segment(segmentref, config=config)
    
        # This test is different if we're working with RawSegment
        # derivatives or not.
        if isinstance(Seg, StringParser) or issubclass(Seg, RawSegment):
            print("Raw/Parser route...")
            with RootParseContext.from_config(config) as ctx:
                with caplog.at_level(logging.DEBUG):
                    parsed = Seg.match(segments=seg_list, parse_context=ctx)
            assert isinstance(parsed, MatchResult)
            assert len(parsed.matched_segments) == 1
            print(parsed)
            parsed = parsed.matched_segments[0]
            print(parsed)
        else:
            print("Base route...")
            # Construct an unparsed segment
            seg = Seg(seg_list, pos_marker=seg_list[0].pos_marker)
            # Perform the match (THIS IS THE MEAT OF THE TEST)
            with RootParseContext.from_config(config) as ctx:
                with caplog.at_level(logging.DEBUG):
                    parsed = seg.parse(parse_context=ctx)
            print(parsed)
            assert isinstance(parsed, Seg)
    
        # Check we get a good response
        print(parsed)
        print(type(parsed))
        # print(type(parsed._reconstruct()))
        print(type(parsed.raw))
        # Check we're all there.
        assert parsed.raw == raw
        # Check that there's nothing un parsable
        typs = parsed.type_set()
>       assert "unparsable" not in typs
E       AssertionError: assert 'unparsable' not in {'raw', 'select_statement', 'unparsable', 'whitespace'}

test/dialects/conftest.py:89: AssertionError
----------------------------- Captured stdout call -----------------------------
(<CodeSegment: ([L:  1, P:  1]) 'SELECT'>, <WhitespaceSegment: ([L:  1, P:  7]) ' '>, <CodeSegment: ([L:  1, P:  8]) 't'>, <CodeSegment: ([L:  1, P:  9]) '.'>, <CodeSegment: ([L:  1, P: 10]) 'val'>, <CodeSegment: ([L:  1, P: 13]) '/'>, <CodeSegment: ([L:  1, P: 14]) 't'>, <CodeSegment: ([L:  1, P: 15]) '.'>, <CodeSegment: ([L:  1, P: 16]) 'id'>, <WhitespaceSegment: ([L:  1, P: 18]) ' '>, <CodeSegment: ([L:  1, P: 19]) 'FROM'>, <WhitespaceSegment: ([L:  1, P: 23]) ' '>, <CodeSegment: ([L:  1, P: 24]) 'test'>, <WhitespaceSegment: ([L:  1, P: 28]) ' '>, <CodeSegment: ([L:  1, P: 29]) 'WHERE'>, <WhitespaceSegment: ([L:  1, P: 34]) ' '>, <CodeSegment: ([L:  1, P: 35]) 'id'>, <CodeSegment: ([L:  1, P: 37]) '*'>, <CodeSegment: ([L:  1, P: 38]) '1.0'>, <CodeSegment: ([L:  1, P: 41]) '/'>, <CodeSegment: ([L:  1, P: 42]) 'id'>, <WhitespaceSegment: ([L:  1, P: 44]) ' '>, <CodeSegment: ([L:  1, P: 45]) '>'>, <WhitespaceSegment: ([L:  1, P: 46]) ' '>, <CodeSegment: ([L:  1, P: 47]) '0.8'>)
Base route...
<SelectStatementSegment: ([L:  1, P:  1])>
<SelectStatementSegment: ([L:  1, P:  1])>
<class 'sqlfluff.dialects.dialect_ansi.SelectStatementSegment'>
<class 'str'>
------------------------------ Captured log call -------------------------------
INFO     sqlfluff.parser:match_logging.py:28 [PD:0  MD:0 ]	SelectStatementSegment                            	Seque.match OUT     	    	[match=<MatchResult 0/25: ''>, seg="'SELECT t.val/t.id FR...'"]
DEBUG    sqlfluff.parser:base.py:859 SelectStatementSegment.parse: Done Parse. Plotting Recursion. Recurse=True
DEBUG    sqlfluff.parser:base.py:868 ###
#
# Beginning Parse Depth 1: SelectStatementSegment
#
###
Initial Structure:
[L:  1, P:  1]      |select_statement:
[L:  1, P:  1]      |    unparsable:                                               !! Expected: 'SelectStatementSegment'
[L:  1, P:  1]      |        raw:                                                  'SELECT'
[L:  1, P:  7]      |        whitespace:                                           ' '
[L:  1, P:  8]      |        raw:                                                  't'
[L:  1, P:  9]      |        raw:                                                  '.'
[L:  1, P: 10]      |        raw:                                                  'val'
[L:  1, P: 13]      |        raw:                                                  '/'
[L:  1, P: 14]      |        raw:                                                  't'
[L:  1, P: 15]      |        raw:                                                  '.'
[L:  1, P: 16]      |        raw:                                                  'id'
[L:  1, P: 18]      |        whitespace:                                           ' '
[L:  1, P: 19]      |        raw:                                                  'FROM'
[L:  1, P: 23]      |        whitespace:                                           ' '
[L:  1, P: 24]      |        raw:                                                  'test'
[L:  1, P: 28]      |        whitespace:                                           ' '
[L:  1, P: 29]      |        raw:                                                  'WHERE'
[L:  1, P: 34]      |        whitespace:                                           ' '
[L:  1, P: 35]      |        raw:                                                  'id'
[L:  1, P: 37]      |        raw:                                                  '*'
[L:  1, P: 38]      |        raw:                                                  '1.0'
[L:  1, P: 41]      |        raw:                                                  '/'
[L:  1, P: 42]      |        raw:                                                  'id'
[L:  1, P: 44]      |        whitespace:                                           ' '
[L:  1, P: 45]      |        raw:                                                  '>'
[L:  1, P: 46]      |        whitespace:                                           ' '
[L:  1, P: 47]      |        raw:                                                  '0.8'

INFO     sqlfluff.parser:base.py:251 [PD:1] Skipping expansion of <UnparsableSegment: ([L:  1, P:  1])>...
_ test__dialect__ansi_specific_segment_parses[SelectClauseElementSegment-t.val/t.id] _

segmentref = 'SelectClauseElementSegment', raw = 't.val/t.id'
caplog = <_pytest.logging.LogCaptureFixture object at 0x7a10854a3f40>
dialect_specific_segment_parses = <function _dialect_specific_segment_parses at 0x7a1085546dc0>

    @pytest.mark.parametrize(
        "segmentref,raw",
        [
            ("SelectKeywordSegment", "select"),
            ("NakedIdentifierSegment", "online_sales"),
            ("BareFunctionSegment", "current_timestamp"),
            ("FunctionSegment", "current_timestamp()"),
            ("NumericLiteralSegment", "1000.0"),
            ("ExpressionSegment", "online_sales / 1000.0"),
            ("IntervalExpressionSegment", "INTERVAL 1 YEAR"),
            ("ExpressionSegment", "CASE WHEN id = 1 THEN 'nothing' ELSE 'test' END"),
            # Nested Case Expressions
            # https://github.com/sqlfluff/sqlfluff/issues/172
            (
                "ExpressionSegment",
                (
                    "CASE WHEN id = 1 THEN CASE WHEN true THEN 'something' "
                    "ELSE 'nothing' END ELSE 'test' END"
                ),
            ),
            # Casting expressions
            # https://github.com/sqlfluff/sqlfluff/issues/161
            ("ExpressionSegment", "CAST(ROUND(online_sales / 1000.0) AS varchar)"),
            # Like expressions
            # https://github.com/sqlfluff/sqlfluff/issues/170
            ("ExpressionSegment", "name NOT LIKE '%y'"),
            # Functions with a space
            # https://github.com/sqlfluff/sqlfluff/issues/171
            ("SelectClauseElementSegment", "MIN (test.id) AS min_test_id"),
            # Interval literals
            # https://github.com/sqlfluff/sqlfluff/issues/148
            (
                "ExpressionSegment",
                "DATE_ADD(CURRENT_DATE('America/New_York'), INTERVAL 1 year)",
            ),
            # Array accessors
            ("ExpressionSegment", "my_array[1]"),
            ("ExpressionSegment", "my_array[OFFSET(1)]"),
            ("ExpressionSegment", "my_array[5:8]"),
            ("ExpressionSegment", "4 + my_array[OFFSET(1)]"),
            ("ExpressionSegment", "bits[OFFSET(0)] + 7"),
            (
                "SelectClauseElementSegment",
                (
                    "(count_18_24 * bits[OFFSET(0)])"
                    " / audience_size AS relative_abundance"
                ),
            ),
            ("ExpressionSegment", "count_18_24 * bits[OFFSET(0)] + count_25_34"),
            (
                "SelectClauseElementSegment",
                (
                    "(count_18_24 * bits[OFFSET(0)] + count_25_34)"
                    " / audience_size AS relative_abundance"
                ),
            ),
            # Dense math expressions
            # https://github.com/sqlfluff/sqlfluff/issues/178
            # https://github.com/sqlfluff/sqlfluff/issues/179
            ("SelectStatementSegment", "SELECT t.val/t.id FROM test WHERE id*1.0/id > 0.8"),
            ("SelectClauseElementSegment", "t.val/t.id"),
            # Issue with casting raise as part of PR #177
            ("SelectClauseElementSegment", "CAST(num AS INT64)"),
            # Casting as datatype with arguments
            ("SelectClauseElementSegment", "CAST(num AS numeric(8,4))"),
            # Wildcard field selection
            ("SelectClauseElementSegment", "a.*"),
            ("SelectClauseElementSegment", "a.b.*"),
            ("SelectClauseElementSegment", "a.b.c.*"),
            # Default Element Syntax
            ("ObjectReferenceSegment", "a..c.*"),
            # Negative Elements
            ("SelectClauseElementSegment", "-some_variable"),
            ("SelectClauseElementSegment", "- some_variable"),
            # Complex Functions
            (
                "ExpressionSegment",
                "concat(left(uaid, 2), '|', right(concat('0000000', SPLIT_PART(uaid, '|', 4)), 10), '|', '00000000')",
            ),
            # Notnull and Isnull
            ("ExpressionSegment", "c is null"),
            ("ExpressionSegment", "c is not null"),
            ("SelectClauseElementSegment", "c is null as c_isnull"),
            ("SelectClauseElementSegment", "c is not null as c_notnull"),
            # Shorthand casting
            ("ExpressionSegment", "NULL::INT"),
            ("SelectClauseElementSegment", "NULL::INT AS user_id"),
            ("TruncateStatementSegment", "TRUNCATE TABLE test"),
            ("TruncateStatementSegment", "TRUNCATE test"),
        ],
    )
    def test__dialect__ansi_specific_segment_parses(
        segmentref, raw, caplog, dialect_specific_segment_parses
    ):
        """Test that specific segments parse as expected.
    
        NB: We're testing the PARSE function not the MATCH function
        although this will be a recursive parse and so the match
        function of SUBSECTIONS will be tested if present. The match
        function of the parent will not be tested.
        """
>       dialect_specific_segment_parses("ansi", segmentref, raw, caplog)

test/dialects/ansi_test.py:132: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

dialect = 'ansi', segmentref = 'SelectClauseElementSegment', raw = 't.val/t.id'
caplog = <_pytest.logging.LogCaptureFixture object at 0x7a10854a3f40>

    def _dialect_specific_segment_parses(dialect, segmentref, raw, caplog):
        """Test that specific segments parse as expected.
    
        NB: We're testing the PARSE function not the MATCH function
        although this will be a recursive parse and so the match
        function of SUBSECTIONS will be tested if present. The match
        function of the parent will not be tested.
        """
        config = FluffConfig(overrides=dict(dialect=dialect))
        seg_list = lex(raw, config=config)
        Seg = validate_segment(segmentref, config=config)
    
        # This test is different if we're working with RawSegment
        # derivatives or not.
        if isinstance(Seg, StringParser) or issubclass(Seg, RawSegment):
            print("Raw/Parser route...")
            with RootParseContext.from_config(config) as ctx:
                with caplog.at_level(logging.DEBUG):
                    parsed = Seg.match(segments=seg_list, parse_context=ctx)
            assert isinstance(parsed, MatchResult)
            assert len(parsed.matched_segments) == 1
            print(parsed)
            parsed = parsed.matched_segments[0]
            print(parsed)
        else:
            print("Base route...")
            # Construct an unparsed segment
            seg = Seg(seg_list, pos_marker=seg_list[0].pos_marker)
            # Perform the match (THIS IS THE MEAT OF THE TEST)
            with RootParseContext.from_config(config) as ctx:
                with caplog.at_level(logging.DEBUG):
                    parsed = seg.parse(parse_context=ctx)
            print(parsed)
            assert isinstance(parsed, Seg)
    
        # Check we get a good response
        print(parsed)
        print(type(parsed))
        # print(type(parsed._reconstruct()))
        print(type(parsed.raw))
        # Check we're all there.
        assert parsed.raw == raw
        # Check that there's nothing un parsable
        typs = parsed.type_set()
>       assert "unparsable" not in typs
E       AssertionError: assert 'unparsable' not in {'raw', 'select_clause_element', 'unparsable'}

test/dialects/conftest.py:89: AssertionError
----------------------------- Captured stdout call -----------------------------
(<CodeSegment: ([L:  1, P:  1]) 't'>, <CodeSegment: ([L:  1, P:  2]) '.'>, <CodeSegment: ([L:  1, P:  3]) 'val'>, <CodeSegment: ([L:  1, P:  6]) '/'>, <CodeSegment: ([L:  1, P:  7]) 't'>, <CodeSegment: ([L:  1, P:  8]) '.'>, <CodeSegment: ([L:  1, P:  9]) 'id'>)
Base route...
<SelectClauseElementSegment: ([L:  1, P:  1])>
<SelectClauseElementSegment: ([L:  1, P:  1])>
<class 'sqlfluff.dialects.dialect_ansi.SelectClauseElementSegment'>
<class 'str'>
------------------------------ Captured log call -------------------------------
INFO     sqlfluff.parser:match_logging.py:28 [PD:0  MD:0 ]	SelectClauseElementSegment                        	OneOf.match PRN     	    	[ns=2, ps=0, ms=0, pruned=[], opts=[<Ref: WildcardExpressionSegment>, <Sequence: [<Ref: BaseExpressionElementGrammar>, <Ref: AliasExpressionSegment [opt]>]>]]
INFO     sqlfluff.parser:match_logging.py:28 [PD:0  MD:2 ]	..WildcardExpressionSegment                       	Seque.match OUT     	    	[match=<MatchResult 0/7: ''>, seg="'t.val/t.id'"]
DEBUG    sqlfluff.parser:match_logging.py:30 [PD:0  MD:1 ]	.WildcardExpressionSegment                        	Wildc.match OUT     	    	[match=<MatchResult 0/7: ''>, seg="'t.val/t.id'"]
DEBUG    sqlfluff.parser:match_logging.py:30 [PD:0  MD:1 ]	.SelectClauseElementSegment                       	Ref.match OUT       	    	[match=<MatchResult 0/7: ''>, seg="'t.val/t.id'"]
INFO     sqlfluff.parser:match_logging.py:28 [PD:0  MD:1 ]	.SelectClauseElementSegment                       	Seque.match OUT     	    	[match=<MatchResult 0/7: ''>, seg="'t.val/t.id'"]
INFO     sqlfluff.parser:match_logging.py:28 [PD:0  MD:0 ]	SelectClauseElementSegment                        	OneOf.match OUT     	    	[match=<MatchResult 0/7: ''>, seg="'t.val/t.id'"]
DEBUG    sqlfluff.parser:base.py:859 SelectClauseElementSegment.parse: Done Parse. Plotting Recursion. Recurse=True
DEBUG    sqlfluff.parser:base.py:868 ###
#
# Beginning Parse Depth 1: SelectClauseElementSegment
#
###
Initial Structure:
[L:  1, P:  1]      |select_clause_element:
[L:  1, P:  1]      |    unparsable:                                               !! Expected: 'SelectClauseElementSegment'
[L:  1, P:  1]      |        raw:                                                  't'
[L:  1, P:  2]      |        raw:                                                  '.'
[L:  1, P:  3]      |        raw:                                                  'val'
[L:  1, P:  6]      |        raw:                                                  '/'
[L:  1, P:  7]      |        raw:                                                  't'
[L:  1, P:  8]      |        raw:                                                  '.'
[L:  1, P:  9]      |        raw:                                                  'id'

INFO     sqlfluff.parser:base.py:251 [PD:1] Skipping expansion of <UnparsableSegment: ([L:  1, P:  1])>...
_ test__dialect__ansi_specific_segment_parses[SelectClauseElementSegment-CAST(num AS INT64)] _

segmentref = 'SelectClauseElementSegment', raw = 'CAST(num AS INT64)'
caplog = <_pytest.logging.LogCaptureFixture object at 0x7a108538aeb0>
dialect_specific_segment_parses = <function _dialect_specific_segment_parses at 0x7a1085546dc0>

    @pytest.mark.parametrize(
        "segmentref,raw",
        [
            ("SelectKeywordSegment", "select"),
            ("NakedIdentifierSegment", "online_sales"),
            ("BareFunctionSegment", "current_timestamp"),
            ("FunctionSegment", "current_timestamp()"),
            ("NumericLiteralSegment", "1000.0"),
            ("ExpressionSegment", "online_sales / 1000.0"),
            ("IntervalExpressionSegment", "INTERVAL 1 YEAR"),
            ("ExpressionSegment", "CASE WHEN id = 1 THEN 'nothing' ELSE 'test' END"),
            # Nested Case Expressions
            # https://github.com/sqlfluff/sqlfluff/issues/172
            (
                "ExpressionSegment",
                (
                    "CASE WHEN id = 1 THEN CASE WHEN true THEN 'something' "
                    "ELSE 'nothing' END ELSE 'test' END"
                ),
            ),
            # Casting expressions
            # https://github.com/sqlfluff/sqlfluff/issues/161
            ("ExpressionSegment", "CAST(ROUND(online_sales / 1000.0) AS varchar)"),
            # Like expressions
            # https://github.com/sqlfluff/sqlfluff/issues/170
            ("ExpressionSegment", "name NOT LIKE '%y'"),
            # Functions with a space
            # https://github.com/sqlfluff/sqlfluff/issues/171
            ("SelectClauseElementSegment", "MIN (test.id) AS min_test_id"),
            # Interval literals
            # https://github.com/sqlfluff/sqlfluff/issues/148
            (
                "ExpressionSegment",
                "DATE_ADD(CURRENT_DATE('America/New_York'), INTERVAL 1 year)",
            ),
            # Array accessors
            ("ExpressionSegment", "my_array[1]"),
            ("ExpressionSegment", "my_array[OFFSET(1)]"),
            ("ExpressionSegment", "my_array[5:8]"),
            ("ExpressionSegment", "4 + my_array[OFFSET(1)]"),
            ("ExpressionSegment", "bits[OFFSET(0)] + 7"),
            (
                "SelectClauseElementSegment",
                (
                    "(count_18_24 * bits[OFFSET(0)])"
                    " / audience_size AS relative_abundance"
                ),
            ),
            ("ExpressionSegment", "count_18_24 * bits[OFFSET(0)] + count_25_34"),
            (
                "SelectClauseElementSegment",
                (
                    "(count_18_24 * bits[OFFSET(0)] + count_25_34)"
                    " / audience_size AS relative_abundance"
                ),
            ),
            # Dense math expressions
            # https://github.com/sqlfluff/sqlfluff/issues/178
            # https://github.com/sqlfluff/sqlfluff/issues/179
            ("SelectStatementSegment", "SELECT t.val/t.id FROM test WHERE id*1.0/id > 0.8"),
            ("SelectClauseElementSegment", "t.val/t.id"),
            # Issue with casting raise as part of PR #177
            ("SelectClauseElementSegment", "CAST(num AS INT64)"),
            # Casting as datatype with arguments
            ("SelectClauseElementSegment", "CAST(num AS numeric(8,4))"),
            # Wildcard field selection
            ("SelectClauseElementSegment", "a.*"),
            ("SelectClauseElementSegment", "a.b.*"),
            ("SelectClauseElementSegment", "a.b.c.*"),
            # Default Element Syntax
            ("ObjectReferenceSegment", "a..c.*"),
            # Negative Elements
            ("SelectClauseElementSegment", "-some_variable"),
            ("SelectClauseElementSegment", "- some_variable"),
            # Complex Functions
            (
                "ExpressionSegment",
                "concat(left(uaid, 2), '|', right(concat('0000000', SPLIT_PART(uaid, '|', 4)), 10), '|', '00000000')",
            ),
            # Notnull and Isnull
            ("ExpressionSegment", "c is null"),
            ("ExpressionSegment", "c is not null"),
            ("SelectClauseElementSegment", "c is null as c_isnull"),
            ("SelectClauseElementSegment", "c is not null as c_notnull"),
            # Shorthand casting
            ("ExpressionSegment", "NULL::INT"),
            ("SelectClauseElementSegment", "NULL::INT AS user_id"),
            ("TruncateStatementSegment", "TRUNCATE TABLE test"),
            ("TruncateStatementSegment", "TRUNCATE test"),
        ],
    )
    def test__dialect__ansi_specific_segment_parses(
        segmentref, raw, caplog, dialect_specific_segment_parses
    ):
        """Test that specific segments parse as expected.
    
        NB: We're testing the PARSE function not the MATCH function
        although this will be a recursive parse and so the match
        function of SUBSECTIONS will be tested if present. The match
        function of the parent will not be tested.
        """
>       dialect_specific_segment_parses("ansi", segmentref, raw, caplog)

test/dialects/ansi_test.py:132: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

dialect = 'ansi', segmentref = 'SelectClauseElementSegment'
raw = 'CAST(num AS INT64)'
caplog = <_pytest.logging.LogCaptureFixture object at 0x7a108538aeb0>

    def _dialect_specific_segment_parses(dialect, segmentref, raw, caplog):
        """Test that specific segments parse as expected.
    
        NB: We're testing the PARSE function not the MATCH function
        although this will be a recursive parse and so the match
        function of SUBSECTIONS will be tested if present. The match
        function of the parent will not be tested.
        """
        config = FluffConfig(overrides=dict(dialect=dialect))
        seg_list = lex(raw, config=config)
        Seg = validate_segment(segmentref, config=config)
    
        # This test is different if we're working with RawSegment
        # derivatives or not.
        if isinstance(Seg, StringParser) or issubclass(Seg, RawSegment):
            print("Raw/Parser route...")
            with RootParseContext.from_config(config) as ctx:
                with caplog.at_level(logging.DEBUG):
                    parsed = Seg.match(segments=seg_list, parse_context=ctx)
            assert isinstance(parsed, MatchResult)
            assert len(parsed.matched_segments) == 1
            print(parsed)
            parsed = parsed.matched_segments[0]
            print(parsed)
        else:
            print("Base route...")
            # Construct an unparsed segment
            seg = Seg(seg_list, pos_marker=seg_list[0].pos_marker)
            # Perform the match (THIS IS THE MEAT OF THE TEST)
            with RootParseContext.from_config(config) as ctx:
                with caplog.at_level(logging.DEBUG):
                    parsed = seg.parse(parse_context=ctx)
            print(parsed)
            assert isinstance(parsed, Seg)
    
        # Check we get a good response
        print(parsed)
        print(type(parsed))
        # print(type(parsed._reconstruct()))
        print(type(parsed.raw))
        # Check we're all there.
        assert parsed.raw == raw
        # Check that there's nothing un parsable
        typs = parsed.type_set()
>       assert "unparsable" not in typs
E       AssertionError: assert 'unparsable' not in {'raw', 'select_clause_element', 'unparsable', 'whitespace'}

test/dialects/conftest.py:89: AssertionError
----------------------------- Captured stdout call -----------------------------
(<CodeSegment: ([L:  1, P:  1]) 'CAST'>, <CodeSegment: ([L:  1, P:  5]) '('>, <CodeSegment: ([L:  1, P:  6]) 'num'>, <WhitespaceSegment: ([L:  1, P:  9]) ' '>, <CodeSegment: ([L:  1, P: 10]) 'AS'>, <WhitespaceSegment: ([L:  1, P: 12]) ' '>, <CodeSegment: ([L:  1, P: 13]) 'INT64'>, <CodeSegment: ([L:  1, P: 18]) ')'>)
Base route...
<SelectClauseElementSegment: ([L:  1, P:  1])>
<SelectClauseElementSegment: ([L:  1, P:  1])>
<class 'sqlfluff.dialects.dialect_ansi.SelectClauseElementSegment'>
<class 'str'>
------------------------------ Captured log call -------------------------------
INFO     sqlfluff.parser:match_logging.py:28 [PD:0  MD:0 ]	SelectClauseElementSegment                        	OneOf.match PRN     	    	[ns=2, ps=0, ms=0, pruned=[], opts=[<Ref: WildcardExpressionSegment>, <Sequence: [<Ref: BaseExpressionElementGrammar>, <Ref: AliasExpressionSegment [opt]>]>]]
INFO     sqlfluff.parser:match_logging.py:28 [PD:0  MD:2 ]	..WildcardExpressionSegment                       	Seque.match OUT     	    	[match=<MatchResult 0/8: ''>, seg="'CAST(num AS INT64)'"]
DEBUG    sqlfluff.parser:match_logging.py:30 [PD:0  MD:1 ]	.WildcardExpressionSegment                        	Wildc.match OUT     	    	[match=<MatchResult 0/8: ''>, seg="'CAST(num AS INT64)'"]
DEBUG    sqlfluff.parser:match_logging.py:30 [PD:0  MD:1 ]	.SelectClauseElementSegment                       	Ref.match OUT       	    	[match=<MatchResult 0/8: ''>, seg="'CAST(num AS INT64)'"]
INFO     sqlfluff.parser:match_logging.py:28 [PD:0  MD:1 ]	.SelectClauseElementSegment                       	Seque.match OUT     	    	[match=<MatchResult 0/8: ''>, seg="'CAST(num AS INT64)'"]
INFO     sqlfluff.parser:match_logging.py:28 [PD:0  MD:0 ]	SelectClauseElementSegment                        	OneOf.match OUT     	    	[match=<MatchResult 0/8: ''>, seg="'CAST(num AS INT64)'"]
DEBUG    sqlfluff.parser:base.py:859 SelectClauseElementSegment.parse: Done Parse. Plotting Recursion. Recurse=True
DEBUG    sqlfluff.parser:base.py:868 ###
#
# Beginning Parse Depth 1: SelectClauseElementSegment
#
###
Initial Structure:
[L:  1, P:  1]      |select_clause_element:
[L:  1, P:  1]      |    unparsable:                                               !! Expected: 'SelectClauseElementSegment'
[L:  1, P:  1]      |        raw:                                                  'CAST'
[L:  1, P:  5]      |        raw:                                                  '('
[L:  1, P:  6]      |        raw:                                                  'num'
[L:  1, P:  9]      |        whitespace:                                           ' '
[L:  1, P: 10]      |        raw:                                                  'AS'
[L:  1, P: 12]      |        whitespace:                                           ' '
[L:  1, P: 13]      |        raw:                                                  'INT64'
[L:  1, P: 18]      |        raw:                                                  ')'

INFO     sqlfluff.parser:base.py:251 [PD:1] Skipping expansion of <UnparsableSegment: ([L:  1, P:  1])>...
_ test__dialect__ansi_specific_segment_parses[SelectClauseElementSegment-CAST(num AS numeric(8,4))] _

segmentref = 'SelectClauseElementSegment', raw = 'CAST(num AS numeric(8,4))'
caplog = <_pytest.logging.LogCaptureFixture object at 0x7a108595da30>
dialect_specific_segment_parses = <function _dialect_specific_segment_parses at 0x7a1085546dc0>

    @pytest.mark.parametrize(
        "segmentref,raw",
        [
            ("SelectKeywordSegment", "select"),
            ("NakedIdentifierSegment", "online_sales"),
            ("BareFunctionSegment", "current_timestamp"),
            ("FunctionSegment", "current_timestamp()"),
            ("NumericLiteralSegment", "1000.0"),
            ("ExpressionSegment", "online_sales / 1000.0"),
            ("IntervalExpressionSegment", "INTERVAL 1 YEAR"),
            ("ExpressionSegment", "CASE WHEN id = 1 THEN 'nothing' ELSE 'test' END"),
            # Nested Case Expressions
            # https://github.com/sqlfluff/sqlfluff/issues/172
            (
                "ExpressionSegment",
                (
                    "CASE WHEN id = 1 THEN CASE WHEN true THEN 'something' "
                    "ELSE 'nothing' END ELSE 'test' END"
                ),
            ),
            # Casting expressions
            # https://github.com/sqlfluff/sqlfluff/issues/161
            ("ExpressionSegment", "CAST(ROUND(online_sales / 1000.0) AS varchar)"),
            # Like expressions
            # https://github.com/sqlfluff/sqlfluff/issues/170
            ("ExpressionSegment", "name NOT LIKE '%y'"),
            # Functions with a space
            # https://github.com/sqlfluff/sqlfluff/issues/171
            ("SelectClauseElementSegment", "MIN (test.id) AS min_test_id"),
            # Interval literals
            # https://github.com/sqlfluff/sqlfluff/issues/148
            (
                "ExpressionSegment",
                "DATE_ADD(CURRENT_DATE('America/New_York'), INTERVAL 1 year)",
            ),
            # Array accessors
            ("ExpressionSegment", "my_array[1]"),
            ("ExpressionSegment", "my_array[OFFSET(1)]"),
            ("ExpressionSegment", "my_array[5:8]"),
            ("ExpressionSegment", "4 + my_array[OFFSET(1)]"),
            ("ExpressionSegment", "bits[OFFSET(0)] + 7"),
            (
                "SelectClauseElementSegment",
                (
                    "(count_18_24 * bits[OFFSET(0)])"
                    " / audience_size AS relative_abundance"
                ),
            ),
            ("ExpressionSegment", "count_18_24 * bits[OFFSET(0)] + count_25_34"),
            (
                "SelectClauseElementSegment",
                (
                    "(count_18_24 * bits[OFFSET(0)] + count_25_34)"
                    " / audience_size AS relative_abundance"
                ),
            ),
            # Dense math expressions
            # https://github.com/sqlfluff/sqlfluff/issues/178
            # https://github.com/sqlfluff/sqlfluff/issues/179
            ("SelectStatementSegment", "SELECT t.val/t.id FROM test WHERE id*1.0/id > 0.8"),
            ("SelectClauseElementSegment", "t.val/t.id"),
            # Issue with casting raise as part of PR #177
            ("SelectClauseElementSegment", "CAST(num AS INT64)"),
            # Casting as datatype with arguments
            ("SelectClauseElementSegment", "CAST(num AS numeric(8,4))"),
            # Wildcard field selection
            ("SelectClauseElementSegment", "a.*"),
            ("SelectClauseElementSegment", "a.b.*"),
            ("SelectClauseElementSegment", "a.b.c.*"),
            # Default Element Syntax
            ("ObjectReferenceSegment", "a..c.*"),
            # Negative Elements
            ("SelectClauseElementSegment", "-some_variable"),
            ("SelectClauseElementSegment", "- some_variable"),
            # Complex Functions
            (
                "ExpressionSegment",
                "concat(left(uaid, 2), '|', right(concat('0000000', SPLIT_PART(uaid, '|', 4)), 10), '|', '00000000')",
            ),
            # Notnull and Isnull
            ("ExpressionSegment", "c is null"),
            ("ExpressionSegment", "c is not null"),
            ("SelectClauseElementSegment", "c is null as c_isnull"),
            ("SelectClauseElementSegment", "c is not null as c_notnull"),
            # Shorthand casting
            ("ExpressionSegment", "NULL::INT"),
            ("SelectClauseElementSegment", "NULL::INT AS user_id"),
            ("TruncateStatementSegment", "TRUNCATE TABLE test"),
            ("TruncateStatementSegment", "TRUNCATE test"),
        ],
    )
    def test__dialect__ansi_specific_segment_parses(
        segmentref, raw, caplog, dialect_specific_segment_parses
    ):
        """Test that specific segments parse as expected.
    
        NB: We're testing the PARSE function not the MATCH function
        although this will be a recursive parse and so the match
        function of SUBSECTIONS will be tested if present. The match
        function of the parent will not be tested.
        """
>       dialect_specific_segment_parses("ansi", segmentref, raw, caplog)

test/dialects/ansi_test.py:132: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

dialect = 'ansi', segmentref = 'SelectClauseElementSegment'
raw = 'CAST(num AS numeric(8,4))'
caplog = <_pytest.logging.LogCaptureFixture object at 0x7a108595da30>

    def _dialect_specific_segment_parses(dialect, segmentref, raw, caplog):
        """Test that specific segments parse as expected.
    
        NB: We're testing the PARSE function not the MATCH function
        although this will be a recursive parse and so the match
        function of SUBSECTIONS will be tested if present. The match
        function of the parent will not be tested.
        """
        config = FluffConfig(overrides=dict(dialect=dialect))
        seg_list = lex(raw, config=config)
        Seg = validate_segment(segmentref, config=config)
    
        # This test is different if we're working with RawSegment
        # derivatives or not.
        if isinstance(Seg, StringParser) or issubclass(Seg, RawSegment):
            print("Raw/Parser route...")
            with RootParseContext.from_config(config) as ctx:
                with caplog.at_level(logging.DEBUG):
                    parsed = Seg.match(segments=seg_list, parse_context=ctx)
            assert isinstance(parsed, MatchResult)
            assert len(parsed.matched_segments) == 1
            print(parsed)
            parsed = parsed.matched_segments[0]
            print(parsed)
        else:
            print("Base route...")
            # Construct an unparsed segment
            seg = Seg(seg_list, pos_marker=seg_list[0].pos_marker)
            # Perform the match (THIS IS THE MEAT OF THE TEST)
            with RootParseContext.from_config(config) as ctx:
                with caplog.at_level(logging.DEBUG):
                    parsed = seg.parse(parse_context=ctx)
            print(parsed)
            assert isinstance(parsed, Seg)
    
        # Check we get a good response
        print(parsed)
        print(type(parsed))
        # print(type(parsed._reconstruct()))
        print(type(parsed.raw))
        # Check we're all there.
        assert parsed.raw == raw
        # Check that there's nothing un parsable
        typs = parsed.type_set()
>       assert "unparsable" not in typs
E       AssertionError: assert 'unparsable' not in {'raw', 'select_clause_element', 'unparsable', 'whitespace'}

test/dialects/conftest.py:89: AssertionError
----------------------------- Captured stdout call -----------------------------
(<CodeSegment: ([L:  1, P:  1]) 'CAST'>, <CodeSegment: ([L:  1, P:  5]) '('>, <CodeSegment: ([L:  1, P:  6]) 'num'>, <WhitespaceSegment: ([L:  1, P:  9]) ' '>, <CodeSegment: ([L:  1, P: 10]) 'AS'>, <WhitespaceSegment: ([L:  1, P: 12]) ' '>, <CodeSegment: ([L:  1, P: 13]) 'numeric'>, <CodeSegment: ([L:  1, P: 20]) '('>, <CodeSegment: ([L:  1, P: 21]) '8'>, <CodeSegment: ([L:  1, P: 22]) ','>, <CodeSegment: ([L:  1, P: 23]) '4'>, <CodeSegment: ([L:  1, P: 24]) ')'>, <CodeSegment: ([L:  1, P: 25]) ')'>)
Base route...
<SelectClauseElementSegment: ([L:  1, P:  1])>
<SelectClauseElementSegment: ([L:  1, P:  1])>
<class 'sqlfluff.dialects.dialect_ansi.SelectClauseElementSegment'>
<class 'str'>
------------------------------ Captured log call -------------------------------
INFO     sqlfluff.parser:match_logging.py:28 [PD:0  MD:0 ]	SelectClauseElementSegment                        	OneOf.match PRN     	    	[ns=2, ps=0, ms=0, pruned=[], opts=[<Ref: WildcardExpressionSegment>, <Sequence: [<Ref: BaseExpressionElementGrammar>, <Ref: AliasExpressionSegment [opt]>]>]]
INFO     sqlfluff.parser:match_logging.py:28 [PD:0  MD:2 ]	..WildcardExpressionSegment                       	Seque.match OUT     	    	[match=<MatchResult 0/13: ''>, seg="'CAST(num AS numeric(...'"]
DEBUG    sqlfluff.parser:match_logging.py:30 [PD:0  MD:1 ]	.WildcardExpressionSegment                        	Wildc.match OUT     	    	[match=<MatchResult 0/13: ''>, seg="'CAST(num AS numeric(...'"]
DEBUG    sqlfluff.parser:match_logging.py:30 [PD:0  MD:1 ]	.SelectClauseElementSegment                       	Ref.match OUT       	    	[match=<MatchResult 0/13: ''>, seg="'CAST(num AS numeric(...'"]
INFO     sqlfluff.parser:match_logging.py:28 [PD:0  MD:1 ]	.SelectClauseElementSegment                       	Seque.match OUT     	    	[match=<MatchResult 0/13: ''>, seg="'CAST(num AS numeric(...'"]
INFO     sqlfluff.parser:match_logging.py:28 [PD:0  MD:0 ]	SelectClauseElementSegment                        	OneOf.match OUT     	    	[match=<MatchResult 0/13: ''>, seg="'CAST(num AS numeric(...'"]
DEBUG    sqlfluff.parser:base.py:859 SelectClauseElementSegment.parse: Done Parse. Plotting Recursion. Recurse=True
DEBUG    sqlfluff.parser:base.py:868 ###
#
# Beginning Parse Depth 1: SelectClauseElementSegment
#
###
Initial Structure:
[L:  1, P:  1]      |select_clause_element:
[L:  1, P:  1]      |    unparsable:                                               !! Expected: 'SelectClauseElementSegment'
[L:  1, P:  1]      |        raw:                                                  'CAST'
[L:  1, P:  5]      |        raw:                                                  '('
[L:  1, P:  6]      |        raw:                                                  'num'
[L:  1, P:  9]      |        whitespace:                                           ' '
[L:  1, P: 10]      |        raw:                                                  'AS'
[L:  1, P: 12]      |        whitespace:                                           ' '
[L:  1, P: 13]      |        raw:                                                  'numeric'
[L:  1, P: 20]      |        raw:                                                  '('
[L:  1, P: 21]      |        raw:                                                  '8'
[L:  1, P: 22]      |        comma:                                                ','
[L:  1, P: 23]      |        raw:                                                  '4'
[L:  1, P: 24]      |        raw:                                                  ')'
[L:  1, P: 25]      |        raw:                                                  ')'

INFO     sqlfluff.parser:base.py:251 [PD:1] Skipping expansion of <UnparsableSegment: ([L:  1, P:  1])>...
_ test__dialect__ansi_specific_segment_parses[SelectClauseElementSegment-a.*] __

segmentref = 'SelectClauseElementSegment', raw = 'a.*'
caplog = <_pytest.logging.LogCaptureFixture object at 0x7a108538a220>
dialect_specific_segment_parses = <function _dialect_specific_segment_parses at 0x7a1085546dc0>

    @pytest.mark.parametrize(
        "segmentref,raw",
        [
            ("SelectKeywordSegment", "select"),
            ("NakedIdentifierSegment", "online_sales"),
            ("BareFunctionSegment", "current_timestamp"),
            ("FunctionSegment", "current_timestamp()"),
            ("NumericLiteralSegment", "1000.0"),
            ("ExpressionSegment", "online_sales / 1000.0"),
            ("IntervalExpressionSegment", "INTERVAL 1 YEAR"),
            ("ExpressionSegment", "CASE WHEN id = 1 THEN 'nothing' ELSE 'test' END"),
            # Nested Case Expressions
            # https://github.com/sqlfluff/sqlfluff/issues/172
            (
                "ExpressionSegment",
                (
                    "CASE WHEN id = 1 THEN CASE WHEN true THEN 'something' "
                    "ELSE 'nothing' END ELSE 'test' END"
                ),
            ),
            # Casting expressions
            # https://github.com/sqlfluff/sqlfluff/issues/161
            ("ExpressionSegment", "CAST(ROUND(online_sales / 1000.0) AS varchar)"),
            # Like expressions
            # https://github.com/sqlfluff/sqlfluff/issues/170
            ("ExpressionSegment", "name NOT LIKE '%y'"),
            # Functions with a space
            # https://github.com/sqlfluff/sqlfluff/issues/171
            ("SelectClauseElementSegment", "MIN (test.id) AS min_test_id"),
            # Interval literals
            # https://github.com/sqlfluff/sqlfluff/issues/148
            (
                "ExpressionSegment",
                "DATE_ADD(CURRENT_DATE('America/New_York'), INTERVAL 1 year)",
            ),
            # Array accessors
            ("ExpressionSegment", "my_array[1]"),
            ("ExpressionSegment", "my_array[OFFSET(1)]"),
            ("ExpressionSegment", "my_array[5:8]"),
            ("ExpressionSegment", "4 + my_array[OFFSET(1)]"),
            ("ExpressionSegment", "bits[OFFSET(0)] + 7"),
            (
                "SelectClauseElementSegment",
                (
                    "(count_18_24 * bits[OFFSET(0)])"
                    " / audience_size AS relative_abundance"
                ),
            ),
            ("ExpressionSegment", "count_18_24 * bits[OFFSET(0)] + count_25_34"),
            (
                "SelectClauseElementSegment",
                (
                    "(count_18_24 * bits[OFFSET(0)] + count_25_34)"
                    " / audience_size AS relative_abundance"
                ),
            ),
            # Dense math expressions
            # https://github.com/sqlfluff/sqlfluff/issues/178
            # https://github.com/sqlfluff/sqlfluff/issues/179
            ("SelectStatementSegment", "SELECT t.val/t.id FROM test WHERE id*1.0/id > 0.8"),
            ("SelectClauseElementSegment", "t.val/t.id"),
            # Issue with casting raise as part of PR #177
            ("SelectClauseElementSegment", "CAST(num AS INT64)"),
            # Casting as datatype with arguments
            ("SelectClauseElementSegment", "CAST(num AS numeric(8,4))"),
            # Wildcard field selection
            ("SelectClauseElementSegment", "a.*"),
            ("SelectClauseElementSegment", "a.b.*"),
            ("SelectClauseElementSegment", "a.b.c.*"),
            # Default Element Syntax
            ("ObjectReferenceSegment", "a..c.*"),
            # Negative Elements
            ("SelectClauseElementSegment", "-some_variable"),
            ("SelectClauseElementSegment", "- some_variable"),
            # Complex Functions
            (
                "ExpressionSegment",
                "concat(left(uaid, 2), '|', right(concat('0000000', SPLIT_PART(uaid, '|', 4)), 10), '|', '00000000')",
            ),
            # Notnull and Isnull
            ("ExpressionSegment", "c is null"),
            ("ExpressionSegment", "c is not null"),
            ("SelectClauseElementSegment", "c is null as c_isnull"),
            ("SelectClauseElementSegment", "c is not null as c_notnull"),
            # Shorthand casting
            ("ExpressionSegment", "NULL::INT"),
            ("SelectClauseElementSegment", "NULL::INT AS user_id"),
            ("TruncateStatementSegment", "TRUNCATE TABLE test"),
            ("TruncateStatementSegment", "TRUNCATE test"),
        ],
    )
    def test__dialect__ansi_specific_segment_parses(
        segmentref, raw, caplog, dialect_specific_segment_parses
    ):
        """Test that specific segments parse as expected.
    
        NB: We're testing the PARSE function not the MATCH function
        although this will be a recursive parse and so the match
        function of SUBSECTIONS will be tested if present. The match
        function of the parent will not be tested.
        """
>       dialect_specific_segment_parses("ansi", segmentref, raw, caplog)

test/dialects/ansi_test.py:132: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

dialect = 'ansi', segmentref = 'SelectClauseElementSegment', raw = 'a.*'
caplog = <_pytest.logging.LogCaptureFixture object at 0x7a108538a220>

    def _dialect_specific_segment_parses(dialect, segmentref, raw, caplog):
        """Test that specific segments parse as expected.
    
        NB: We're testing the PARSE function not the MATCH function
        although this will be a recursive parse and so the match
        function of SUBSECTIONS will be tested if present. The match
        function of the parent will not be tested.
        """
        config = FluffConfig(overrides=dict(dialect=dialect))
        seg_list = lex(raw, config=config)
        Seg = validate_segment(segmentref, config=config)
    
        # This test is different if we're working with RawSegment
        # derivatives or not.
        if isinstance(Seg, StringParser) or issubclass(Seg, RawSegment):
            print("Raw/Parser route...")
            with RootParseContext.from_config(config) as ctx:
                with caplog.at_level(logging.DEBUG):
                    parsed = Seg.match(segments=seg_list, parse_context=ctx)
            assert isinstance(parsed, MatchResult)
            assert len(parsed.matched_segments) == 1
            print(parsed)
            parsed = parsed.matched_segments[0]
            print(parsed)
        else:
            print("Base route...")
            # Construct an unparsed segment
            seg = Seg(seg_list, pos_marker=seg_list[0].pos_marker)
            # Perform the match (THIS IS THE MEAT OF THE TEST)
            with RootParseContext.from_config(config) as ctx:
                with caplog.at_level(logging.DEBUG):
                    parsed = seg.parse(parse_context=ctx)
            print(parsed)
            assert isinstance(parsed, Seg)
    
        # Check we get a good response
        print(parsed)
        print(type(parsed))
        # print(type(parsed._reconstruct()))
        print(type(parsed.raw))
        # Check we're all there.
        assert parsed.raw == raw
        # Check that there's nothing un parsable
        typs = parsed.type_set()
>       assert "unparsable" not in typs
E       AssertionError: assert 'unparsable' not in {'raw', 'select_clause_element', 'unparsable'}

test/dialects/conftest.py:89: AssertionError
----------------------------- Captured stdout call -----------------------------
(<CodeSegment: ([L:  1, P:  1]) 'a'>, <CodeSegment: ([L:  1, P:  2]) '.'>, <CodeSegment: ([L:  1, P:  3]) '*'>)
Base route...
<SelectClauseElementSegment: ([L:  1, P:  1])>
<SelectClauseElementSegment: ([L:  1, P:  1])>
<class 'sqlfluff.dialects.dialect_ansi.SelectClauseElementSegment'>
<class 'str'>
------------------------------ Captured log call -------------------------------
INFO     sqlfluff.parser:match_logging.py:28 [PD:0  MD:0 ]	SelectClauseElementSegment                        	OneOf.match PRN     	    	[ns=2, ps=0, ms=0, pruned=[], opts=[<Ref: WildcardExpressionSegment>, <Sequence: [<Ref: BaseExpressionElementGrammar>, <Ref: AliasExpressionSegment [opt]>]>]]
INFO     sqlfluff.parser:match_logging.py:28 [PD:0  MD:2 ]	..WildcardExpressionSegment                       	Seque.match OUT     	    	[match=<MatchResult 0/3: ''>, seg="'a.*'"]
DEBUG    sqlfluff.parser:match_logging.py:30 [PD:0  MD:1 ]	.WildcardExpressionSegment                        	Wildc.match OUT     	    	[match=<MatchResult 0/3: ''>, seg="'a.*'"]
DEBUG    sqlfluff.parser:match_logging.py:30 [PD:0  MD:1 ]	.SelectClauseElementSegment                       	Ref.match OUT       	    	[match=<MatchResult 0/3: ''>, seg="'a.*'"]
INFO     sqlfluff.parser:match_logging.py:28 [PD:0  MD:1 ]	.SelectClauseElementSegment                       	Seque.match OUT     	    	[match=<MatchResult 0/3: ''>, seg="'a.*'"]
INFO     sqlfluff.parser:match_logging.py:28 [PD:0  MD:0 ]	SelectClauseElementSegment                        	OneOf.match OUT     	    	[match=<MatchResult 0/3: ''>, seg="'a.*'"]
DEBUG    sqlfluff.parser:base.py:859 SelectClauseElementSegment.parse: Done Parse. Plotting Recursion. Recurse=True
DEBUG    sqlfluff.parser:base.py:868 ###
#
# Beginning Parse Depth 1: SelectClauseElementSegment
#
###
Initial Structure:
[L:  1, P:  1]      |select_clause_element:
[L:  1, P:  1]      |    unparsable:                                               !! Expected: 'SelectClauseElementSegment'
[L:  1, P:  1]      |        raw:                                                  'a'
[L:  1, P:  2]      |        raw:                                                  '.'
[L:  1, P:  3]      |        raw:                                                  '*'

INFO     sqlfluff.parser:base.py:251 [PD:1] Skipping expansion of <UnparsableSegment: ([L:  1, P:  1])>...
_ test__dialect__ansi_specific_segment_parses[SelectClauseElementSegment-a.b.*] _

segmentref = 'SelectClauseElementSegment', raw = 'a.b.*'
caplog = <_pytest.logging.LogCaptureFixture object at 0x7a108595d940>
dialect_specific_segment_parses = <function _dialect_specific_segment_parses at 0x7a1085546dc0>

    @pytest.mark.parametrize(
        "segmentref,raw",
        [
            ("SelectKeywordSegment", "select"),
            ("NakedIdentifierSegment", "online_sales"),
            ("BareFunctionSegment", "current_timestamp"),
            ("FunctionSegment", "current_timestamp()"),
            ("NumericLiteralSegment", "1000.0"),
            ("ExpressionSegment", "online_sales / 1000.0"),
            ("IntervalExpressionSegment", "INTERVAL 1 YEAR"),
            ("ExpressionSegment", "CASE WHEN id = 1 THEN 'nothing' ELSE 'test' END"),
            # Nested Case Expressions
            # https://github.com/sqlfluff/sqlfluff/issues/172
            (
                "ExpressionSegment",
                (
                    "CASE WHEN id = 1 THEN CASE WHEN true THEN 'something' "
                    "ELSE 'nothing' END ELSE 'test' END"
                ),
            ),
            # Casting expressions
            # https://github.com/sqlfluff/sqlfluff/issues/161
            ("ExpressionSegment", "CAST(ROUND(online_sales / 1000.0) AS varchar)"),
            # Like expressions
            # https://github.com/sqlfluff/sqlfluff/issues/170
            ("ExpressionSegment", "name NOT LIKE '%y'"),
            # Functions with a space
            # https://github.com/sqlfluff/sqlfluff/issues/171
            ("SelectClauseElementSegment", "MIN (test.id) AS min_test_id"),
            # Interval literals
            # https://github.com/sqlfluff/sqlfluff/issues/148
            (
                "ExpressionSegment",
                "DATE_ADD(CURRENT_DATE('America/New_York'), INTERVAL 1 year)",
            ),
            # Array accessors
            ("ExpressionSegment", "my_array[1]"),
            ("ExpressionSegment", "my_array[OFFSET(1)]"),
            ("ExpressionSegment", "my_array[5:8]"),
            ("ExpressionSegment", "4 + my_array[OFFSET(1)]"),
            ("ExpressionSegment", "bits[OFFSET(0)] + 7"),
            (
                "SelectClauseElementSegment",
                (
                    "(count_18_24 * bits[OFFSET(0)])"
                    " / audience_size AS relative_abundance"
                ),
            ),
            ("ExpressionSegment", "count_18_24 * bits[OFFSET(0)] + count_25_34"),
            (
                "SelectClauseElementSegment",
                (
                    "(count_18_24 * bits[OFFSET(0)] + count_25_34)"
                    " / audience_size AS relative_abundance"
                ),
            ),
            # Dense math expressions
            # https://github.com/sqlfluff/sqlfluff/issues/178
            # https://github.com/sqlfluff/sqlfluff/issues/179
            ("SelectStatementSegment", "SELECT t.val/t.id FROM test WHERE id*1.0/id > 0.8"),
            ("SelectClauseElementSegment", "t.val/t.id"),
            # Issue with casting raise as part of PR #177
            ("SelectClauseElementSegment", "CAST(num AS INT64)"),
            # Casting as datatype with arguments
            ("SelectClauseElementSegment", "CAST(num AS numeric(8,4))"),
            # Wildcard field selection
            ("SelectClauseElementSegment", "a.*"),
            ("SelectClauseElementSegment", "a.b.*"),
            ("SelectClauseElementSegment", "a.b.c.*"),
            # Default Element Syntax
            ("ObjectReferenceSegment", "a..c.*"),
            # Negative Elements
            ("SelectClauseElementSegment", "-some_variable"),
            ("SelectClauseElementSegment", "- some_variable"),
            # Complex Functions
            (
                "ExpressionSegment",
                "concat(left(uaid, 2), '|', right(concat('0000000', SPLIT_PART(uaid, '|', 4)), 10), '|', '00000000')",
            ),
            # Notnull and Isnull
            ("ExpressionSegment", "c is null"),
            ("ExpressionSegment", "c is not null"),
            ("SelectClauseElementSegment", "c is null as c_isnull"),
            ("SelectClauseElementSegment", "c is not null as c_notnull"),
            # Shorthand casting
            ("ExpressionSegment", "NULL::INT"),
            ("SelectClauseElementSegment", "NULL::INT AS user_id"),
            ("TruncateStatementSegment", "TRUNCATE TABLE test"),
            ("TruncateStatementSegment", "TRUNCATE test"),
        ],
    )
    def test__dialect__ansi_specific_segment_parses(
        segmentref, raw, caplog, dialect_specific_segment_parses
    ):
        """Test that specific segments parse as expected.
    
        NB: We're testing the PARSE function not the MATCH function
        although this will be a recursive parse and so the match
        function of SUBSECTIONS will be tested if present. The match
        function of the parent will not be tested.
        """
>       dialect_specific_segment_parses("ansi", segmentref, raw, caplog)

test/dialects/ansi_test.py:132: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

dialect = 'ansi', segmentref = 'SelectClauseElementSegment', raw = 'a.b.*'
caplog = <_pytest.logging.LogCaptureFixture object at 0x7a108595d940>

    def _dialect_specific_segment_parses(dialect, segmentref, raw, caplog):
        """Test that specific segments parse as expected.
    
        NB: We're testing the PARSE function not the MATCH function
        although this will be a recursive parse and so the match
        function of SUBSECTIONS will be tested if present. The match
        function of the parent will not be tested.
        """
        config = FluffConfig(overrides=dict(dialect=dialect))
        seg_list = lex(raw, config=config)
        Seg = validate_segment(segmentref, config=config)
    
        # This test is different if we're working with RawSegment
        # derivatives or not.
        if isinstance(Seg, StringParser) or issubclass(Seg, RawSegment):
            print("Raw/Parser route...")
            with RootParseContext.from_config(config) as ctx:
                with caplog.at_level(logging.DEBUG):
                    parsed = Seg.match(segments=seg_list, parse_context=ctx)
            assert isinstance(parsed, MatchResult)
            assert len(parsed.matched_segments) == 1
            print(parsed)
            parsed = parsed.matched_segments[0]
            print(parsed)
        else:
            print("Base route...")
            # Construct an unparsed segment
            seg = Seg(seg_list, pos_marker=seg_list[0].pos_marker)
            # Perform the match (THIS IS THE MEAT OF THE TEST)
            with RootParseContext.from_config(config) as ctx:
                with caplog.at_level(logging.DEBUG):
                    parsed = seg.parse(parse_context=ctx)
            print(parsed)
            assert isinstance(parsed, Seg)
    
        # Check we get a good response
        print(parsed)
        print(type(parsed))
        # print(type(parsed._reconstruct()))
        print(type(parsed.raw))
        # Check we're all there.
        assert parsed.raw == raw
        # Check that there's nothing un parsable
        typs = parsed.type_set()
>       assert "unparsable" not in typs
E       AssertionError: assert 'unparsable' not in {'raw', 'select_clause_element', 'unparsable'}

test/dialects/conftest.py:89: AssertionError
----------------------------- Captured stdout call -----------------------------
(<CodeSegment: ([L:  1, P:  1]) 'a'>, <CodeSegment: ([L:  1, P:  2]) '.'>, <CodeSegment: ([L:  1, P:  3]) 'b'>, <CodeSegment: ([L:  1, P:  4]) '.'>, <CodeSegment: ([L:  1, P:  5]) '*'>)
Base route...
<SelectClauseElementSegment: ([L:  1, P:  1])>
<SelectClauseElementSegment: ([L:  1, P:  1])>
<class 'sqlfluff.dialects.dialect_ansi.SelectClauseElementSegment'>
<class 'str'>
------------------------------ Captured log call -------------------------------
INFO     sqlfluff.parser:match_logging.py:28 [PD:0  MD:0 ]	SelectClauseElementSegment                        	OneOf.match PRN     	    	[ns=2, ps=0, ms=0, pruned=[], opts=[<Ref: WildcardExpressionSegment>, <Sequence: [<Ref: BaseExpressionElementGrammar>, <Ref: AliasExpressionSegment [opt]>]>]]
INFO     sqlfluff.parser:match_logging.py:28 [PD:0  MD:2 ]	..WildcardExpressionSegment                       	Seque.match OUT     	    	[match=<MatchResult 0/5: ''>, seg="'a.b.*'"]
DEBUG    sqlfluff.parser:match_logging.py:30 [PD:0  MD:1 ]	.WildcardExpressionSegment                        	Wildc.match OUT     	    	[match=<MatchResult 0/5: ''>, seg="'a.b.*'"]
DEBUG    sqlfluff.parser:match_logging.py:30 [PD:0  MD:1 ]	.SelectClauseElementSegment                       	Ref.match OUT       	    	[match=<MatchResult 0/5: ''>, seg="'a.b.*'"]
INFO     sqlfluff.parser:match_logging.py:28 [PD:0  MD:1 ]	.SelectClauseElementSegment                       	Seque.match OUT     	    	[match=<MatchResult 0/5: ''>, seg="'a.b.*'"]
INFO     sqlfluff.parser:match_logging.py:28 [PD:0  MD:0 ]	SelectClauseElementSegment                        	OneOf.match OUT     	    	[match=<MatchResult 0/5: ''>, seg="'a.b.*'"]
DEBUG    sqlfluff.parser:base.py:859 SelectClauseElementSegment.parse: Done Parse. Plotting Recursion. Recurse=True
DEBUG    sqlfluff.parser:base.py:868 ###
#
# Beginning Parse Depth 1: SelectClauseElementSegment
#
###
Initial Structure:
[L:  1, P:  1]      |select_clause_element:
[L:  1, P:  1]      |    unparsable:                                               !! Expected: 'SelectClauseElementSegment'
[L:  1, P:  1]      |        raw:                                                  'a'
[L:  1, P:  2]      |        raw:                                                  '.'
[L:  1, P:  3]      |        raw:                                                  'b'
[L:  1, P:  4]      |        raw:                                                  '.'
[L:  1, P:  5]      |        raw:                                                  '*'

INFO     sqlfluff.parser:base.py:251 [PD:1] Skipping expansion of <UnparsableSegment: ([L:  1, P:  1])>...
_ test__dialect__ansi_specific_segment_parses[SelectClauseElementSegment-a.b.c.*] _

segmentref = 'SelectClauseElementSegment', raw = 'a.b.c.*'
caplog = <_pytest.logging.LogCaptureFixture object at 0x7a1085392f40>
dialect_specific_segment_parses = <function _dialect_specific_segment_parses at 0x7a1085546dc0>

    @pytest.mark.parametrize(
        "segmentref,raw",
        [
            ("SelectKeywordSegment", "select"),
            ("NakedIdentifierSegment", "online_sales"),
            ("BareFunctionSegment", "current_timestamp"),
            ("FunctionSegment", "current_timestamp()"),
            ("NumericLiteralSegment", "1000.0"),
            ("ExpressionSegment", "online_sales / 1000.0"),
            ("IntervalExpressionSegment", "INTERVAL 1 YEAR"),
            ("ExpressionSegment", "CASE WHEN id = 1 THEN 'nothing' ELSE 'test' END"),
            # Nested Case Expressions
            # https://github.com/sqlfluff/sqlfluff/issues/172
            (
                "ExpressionSegment",
                (
                    "CASE WHEN id = 1 THEN CASE WHEN true THEN 'something' "
                    "ELSE 'nothing' END ELSE 'test' END"
                ),
            ),
            # Casting expressions
            # https://github.com/sqlfluff/sqlfluff/issues/161
            ("ExpressionSegment", "CAST(ROUND(online_sales / 1000.0) AS varchar)"),
            # Like expressions
            # https://github.com/sqlfluff/sqlfluff/issues/170
            ("ExpressionSegment", "name NOT LIKE '%y'"),
            # Functions with a space
            # https://github.com/sqlfluff/sqlfluff/issues/171
            ("SelectClauseElementSegment", "MIN (test.id) AS min_test_id"),
            # Interval literals
            # https://github.com/sqlfluff/sqlfluff/issues/148
            (
                "ExpressionSegment",
                "DATE_ADD(CURRENT_DATE('America/New_York'), INTERVAL 1 year)",
            ),
            # Array accessors
            ("ExpressionSegment", "my_array[1]"),
            ("ExpressionSegment", "my_array[OFFSET(1)]"),
            ("ExpressionSegment", "my_array[5:8]"),
            ("ExpressionSegment", "4 + my_array[OFFSET(1)]"),
            ("ExpressionSegment", "bits[OFFSET(0)] + 7"),
            (
                "SelectClauseElementSegment",
                (
                    "(count_18_24 * bits[OFFSET(0)])"
                    " / audience_size AS relative_abundance"
                ),
            ),
            ("ExpressionSegment", "count_18_24 * bits[OFFSET(0)] + count_25_34"),
            (
                "SelectClauseElementSegment",
                (
                    "(count_18_24 * bits[OFFSET(0)] + count_25_34)"
                    " / audience_size AS relative_abundance"
                ),
            ),
            # Dense math expressions
            # https://github.com/sqlfluff/sqlfluff/issues/178
            # https://github.com/sqlfluff/sqlfluff/issues/179
            ("SelectStatementSegment", "SELECT t.val/t.id FROM test WHERE id*1.0/id > 0.8"),
            ("SelectClauseElementSegment", "t.val/t.id"),
            # Issue with casting raise as part of PR #177
            ("SelectClauseElementSegment", "CAST(num AS INT64)"),
            # Casting as datatype with arguments
            ("SelectClauseElementSegment", "CAST(num AS numeric(8,4))"),
            # Wildcard field selection
            ("SelectClauseElementSegment", "a.*"),
            ("SelectClauseElementSegment", "a.b.*"),
            ("SelectClauseElementSegment", "a.b.c.*"),
            # Default Element Syntax
            ("ObjectReferenceSegment", "a..c.*"),
            # Negative Elements
            ("SelectClauseElementSegment", "-some_variable"),
            ("SelectClauseElementSegment", "- some_variable"),
            # Complex Functions
            (
                "ExpressionSegment",
                "concat(left(uaid, 2), '|', right(concat('0000000', SPLIT_PART(uaid, '|', 4)), 10), '|', '00000000')",
            ),
            # Notnull and Isnull
            ("ExpressionSegment", "c is null"),
            ("ExpressionSegment", "c is not null"),
            ("SelectClauseElementSegment", "c is null as c_isnull"),
            ("SelectClauseElementSegment", "c is not null as c_notnull"),
            # Shorthand casting
            ("ExpressionSegment", "NULL::INT"),
            ("SelectClauseElementSegment", "NULL::INT AS user_id"),
            ("TruncateStatementSegment", "TRUNCATE TABLE test"),
            ("TruncateStatementSegment", "TRUNCATE test"),
        ],
    )
    def test__dialect__ansi_specific_segment_parses(
        segmentref, raw, caplog, dialect_specific_segment_parses
    ):
        """Test that specific segments parse as expected.
    
        NB: We're testing the PARSE function not the MATCH function
        although this will be a recursive parse and so the match
        function of SUBSECTIONS will be tested if present. The match
        function of the parent will not be tested.
        """
>       dialect_specific_segment_parses("ansi", segmentref, raw, caplog)

test/dialects/ansi_test.py:132: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

dialect = 'ansi', segmentref = 'SelectClauseElementSegment', raw = 'a.b.c.*'
caplog = <_pytest.logging.LogCaptureFixture object at 0x7a1085392f40>

    def _dialect_specific_segment_parses(dialect, segmentref, raw, caplog):
        """Test that specific segments parse as expected.
    
        NB: We're testing the PARSE function not the MATCH function
        although this will be a recursive parse and so the match
        function of SUBSECTIONS will be tested if present. The match
        function of the parent will not be tested.
        """
        config = FluffConfig(overrides=dict(dialect=dialect))
        seg_list = lex(raw, config=config)
        Seg = validate_segment(segmentref, config=config)
    
        # This test is different if we're working with RawSegment
        # derivatives or not.
        if isinstance(Seg, StringParser) or issubclass(Seg, RawSegment):
            print("Raw/Parser route...")
            with RootParseContext.from_config(config) as ctx:
                with caplog.at_level(logging.DEBUG):
                    parsed = Seg.match(segments=seg_list, parse_context=ctx)
            assert isinstance(parsed, MatchResult)
            assert len(parsed.matched_segments) == 1
            print(parsed)
            parsed = parsed.matched_segments[0]
            print(parsed)
        else:
            print("Base route...")
            # Construct an unparsed segment
            seg = Seg(seg_list, pos_marker=seg_list[0].pos_marker)
            # Perform the match (THIS IS THE MEAT OF THE TEST)
            with RootParseContext.from_config(config) as ctx:
                with caplog.at_level(logging.DEBUG):
                    parsed = seg.parse(parse_context=ctx)
            print(parsed)
            assert isinstance(parsed, Seg)
    
        # Check we get a good response
        print(parsed)
        print(type(parsed))
        # print(type(parsed._reconstruct()))
        print(type(parsed.raw))
        # Check we're all there.
        assert parsed.raw == raw
        # Check that there's nothing un parsable
        typs = parsed.type_set()
>       assert "unparsable" not in typs
E       AssertionError: assert 'unparsable' not in {'raw', 'select_clause_element', 'unparsable'}

test/dialects/conftest.py:89: AssertionError
----------------------------- Captured stdout call -----------------------------
(<CodeSegment: ([L:  1, P:  1]) 'a'>, <CodeSegment: ([L:  1, P:  2]) '.'>, <CodeSegment: ([L:  1, P:  3]) 'b'>, <CodeSegment: ([L:  1, P:  4]) '.'>, <CodeSegment: ([L:  1, P:  5]) 'c'>, <CodeSegment: ([L:  1, P:  6]) '.'>, <CodeSegment: ([L:  1, P:  7]) '*'>)
Base route...
<SelectClauseElementSegment: ([L:  1, P:  1])>
<SelectClauseElementSegment: ([L:  1, P:  1])>
<class 'sqlfluff.dialects.dialect_ansi.SelectClauseElementSegment'>
<class 'str'>
------------------------------ Captured log call -------------------------------
INFO     sqlfluff.parser:match_logging.py:28 [PD:0  MD:0 ]	SelectClauseElementSegment                        	OneOf.match PRN     	    	[ns=2, ps=0, ms=0, pruned=[], opts=[<Ref: WildcardExpressionSegment>, <Sequence: [<Ref: BaseExpressionElementGrammar>, <Ref: AliasExpressionSegment [opt]>]>]]
INFO     sqlfluff.parser:match_logging.py:28 [PD:0  MD:2 ]	..WildcardExpressionSegment                       	Seque.match OUT     	    	[match=<MatchResult 0/7: ''>, seg="'a.b.c.*'"]
DEBUG    sqlfluff.parser:match_logging.py:30 [PD:0  MD:1 ]	.WildcardExpressionSegment                        	Wildc.match OUT     	    	[match=<MatchResult 0/7: ''>, seg="'a.b.c.*'"]
DEBUG    sqlfluff.parser:match_logging.py:30 [PD:0  MD:1 ]	.SelectClauseElementSegment                       	Ref.match OUT       	    	[match=<MatchResult 0/7: ''>, seg="'a.b.c.*'"]
INFO     sqlfluff.parser:match_logging.py:28 [PD:0  MD:1 ]	.SelectClauseElementSegment                       	Seque.match OUT     	    	[match=<MatchResult 0/7: ''>, seg="'a.b.c.*'"]
INFO     sqlfluff.parser:match_logging.py:28 [PD:0  MD:0 ]	SelectClauseElementSegment                        	OneOf.match OUT     	    	[match=<MatchResult 0/7: ''>, seg="'a.b.c.*'"]
DEBUG    sqlfluff.parser:base.py:859 SelectClauseElementSegment.parse: Done Parse. Plotting Recursion. Recurse=True
DEBUG    sqlfluff.parser:base.py:868 ###
#
# Beginning Parse Depth 1: SelectClauseElementSegment
#
###
Initial Structure:
[L:  1, P:  1]      |select_clause_element:
[L:  1, P:  1]      |    unparsable:                                               !! Expected: 'SelectClauseElementSegment'
[L:  1, P:  1]      |        raw:                                                  'a'
[L:  1, P:  2]      |        raw:                                                  '.'
[L:  1, P:  3]      |        raw:                                                  'b'
[L:  1, P:  4]      |        raw:                                                  '.'
[L:  1, P:  5]      |        raw:                                                  'c'
[L:  1, P:  6]      |        raw:                                                  '.'
[L:  1, P:  7]      |        raw:                                                  '*'

INFO     sqlfluff.parser:base.py:251 [PD:1] Skipping expansion of <UnparsableSegment: ([L:  1, P:  1])>...
_ test__dialect__ansi_specific_segment_parses[SelectClauseElementSegment--some_variable] _

segmentref = 'SelectClauseElementSegment', raw = '-some_variable'
caplog = <_pytest.logging.LogCaptureFixture object at 0x7a10851e3f70>
dialect_specific_segment_parses = <function _dialect_specific_segment_parses at 0x7a1085546dc0>

    @pytest.mark.parametrize(
        "segmentref,raw",
        [
            ("SelectKeywordSegment", "select"),
            ("NakedIdentifierSegment", "online_sales"),
            ("BareFunctionSegment", "current_timestamp"),
            ("FunctionSegment", "current_timestamp()"),
            ("NumericLiteralSegment", "1000.0"),
            ("ExpressionSegment", "online_sales / 1000.0"),
            ("IntervalExpressionSegment", "INTERVAL 1 YEAR"),
            ("ExpressionSegment", "CASE WHEN id = 1 THEN 'nothing' ELSE 'test' END"),
            # Nested Case Expressions
            # https://github.com/sqlfluff/sqlfluff/issues/172
            (
                "ExpressionSegment",
                (
                    "CASE WHEN id = 1 THEN CASE WHEN true THEN 'something' "
                    "ELSE 'nothing' END ELSE 'test' END"
                ),
            ),
            # Casting expressions
            # https://github.com/sqlfluff/sqlfluff/issues/161
            ("ExpressionSegment", "CAST(ROUND(online_sales / 1000.0) AS varchar)"),
            # Like expressions
            # https://github.com/sqlfluff/sqlfluff/issues/170
            ("ExpressionSegment", "name NOT LIKE '%y'"),
            # Functions with a space
            # https://github.com/sqlfluff/sqlfluff/issues/171
            ("SelectClauseElementSegment", "MIN (test.id) AS min_test_id"),
            # Interval literals
            # https://github.com/sqlfluff/sqlfluff/issues/148
            (
                "ExpressionSegment",
                "DATE_ADD(CURRENT_DATE('America/New_York'), INTERVAL 1 year)",
            ),
            # Array accessors
            ("ExpressionSegment", "my_array[1]"),
            ("ExpressionSegment", "my_array[OFFSET(1)]"),
            ("ExpressionSegment", "my_array[5:8]"),
            ("ExpressionSegment", "4 + my_array[OFFSET(1)]"),
            ("ExpressionSegment", "bits[OFFSET(0)] + 7"),
            (
                "SelectClauseElementSegment",
                (
                    "(count_18_24 * bits[OFFSET(0)])"
                    " / audience_size AS relative_abundance"
                ),
            ),
            ("ExpressionSegment", "count_18_24 * bits[OFFSET(0)] + count_25_34"),
            (
                "SelectClauseElementSegment",
                (
                    "(count_18_24 * bits[OFFSET(0)] + count_25_34)"
                    " / audience_size AS relative_abundance"
                ),
            ),
            # Dense math expressions
            # https://github.com/sqlfluff/sqlfluff/issues/178
            # https://github.com/sqlfluff/sqlfluff/issues/179
            ("SelectStatementSegment", "SELECT t.val/t.id FROM test WHERE id*1.0/id > 0.8"),
            ("SelectClauseElementSegment", "t.val/t.id"),
            # Issue with casting raise as part of PR #177
            ("SelectClauseElementSegment", "CAST(num AS INT64)"),
            # Casting as datatype with arguments
            ("SelectClauseElementSegment", "CAST(num AS numeric(8,4))"),
            # Wildcard field selection
            ("SelectClauseElementSegment", "a.*"),
            ("SelectClauseElementSegment", "a.b.*"),
            ("SelectClauseElementSegment", "a.b.c.*"),
            # Default Element Syntax
            ("ObjectReferenceSegment", "a..c.*"),
            # Negative Elements
            ("SelectClauseElementSegment", "-some_variable"),
            ("SelectClauseElementSegment", "- some_variable"),
            # Complex Functions
            (
                "ExpressionSegment",
                "concat(left(uaid, 2), '|', right(concat('0000000', SPLIT_PART(uaid, '|', 4)), 10), '|', '00000000')",
            ),
            # Notnull and Isnull
            ("ExpressionSegment", "c is null"),
            ("ExpressionSegment", "c is not null"),
            ("SelectClauseElementSegment", "c is null as c_isnull"),
            ("SelectClauseElementSegment", "c is not null as c_notnull"),
            # Shorthand casting
            ("ExpressionSegment", "NULL::INT"),
            ("SelectClauseElementSegment", "NULL::INT AS user_id"),
            ("TruncateStatementSegment", "TRUNCATE TABLE test"),
            ("TruncateStatementSegment", "TRUNCATE test"),
        ],
    )
    def test__dialect__ansi_specific_segment_parses(
        segmentref, raw, caplog, dialect_specific_segment_parses
    ):
        """Test that specific segments parse as expected.
    
        NB: We're testing the PARSE function not the MATCH function
        although this will be a recursive parse and so the match
        function of SUBSECTIONS will be tested if present. The match
        function of the parent will not be tested.
        """
>       dialect_specific_segment_parses("ansi", segmentref, raw, caplog)

test/dialects/ansi_test.py:132: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

dialect = 'ansi', segmentref = 'SelectClauseElementSegment'
raw = '-some_variable'
caplog = <_pytest.logging.LogCaptureFixture object at 0x7a10851e3f70>

    def _dialect_specific_segment_parses(dialect, segmentref, raw, caplog):
        """Test that specific segments parse as expected.
    
        NB: We're testing the PARSE function not the MATCH function
        although this will be a recursive parse and so the match
        function of SUBSECTIONS will be tested if present. The match
        function of the parent will not be tested.
        """
        config = FluffConfig(overrides=dict(dialect=dialect))
        seg_list = lex(raw, config=config)
        Seg = validate_segment(segmentref, config=config)
    
        # This test is different if we're working with RawSegment
        # derivatives or not.
        if isinstance(Seg, StringParser) or issubclass(Seg, RawSegment):
            print("Raw/Parser route...")
            with RootParseContext.from_config(config) as ctx:
                with caplog.at_level(logging.DEBUG):
                    parsed = Seg.match(segments=seg_list, parse_context=ctx)
            assert isinstance(parsed, MatchResult)
            assert len(parsed.matched_segments) == 1
            print(parsed)
            parsed = parsed.matched_segments[0]
            print(parsed)
        else:
            print("Base route...")
            # Construct an unparsed segment
            seg = Seg(seg_list, pos_marker=seg_list[0].pos_marker)
            # Perform the match (THIS IS THE MEAT OF THE TEST)
            with RootParseContext.from_config(config) as ctx:
                with caplog.at_level(logging.DEBUG):
                    parsed = seg.parse(parse_context=ctx)
            print(parsed)
            assert isinstance(parsed, Seg)
    
        # Check we get a good response
        print(parsed)
        print(type(parsed))
        # print(type(parsed._reconstruct()))
        print(type(parsed.raw))
        # Check we're all there.
        assert parsed.raw == raw
        # Check that there's nothing un parsable
        typs = parsed.type_set()
>       assert "unparsable" not in typs
E       AssertionError: assert 'unparsable' not in {'raw', 'select_clause_element', 'unparsable'}

test/dialects/conftest.py:89: AssertionError
----------------------------- Captured stdout call -----------------------------
(<CodeSegment: ([L:  1, P:  1]) '-'>, <CodeSegment: ([L:  1, P:  2]) 'some_variable'>)
Base route...
<SelectClauseElementSegment: ([L:  1, P:  1])>
<SelectClauseElementSegment: ([L:  1, P:  1])>
<class 'sqlfluff.dialects.dialect_ansi.SelectClauseElementSegment'>
<class 'str'>
------------------------------ Captured log call -------------------------------
INFO     sqlfluff.parser:match_logging.py:28 [PD:0  MD:0 ]	SelectClauseElementSegment                        	OneOf.match PRN     	    	[ns=2, ps=0, ms=0, pruned=[], opts=[<Ref: WildcardExpressionSegment>, <Sequence: [<Ref: BaseExpressionElementGrammar>, <Ref: AliasExpressionSegment [opt]>]>]]
INFO     sqlfluff.parser:match_logging.py:28 [PD:0  MD:2 ]	..WildcardExpressionSegment                       	Seque.match OUT     	    	[match=<MatchResult 0/2: ''>, seg="'-some_variable'"]
DEBUG    sqlfluff.parser:match_logging.py:30 [PD:0  MD:1 ]	.WildcardExpressionSegment                        	Wildc.match OUT     	    	[match=<MatchResult 0/2: ''>, seg="'-some_variable'"]
DEBUG    sqlfluff.parser:match_logging.py:30 [PD:0  MD:1 ]	.SelectClauseElementSegment                       	Ref.match OUT       	    	[match=<MatchResult 0/2: ''>, seg="'-some_variable'"]
INFO     sqlfluff.parser:match_logging.py:28 [PD:0  MD:1 ]	.SelectClauseElementSegment                       	Seque.match OUT     	    	[match=<MatchResult 0/2: ''>, seg="'-some_variable'"]
INFO     sqlfluff.parser:match_logging.py:28 [PD:0  MD:0 ]	SelectClauseElementSegment                        	OneOf.match OUT     	    	[match=<MatchResult 0/2: ''>, seg="'-some_variable'"]
DEBUG    sqlfluff.parser:base.py:859 SelectClauseElementSegment.parse: Done Parse. Plotting Recursion. Recurse=True
DEBUG    sqlfluff.parser:base.py:868 ###
#
# Beginning Parse Depth 1: SelectClauseElementSegment
#
###
Initial Structure:
[L:  1, P:  1]      |select_clause_element:
[L:  1, P:  1]      |    unparsable:                                               !! Expected: 'SelectClauseElementSegment'
[L:  1, P:  1]      |        raw:                                                  '-'
[L:  1, P:  2]      |        raw:                                                  'some_variable'

INFO     sqlfluff.parser:base.py:251 [PD:1] Skipping expansion of <UnparsableSegment: ([L:  1, P:  1])>...
_ test__dialect__ansi_specific_segment_parses[SelectClauseElementSegment-- some_variable] _

segmentref = 'SelectClauseElementSegment', raw = '- some_variable'
caplog = <_pytest.logging.LogCaptureFixture object at 0x7a108512e040>
dialect_specific_segment_parses = <function _dialect_specific_segment_parses at 0x7a1085546dc0>

    @pytest.mark.parametrize(
        "segmentref,raw",
        [
            ("SelectKeywordSegment", "select"),
            ("NakedIdentifierSegment", "online_sales"),
            ("BareFunctionSegment", "current_timestamp"),
            ("FunctionSegment", "current_timestamp()"),
            ("NumericLiteralSegment", "1000.0"),
            ("ExpressionSegment", "online_sales / 1000.0"),
            ("IntervalExpressionSegment", "INTERVAL 1 YEAR"),
            ("ExpressionSegment", "CASE WHEN id = 1 THEN 'nothing' ELSE 'test' END"),
            # Nested Case Expressions
            # https://github.com/sqlfluff/sqlfluff/issues/172
            (
                "ExpressionSegment",
                (
                    "CASE WHEN id = 1 THEN CASE WHEN true THEN 'something' "
                    "ELSE 'nothing' END ELSE 'test' END"
                ),
            ),
            # Casting expressions
            # https://github.com/sqlfluff/sqlfluff/issues/161
            ("ExpressionSegment", "CAST(ROUND(online_sales / 1000.0) AS varchar)"),
            # Like expressions
            # https://github.com/sqlfluff/sqlfluff/issues/170
            ("ExpressionSegment", "name NOT LIKE '%y'"),
            # Functions with a space
            # https://github.com/sqlfluff/sqlfluff/issues/171
            ("SelectClauseElementSegment", "MIN (test.id) AS min_test_id"),
            # Interval literals
            # https://github.com/sqlfluff/sqlfluff/issues/148
            (
                "ExpressionSegment",
                "DATE_ADD(CURRENT_DATE('America/New_York'), INTERVAL 1 year)",
            ),
            # Array accessors
            ("ExpressionSegment", "my_array[1]"),
            ("ExpressionSegment", "my_array[OFFSET(1)]"),
            ("ExpressionSegment", "my_array[5:8]"),
            ("ExpressionSegment", "4 + my_array[OFFSET(1)]"),
            ("ExpressionSegment", "bits[OFFSET(0)] + 7"),
            (
                "SelectClauseElementSegment",
                (
                    "(count_18_24 * bits[OFFSET(0)])"
                    " / audience_size AS relative_abundance"
                ),
            ),
            ("ExpressionSegment", "count_18_24 * bits[OFFSET(0)] + count_25_34"),
            (
                "SelectClauseElementSegment",
                (
                    "(count_18_24 * bits[OFFSET(0)] + count_25_34)"
                    " / audience_size AS relative_abundance"
                ),
            ),
            # Dense math expressions
            # https://github.com/sqlfluff/sqlfluff/issues/178
            # https://github.com/sqlfluff/sqlfluff/issues/179
            ("SelectStatementSegment", "SELECT t.val/t.id FROM test WHERE id*1.0/id > 0.8"),
            ("SelectClauseElementSegment", "t.val/t.id"),
            # Issue with casting raise as part of PR #177
            ("SelectClauseElementSegment", "CAST(num AS INT64)"),
            # Casting as datatype with arguments
            ("SelectClauseElementSegment", "CAST(num AS numeric(8,4))"),
            # Wildcard field selection
            ("SelectClauseElementSegment", "a.*"),
            ("SelectClauseElementSegment", "a.b.*"),
            ("SelectClauseElementSegment", "a.b.c.*"),
            # Default Element Syntax
            ("ObjectReferenceSegment", "a..c.*"),
            # Negative Elements
            ("SelectClauseElementSegment", "-some_variable"),
            ("SelectClauseElementSegment", "- some_variable"),
            # Complex Functions
            (
                "ExpressionSegment",
                "concat(left(uaid, 2), '|', right(concat('0000000', SPLIT_PART(uaid, '|', 4)), 10), '|', '00000000')",
            ),
            # Notnull and Isnull
            ("ExpressionSegment", "c is null"),
            ("ExpressionSegment", "c is not null"),
            ("SelectClauseElementSegment", "c is null as c_isnull"),
            ("SelectClauseElementSegment", "c is not null as c_notnull"),
            # Shorthand casting
            ("ExpressionSegment", "NULL::INT"),
            ("SelectClauseElementSegment", "NULL::INT AS user_id"),
            ("TruncateStatementSegment", "TRUNCATE TABLE test"),
            ("TruncateStatementSegment", "TRUNCATE test"),
        ],
    )
    def test__dialect__ansi_specific_segment_parses(
        segmentref, raw, caplog, dialect_specific_segment_parses
    ):
        """Test that specific segments parse as expected.
    
        NB: We're testing the PARSE function not the MATCH function
        although this will be a recursive parse and so the match
        function of SUBSECTIONS will be tested if present. The match
        function of the parent will not be tested.
        """
>       dialect_specific_segment_parses("ansi", segmentref, raw, caplog)

test/dialects/ansi_test.py:132: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

dialect = 'ansi', segmentref = 'SelectClauseElementSegment'
raw = '- some_variable'
caplog = <_pytest.logging.LogCaptureFixture object at 0x7a108512e040>

    def _dialect_specific_segment_parses(dialect, segmentref, raw, caplog):
        """Test that specific segments parse as expected.
    
        NB: We're testing the PARSE function not the MATCH function
        although this will be a recursive parse and so the match
        function of SUBSECTIONS will be tested if present. The match
        function of the parent will not be tested.
        """
        config = FluffConfig(overrides=dict(dialect=dialect))
        seg_list = lex(raw, config=config)
        Seg = validate_segment(segmentref, config=config)
    
        # This test is different if we're working with RawSegment
        # derivatives or not.
        if isinstance(Seg, StringParser) or issubclass(Seg, RawSegment):
            print("Raw/Parser route...")
            with RootParseContext.from_config(config) as ctx:
                with caplog.at_level(logging.DEBUG):
                    parsed = Seg.match(segments=seg_list, parse_context=ctx)
            assert isinstance(parsed, MatchResult)
            assert len(parsed.matched_segments) == 1
            print(parsed)
            parsed = parsed.matched_segments[0]
            print(parsed)
        else:
            print("Base route...")
            # Construct an unparsed segment
            seg = Seg(seg_list, pos_marker=seg_list[0].pos_marker)
            # Perform the match (THIS IS THE MEAT OF THE TEST)
            with RootParseContext.from_config(config) as ctx:
                with caplog.at_level(logging.DEBUG):
                    parsed = seg.parse(parse_context=ctx)
            print(parsed)
            assert isinstance(parsed, Seg)
    
        # Check we get a good response
        print(parsed)
        print(type(parsed))
        # print(type(parsed._reconstruct()))
        print(type(parsed.raw))
        # Check we're all there.
        assert parsed.raw == raw
        # Check that there's nothing un parsable
        typs = parsed.type_set()
>       assert "unparsable" not in typs
E       AssertionError: assert 'unparsable' not in {'raw', 'select_clause_element', 'unparsable', 'whitespace'}

test/dialects/conftest.py:89: AssertionError
----------------------------- Captured stdout call -----------------------------
(<CodeSegment: ([L:  1, P:  1]) '-'>, <WhitespaceSegment: ([L:  1, P:  2]) ' '>, <CodeSegment: ([L:  1, P:  3]) 'some_variable'>)
Base route...
<SelectClauseElementSegment: ([L:  1, P:  1])>
<SelectClauseElementSegment: ([L:  1, P:  1])>
<class 'sqlfluff.dialects.dialect_ansi.SelectClauseElementSegment'>
<class 'str'>
------------------------------ Captured log call -------------------------------
INFO     sqlfluff.parser:match_logging.py:28 [PD:0  MD:0 ]	SelectClauseElementSegment                        	OneOf.match PRN     	    	[ns=2, ps=0, ms=0, pruned=[], opts=[<Ref: WildcardExpressionSegment>, <Sequence: [<Ref: BaseExpressionElementGrammar>, <Ref: AliasExpressionSegment [opt]>]>]]
INFO     sqlfluff.parser:match_logging.py:28 [PD:0  MD:2 ]	..WildcardExpressionSegment                       	Seque.match OUT     	    	[match=<MatchResult 0/3: ''>, seg="'- some_variable'"]
DEBUG    sqlfluff.parser:match_logging.py:30 [PD:0  MD:1 ]	.WildcardExpressionSegment                        	Wildc.match OUT     	    	[match=<MatchResult 0/3: ''>, seg="'- some_variable'"]
DEBUG    sqlfluff.parser:match_logging.py:30 [PD:0  MD:1 ]	.SelectClauseElementSegment                       	Ref.match OUT       	    	[match=<MatchResult 0/3: ''>, seg="'- some_variable'"]
INFO     sqlfluff.parser:match_logging.py:28 [PD:0  MD:1 ]	.SelectClauseElementSegment                       	Seque.match OUT     	    	[match=<MatchResult 0/3: ''>, seg="'- some_variable'"]
INFO     sqlfluff.parser:match_logging.py:28 [PD:0  MD:0 ]	SelectClauseElementSegment                        	OneOf.match OUT     	    	[match=<MatchResult 0/3: ''>, seg="'- some_variable'"]
DEBUG    sqlfluff.parser:base.py:859 SelectClauseElementSegment.parse: Done Parse. Plotting Recursion. Recurse=True
DEBUG    sqlfluff.parser:base.py:868 ###
#
# Beginning Parse Depth 1: SelectClauseElementSegment
#
###
Initial Structure:
[L:  1, P:  1]      |select_clause_element:
[L:  1, P:  1]      |    unparsable:                                               !! Expected: 'SelectClauseElementSegment'
[L:  1, P:  1]      |        raw:                                                  '-'
[L:  1, P:  2]      |        whitespace:                                           ' '
[L:  1, P:  3]      |        raw:                                                  'some_variable'

INFO     sqlfluff.parser:base.py:251 [PD:1] Skipping expansion of <UnparsableSegment: ([L:  1, P:  1])>...
_ test__dialect__ansi_specific_segment_parses[SelectClauseElementSegment-c is null as c_isnull] _

segmentref = 'SelectClauseElementSegment', raw = 'c is null as c_isnull'
caplog = <_pytest.logging.LogCaptureFixture object at 0x7a10851e9df0>
dialect_specific_segment_parses = <function _dialect_specific_segment_parses at 0x7a1085546dc0>

    @pytest.mark.parametrize(
        "segmentref,raw",
        [
            ("SelectKeywordSegment", "select"),
            ("NakedIdentifierSegment", "online_sales"),
            ("BareFunctionSegment", "current_timestamp"),
            ("FunctionSegment", "current_timestamp()"),
            ("NumericLiteralSegment", "1000.0"),
            ("ExpressionSegment", "online_sales / 1000.0"),
            ("IntervalExpressionSegment", "INTERVAL 1 YEAR"),
            ("ExpressionSegment", "CASE WHEN id = 1 THEN 'nothing' ELSE 'test' END"),
            # Nested Case Expressions
            # https://github.com/sqlfluff/sqlfluff/issues/172
            (
                "ExpressionSegment",
                (
                    "CASE WHEN id = 1 THEN CASE WHEN true THEN 'something' "
                    "ELSE 'nothing' END ELSE 'test' END"
                ),
            ),
            # Casting expressions
            # https://github.com/sqlfluff/sqlfluff/issues/161
            ("ExpressionSegment", "CAST(ROUND(online_sales / 1000.0) AS varchar)"),
            # Like expressions
            # https://github.com/sqlfluff/sqlfluff/issues/170
            ("ExpressionSegment", "name NOT LIKE '%y'"),
            # Functions with a space
            # https://github.com/sqlfluff/sqlfluff/issues/171
            ("SelectClauseElementSegment", "MIN (test.id) AS min_test_id"),
            # Interval literals
            # https://github.com/sqlfluff/sqlfluff/issues/148
            (
                "ExpressionSegment",
                "DATE_ADD(CURRENT_DATE('America/New_York'), INTERVAL 1 year)",
            ),
            # Array accessors
            ("ExpressionSegment", "my_array[1]"),
            ("ExpressionSegment", "my_array[OFFSET(1)]"),
            ("ExpressionSegment", "my_array[5:8]"),
            ("ExpressionSegment", "4 + my_array[OFFSET(1)]"),
            ("ExpressionSegment", "bits[OFFSET(0)] + 7"),
            (
                "SelectClauseElementSegment",
                (
                    "(count_18_24 * bits[OFFSET(0)])"
                    " / audience_size AS relative_abundance"
                ),
            ),
            ("ExpressionSegment", "count_18_24 * bits[OFFSET(0)] + count_25_34"),
            (
                "SelectClauseElementSegment",
                (
                    "(count_18_24 * bits[OFFSET(0)] + count_25_34)"
                    " / audience_size AS relative_abundance"
                ),
            ),
            # Dense math expressions
            # https://github.com/sqlfluff/sqlfluff/issues/178
            # https://github.com/sqlfluff/sqlfluff/issues/179
            ("SelectStatementSegment", "SELECT t.val/t.id FROM test WHERE id*1.0/id > 0.8"),
            ("SelectClauseElementSegment", "t.val/t.id"),
            # Issue with casting raise as part of PR #177
            ("SelectClauseElementSegment", "CAST(num AS INT64)"),
            # Casting as datatype with arguments
            ("SelectClauseElementSegment", "CAST(num AS numeric(8,4))"),
            # Wildcard field selection
            ("SelectClauseElementSegment", "a.*"),
            ("SelectClauseElementSegment", "a.b.*"),
            ("SelectClauseElementSegment", "a.b.c.*"),
            # Default Element Syntax
            ("ObjectReferenceSegment", "a..c.*"),
            # Negative Elements
            ("SelectClauseElementSegment", "-some_variable"),
            ("SelectClauseElementSegment", "- some_variable"),
            # Complex Functions
            (
                "ExpressionSegment",
                "concat(left(uaid, 2), '|', right(concat('0000000', SPLIT_PART(uaid, '|', 4)), 10), '|', '00000000')",
            ),
            # Notnull and Isnull
            ("ExpressionSegment", "c is null"),
            ("ExpressionSegment", "c is not null"),
            ("SelectClauseElementSegment", "c is null as c_isnull"),
            ("SelectClauseElementSegment", "c is not null as c_notnull"),
            # Shorthand casting
            ("ExpressionSegment", "NULL::INT"),
            ("SelectClauseElementSegment", "NULL::INT AS user_id"),
            ("TruncateStatementSegment", "TRUNCATE TABLE test"),
            ("TruncateStatementSegment", "TRUNCATE test"),
        ],
    )
    def test__dialect__ansi_specific_segment_parses(
        segmentref, raw, caplog, dialect_specific_segment_parses
    ):
        """Test that specific segments parse as expected.
    
        NB: We're testing the PARSE function not the MATCH function
        although this will be a recursive parse and so the match
        function of SUBSECTIONS will be tested if present. The match
        function of the parent will not be tested.
        """
>       dialect_specific_segment_parses("ansi", segmentref, raw, caplog)

test/dialects/ansi_test.py:132: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

dialect = 'ansi', segmentref = 'SelectClauseElementSegment'
raw = 'c is null as c_isnull'
caplog = <_pytest.logging.LogCaptureFixture object at 0x7a10851e9df0>

    def _dialect_specific_segment_parses(dialect, segmentref, raw, caplog):
        """Test that specific segments parse as expected.
    
        NB: We're testing the PARSE function not the MATCH function
        although this will be a recursive parse and so the match
        function of SUBSECTIONS will be tested if present. The match
        function of the parent will not be tested.
        """
        config = FluffConfig(overrides=dict(dialect=dialect))
        seg_list = lex(raw, config=config)
        Seg = validate_segment(segmentref, config=config)
    
        # This test is different if we're working with RawSegment
        # derivatives or not.
        if isinstance(Seg, StringParser) or issubclass(Seg, RawSegment):
            print("Raw/Parser route...")
            with RootParseContext.from_config(config) as ctx:
                with caplog.at_level(logging.DEBUG):
                    parsed = Seg.match(segments=seg_list, parse_context=ctx)
            assert isinstance(parsed, MatchResult)
            assert len(parsed.matched_segments) == 1
            print(parsed)
            parsed = parsed.matched_segments[0]
            print(parsed)
        else:
            print("Base route...")
            # Construct an unparsed segment
            seg = Seg(seg_list, pos_marker=seg_list[0].pos_marker)
            # Perform the match (THIS IS THE MEAT OF THE TEST)
            with RootParseContext.from_config(config) as ctx:
                with caplog.at_level(logging.DEBUG):
                    parsed = seg.parse(parse_context=ctx)
            print(parsed)
            assert isinstance(parsed, Seg)
    
        # Check we get a good response
        print(parsed)
        print(type(parsed))
        # print(type(parsed._reconstruct()))
        print(type(parsed.raw))
        # Check we're all there.
        assert parsed.raw == raw
        # Check that there's nothing un parsable
        typs = parsed.type_set()
>       assert "unparsable" not in typs
E       AssertionError: assert 'unparsable' not in {'raw', 'select_clause_element', 'unparsable', 'whitespace'}

test/dialects/conftest.py:89: AssertionError
----------------------------- Captured stdout call -----------------------------
(<CodeSegment: ([L:  1, P:  1]) 'c'>, <WhitespaceSegment: ([L:  1, P:  2]) ' '>, <CodeSegment: ([L:  1, P:  3]) 'is'>, <WhitespaceSegment: ([L:  1, P:  5]) ' '>, <CodeSegment: ([L:  1, P:  6]) 'null'>, <WhitespaceSegment: ([L:  1, P: 10]) ' '>, <CodeSegment: ([L:  1, P: 11]) 'as'>, <WhitespaceSegment: ([L:  1, P: 13]) ' '>, <CodeSegment: ([L:  1, P: 14]) 'c_isnull'>)
Base route...
<SelectClauseElementSegment: ([L:  1, P:  1])>
<SelectClauseElementSegment: ([L:  1, P:  1])>
<class 'sqlfluff.dialects.dialect_ansi.SelectClauseElementSegment'>
<class 'str'>
------------------------------ Captured log call -------------------------------
INFO     sqlfluff.parser:match_logging.py:28 [PD:0  MD:0 ]	SelectClauseElementSegment                        	OneOf.match PRN     	    	[ns=2, ps=0, ms=0, pruned=[], opts=[<Ref: WildcardExpressionSegment>, <Sequence: [<Ref: BaseExpressionElementGrammar>, <Ref: AliasExpressionSegment [opt]>]>]]
INFO     sqlfluff.parser:match_logging.py:28 [PD:0  MD:2 ]	..WildcardExpressionSegment                       	Seque.match OUT     	    	[match=<MatchResult 0/9: ''>, seg="'c is null as c_isnul...'"]
DEBUG    sqlfluff.parser:match_logging.py:30 [PD:0  MD:1 ]	.WildcardExpressionSegment                        	Wildc.match OUT     	    	[match=<MatchResult 0/9: ''>, seg="'c is null as c_isnul...'"]
DEBUG    sqlfluff.parser:match_logging.py:30 [PD:0  MD:1 ]	.SelectClauseElementSegment                       	Ref.match OUT       	    	[match=<MatchResult 0/9: ''>, seg="'c is null as c_isnul...'"]
INFO     sqlfluff.parser:match_logging.py:28 [PD:0  MD:1 ]	.SelectClauseElementSegment                       	Seque.match OUT     	    	[match=<MatchResult 0/9: ''>, seg="'c is null as c_isnul...'"]
INFO     sqlfluff.parser:match_logging.py:28 [PD:0  MD:0 ]	SelectClauseElementSegment                        	OneOf.match OUT     	    	[match=<MatchResult 0/9: ''>, seg="'c is null as c_isnul...'"]
DEBUG    sqlfluff.parser:base.py:859 SelectClauseElementSegment.parse: Done Parse. Plotting Recursion. Recurse=True
DEBUG    sqlfluff.parser:base.py:868 ###
#
# Beginning Parse Depth 1: SelectClauseElementSegment
#
###
Initial Structure:
[L:  1, P:  1]      |select_clause_element:
[L:  1, P:  1]      |    unparsable:                                               !! Expected: 'SelectClauseElementSegment'
[L:  1, P:  1]      |        raw:                                                  'c'
[L:  1, P:  2]      |        whitespace:                                           ' '
[L:  1, P:  3]      |        raw:                                                  'is'
[L:  1, P:  5]      |        whitespace:                                           ' '
[L:  1, P:  6]      |        raw:                                                  'null'
[L:  1, P: 10]      |        whitespace:                                           ' '
[L:  1, P: 11]      |        raw:                                                  'as'
[L:  1, P: 13]      |        whitespace:                                           ' '
[L:  1, P: 14]      |        raw:                                                  'c_isnull'

INFO     sqlfluff.parser:base.py:251 [PD:1] Skipping expansion of <UnparsableSegment: ([L:  1, P:  1])>...
_ test__dialect__ansi_specific_segment_parses[SelectClauseElementSegment-c is not null as c_notnull] _

segmentref = 'SelectClauseElementSegment', raw = 'c is not null as c_notnull'
caplog = <_pytest.logging.LogCaptureFixture object at 0x7a108517b220>
dialect_specific_segment_parses = <function _dialect_specific_segment_parses at 0x7a1085546dc0>

    @pytest.mark.parametrize(
        "segmentref,raw",
        [
            ("SelectKeywordSegment", "select"),
            ("NakedIdentifierSegment", "online_sales"),
            ("BareFunctionSegment", "current_timestamp"),
            ("FunctionSegment", "current_timestamp()"),
            ("NumericLiteralSegment", "1000.0"),
            ("ExpressionSegment", "online_sales / 1000.0"),
            ("IntervalExpressionSegment", "INTERVAL 1 YEAR"),
            ("ExpressionSegment", "CASE WHEN id = 1 THEN 'nothing' ELSE 'test' END"),
            # Nested Case Expressions
            # https://github.com/sqlfluff/sqlfluff/issues/172
            (
                "ExpressionSegment",
                (
                    "CASE WHEN id = 1 THEN CASE WHEN true THEN 'something' "
                    "ELSE 'nothing' END ELSE 'test' END"
                ),
            ),
            # Casting expressions
            # https://github.com/sqlfluff/sqlfluff/issues/161
            ("ExpressionSegment", "CAST(ROUND(online_sales / 1000.0) AS varchar)"),
            # Like expressions
            # https://github.com/sqlfluff/sqlfluff/issues/170
            ("ExpressionSegment", "name NOT LIKE '%y'"),
            # Functions with a space
            # https://github.com/sqlfluff/sqlfluff/issues/171
            ("SelectClauseElementSegment", "MIN (test.id) AS min_test_id"),
            # Interval literals
            # https://github.com/sqlfluff/sqlfluff/issues/148
            (
                "ExpressionSegment",
                "DATE_ADD(CURRENT_DATE('America/New_York'), INTERVAL 1 year)",
            ),
            # Array accessors
            ("ExpressionSegment", "my_array[1]"),
            ("ExpressionSegment", "my_array[OFFSET(1)]"),
            ("ExpressionSegment", "my_array[5:8]"),
            ("ExpressionSegment", "4 + my_array[OFFSET(1)]"),
            ("ExpressionSegment", "bits[OFFSET(0)] + 7"),
            (
                "SelectClauseElementSegment",
                (
                    "(count_18_24 * bits[OFFSET(0)])"
                    " / audience_size AS relative_abundance"
                ),
            ),
            ("ExpressionSegment", "count_18_24 * bits[OFFSET(0)] + count_25_34"),
            (
                "SelectClauseElementSegment",
                (
                    "(count_18_24 * bits[OFFSET(0)] + count_25_34)"
                    " / audience_size AS relative_abundance"
                ),
            ),
            # Dense math expressions
            # https://github.com/sqlfluff/sqlfluff/issues/178
            # https://github.com/sqlfluff/sqlfluff/issues/179
            ("SelectStatementSegment", "SELECT t.val/t.id FROM test WHERE id*1.0/id > 0.8"),
            ("SelectClauseElementSegment", "t.val/t.id"),
            # Issue with casting raise as part of PR #177
            ("SelectClauseElementSegment", "CAST(num AS INT64)"),
            # Casting as datatype with arguments
            ("SelectClauseElementSegment", "CAST(num AS numeric(8,4))"),
            # Wildcard field selection
            ("SelectClauseElementSegment", "a.*"),
            ("SelectClauseElementSegment", "a.b.*"),
            ("SelectClauseElementSegment", "a.b.c.*"),
            # Default Element Syntax
            ("ObjectReferenceSegment", "a..c.*"),
            # Negative Elements
            ("SelectClauseElementSegment", "-some_variable"),
            ("SelectClauseElementSegment", "- some_variable"),
            # Complex Functions
            (
                "ExpressionSegment",
                "concat(left(uaid, 2), '|', right(concat('0000000', SPLIT_PART(uaid, '|', 4)), 10), '|', '00000000')",
            ),
            # Notnull and Isnull
            ("ExpressionSegment", "c is null"),
            ("ExpressionSegment", "c is not null"),
            ("SelectClauseElementSegment", "c is null as c_isnull"),
            ("SelectClauseElementSegment", "c is not null as c_notnull"),
            # Shorthand casting
            ("ExpressionSegment", "NULL::INT"),
            ("SelectClauseElementSegment", "NULL::INT AS user_id"),
            ("TruncateStatementSegment", "TRUNCATE TABLE test"),
            ("TruncateStatementSegment", "TRUNCATE test"),
        ],
    )
    def test__dialect__ansi_specific_segment_parses(
        segmentref, raw, caplog, dialect_specific_segment_parses
    ):
        """Test that specific segments parse as expected.
    
        NB: We're testing the PARSE function not the MATCH function
        although this will be a recursive parse and so the match
        function of SUBSECTIONS will be tested if present. The match
        function of the parent will not be tested.
        """
>       dialect_specific_segment_parses("ansi", segmentref, raw, caplog)

test/dialects/ansi_test.py:132: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

dialect = 'ansi', segmentref = 'SelectClauseElementSegment'
raw = 'c is not null as c_notnull'
caplog = <_pytest.logging.LogCaptureFixture object at 0x7a108517b220>

    def _dialect_specific_segment_parses(dialect, segmentref, raw, caplog):
        """Test that specific segments parse as expected.
    
        NB: We're testing the PARSE function not the MATCH function
        although this will be a recursive parse and so the match
        function of SUBSECTIONS will be tested if present. The match
        function of the parent will not be tested.
        """
        config = FluffConfig(overrides=dict(dialect=dialect))
        seg_list = lex(raw, config=config)
        Seg = validate_segment(segmentref, config=config)
    
        # This test is different if we're working with RawSegment
        # derivatives or not.
        if isinstance(Seg, StringParser) or issubclass(Seg, RawSegment):
            print("Raw/Parser route...")
            with RootParseContext.from_config(config) as ctx:
                with caplog.at_level(logging.DEBUG):
                    parsed = Seg.match(segments=seg_list, parse_context=ctx)
            assert isinstance(parsed, MatchResult)
            assert len(parsed.matched_segments) == 1
            print(parsed)
            parsed = parsed.matched_segments[0]
            print(parsed)
        else:
            print("Base route...")
            # Construct an unparsed segment
            seg = Seg(seg_list, pos_marker=seg_list[0].pos_marker)
            # Perform the match (THIS IS THE MEAT OF THE TEST)
            with RootParseContext.from_config(config) as ctx:
                with caplog.at_level(logging.DEBUG):
                    parsed = seg.parse(parse_context=ctx)
            print(parsed)
            assert isinstance(parsed, Seg)
    
        # Check we get a good response
        print(parsed)
        print(type(parsed))
        # print(type(parsed._reconstruct()))
        print(type(parsed.raw))
        # Check we're all there.
        assert parsed.raw == raw
        # Check that there's nothing un parsable
        typs = parsed.type_set()
>       assert "unparsable" not in typs
E       AssertionError: assert 'unparsable' not in {'raw', 'select_clause_element', 'unparsable', 'whitespace'}

test/dialects/conftest.py:89: AssertionError
----------------------------- Captured stdout call -----------------------------
(<CodeSegment: ([L:  1, P:  1]) 'c'>, <WhitespaceSegment: ([L:  1, P:  2]) ' '>, <CodeSegment: ([L:  1, P:  3]) 'is'>, <WhitespaceSegment: ([L:  1, P:  5]) ' '>, <CodeSegment: ([L:  1, P:  6]) 'not'>, <WhitespaceSegment: ([L:  1, P:  9]) ' '>, <CodeSegment: ([L:  1, P: 10]) 'null'>, <WhitespaceSegment: ([L:  1, P: 14]) ' '>, <CodeSegment: ([L:  1, P: 15]) 'as'>, <WhitespaceSegment: ([L:  1, P: 17]) ' '>, <CodeSegment: ([L:  1, P: 18]) 'c_notnull'>)
Base route...
<SelectClauseElementSegment: ([L:  1, P:  1])>
<SelectClauseElementSegment: ([L:  1, P:  1])>
<class 'sqlfluff.dialects.dialect_ansi.SelectClauseElementSegment'>
<class 'str'>
------------------------------ Captured log call -------------------------------
INFO     sqlfluff.parser:match_logging.py:28 [PD:0  MD:0 ]	SelectClauseElementSegment                        	OneOf.match PRN     	    	[ns=2, ps=0, ms=0, pruned=[], opts=[<Ref: WildcardExpressionSegment>, <Sequence: [<Ref: BaseExpressionElementGrammar>, <Ref: AliasExpressionSegment [opt]>]>]]
INFO     sqlfluff.parser:match_logging.py:28 [PD:0  MD:2 ]	..WildcardExpressionSegment                       	Seque.match OUT     	    	[match=<MatchResult 0/11: ''>, seg="'c is not null as c_n...'"]
DEBUG    sqlfluff.parser:match_logging.py:30 [PD:0  MD:1 ]	.WildcardExpressionSegment                        	Wildc.match OUT     	    	[match=<MatchResult 0/11: ''>, seg="'c is not null as c_n...'"]
DEBUG    sqlfluff.parser:match_logging.py:30 [PD:0  MD:1 ]	.SelectClauseElementSegment                       	Ref.match OUT       	    	[match=<MatchResult 0/11: ''>, seg="'c is not null as c_n...'"]
INFO     sqlfluff.parser:match_logging.py:28 [PD:0  MD:1 ]	.SelectClauseElementSegment                       	Seque.match OUT     	    	[match=<MatchResult 0/11: ''>, seg="'c is not null as c_n...'"]
INFO     sqlfluff.parser:match_logging.py:28 [PD:0  MD:0 ]	SelectClauseElementSegment                        	OneOf.match OUT     	    	[match=<MatchResult 0/11: ''>, seg="'c is not null as c_n...'"]
DEBUG    sqlfluff.parser:base.py:859 SelectClauseElementSegment.parse: Done Parse. Plotting Recursion. Recurse=True
DEBUG    sqlfluff.parser:base.py:868 ###
#
# Beginning Parse Depth 1: SelectClauseElementSegment
#
###
Initial Structure:
[L:  1, P:  1]      |select_clause_element:
[L:  1, P:  1]      |    unparsable:                                               !! Expected: 'SelectClauseElementSegment'
[L:  1, P:  1]      |        raw:                                                  'c'
[L:  1, P:  2]      |        whitespace:                                           ' '
[L:  1, P:  3]      |        raw:                                                  'is'
[L:  1, P:  5]      |        whitespace:                                           ' '
[L:  1, P:  6]      |        raw:                                                  'not'
[L:  1, P:  9]      |        whitespace:                                           ' '
[L:  1, P: 10]      |        raw:                                                  'null'
[L:  1, P: 14]      |        whitespace:                                           ' '
[L:  1, P: 15]      |        raw:                                                  'as'
[L:  1, P: 17]      |        whitespace:                                           ' '
[L:  1, P: 18]      |        raw:                                                  'c_notnull'

INFO     sqlfluff.parser:base.py:251 [PD:1] Skipping expansion of <UnparsableSegment: ([L:  1, P:  1])>...
_ test__dialect__ansi_specific_segment_parses[SelectClauseElementSegment-NULL::INT AS user_id] _

segmentref = 'SelectClauseElementSegment', raw = 'NULL::INT AS user_id'
caplog = <_pytest.logging.LogCaptureFixture object at 0x7a108522b3a0>
dialect_specific_segment_parses = <function _dialect_specific_segment_parses at 0x7a1085546dc0>

    @pytest.mark.parametrize(
        "segmentref,raw",
        [
            ("SelectKeywordSegment", "select"),
            ("NakedIdentifierSegment", "online_sales"),
            ("BareFunctionSegment", "current_timestamp"),
            ("FunctionSegment", "current_timestamp()"),
            ("NumericLiteralSegment", "1000.0"),
            ("ExpressionSegment", "online_sales / 1000.0"),
            ("IntervalExpressionSegment", "INTERVAL 1 YEAR"),
            ("ExpressionSegment", "CASE WHEN id = 1 THEN 'nothing' ELSE 'test' END"),
            # Nested Case Expressions
            # https://github.com/sqlfluff/sqlfluff/issues/172
            (
                "ExpressionSegment",
                (
                    "CASE WHEN id = 1 THEN CASE WHEN true THEN 'something' "
                    "ELSE 'nothing' END ELSE 'test' END"
                ),
            ),
            # Casting expressions
            # https://github.com/sqlfluff/sqlfluff/issues/161
            ("ExpressionSegment", "CAST(ROUND(online_sales / 1000.0) AS varchar)"),
            # Like expressions
            # https://github.com/sqlfluff/sqlfluff/issues/170
            ("ExpressionSegment", "name NOT LIKE '%y'"),
            # Functions with a space
            # https://github.com/sqlfluff/sqlfluff/issues/171
            ("SelectClauseElementSegment", "MIN (test.id) AS min_test_id"),
            # Interval literals
            # https://github.com/sqlfluff/sqlfluff/issues/148
            (
                "ExpressionSegment",
                "DATE_ADD(CURRENT_DATE('America/New_York'), INTERVAL 1 year)",
            ),
            # Array accessors
            ("ExpressionSegment", "my_array[1]"),
            ("ExpressionSegment", "my_array[OFFSET(1)]"),
            ("ExpressionSegment", "my_array[5:8]"),
            ("ExpressionSegment", "4 + my_array[OFFSET(1)]"),
            ("ExpressionSegment", "bits[OFFSET(0)] + 7"),
            (
                "SelectClauseElementSegment",
                (
                    "(count_18_24 * bits[OFFSET(0)])"
                    " / audience_size AS relative_abundance"
                ),
            ),
            ("ExpressionSegment", "count_18_24 * bits[OFFSET(0)] + count_25_34"),
            (
                "SelectClauseElementSegment",
                (
                    "(count_18_24 * bits[OFFSET(0)] + count_25_34)"
                    " / audience_size AS relative_abundance"
                ),
            ),
            # Dense math expressions
            # https://github.com/sqlfluff/sqlfluff/issues/178
            # https://github.com/sqlfluff/sqlfluff/issues/179
            ("SelectStatementSegment", "SELECT t.val/t.id FROM test WHERE id*1.0/id > 0.8"),
            ("SelectClauseElementSegment", "t.val/t.id"),
            # Issue with casting raise as part of PR #177
            ("SelectClauseElementSegment", "CAST(num AS INT64)"),
            # Casting as datatype with arguments
            ("SelectClauseElementSegment", "CAST(num AS numeric(8,4))"),
            # Wildcard field selection
            ("SelectClauseElementSegment", "a.*"),
            ("SelectClauseElementSegment", "a.b.*"),
            ("SelectClauseElementSegment", "a.b.c.*"),
            # Default Element Syntax
            ("ObjectReferenceSegment", "a..c.*"),
            # Negative Elements
            ("SelectClauseElementSegment", "-some_variable"),
            ("SelectClauseElementSegment", "- some_variable"),
            # Complex Functions
            (
                "ExpressionSegment",
                "concat(left(uaid, 2), '|', right(concat('0000000', SPLIT_PART(uaid, '|', 4)), 10), '|', '00000000')",
            ),
            # Notnull and Isnull
            ("ExpressionSegment", "c is null"),
            ("ExpressionSegment", "c is not null"),
            ("SelectClauseElementSegment", "c is null as c_isnull"),
            ("SelectClauseElementSegment", "c is not null as c_notnull"),
            # Shorthand casting
            ("ExpressionSegment", "NULL::INT"),
            ("SelectClauseElementSegment", "NULL::INT AS user_id"),
            ("TruncateStatementSegment", "TRUNCATE TABLE test"),
            ("TruncateStatementSegment", "TRUNCATE test"),
        ],
    )
    def test__dialect__ansi_specific_segment_parses(
        segmentref, raw, caplog, dialect_specific_segment_parses
    ):
        """Test that specific segments parse as expected.
    
        NB: We're testing the PARSE function not the MATCH function
        although this will be a recursive parse and so the match
        function of SUBSECTIONS will be tested if present. The match
        function of the parent will not be tested.
        """
>       dialect_specific_segment_parses("ansi", segmentref, raw, caplog)

test/dialects/ansi_test.py:132: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

dialect = 'ansi', segmentref = 'SelectClauseElementSegment'
raw = 'NULL::INT AS user_id'
caplog = <_pytest.logging.LogCaptureFixture object at 0x7a108522b3a0>

    def _dialect_specific_segment_parses(dialect, segmentref, raw, caplog):
        """Test that specific segments parse as expected.
    
        NB: We're testing the PARSE function not the MATCH function
        although this will be a recursive parse and so the match
        function of SUBSECTIONS will be tested if present. The match
        function of the parent will not be tested.
        """
        config = FluffConfig(overrides=dict(dialect=dialect))
        seg_list = lex(raw, config=config)
        Seg = validate_segment(segmentref, config=config)
    
        # This test is different if we're working with RawSegment
        # derivatives or not.
        if isinstance(Seg, StringParser) or issubclass(Seg, RawSegment):
            print("Raw/Parser route...")
            with RootParseContext.from_config(config) as ctx:
                with caplog.at_level(logging.DEBUG):
                    parsed = Seg.match(segments=seg_list, parse_context=ctx)
            assert isinstance(parsed, MatchResult)
            assert len(parsed.matched_segments) == 1
            print(parsed)
            parsed = parsed.matched_segments[0]
            print(parsed)
        else:
            print("Base route...")
            # Construct an unparsed segment
            seg = Seg(seg_list, pos_marker=seg_list[0].pos_marker)
            # Perform the match (THIS IS THE MEAT OF THE TEST)
            with RootParseContext.from_config(config) as ctx:
                with caplog.at_level(logging.DEBUG):
                    parsed = seg.parse(parse_context=ctx)
            print(parsed)
            assert isinstance(parsed, Seg)
    
        # Check we get a good response
        print(parsed)
        print(type(parsed))
        # print(type(parsed._reconstruct()))
        print(type(parsed.raw))
        # Check we're all there.
        assert parsed.raw == raw
        # Check that there's nothing un parsable
        typs = parsed.type_set()
>       assert "unparsable" not in typs
E       AssertionError: assert 'unparsable' not in {'raw', 'select_clause_element', 'unparsable', 'whitespace'}

test/dialects/conftest.py:89: AssertionError
----------------------------- Captured stdout call -----------------------------
(<CodeSegment: ([L:  1, P:  1]) 'NULL'>, <CodeSegment: ([L:  1, P:  5]) '::'>, <CodeSegment: ([L:  1, P:  7]) 'INT'>, <WhitespaceSegment: ([L:  1, P: 10]) ' '>, <CodeSegment: ([L:  1, P: 11]) 'AS'>, <WhitespaceSegment: ([L:  1, P: 13]) ' '>, <CodeSegment: ([L:  1, P: 14]) 'user_id'>)
Base route...
<SelectClauseElementSegment: ([L:  1, P:  1])>
<SelectClauseElementSegment: ([L:  1, P:  1])>
<class 'sqlfluff.dialects.dialect_ansi.SelectClauseElementSegment'>
<class 'str'>
------------------------------ Captured log call -------------------------------
INFO     sqlfluff.parser:match_logging.py:28 [PD:0  MD:0 ]	SelectClauseElementSegment                        	OneOf.match PRN     	    	[ns=2, ps=0, ms=0, pruned=[], opts=[<Ref: WildcardExpressionSegment>, <Sequence: [<Ref: BaseExpressionElementGrammar>, <Ref: AliasExpressionSegment [opt]>]>]]
INFO     sqlfluff.parser:match_logging.py:28 [PD:0  MD:2 ]	..WildcardExpressionSegment                       	Seque.match OUT     	    	[match=<MatchResult 0/7: ''>, seg="'NULL::INT AS user_id'"]
DEBUG    sqlfluff.parser:match_logging.py:30 [PD:0  MD:1 ]	.WildcardExpressionSegment                        	Wildc.match OUT     	    	[match=<MatchResult 0/7: ''>, seg="'NULL::INT AS user_id'"]
DEBUG    sqlfluff.parser:match_logging.py:30 [PD:0  MD:1 ]	.SelectClauseElementSegment                       	Ref.match OUT       	    	[match=<MatchResult 0/7: ''>, seg="'NULL::INT AS user_id'"]
INFO     sqlfluff.parser:match_logging.py:28 [PD:0  MD:1 ]	.SelectClauseElementSegment                       	Seque.match OUT     	    	[match=<MatchResult 0/7: ''>, seg="'NULL::INT AS user_id'"]
INFO     sqlfluff.parser:match_logging.py:28 [PD:0  MD:0 ]	SelectClauseElementSegment                        	OneOf.match OUT     	    	[match=<MatchResult 0/7: ''>, seg="'NULL::INT AS user_id'"]
DEBUG    sqlfluff.parser:base.py:859 SelectClauseElementSegment.parse: Done Parse. Plotting Recursion. Recurse=True
DEBUG    sqlfluff.parser:base.py:868 ###
#
# Beginning Parse Depth 1: SelectClauseElementSegment
#
###
Initial Structure:
[L:  1, P:  1]      |select_clause_element:
[L:  1, P:  1]      |    unparsable:                                               !! Expected: 'SelectClauseElementSegment'
[L:  1, P:  1]      |        raw:                                                  'NULL'
[L:  1, P:  5]      |        raw:                                                  '::'
[L:  1, P:  7]      |        raw:                                                  'INT'
[L:  1, P: 10]      |        whitespace:                                           ' '
[L:  1, P: 11]      |        raw:                                                  'AS'
[L:  1, P: 13]      |        whitespace:                                           ' '
[L:  1, P: 14]      |        raw:                                                  'user_id'

INFO     sqlfluff.parser:base.py:251 [PD:1] Skipping expansion of <UnparsableSegment: ([L:  1, P:  1])>...
_ test__dialect__ansi_specific_segment_not_parse[SELECT * FROM a ORDER BY 1 UNION SELECT * FROM b-err_locations1] _

raw = 'SELECT * FROM a ORDER BY 1 UNION SELECT * FROM b'
err_locations = [(1, 27)]
caplog = <_pytest.logging.LogCaptureFixture object at 0x7a1085250d30>

    @pytest.mark.parametrize(
        "raw,err_locations",
        [
            # Missing Closing bracket. Error should be raised
            # on the starting bracket.
            ("SELECT 1 + (2 ", [(1, 12)]),
            # Set expression with inappropriate ORDER BY or LIMIT. Error
            # raised on the UNION.
            ("SELECT * FROM a ORDER BY 1 UNION SELECT * FROM b", [(1, 27)]),
            ("SELECT * FROM a LIMIT 1 UNION SELECT * FROM b", [(1, 24)]),
            ("SELECT * FROM a ORDER BY 1 LIMIT 1 UNION SELECT * FROM b", [(1, 35)]),
        ],
    )
    def test__dialect__ansi_specific_segment_not_parse(raw, err_locations, caplog):
        """Test queries do not parse, with parsing errors raised properly."""
        lnt = Linter()
        parsed = lnt.parse_string(raw)
        assert len(parsed.violations) > 0
        print(parsed.violations)
        locs = [(v.line_no, v.line_pos) for v in parsed.violations]
>       assert locs == err_locations
E       assert [(1, 1)] == [(1, 27)]
E         
E         At index 0 diff: (1, 1) != (1, 27)
E         Use -v to get more diff

test/dialects/ansi_test.py:173: AssertionError
----------------------------- Captured stdout call -----------------------------
[SQLParseError("Line 1, Position 1: Found unparsable section: 'SELECT * FROM a ORDER BY 1 UNION SELECT ...'")]
_ test__dialect__ansi_specific_segment_not_parse[SELECT * FROM a LIMIT 1 UNION SELECT * FROM b-err_locations2] _

raw = 'SELECT * FROM a LIMIT 1 UNION SELECT * FROM b', err_locations = [(1, 24)]
caplog = <_pytest.logging.LogCaptureFixture object at 0x7a10854cbf70>

    @pytest.mark.parametrize(
        "raw,err_locations",
        [
            # Missing Closing bracket. Error should be raised
            # on the starting bracket.
            ("SELECT 1 + (2 ", [(1, 12)]),
            # Set expression with inappropriate ORDER BY or LIMIT. Error
            # raised on the UNION.
            ("SELECT * FROM a ORDER BY 1 UNION SELECT * FROM b", [(1, 27)]),
            ("SELECT * FROM a LIMIT 1 UNION SELECT * FROM b", [(1, 24)]),
            ("SELECT * FROM a ORDER BY 1 LIMIT 1 UNION SELECT * FROM b", [(1, 35)]),
        ],
    )
    def test__dialect__ansi_specific_segment_not_parse(raw, err_locations, caplog):
        """Test queries do not parse, with parsing errors raised properly."""
        lnt = Linter()
        parsed = lnt.parse_string(raw)
        assert len(parsed.violations) > 0
        print(parsed.violations)
        locs = [(v.line_no, v.line_pos) for v in parsed.violations]
>       assert locs == err_locations
E       assert [(1, 1)] == [(1, 24)]
E         
E         At index 0 diff: (1, 1) != (1, 24)
E         Use -v to get more diff

test/dialects/ansi_test.py:173: AssertionError
----------------------------- Captured stdout call -----------------------------
[SQLParseError("Line 1, Position 1: Found unparsable section: 'SELECT * FROM a LIMIT 1 UNION SELECT * F...'")]
_ test__dialect__ansi_specific_segment_not_parse[SELECT * FROM a ORDER BY 1 LIMIT 1 UNION SELECT * FROM b-err_locations3] _

raw = 'SELECT * FROM a ORDER BY 1 LIMIT 1 UNION SELECT * FROM b'
err_locations = [(1, 35)]
caplog = <_pytest.logging.LogCaptureFixture object at 0x7a1085392f10>

    @pytest.mark.parametrize(
        "raw,err_locations",
        [
            # Missing Closing bracket. Error should be raised
            # on the starting bracket.
            ("SELECT 1 + (2 ", [(1, 12)]),
            # Set expression with inappropriate ORDER BY or LIMIT. Error
            # raised on the UNION.
            ("SELECT * FROM a ORDER BY 1 UNION SELECT * FROM b", [(1, 27)]),
            ("SELECT * FROM a LIMIT 1 UNION SELECT * FROM b", [(1, 24)]),
            ("SELECT * FROM a ORDER BY 1 LIMIT 1 UNION SELECT * FROM b", [(1, 35)]),
        ],
    )
    def test__dialect__ansi_specific_segment_not_parse(raw, err_locations, caplog):
        """Test queries do not parse, with parsing errors raised properly."""
        lnt = Linter()
        parsed = lnt.parse_string(raw)
        assert len(parsed.violations) > 0
        print(parsed.violations)
        locs = [(v.line_no, v.line_pos) for v in parsed.violations]
>       assert locs == err_locations
E       assert [(1, 1)] == [(1, 35)]
E         
E         At index 0 diff: (1, 1) != (1, 35)
E         Use -v to get more diff

test/dialects/ansi_test.py:173: AssertionError
----------------------------- Captured stdout call -----------------------------
[SQLParseError("Line 1, Position 1: Found unparsable section: 'SELECT * FROM a ORDER BY 1 LIMIT 1 UNION...'")]
_ test__dialect__ansi_parse_indented_joins[select field_1 from my_table as alias_1-True-meta_loc0] _

sql_string = 'select field_1 from my_table as alias_1', indented_joins = True
meta_loc = (1, 5, 8, 14)

    @pytest.mark.parametrize(
        "sql_string, indented_joins,meta_loc",
        [
            ("select field_1 from my_table as alias_1", True, (1, 5, 8, 14)),
            ("select field_1 from my_table as alias_1", False, (1, 5, 8, 14)),
            (
                "select field_1 from my_table as alias_1 join foo using (field_1)",
                True,
                (1, 5, 8, 16, 21, 24, 26, 28, 29, 30),
            ),
            (
                "select field_1 from my_table as alias_1 join foo using (field_1)",
                False,
                (1, 5, 8, 15, 17, 22, 25, 27, 29, 30),
            ),
        ],
    )
    def test__dialect__ansi_parse_indented_joins(sql_string, indented_joins, meta_loc):
        """Test parsing of meta segments using Conditional works with indented_joins."""
        lnt = Linter(
            config=FluffConfig(configs={"indentation": {"indented_joins": indented_joins}})
        )
        parsed = lnt.parse_string(sql_string)
        # Check that there's nothing unparsable
>       assert "unparsable" not in parsed.tree.type_set()
E       assert 'unparsable' not in {'file', 'raw', 'statement', 'unparsable', 'whitespace'}
E        +  where {'file', 'raw', 'statement', 'unparsable', 'whitespace'} = type_set()
E        +    where type_set = <FileSegment: ([L:  1, P:  1])>.type_set
E        +      where <FileSegment: ([L:  1, P:  1])> = ParsedString(tree=<FileSegment: ([L:  1, P:  1])>, violations=[SQLParseError("Line 1, Position 1: Found unparsable sec..., templated_file=<TemplatedFile>, config=<sqlfluff.core.config.FluffConfig object at 0x7a10854a3760>, fname='<string>').tree

test/dialects/ansi_test.py:211: AssertionError
_ test__dialect__ansi_parse_indented_joins[select field_1 from my_table as alias_1-False-meta_loc1] _

sql_string = 'select field_1 from my_table as alias_1', indented_joins = False
meta_loc = (1, 5, 8, 14)

    @pytest.mark.parametrize(
        "sql_string, indented_joins,meta_loc",
        [
            ("select field_1 from my_table as alias_1", True, (1, 5, 8, 14)),
            ("select field_1 from my_table as alias_1", False, (1, 5, 8, 14)),
            (
                "select field_1 from my_table as alias_1 join foo using (field_1)",
                True,
                (1, 5, 8, 16, 21, 24, 26, 28, 29, 30),
            ),
            (
                "select field_1 from my_table as alias_1 join foo using (field_1)",
                False,
                (1, 5, 8, 15, 17, 22, 25, 27, 29, 30),
            ),
        ],
    )
    def test__dialect__ansi_parse_indented_joins(sql_string, indented_joins, meta_loc):
        """Test parsing of meta segments using Conditional works with indented_joins."""
        lnt = Linter(
            config=FluffConfig(configs={"indentation": {"indented_joins": indented_joins}})
        )
        parsed = lnt.parse_string(sql_string)
        # Check that there's nothing unparsable
>       assert "unparsable" not in parsed.tree.type_set()
E       assert 'unparsable' not in {'file', 'raw', 'statement', 'unparsable', 'whitespace'}
E        +  where {'file', 'raw', 'statement', 'unparsable', 'whitespace'} = type_set()
E        +    where type_set = <FileSegment: ([L:  1, P:  1])>.type_set
E        +      where <FileSegment: ([L:  1, P:  1])> = ParsedString(tree=<FileSegment: ([L:  1, P:  1])>, violations=[SQLParseError("Line 1, Position 1: Found unparsable sec..., templated_file=<TemplatedFile>, config=<sqlfluff.core.config.FluffConfig object at 0x7a10854076a0>, fname='<string>').tree

test/dialects/ansi_test.py:211: AssertionError
_ test__dialect__ansi_parse_indented_joins[select field_1 from my_table as alias_1 join foo using (field_1)-True-meta_loc2] _

sql_string = 'select field_1 from my_table as alias_1 join foo using (field_1)'
indented_joins = True, meta_loc = (1, 5, 8, 16, 21, 24, ...)

    @pytest.mark.parametrize(
        "sql_string, indented_joins,meta_loc",
        [
            ("select field_1 from my_table as alias_1", True, (1, 5, 8, 14)),
            ("select field_1 from my_table as alias_1", False, (1, 5, 8, 14)),
            (
                "select field_1 from my_table as alias_1 join foo using (field_1)",
                True,
                (1, 5, 8, 16, 21, 24, 26, 28, 29, 30),
            ),
            (
                "select field_1 from my_table as alias_1 join foo using (field_1)",
                False,
                (1, 5, 8, 15, 17, 22, 25, 27, 29, 30),
            ),
        ],
    )
    def test__dialect__ansi_parse_indented_joins(sql_string, indented_joins, meta_loc):
        """Test parsing of meta segments using Conditional works with indented_joins."""
        lnt = Linter(
            config=FluffConfig(configs={"indentation": {"indented_joins": indented_joins}})
        )
        parsed = lnt.parse_string(sql_string)
        # Check that there's nothing unparsable
>       assert "unparsable" not in parsed.tree.type_set()
E       assert 'unparsable' not in {'bracketed', 'file', 'raw', 'statement', 'symbol', 'unparsable', ...}
E        +  where {'bracketed', 'file', 'raw', 'statement', 'symbol', 'unparsable', ...} = type_set()
E        +    where type_set = <FileSegment: ([L:  1, P:  1])>.type_set
E        +      where <FileSegment: ([L:  1, P:  1])> = ParsedString(tree=<FileSegment: ([L:  1, P:  1])>, violations=[SQLParseError("Line 1, Position 1: Found unparsable sec..., templated_file=<TemplatedFile>, config=<sqlfluff.core.config.FluffConfig object at 0x7a10852ceb80>, fname='<string>').tree

test/dialects/ansi_test.py:211: AssertionError
_ test__dialect__ansi_parse_indented_joins[select field_1 from my_table as alias_1 join foo using (field_1)-False-meta_loc3] _

sql_string = 'select field_1 from my_table as alias_1 join foo using (field_1)'
indented_joins = False, meta_loc = (1, 5, 8, 15, 17, 22, ...)

    @pytest.mark.parametrize(
        "sql_string, indented_joins,meta_loc",
        [
            ("select field_1 from my_table as alias_1", True, (1, 5, 8, 14)),
            ("select field_1 from my_table as alias_1", False, (1, 5, 8, 14)),
            (
                "select field_1 from my_table as alias_1 join foo using (field_1)",
                True,
                (1, 5, 8, 16, 21, 24, 26, 28, 29, 30),
            ),
            (
                "select field_1 from my_table as alias_1 join foo using (field_1)",
                False,
                (1, 5, 8, 15, 17, 22, 25, 27, 29, 30),
            ),
        ],
    )
    def test__dialect__ansi_parse_indented_joins(sql_string, indented_joins, meta_loc):
        """Test parsing of meta segments using Conditional works with indented_joins."""
        lnt = Linter(
            config=FluffConfig(configs={"indentation": {"indented_joins": indented_joins}})
        )
        parsed = lnt.parse_string(sql_string)
        # Check that there's nothing unparsable
>       assert "unparsable" not in parsed.tree.type_set()
E       assert 'unparsable' not in {'bracketed', 'file', 'raw', 'statement', 'symbol', 'unparsable', ...}
E        +  where {'bracketed', 'file', 'raw', 'statement', 'symbol', 'unparsable', ...} = type_set()
E        +    where type_set = <FileSegment: ([L:  1, P:  1])>.type_set
E        +      where <FileSegment: ([L:  1, P:  1])> = ParsedString(tree=<FileSegment: ([L:  1, P:  1])>, violations=[SQLParseError("Line 1, Position 1: Found unparsable sec..., templated_file=<TemplatedFile>, config=<sqlfluff.core.config.FluffConfig object at 0x7a10853689d0>, fname='<string>').tree

test/dialects/ansi_test.py:211: AssertionError
________ test__dialect__ansi_multiple_semicolons[select id from tbl;-] _________

raw = 'select id from tbl;', expected_message = ''

    @pytest.mark.parametrize(
        "raw,expected_message",
        [
            (";;", "Line 1, Position 1: Found unparsable section: ';;'"),
            ("select id from tbl;", ""),
            ("select id from tbl;;", "Could not parse: ;"),
            ("select id from tbl;;;;;;", "Could not parse: ;;;;;"),
            ("select id from tbl;select id2 from tbl2;", ""),
            (
                "select id from tbl;;select id2 from tbl2;",
                "Could not parse: ;select id2 from tbl2;",
            ),
        ],
    )
    def test__dialect__ansi_multiple_semicolons(raw: str, expected_message: str) -> None:
        """Multiple semicolons should be properly handled."""
        lnt = Linter()
        parsed = lnt.parse_string(raw)
    
>       assert len(parsed.violations) == (1 if expected_message else 0)
E       assert 1 == 0
E        +  where 1 = len([SQLParseError("Line 1, Position 1: Found unparsable section: 'select id from tbl'")])
E        +    where [SQLParseError("Line 1, Position 1: Found unparsable section: 'select id from tbl'")] = ParsedString(tree=<FileSegment: ([L:  1, P:  1])>, violations=[SQLParseError("Line 1, Position 1: Found unparsable sec..., templated_file=<TemplatedFile>, config=<sqlfluff.core.config.FluffConfig object at 0x7a10853ed490>, fname='<string>').violations

test/dialects/ansi_test.py:238: AssertionError
_ test__dialect__ansi_multiple_semicolons[select id from tbl;;-Could not parse: ;] _

raw = 'select id from tbl;;', expected_message = 'Could not parse: ;'

    @pytest.mark.parametrize(
        "raw,expected_message",
        [
            (";;", "Line 1, Position 1: Found unparsable section: ';;'"),
            ("select id from tbl;", ""),
            ("select id from tbl;;", "Could not parse: ;"),
            ("select id from tbl;;;;;;", "Could not parse: ;;;;;"),
            ("select id from tbl;select id2 from tbl2;", ""),
            (
                "select id from tbl;;select id2 from tbl2;",
                "Could not parse: ;select id2 from tbl2;",
            ),
        ],
    )
    def test__dialect__ansi_multiple_semicolons(raw: str, expected_message: str) -> None:
        """Multiple semicolons should be properly handled."""
        lnt = Linter()
>       parsed = lnt.parse_string(raw)

test/dialects/ansi_test.py:236: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/sqlfluff/core/linter/linter.py:607: in parse_string
    return self.parse_rendered(rendered, recurse=recurse)
src/sqlfluff/core/linter/linter.py:313: in parse_rendered
    parsed, pvs = cls._parse_tokens(
src/sqlfluff/core/linter/linter.py:190: in _parse_tokens
    parsed: Optional[BaseSegment] = parser.parse(
src/sqlfluff/core/parser/parser.py:32: in parse
    parsed = root_segment.parse(parse_context=ctx)
src/sqlfluff/core/parser/segments/base.py:821: in parse
    check_still_complete(segments, m.matched_segments, m.unmatched_segments)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

segments_in = (<CodeSegment: ([L:  1, P:  1]) 'select'>, <WhitespaceSegment: ([L:  1, P:  7]) ' '>, <CodeSegment: ([L:  1, P:  8]) '...Segment: ([L:  1, P: 10]) ' '>, <CodeSegment: ([L:  1, P: 11]) 'from'>, <WhitespaceSegment: ([L:  1, P: 15]) ' '>, ...)
matched_segments = ()
unmatched_segments = (<SymbolSegment: ([L:  1, P: 20]) ';'>,)

    def check_still_complete(
        segments_in: Tuple["BaseSegment", ...],
        matched_segments: Tuple["BaseSegment", ...],
        unmatched_segments: Tuple["BaseSegment", ...],
    ) -> bool:
        """Check that the segments in are the same as the segments out."""
        initial_str = join_segments_raw(segments_in)
        current_str = join_segments_raw(matched_segments + unmatched_segments)
        if initial_str != current_str:  # pragma: no cover
>           raise RuntimeError(
                "Dropped elements in sequence matching! {!r} != {!r}".format(
                    initial_str, current_str
                )
            )
E           RuntimeError: Dropped elements in sequence matching! 'select id from tbl;;' != ';'

src/sqlfluff/core/parser/helpers.py:30: RuntimeError
_ test__dialect__ansi_multiple_semicolons[select id from tbl;;;;;;-Could not parse: ;;;;;] _

raw = 'select id from tbl;;;;;;', expected_message = 'Could not parse: ;;;;;'

    @pytest.mark.parametrize(
        "raw,expected_message",
        [
            (";;", "Line 1, Position 1: Found unparsable section: ';;'"),
            ("select id from tbl;", ""),
            ("select id from tbl;;", "Could not parse: ;"),
            ("select id from tbl;;;;;;", "Could not parse: ;;;;;"),
            ("select id from tbl;select id2 from tbl2;", ""),
            (
                "select id from tbl;;select id2 from tbl2;",
                "Could not parse: ;select id2 from tbl2;",
            ),
        ],
    )
    def test__dialect__ansi_multiple_semicolons(raw: str, expected_message: str) -> None:
        """Multiple semicolons should be properly handled."""
        lnt = Linter()
>       parsed = lnt.parse_string(raw)

test/dialects/ansi_test.py:236: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/sqlfluff/core/linter/linter.py:607: in parse_string
    return self.parse_rendered(rendered, recurse=recurse)
src/sqlfluff/core/linter/linter.py:313: in parse_rendered
    parsed, pvs = cls._parse_tokens(
src/sqlfluff/core/linter/linter.py:190: in _parse_tokens
    parsed: Optional[BaseSegment] = parser.parse(
src/sqlfluff/core/parser/parser.py:32: in parse
    parsed = root_segment.parse(parse_context=ctx)
src/sqlfluff/core/parser/segments/base.py:821: in parse
    check_still_complete(segments, m.matched_segments, m.unmatched_segments)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

segments_in = (<CodeSegment: ([L:  1, P:  1]) 'select'>, <WhitespaceSegment: ([L:  1, P:  7]) ' '>, <CodeSegment: ([L:  1, P:  8]) '...Segment: ([L:  1, P: 10]) ' '>, <CodeSegment: ([L:  1, P: 11]) 'from'>, <WhitespaceSegment: ([L:  1, P: 15]) ' '>, ...)
matched_segments = ()
unmatched_segments = (<SymbolSegment: ([L:  1, P: 20]) ';'>, <CodeSegment: ([L:  1, P: 21]) ';'>, <CodeSegment: ([L:  1, P: 22]) ';'>, <CodeSegment: ([L:  1, P: 23]) ';'>, <CodeSegment: ([L:  1, P: 24]) ';'>)

    def check_still_complete(
        segments_in: Tuple["BaseSegment", ...],
        matched_segments: Tuple["BaseSegment", ...],
        unmatched_segments: Tuple["BaseSegment", ...],
    ) -> bool:
        """Check that the segments in are the same as the segments out."""
        initial_str = join_segments_raw(segments_in)
        current_str = join_segments_raw(matched_segments + unmatched_segments)
        if initial_str != current_str:  # pragma: no cover
>           raise RuntimeError(
                "Dropped elements in sequence matching! {!r} != {!r}".format(
                    initial_str, current_str
                )
            )
E           RuntimeError: Dropped elements in sequence matching! 'select id from tbl;;;;;;' != ';;;;;'

src/sqlfluff/core/parser/helpers.py:30: RuntimeError
_ test__dialect__ansi_multiple_semicolons[select id from tbl;select id2 from tbl2;-] _

raw = 'select id from tbl;select id2 from tbl2;', expected_message = ''

    @pytest.mark.parametrize(
        "raw,expected_message",
        [
            (";;", "Line 1, Position 1: Found unparsable section: ';;'"),
            ("select id from tbl;", ""),
            ("select id from tbl;;", "Could not parse: ;"),
            ("select id from tbl;;;;;;", "Could not parse: ;;;;;"),
            ("select id from tbl;select id2 from tbl2;", ""),
            (
                "select id from tbl;;select id2 from tbl2;",
                "Could not parse: ;select id2 from tbl2;",
            ),
        ],
    )
    def test__dialect__ansi_multiple_semicolons(raw: str, expected_message: str) -> None:
        """Multiple semicolons should be properly handled."""
        lnt = Linter()
        parsed = lnt.parse_string(raw)
    
>       assert len(parsed.violations) == (1 if expected_message else 0)
E       assert 2 == 0
E        +  where 2 = len([SQLParseError("Line 1, Position 1: Found unparsable section: 'select id from tbl'"), SQLParseError("Line 1, Position 20: Found unparsable section: 'select id2 from tbl2'")])
E        +    where [SQLParseError("Line 1, Position 1: Found unparsable section: 'select id from tbl'"), SQLParseError("Line 1, Position 20: Found unparsable section: 'select id2 from tbl2'")] = ParsedString(tree=<FileSegment: ([L:  1, P:  1])>, violations=[SQLParseError("Line 1, Position 1: Found unparsable sec..., templated_file=<TemplatedFile>, config=<sqlfluff.core.config.FluffConfig object at 0x7a1085195580>, fname='<string>').violations

test/dialects/ansi_test.py:238: AssertionError
_ test__dialect__ansi_multiple_semicolons[select id from tbl;;select id2 from tbl2;-Could not parse: ;select id2 from tbl2;] _

raw = 'select id from tbl;;select id2 from tbl2;'
expected_message = 'Could not parse: ;select id2 from tbl2;'

    @pytest.mark.parametrize(
        "raw,expected_message",
        [
            (";;", "Line 1, Position 1: Found unparsable section: ';;'"),
            ("select id from tbl;", ""),
            ("select id from tbl;;", "Could not parse: ;"),
            ("select id from tbl;;;;;;", "Could not parse: ;;;;;"),
            ("select id from tbl;select id2 from tbl2;", ""),
            (
                "select id from tbl;;select id2 from tbl2;",
                "Could not parse: ;select id2 from tbl2;",
            ),
        ],
    )
    def test__dialect__ansi_multiple_semicolons(raw: str, expected_message: str) -> None:
        """Multiple semicolons should be properly handled."""
        lnt = Linter()
>       parsed = lnt.parse_string(raw)

test/dialects/ansi_test.py:236: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
src/sqlfluff/core/linter/linter.py:607: in parse_string
    return self.parse_rendered(rendered, recurse=recurse)
src/sqlfluff/core/linter/linter.py:313: in parse_rendered
    parsed, pvs = cls._parse_tokens(
src/sqlfluff/core/linter/linter.py:190: in _parse_tokens
    parsed: Optional[BaseSegment] = parser.parse(
src/sqlfluff/core/parser/parser.py:32: in parse
    parsed = root_segment.parse(parse_context=ctx)
src/sqlfluff/core/parser/segments/base.py:821: in parse
    check_still_complete(segments, m.matched_segments, m.unmatched_segments)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

segments_in = (<CodeSegment: ([L:  1, P:  1]) 'select'>, <WhitespaceSegment: ([L:  1, P:  7]) ' '>, <CodeSegment: ([L:  1, P:  8]) '...Segment: ([L:  1, P: 10]) ' '>, <CodeSegment: ([L:  1, P: 11]) 'from'>, <WhitespaceSegment: ([L:  1, P: 15]) ' '>, ...)
matched_segments = ()
unmatched_segments = (<SymbolSegment: ([L:  1, P: 20]) ';'>, <CodeSegment: ([L:  1, P: 21]) 'select'>, <WhitespaceSegment: ([L:  1, P: 27])...gment: ([L:  1, P: 28]) 'id2'>, <WhitespaceSegment: ([L:  1, P: 31]) ' '>, <CodeSegment: ([L:  1, P: 32]) 'from'>, ...)

    def check_still_complete(
        segments_in: Tuple["BaseSegment", ...],
        matched_segments: Tuple["BaseSegment", ...],
        unmatched_segments: Tuple["BaseSegment", ...],
    ) -> bool:
        """Check that the segments in are the same as the segments out."""
        initial_str = join_segments_raw(segments_in)
        current_str = join_segments_raw(matched_segments + unmatched_segments)
        if initial_str != current_str:  # pragma: no cover
>           raise RuntimeError(
                "Dropped elements in sequence matching! {!r} != {!r}".format(
                    initial_str, current_str
                )
            )
E           RuntimeError: Dropped elements in sequence matching! 'select id from tbl;;select id2 from tbl2;' != ';select id2 from tbl2;'

src/sqlfluff/core/parser/helpers.py:30: RuntimeError
=============================== warnings summary ===============================
src/sqlfluff/__init__.py:9
  /testbed/src/sqlfluff/__init__.py:9: DeprecationWarning: pkg_resources is deprecated as an API. See https://setuptools.pypa.io/en/latest/pkg_resources.html
    import pkg_resources

-- Docs: https://docs.pytest.org/en/stable/how-to/capture-warnings.html
==================================== PASSES ====================================
___________________ test__dialect__ansi__file_lex[a b-res0] ____________________
------------------------------ Captured log call -------------------------------
INFO     sqlfluff.lexer:lexer.py:335 Elements to Segments.
INFO     sqlfluff.lexer:lexer.py:338 Source-only slices: []
DEBUG    sqlfluff.lexer:lexer.py:351   0, TemplateElement(raw='a', template_slice=slice(0, 1, None), matcher=<RegexLexer: code>), slice(0, 1, None), 'a'
DEBUG    sqlfluff.lexer:lexer.py:351   1, TemplateElement(raw=' ', template_slice=slice(1, 2, None), matcher=<RegexLexer: whitespace>), slice(1, 2, None), ' '
DEBUG    sqlfluff.lexer:lexer.py:351   2, TemplateElement(raw='b', template_slice=slice(2, 3, None), matcher=<RegexLexer: code>), slice(2, 3, None), 'b'
___________________ test__dialect__ansi__file_lex[b.c-res1] ____________________
------------------------------ Captured log call -------------------------------
INFO     sqlfluff.lexer:lexer.py:335 Elements to Segments.
INFO     sqlfluff.lexer:lexer.py:338 Source-only slices: []
DEBUG    sqlfluff.lexer:lexer.py:351   0, TemplateElement(raw='b', template_slice=slice(0, 1, None), matcher=<RegexLexer: code>), slice(0, 1, None), 'b'
DEBUG    sqlfluff.lexer:lexer.py:351   1, TemplateElement(raw='.', template_slice=slice(1, 2, None), matcher=<StringLexer: dot>), slice(1, 2, None), '.'
DEBUG    sqlfluff.lexer:lexer.py:351   2, TemplateElement(raw='c', template_slice=slice(2, 3, None), matcher=<RegexLexer: code>), slice(2, 3, None), 'c'
___________ test__dialect__ansi__file_lex[abc \n \t def  ;blah-res2] ___________
------------------------------ Captured log call -------------------------------
INFO     sqlfluff.lexer:lexer.py:335 Elements to Segments.
INFO     sqlfluff.lexer:lexer.py:338 Source-only slices: []
DEBUG    sqlfluff.lexer:lexer.py:351   0, TemplateElement(raw='abc', template_slice=slice(0, 3, None), matcher=<RegexLexer: code>), slice(0, 3, None), 'abc'
DEBUG    sqlfluff.lexer:lexer.py:351   1, TemplateElement(raw=' ', template_slice=slice(3, 4, None), matcher=<RegexLexer: whitespace>), slice(3, 4, None), ' '
DEBUG    sqlfluff.lexer:lexer.py:351   2, TemplateElement(raw='\n', template_slice=slice(4, 5, None), matcher=<RegexLexer: newline>), slice(4, 5, None), '\n'
DEBUG    sqlfluff.lexer:lexer.py:351   3, TemplateElement(raw=' \t ', template_slice=slice(5, 8, None), matcher=<RegexLexer: whitespace>), slice(5, 8, None), ' \t '
DEBUG    sqlfluff.lexer:lexer.py:351   4, TemplateElement(raw='def', template_slice=slice(8, 11, None), matcher=<RegexLexer: code>), slice(8, 11, None), 'def'
DEBUG    sqlfluff.lexer:lexer.py:351   5, TemplateElement(raw='  ', template_slice=slice(11, 13, None), matcher=<RegexLexer: whitespace>), slice(11, 13, None), '  '
DEBUG    sqlfluff.lexer:lexer.py:351   6, TemplateElement(raw=';', template_slice=slice(13, 14, None), matcher=<StringLexer: semicolon>), slice(13, 14, None), ';'
DEBUG    sqlfluff.lexer:lexer.py:351   7, TemplateElement(raw='blah', template_slice=slice(14, 18, None), matcher=<RegexLexer: code>), slice(14, 18, None), 'blah'
___ test__dialect__ansi_specific_segment_parses[SelectKeywordSegment-select] ___
----------------------------- Captured stdout call -----------------------------
(<CodeSegment: ([L:  1, P:  1]) 'select'>,)
Raw/Parser route...
<MatchResult 1/1: 'select'>
<KeywordSegment: ([L:  1, P:  1]) 'select'>
<KeywordSegment: ([L:  1, P:  1]) 'select'>
<class 'sqlfluff.core.parser.segments.raw.KeywordSegment'>
<class 'str'>
_ test__dialect__ansi_specific_segment_parses[NakedIdentifierSegment-online_sales] _
----------------------------- Captured stdout call -----------------------------
(<CodeSegment: ([L:  1, P:  1]) 'online_sales'>,)
Raw/Parser route...
<MatchResult 1/1: 'online_sales'>
<CodeSegment: ([L:  1, P:  1]) 'online_sales'>
<CodeSegment: ([L:  1, P:  1]) 'online_sales'>
<class 'sqlfluff.core.parser.segments.raw.CodeSegment'>
<class 'str'>
_ test__dialect__ansi_specific_segment_parses[BareFunctionSegment-current_timestamp] _
----------------------------- Captured stdout call -----------------------------
(<CodeSegment: ([L:  1, P:  1]) 'current_timestamp'>,)
Raw/Parser route...
<MatchResult 1/1: 'current_timestamp'>
<CodeSegment: ([L:  1, P:  1]) 'current_timestamp'>
<CodeSegment: ([L:  1, P:  1]) 'current_timestamp'>
<class 'sqlfluff.core.parser.segments.raw.CodeSegment'>
<class 'str'>
_ test__dialect__ansi_specific_segment_parses[FunctionSegment-current_timestamp()] _
----------------------------- Captured stdout call -----------------------------
(<CodeSegment: ([L:  1, P:  1]) 'current_timestamp'>, <CodeSegment: ([L:  1, P: 18]) '('>, <CodeSegment: ([L:  1, P: 19]) ')'>)
Base route...
<FunctionSegment: ([L:  1, P:  1])>
<FunctionSegment: ([L:  1, P:  1])>
<class 'sqlfluff.dialects.dialect_ansi.FunctionSegment'>
<class 'str'>
------------------------------ Captured log call -------------------------------
DEBUG    sqlfluff.parser:base.py:777 FunctionSegment.parse: no grammar. Going straight to expansion
DEBUG    sqlfluff.parser:base.py:859 FunctionSegment.parse: Done Parse. Plotting Recursion. Recurse=True
DEBUG    sqlfluff.parser:base.py:868 ###
#
# Beginning Parse Depth 1: FunctionSegment
#
###
Initial Structure:
[L:  1, P:  1]      |function:
[L:  1, P:  1]      |    raw:                                                      'current_timestamp'
[L:  1, P: 18]      |    raw:                                                      '('
[L:  1, P: 19]      |    raw:                                                      ')'

INFO     sqlfluff.parser:base.py:251 [PD:1] Skipping expansion of <CodeSegment: ([L:  1, P:  1]) 'current_timestamp'>...
INFO     sqlfluff.parser:base.py:251 [PD:1] Skipping expansion of <CodeSegment: ([L:  1, P: 18]) '('>...
INFO     sqlfluff.parser:base.py:251 [PD:1] Skipping expansion of <CodeSegment: ([L:  1, P: 19]) ')'>...
__ test__dialect__ansi_specific_segment_parses[NumericLiteralSegment-1000.0] ___
----------------------------- Captured stdout call -----------------------------
(<CodeSegment: ([L:  1, P:  1]) '1000.0'>,)
Raw/Parser route...
<MatchResult 1/1: '1000.0'>
<CodeSegment: ([L:  1, P:  1]) '1000.0'>
<CodeSegment: ([L:  1, P:  1]) '1000.0'>
<class 'sqlfluff.core.parser.segments.raw.CodeSegment'>
<class 'str'>
_ test__dialect__ansi_specific_segment_parses[ExpressionSegment-online_sales / 1000.0] _
----------------------------- Captured stdout call -----------------------------
(<CodeSegment: ([L:  1, P:  1]) 'online_sales'>, <WhitespaceSegment: ([L:  1, P: 13]) ' '>, <CodeSegment: ([L:  1, P: 14]) '/'>, <WhitespaceSegment: ([L:  1, P: 15]) ' '>, <CodeSegment: ([L:  1, P: 16]) '1000.0'>)
Base route...
<ExpressionSegment: ([L:  1, P:  1])>
<ExpressionSegment: ([L:  1, P:  1])>
<class 'sqlfluff.dialects.dialect_ansi.ExpressionSegment'>
<class 'str'>
------------------------------ Captured log call -------------------------------
DEBUG    sqlfluff.parser:base.py:777 ExpressionSegment.parse: no grammar. Going straight to expansion
DEBUG    sqlfluff.parser:base.py:859 ExpressionSegment.parse: Done Parse. Plotting Recursion. Recurse=True
DEBUG    sqlfluff.parser:base.py:868 ###
#
# Beginning Parse Depth 1: ExpressionSegment
#
###
Initial Structure:
[L:  1, P:  1]      |expression:
[L:  1, P:  1]      |    raw:                                                      'online_sales'
[L:  1, P: 13]      |    whitespace:                                               ' '
[L:  1, P: 14]      |    raw:                                                      '/'
[L:  1, P: 15]      |    whitespace:                                               ' '
[L:  1, P: 16]      |    raw:                                                      '1000.0'

INFO     sqlfluff.parser:base.py:251 [PD:1] Skipping expansion of <CodeSegment: ([L:  1, P:  1]) 'online_sales'>...
INFO     sqlfluff.parser:base.py:251 [PD:1] Skipping expansion of <WhitespaceSegment: ([L:  1, P: 13]) ' '>...
INFO     sqlfluff.parser:base.py:251 [PD:1] Skipping expansion of <CodeSegment: ([L:  1, P: 14]) '/'>...
INFO     sqlfluff.parser:base.py:251 [PD:1] Skipping expansion of <WhitespaceSegment: ([L:  1, P: 15]) ' '>...
INFO     sqlfluff.parser:base.py:251 [PD:1] Skipping expansion of <CodeSegment: ([L:  1, P: 16]) '1000.0'>...
_ test__dialect__ansi_specific_segment_parses[IntervalExpressionSegment-INTERVAL 1 YEAR] _
----------------------------- Captured stdout call -----------------------------
(<CodeSegment: ([L:  1, P:  1]) 'INTERVAL'>, <WhitespaceSegment: ([L:  1, P:  9]) ' '>, <CodeSegment: ([L:  1, P: 10]) '1'>, <WhitespaceSegment: ([L:  1, P: 11]) ' '>, <CodeSegment: ([L:  1, P: 12]) 'YEAR'>)
Base route...
<IntervalExpressionSegment: ([L:  1, P:  1])>
<IntervalExpressionSegment: ([L:  1, P:  1])>
<class 'sqlfluff.dialects.dialect_ansi.IntervalExpressionSegment'>
<class 'str'>
------------------------------ Captured log call -------------------------------
DEBUG    sqlfluff.parser:base.py:777 IntervalExpressionSegment.parse: no grammar. Going straight to expansion
DEBUG    sqlfluff.parser:base.py:859 IntervalExpressionSegment.parse: Done Parse. Plotting Recursion. Recurse=True
DEBUG    sqlfluff.parser:base.py:868 ###
#
# Beginning Parse Depth 1: IntervalExpressionSegment
#
###
Initial Structure:
[L:  1, P:  1]      |interval_expression:
[L:  1, P:  1]      |    raw:                                                      'INTERVAL'
[L:  1, P:  9]      |    whitespace:                                               ' '
[L:  1, P: 10]      |    raw:                                                      '1'
[L:  1, P: 11]      |    whitespace:                                               ' '
[L:  1, P: 12]      |    raw:                                                      'YEAR'

INFO     sqlfluff.parser:base.py:251 [PD:1] Skipping expansion of <CodeSegment: ([L:  1, P:  1]) 'INTERVAL'>...
INFO     sqlfluff.parser:base.py:251 [PD:1] Skipping expansion of <WhitespaceSegment: ([L:  1, P:  9]) ' '>...
INFO     sqlfluff.parser:base.py:251 [PD:1] Skipping expansion of <CodeSegment: ([L:  1, P: 10]) '1'>...
INFO     sqlfluff.parser:base.py:251 [PD:1] Skipping expansion of <WhitespaceSegment: ([L:  1, P: 11]) ' '>...
INFO     sqlfluff.parser:base.py:251 [PD:1] Skipping expansion of <CodeSegment: ([L:  1, P: 12]) 'YEAR'>...
_ test__dialect__ansi_specific_segment_parses[ExpressionSegment-CASE WHEN id = 1 THEN 'nothing' ELSE 'test' END] _
----------------------------- Captured stdout call -----------------------------
(<CodeSegment: ([L:  1, P:  1]) 'CASE'>, <WhitespaceSegment: ([L:  1, P:  5]) ' '>, <CodeSegment: ([L:  1, P:  6]) 'WHEN'>, <WhitespaceSegment: ([L:  1, P: 10]) ' '>, <CodeSegment: ([L:  1, P: 11]) 'id'>, <WhitespaceSegment: ([L:  1, P: 13]) ' '>, <CodeSegment: ([L:  1, P: 14]) '='>, <WhitespaceSegment: ([L:  1, P: 15]) ' '>, <CodeSegment: ([L:  1, P: 16]) '1'>, <WhitespaceSegment: ([L:  1, P: 17]) ' '>, <CodeSegment: ([L:  1, P: 18]) 'THEN'>, <WhitespaceSegment: ([L:  1, P: 22]) ' '>, <CodeSegment: ([L:  1, P: 23]) "'nothing'">, <WhitespaceSegment: ([L:  1, P: 32]) ' '>, <CodeSegment: ([L:  1, P: 33]) 'ELSE'>, <WhitespaceSegment: ([L:  1, P: 37]) ' '>, <CodeSegment: ([L:  1, P: 38]) "'test'">, <WhitespaceSegment: ([L:  1, P: 44]) ' '>, <CodeSegment: ([L:  1, P: 45]) 'END'>)
Base route...
<ExpressionSegment: ([L:  1, P:  1])>
<ExpressionSegment: ([L:  1, P:  1])>
<class 'sqlfluff.dialects.dialect_ansi.ExpressionSegment'>
<class 'str'>
------------------------------ Captured log call -------------------------------
DEBUG    sqlfluff.parser:base.py:777 ExpressionSegment.parse: no grammar. Going straight to expansion
DEBUG    sqlfluff.parser:base.py:859 ExpressionSegment.parse: Done Parse. Plotting Recursion. Recurse=True
DEBUG    sqlfluff.parser:base.py:868 ###
#
# Beginning Parse Depth 1: ExpressionSegment
#
###
Initial Structure:
[L:  1, P:  1]      |expression:
[L:  1, P:  1]      |    raw:                                                      'CASE'
[L:  1, P:  5]      |    whitespace:                                               ' '
[L:  1, P:  6]      |    raw:                                                      'WHEN'
[L:  1, P: 10]      |    whitespace:                                               ' '
[L:  1, P: 11]      |    raw:                                                      'id'
[L:  1, P: 13]      |    whitespace:                                               ' '
[L:  1, P: 14]      |    raw:                                                      '='
[L:  1, P: 15]      |    whitespace:                                               ' '
[L:  1, P: 16]      |    raw:                                                      '1'
[L:  1, P: 17]      |    whitespace:                                               ' '
[L:  1, P: 18]      |    raw:                                                      'THEN'
[L:  1, P: 22]      |    whitespace:                                               ' '
[L:  1, P: 23]      |    raw:                                                      "'nothing'"
[L:  1, P: 32]      |    whitespace:                                               ' '
[L:  1, P: 33]      |    raw:                                                      'ELSE'
[L:  1, P: 37]      |    whitespace:                                               ' '
[L:  1, P: 38]      |    raw:                                                      "'test'"
[L:  1, P: 44]      |    whitespace:                                               ' '
[L:  1, P: 45]      |    raw:                                                      'END'

INFO     sqlfluff.parser:base.py:251 [PD:1] Skipping expansion of <CodeSegment: ([L:  1, P:  1]) 'CASE'>...
INFO     sqlfluff.parser:base.py:251 [PD:1] Skipping expansion of <WhitespaceSegment: ([L:  1, P:  5]) ' '>...
INFO     sqlfluff.parser:base.py:251 [PD:1] Skipping expansion of <CodeSegment: ([L:  1, P:  6]) 'WHEN'>...
INFO     sqlfluff.parser:base.py:251 [PD:1] Skipping expansion of <WhitespaceSegment: ([L:  1, P: 10]) ' '>...
INFO     sqlfluff.parser:base.py:251 [PD:1] Skipping expansion of <CodeSegment: ([L:  1, P: 11]) 'id'>...
INFO     sqlfluff.parser:base.py:251 [PD:1] Skipping expansion of <WhitespaceSegment: ([L:  1, P: 13]) ' '>...
INFO     sqlfluff.parser:base.py:251 [PD:1] Skipping expansion of <CodeSegment: ([L:  1, P: 14]) '='>...
INFO     sqlfluff.parser:base.py:251 [PD:1] Skipping expansion of <WhitespaceSegment: ([L:  1, P: 15]) ' '>...
INFO     sqlfluff.parser:base.py:251 [PD:1] Skipping expansion of <CodeSegment: ([L:  1, P: 16]) '1'>...
INFO     sqlfluff.parser:base.py:251 [PD:1] Skipping expansion of <WhitespaceSegment: ([L:  1, P: 17]) ' '>...
INFO     sqlfluff.parser:base.py:251 [PD:1] Skipping expansion of <CodeSegment: ([L:  1, P: 18]) 'THEN'>...
INFO     sqlfluff.parser:base.py:251 [PD:1] Skipping expansion of <WhitespaceSegment: ([L:  1, P: 22]) ' '>...
INFO     sqlfluff.parser:base.py:251 [PD:1] Skipping expansion of <CodeSegment: ([L:  1, P: 23]) "'nothing'">...
INFO     sqlfluff.parser:base.py:251 [PD:1] Skipping expansion of <WhitespaceSegment: ([L:  1, P: 32]) ' '>...
INFO     sqlfluff.parser:base.py:251 [PD:1] Skipping expansion of <CodeSegment: ([L:  1, P: 33]) 'ELSE'>...
INFO     sqlfluff.parser:base.py:251 [PD:1] Skipping expansion of <WhitespaceSegment: ([L:  1, P: 37]) ' '>...
INFO     sqlfluff.parser:base.py:251 [PD:1] Skipping expansion of <CodeSegment: ([L:  1, P: 38]) "'test'">...
INFO     sqlfluff.parser:base.py:251 [PD:1] Skipping expansion of <WhitespaceSegment: ([L:  1, P: 44]) ' '>...
INFO     sqlfluff.parser:base.py:251 [PD:1] Skipping expansion of <CodeSegment: ([L:  1, P: 45]) 'END'>...
_ test__dialect__ansi_specific_segment_parses[ExpressionSegment-CASE WHEN id = 1 THEN CASE WHEN true THEN 'something' ELSE 'nothing' END ELSE 'test' END] _
----------------------------- Captured stdout call -----------------------------
(<CodeSegment: ([L:  1, P:  1]) 'CASE'>, <WhitespaceSegment: ([L:  1, P:  5]) ' '>, <CodeSegment: ([L:  1, P:  6]) 'WHEN'>, <WhitespaceSegment: ([L:  1, P: 10]) ' '>, <CodeSegment: ([L:  1, P: 11]) 'id'>, <WhitespaceSegment: ([L:  1, P: 13]) ' '>, <CodeSegment: ([L:  1, P: 14]) '='>, <WhitespaceSegment: ([L:  1, P: 15]) ' '>, <CodeSegment: ([L:  1, P: 16]) '1'>, <WhitespaceSegment: ([L:  1, P: 17]) ' '>, <CodeSegment: ([L:  1, P: 18]) 'THEN'>, <WhitespaceSegment: ([L:  1, P: 22]) ' '>, <CodeSegment: ([L:  1, P: 23]) 'CASE'>, <WhitespaceSegment: ([L:  1, P: 27]) ' '>, <CodeSegment: ([L:  1, P: 28]) 'WHEN'>, <WhitespaceSegment: ([L:  1, P: 32]) ' '>, <CodeSegment: ([L:  1, P: 33]) 'true'>, <WhitespaceSegment: ([L:  1, P: 37]) ' '>, <CodeSegment: ([L:  1, P: 38]) 'THEN'>, <WhitespaceSegment: ([L:  1, P: 42]) ' '>, <CodeSegment: ([L:  1, P: 43]) "'something'">, <WhitespaceSegment: ([L:  1, P: 54]) ' '>, <CodeSegment: ([L:  1, P: 55]) 'ELSE'>, <WhitespaceSegment: ([L:  1, P: 59]) ' '>, <CodeSegment: ([L:  1, P: 60]) "'nothing'">, <WhitespaceSegment: ([L:  1, P: 69]) ' '>, <CodeSegment: ([L:  1, P: 70]) 'END'>, <WhitespaceSegment: ([L:  1, P: 73]) ' '>, <CodeSegment: ([L:  1, P: 74]) 'ELSE'>, <WhitespaceSegment: ([L:  1, P: 78]) ' '>, <CodeSegment: ([L:  1, P: 79]) "'test'">, <WhitespaceSegment: ([L:  1, P: 85]) ' '>, <CodeSegment: ([L:  1, P: 86]) 'END'>)
Base route...
<ExpressionSegment: ([L:  1, P:  1])>
<ExpressionSegment: ([L:  1, P:  1])>
<class 'sqlfluff.dialects.dialect_ansi.ExpressionSegment'>
<class 'str'>
------------------------------ Captured log call -------------------------------
DEBUG    sqlfluff.parser:base.py:777 ExpressionSegment.parse: no grammar. Going straight to expansion
DEBUG    sqlfluff.parser:base.py:859 ExpressionSegment.parse: Done Parse. Plotting Recursion. Recurse=True
DEBUG    sqlfluff.parser:base.py:868 ###
#
# Beginning Parse Depth 1: ExpressionSegment
#
###
Initial Structure:
[L:  1, P:  1]      |expression:
[L:  1, P:  1]      |    raw:                                                      'CASE'
[L:  1, P:  5]      |    whitespace:                                               ' '
[L:  1, P:  6]      |    raw:                                                      'WHEN'
[L:  1, P: 10]      |    whitespace:                                               ' '
[L:  1, P: 11]      |    raw:                                                      'id'
[L:  1, P: 13]      |    whitespace:                                               ' '
[L:  1, P: 14]      |    raw:                                                      '='
[L:  1, P: 15]      |    whitespace:                                               ' '
[L:  1, P: 16]      |    raw:                                                      '1'
[L:  1, P: 17]      |    whitespace:                                               ' '
[L:  1, P: 18]      |    raw:                                                      'THEN'
[L:  1, P: 22]      |    whitespace:                                               ' '
[L:  1, P: 23]      |    raw:                                                      'CASE'
[L:  1, P: 27]      |    whitespace:                                               ' '
[L:  1, P: 28]      |    raw:                                                      'WHEN'
[L:  1, P: 32]      |    whitespace:                                               ' '
[L:  1, P: 33]      |    raw:                                                      'true'
[L:  1, P: 37]      |    whitespace:                                               ' '
[L:  1, P: 38]      |    raw:                                                      'THEN'
[L:  1, P: 42]      |    whitespace:                                               ' '
[L:  1, P: 43]      |    raw:                                                      "'something'"
[L:  1, P: 54]      |    whitespace:                                               ' '
[L:  1, P: 55]      |    raw:                                                      'ELSE'
[L:  1, P: 59]      |    whitespace:                                               ' '
[L:  1, P: 60]      |    raw:                                                      "'nothing'"
[L:  1, P: 69]      |    whitespace:                                               ' '
[L:  1, P: 70]      |    raw:                                                      'END'
[L:  1, P: 73]      |    whitespace:                                               ' '
[L:  1, P: 74]      |    raw:                                                      'ELSE'
[L:  1, P: 78]      |    whitespace:                                               ' '
[L:  1, P: 79]      |    raw:                                                      "'test'"
[L:  1, P: 85]      |    whitespace:                                               ' '
[L:  1, P: 86]      |    raw:                                                      'END'

INFO     sqlfluff.parser:base.py:251 [PD:1] Skipping expansion of <CodeSegment: ([L:  1, P:  1]) 'CASE'>...
INFO     sqlfluff.parser:base.py:251 [PD:1] Skipping expansion of <WhitespaceSegment: ([L:  1, P:  5]) ' '>...
INFO     sqlfluff.parser:base.py:251 [PD:1] Skipping expansion of <CodeSegment: ([L:  1, P:  6]) 'WHEN'>...
INFO     sqlfluff.parser:base.py:251 [PD:1] Skipping expansion of <WhitespaceSegment: ([L:  1, P: 10]) ' '>...
INFO     sqlfluff.parser:base.py:251 [PD:1] Skipping expansion of <CodeSegment: ([L:  1, P: 11]) 'id'>...
INFO     sqlfluff.parser:base.py:251 [PD:1] Skipping expansion of <WhitespaceSegment: ([L:  1, P: 13]) ' '>...
INFO     sqlfluff.parser:base.py:251 [PD:1] Skipping expansion of <CodeSegment: ([L:  1, P: 14]) '='>...
INFO     sqlfluff.parser:base.py:251 [PD:1] Skipping expansion of <WhitespaceSegment: ([L:  1, P: 15]) ' '>...
INFO     sqlfluff.parser:base.py:251 [PD:1] Skipping expansion of <CodeSegment: ([L:  1, P: 16]) '1'>...
INFO     sqlfluff.parser:base.py:251 [PD:1] Skipping expansion of <WhitespaceSegment: ([L:  1, P: 17]) ' '>...
INFO     sqlfluff.parser:base.py:251 [PD:1] Skipping expansion of <CodeSegment: ([L:  1, P: 18]) 'THEN'>...
INFO     sqlfluff.parser:base.py:251 [PD:1] Skipping expansion of <WhitespaceSegment: ([L:  1, P: 22]) ' '>...
INFO     sqlfluff.parser:base.py:251 [PD:1] Skipping expansion of <CodeSegment: ([L:  1, P: 23]) 'CASE'>...
INFO     sqlfluff.parser:base.py:251 [PD:1] Skipping expansion of <WhitespaceSegment: ([L:  1, P: 27]) ' '>...
INFO     sqlfluff.parser:base.py:251 [PD:1] Skipping expansion of <CodeSegment: ([L:  1, P: 28]) 'WHEN'>...
INFO     sqlfluff.parser:base.py:251 [PD:1] Skipping expansion of <WhitespaceSegment: ([L:  1, P: 32]) ' '>...
INFO     sqlfluff.parser:base.py:251 [PD:1] Skipping expansion of <CodeSegment: ([L:  1, P: 33]) 'true'>...
INFO     sqlfluff.parser:base.py:251 [PD:1] Skipping expansion of <WhitespaceSegment: ([L:  1, P: 37]) ' '>...
INFO     sqlfluff.parser:base.py:251 [PD:1] Skipping expansion of <CodeSegment: ([L:  1, P: 38]) 'THEN'>...
INFO     sqlfluff.parser:base.py:251 [PD:1] Skipping expansion of <WhitespaceSegment: ([L:  1, P: 42]) ' '>...
INFO     sqlfluff.parser:base.py:251 [PD:1] Skipping expansion of <CodeSegment: ([L:  1, P: 43]) "'something'">...
INFO     sqlfluff.parser:base.py:251 [PD:1] Skipping expansion of <WhitespaceSegment: ([L:  1, P: 54]) ' '>...
INFO     sqlfluff.parser:base.py:251 [PD:1] Skipping expansion of <CodeSegment: ([L:  1, P: 55]) 'ELSE'>...
INFO     sqlfluff.parser:base.py:251 [PD:1] Skipping expansion of <WhitespaceSegment: ([L:  1, P: 59]) ' '>...
INFO     sqlfluff.parser:base.py:251 [PD:1] Skipping expansion of <CodeSegment: ([L:  1, P: 60]) "'nothing'">...
INFO     sqlfluff.parser:base.py:251 [PD:1] Skipping expansion of <WhitespaceSegment: ([L:  1, P: 69]) ' '>...
INFO     sqlfluff.parser:base.py:251 [PD:1] Skipping expansion of <CodeSegment: ([L:  1, P: 70]) 'END'>...
INFO     sqlfluff.parser:base.py:251 [PD:1] Skipping expansion of <WhitespaceSegment: ([L:  1, P: 73]) ' '>...
INFO     sqlfluff.parser:base.py:251 [PD:1] Skipping expansion of <CodeSegment: ([L:  1, P: 74]) 'ELSE'>...
INFO     sqlfluff.parser:base.py:251 [PD:1] Skipping expansion of <WhitespaceSegment: ([L:  1, P: 78]) ' '>...
INFO     sqlfluff.parser:base.py:251 [PD:1] Skipping expansion of <CodeSegment: ([L:  1, P: 79]) "'test'">...
INFO     sqlfluff.parser:base.py:251 [PD:1] Skipping expansion of <WhitespaceSegment: ([L:  1, P: 85]) ' '>...
INFO     sqlfluff.parser:base.py:251 [PD:1] Skipping expansion of <CodeSegment: ([L:  1, P: 86]) 'END'>...
_ test__dialect__ansi_specific_segment_parses[ExpressionSegment-CAST(ROUND(online_sales / 1000.0) AS varchar)] _
----------------------------- Captured stdout call -----------------------------
(<CodeSegment: ([L:  1, P:  1]) 'CAST'>, <CodeSegment: ([L:  1, P:  5]) '('>, <CodeSegment: ([L:  1, P:  6]) 'ROUND'>, <CodeSegment: ([L:  1, P: 11]) '('>, <CodeSegment: ([L:  1, P: 12]) 'online_sales'>, <WhitespaceSegment: ([L:  1, P: 24]) ' '>, <CodeSegment: ([L:  1, P: 25]) '/'>, <WhitespaceSegment: ([L:  1, P: 26]) ' '>, <CodeSegment: ([L:  1, P: 27]) '1000.0'>, <CodeSegment: ([L:  1, P: 33]) ')'>, <WhitespaceSegment: ([L:  1, P: 34]) ' '>, <CodeSegment: ([L:  1, P: 35]) 'AS'>, <WhitespaceSegment: ([L:  1, P: 37]) ' '>, <CodeSegment: ([L:  1, P: 38]) 'varchar'>, <CodeSegment: ([L:  1, P: 45]) ')'>)
Base route...
<ExpressionSegment: ([L:  1, P:  1])>
<ExpressionSegment: ([L:  1, P:  1])>
<class 'sqlfluff.dialects.dialect_ansi.ExpressionSegment'>
<class 'str'>
------------------------------ Captured log call -------------------------------
DEBUG    sqlfluff.parser:base.py:777 ExpressionSegment.parse: no grammar. Going straight to expansion
DEBUG    sqlfluff.parser:base.py:859 ExpressionSegment.parse: Done Parse. Plotting Recursion. Recurse=True
DEBUG    sqlfluff.parser:base.py:868 ###
#
# Beginning Parse Depth 1: ExpressionSegment
#
###
Initial Structure:
[L:  1, P:  1]      |expression:
[L:  1, P:  1]      |    raw:                                                      'CAST'
[L:  1, P:  5]      |    raw:                                                      '('
[L:  1, P:  6]      |    raw:                                                      'ROUND'
[L:  1, P: 11]      |    raw:                                                      '('
[L:  1, P: 12]      |    raw:                                                      'online_sales'
[L:  1, P: 24]      |    whitespace:                                               ' '
[L:  1, P: 25]      |    raw:                                                      '/'
[L:  1, P: 26]      |    whitespace:                                               ' '
[L:  1, P: 27]      |    raw:                                                      '1000.0'
[L:  1, P: 33]      |    raw:                                                      ')'
[L:  1, P: 34]      |    whitespace:                                               ' '
[L:  1, P: 35]      |    raw:                                                      'AS'
[L:  1, P: 37]      |    whitespace:                                               ' '
[L:  1, P: 38]      |    raw:                                                      'varchar'
[L:  1, P: 45]      |    raw:                                                      ')'

INFO     sqlfluff.parser:base.py:251 [PD:1] Skipping expansion of <CodeSegment: ([L:  1, P:  1]) 'CAST'>...
INFO     sqlfluff.parser:base.py:251 [PD:1] Skipping expansion of <CodeSegment: ([L:  1, P:  5]) '('>...
INFO     sqlfluff.parser:base.py:251 [PD:1] Skipping expansion of <CodeSegment: ([L:  1, P:  6]) 'ROUND'>...
INFO     sqlfluff.parser:base.py:251 [PD:1] Skipping expansion of <CodeSegment: ([L:  1, P: 11]) '('>...
INFO     sqlfluff.parser:base.py:251 [PD:1] Skipping expansion of <CodeSegment: ([L:  1, P: 12]) 'online_sales'>...
INFO     sqlfluff.parser:base.py:251 [PD:1] Skipping expansion of <WhitespaceSegment: ([L:  1, P: 24]) ' '>...
INFO     sqlfluff.parser:base.py:251 [PD:1] Skipping expansion of <CodeSegment: ([L:  1, P: 25]) '/'>...
INFO     sqlfluff.parser:base.py:251 [PD:1] Skipping expansion of <WhitespaceSegment: ([L:  1, P: 26]) ' '>...
INFO     sqlfluff.parser:base.py:251 [PD:1] Skipping expansion of <CodeSegment: ([L:  1, P: 27]) '1000.0'>...
INFO     sqlfluff.parser:base.py:251 [PD:1] Skipping expansion of <CodeSegment: ([L:  1, P: 33]) ')'>...
INFO     sqlfluff.parser:base.py:251 [PD:1] Skipping expansion of <WhitespaceSegment: ([L:  1, P: 34]) ' '>...
INFO     sqlfluff.parser:base.py:251 [PD:1] Skipping expansion of <CodeSegment: ([L:  1, P: 35]) 'AS'>...
INFO     sqlfluff.parser:base.py:251 [PD:1] Skipping expansion of <WhitespaceSegment: ([L:  1, P: 37]) ' '>...
INFO     sqlfluff.parser:base.py:251 [PD:1] Skipping expansion of <CodeSegment: ([L:  1, P: 38]) 'varchar'>...
INFO     sqlfluff.parser:base.py:251 [PD:1] Skipping expansion of <CodeSegment: ([L:  1, P: 45]) ')'>...
_ test__dialect__ansi_specific_segment_parses[ExpressionSegment-name NOT LIKE '%y'] _
----------------------------- Captured stdout call -----------------------------
(<CodeSegment: ([L:  1, P:  1]) 'name'>, <WhitespaceSegment: ([L:  1, P:  5]) ' '>, <CodeSegment: ([L:  1, P:  6]) 'NOT'>, <WhitespaceSegment: ([L:  1, P:  9]) ' '>, <CodeSegment: ([L:  1, P: 10]) 'LIKE'>, <WhitespaceSegment: ([L:  1, P: 14]) ' '>, <CodeSegment: ([L:  1, P: 15]) "'%y'">)
Base route...
<ExpressionSegment: ([L:  1, P:  1])>
<ExpressionSegment: ([L:  1, P:  1])>
<class 'sqlfluff.dialects.dialect_ansi.ExpressionSegment'>
<class 'str'>
------------------------------ Captured log call -------------------------------
DEBUG    sqlfluff.parser:base.py:777 ExpressionSegment.parse: no grammar. Going straight to expansion
DEBUG    sqlfluff.parser:base.py:859 ExpressionSegment.parse: Done Parse. Plotting Recursion. Recurse=True
DEBUG    sqlfluff.parser:base.py:868 ###
#
# Beginning Parse Depth 1: ExpressionSegment
#
###
Initial Structure:
[L:  1, P:  1]      |expression:
[L:  1, P:  1]      |    raw:                                                      'name'
[L:  1, P:  5]      |    whitespace:                                               ' '
[L:  1, P:  6]      |    raw:                                                      'NOT'
[L:  1, P:  9]      |    whitespace:                                               ' '
[L:  1, P: 10]      |    raw:                                                      'LIKE'
[L:  1, P: 14]      |    whitespace:                                               ' '
[L:  1, P: 15]      |    raw:                                                      "'%y'"

INFO     sqlfluff.parser:base.py:251 [PD:1] Skipping expansion of <CodeSegment: ([L:  1, P:  1]) 'name'>...
INFO     sqlfluff.parser:base.py:251 [PD:1] Skipping expansion of <WhitespaceSegment: ([L:  1, P:  5]) ' '>...
INFO     sqlfluff.parser:base.py:251 [PD:1] Skipping expansion of <CodeSegment: ([L:  1, P:  6]) 'NOT'>...
INFO     sqlfluff.parser:base.py:251 [PD:1] Skipping expansion of <WhitespaceSegment: ([L:  1, P:  9]) ' '>...
INFO     sqlfluff.parser:base.py:251 [PD:1] Skipping expansion of <CodeSegment: ([L:  1, P: 10]) 'LIKE'>...
INFO     sqlfluff.parser:base.py:251 [PD:1] Skipping expansion of <WhitespaceSegment: ([L:  1, P: 14]) ' '>...
INFO     sqlfluff.parser:base.py:251 [PD:1] Skipping expansion of <CodeSegment: ([L:  1, P: 15]) "'%y'">...
_ test__dialect__ansi_specific_segment_parses[ExpressionSegment-DATE_ADD(CURRENT_DATE('America/New_York'), INTERVAL 1 year)] _
----------------------------- Captured stdout call -----------------------------
(<CodeSegment: ([L:  1, P:  1]) 'DATE_ADD'>, <CodeSegment: ([L:  1, P:  9]) '('>, <CodeSegment: ([L:  1, P: 10]) 'CURRENT_DATE'>, <CodeSegment: ([L:  1, P: 22]) '('>, <CodeSegment: ([L:  1, P: 23]) "'America/New_York'">, <CodeSegment: ([L:  1, P: 41]) ')'>, <CodeSegment: ([L:  1, P: 42]) ','>, <WhitespaceSegment: ([L:  1, P: 43]) ' '>, <CodeSegment: ([L:  1, P: 44]) 'INTERVAL'>, <WhitespaceSegment: ([L:  1, P: 52]) ' '>, <CodeSegment: ([L:  1, P: 53]) '1'>, <WhitespaceSegment: ([L:  1, P: 54]) ' '>, <CodeSegment: ([L:  1, P: 55]) 'year'>, <CodeSegment: ([L:  1, P: 59]) ')'>)
Base route...
<ExpressionSegment: ([L:  1, P:  1])>
<ExpressionSegment: ([L:  1, P:  1])>
<class 'sqlfluff.dialects.dialect_ansi.ExpressionSegment'>
<class 'str'>
------------------------------ Captured log call -------------------------------
DEBUG    sqlfluff.parser:base.py:777 ExpressionSegment.parse: no grammar. Going straight to expansion
DEBUG    sqlfluff.parser:base.py:859 ExpressionSegment.parse: Done Parse. Plotting Recursion. Recurse=True
DEBUG    sqlfluff.parser:base.py:868 ###
#
# Beginning Parse Depth 1: ExpressionSegment
#
###
Initial Structure:
[L:  1, P:  1]      |expression:
[L:  1, P:  1]      |    raw:                                                      'DATE_ADD'
[L:  1, P:  9]      |    raw:                                                      '('
[L:  1, P: 10]      |    raw:                                                      'CURRENT_DATE'
[L:  1, P: 22]      |    raw:                                                      '('
[L:  1, P: 23]      |    raw:                                                      "'America/New_York'"
[L:  1, P: 41]      |    raw:                                                      ')'
[L:  1, P: 42]      |    comma:                                                    ','
[L:  1, P: 43]      |    whitespace:                                               ' '
[L:  1, P: 44]      |    raw:                                                      'INTERVAL'
[L:  1, P: 52]      |    whitespace:                                               ' '
[L:  1, P: 53]      |    raw:                                                      '1'
[L:  1, P: 54]      |    whitespace:                                               ' '
[L:  1, P: 55]      |    raw:                                                      'year'
[L:  1, P: 59]      |    raw:                                                      ')'

INFO     sqlfluff.parser:base.py:251 [PD:1] Skipping expansion of <CodeSegment: ([L:  1, P:  1]) 'DATE_ADD'>...
INFO     sqlfluff.parser:base.py:251 [PD:1] Skipping expansion of <CodeSegment: ([L:  1, P:  9]) '('>...
INFO     sqlfluff.parser:base.py:251 [PD:1] Skipping expansion of <CodeSegment: ([L:  1, P: 10]) 'CURRENT_DATE'>...
INFO     sqlfluff.parser:base.py:251 [PD:1] Skipping expansion of <CodeSegment: ([L:  1, P: 22]) '('>...
INFO     sqlfluff.parser:base.py:251 [PD:1] Skipping expansion of <CodeSegment: ([L:  1, P: 23]) "'America/New_York'">...
INFO     sqlfluff.parser:base.py:251 [PD:1] Skipping expansion of <CodeSegment: ([L:  1, P: 41]) ')'>...
INFO     sqlfluff.parser:base.py:251 [PD:1] Skipping expansion of <CodeSegment: ([L:  1, P: 42]) ','>...
INFO     sqlfluff.parser:base.py:251 [PD:1] Skipping expansion of <WhitespaceSegment: ([L:  1, P: 43]) ' '>...
INFO     sqlfluff.parser:base.py:251 [PD:1] Skipping expansion of <CodeSegment: ([L:  1, P: 44]) 'INTERVAL'>...
INFO     sqlfluff.parser:base.py:251 [PD:1] Skipping expansion of <WhitespaceSegment: ([L:  1, P: 52]) ' '>...
INFO     sqlfluff.parser:base.py:251 [PD:1] Skipping expansion of <CodeSegment: ([L:  1, P: 53]) '1'>...
INFO     sqlfluff.parser:base.py:251 [PD:1] Skipping expansion of <WhitespaceSegment: ([L:  1, P: 54]) ' '>...
INFO     sqlfluff.parser:base.py:251 [PD:1] Skipping expansion of <CodeSegment: ([L:  1, P: 55]) 'year'>...
INFO     sqlfluff.parser:base.py:251 [PD:1] Skipping expansion of <CodeSegment: ([L:  1, P: 59]) ')'>...
__ test__dialect__ansi_specific_segment_parses[ExpressionSegment-my_array[1]] __
----------------------------- Captured stdout call -----------------------------
(<CodeSegment: ([L:  1, P:  1]) 'my_array'>, <CodeSegment: ([L:  1, P:  9]) '['>, <CodeSegment: ([L:  1, P: 10]) '1'>, <CodeSegment: ([L:  1, P: 11]) ']'>)
Base route...
<ExpressionSegment: ([L:  1, P:  1])>
<ExpressionSegment: ([L:  1, P:  1])>
<class 'sqlfluff.dialects.dialect_ansi.ExpressionSegment'>
<class 'str'>
------------------------------ Captured log call -------------------------------
DEBUG    sqlfluff.parser:base.py:777 ExpressionSegment.parse: no grammar. Going straight to expansion
DEBUG    sqlfluff.parser:base.py:859 ExpressionSegment.parse: Done Parse. Plotting Recursion. Recurse=True
DEBUG    sqlfluff.parser:base.py:868 ###
#
# Beginning Parse Depth 1: ExpressionSegment
#
###
Initial Structure:
[L:  1, P:  1]      |expression:
[L:  1, P:  1]      |    raw:                                                      'my_array'
[L:  1, P:  9]      |    raw:                                                      '['
[L:  1, P: 10]      |    raw:                                                      '1'
[L:  1, P: 11]      |    raw:                                                      ']'

INFO     sqlfluff.parser:base.py:251 [PD:1] Skipping expansion of <CodeSegment: ([L:  1, P:  1]) 'my_array'>...
INFO     sqlfluff.parser:base.py:251 [PD:1] Skipping expansion of <CodeSegment: ([L:  1, P:  9]) '['>...
INFO     sqlfluff.parser:base.py:251 [PD:1] Skipping expansion of <CodeSegment: ([L:  1, P: 10]) '1'>...
INFO     sqlfluff.parser:base.py:251 [PD:1] Skipping expansion of <CodeSegment: ([L:  1, P: 11]) ']'>...
_ test__dialect__ansi_specific_segment_parses[ExpressionSegment-my_array[OFFSET(1)]] _
----------------------------- Captured stdout call -----------------------------
(<CodeSegment: ([L:  1, P:  1]) 'my_array'>, <CodeSegment: ([L:  1, P:  9]) '['>, <CodeSegment: ([L:  1, P: 10]) 'OFFSET'>, <CodeSegment: ([L:  1, P: 16]) '('>, <CodeSegment: ([L:  1, P: 17]) '1'>, <CodeSegment: ([L:  1, P: 18]) ')'>, <CodeSegment: ([L:  1, P: 19]) ']'>)
Base route...
<ExpressionSegment: ([L:  1, P:  1])>
<ExpressionSegment: ([L:  1, P:  1])>
<class 'sqlfluff.dialects.dialect_ansi.ExpressionSegment'>
<class 'str'>
------------------------------ Captured log call -------------------------------
DEBUG    sqlfluff.parser:base.py:777 ExpressionSegment.parse: no grammar. Going straight to expansion
DEBUG    sqlfluff.parser:base.py:859 ExpressionSegment.parse: Done Parse. Plotting Recursion. Recurse=True
DEBUG    sqlfluff.parser:base.py:868 ###
#
# Beginning Parse Depth 1: ExpressionSegment
#
###
Initial Structure:
[L:  1, P:  1]      |expression:
[L:  1, P:  1]      |    raw:                                                      'my_array'
[L:  1, P:  9]      |    raw:                                                      '['
[L:  1, P: 10]      |    raw:                                                      'OFFSET'
[L:  1, P: 16]      |    raw:                                                      '('
[L:  1, P: 17]      |    raw:                                                      '1'
[L:  1, P: 18]      |    raw:                                                      ')'
[L:  1, P: 19]      |    raw:                                                      ']'

INFO     sqlfluff.parser:base.py:251 [PD:1] Skipping expansion of <CodeSegment: ([L:  1, P:  1]) 'my_array'>...
INFO     sqlfluff.parser:base.py:251 [PD:1] Skipping expansion of <CodeSegment: ([L:  1, P:  9]) '['>...
INFO     sqlfluff.parser:base.py:251 [PD:1] Skipping expansion of <CodeSegment: ([L:  1, P: 10]) 'OFFSET'>...
INFO     sqlfluff.parser:base.py:251 [PD:1] Skipping expansion of <CodeSegment: ([L:  1, P: 16]) '('>...
INFO     sqlfluff.parser:base.py:251 [PD:1] Skipping expansion of <CodeSegment: ([L:  1, P: 17]) '1'>...
INFO     sqlfluff.parser:base.py:251 [PD:1] Skipping expansion of <CodeSegment: ([L:  1, P: 18]) ')'>...
INFO     sqlfluff.parser:base.py:251 [PD:1] Skipping expansion of <CodeSegment: ([L:  1, P: 19]) ']'>...
_ test__dialect__ansi_specific_segment_parses[ExpressionSegment-my_array[5:8]] _
----------------------------- Captured stdout call -----------------------------
(<CodeSegment: ([L:  1, P:  1]) 'my_array'>, <CodeSegment: ([L:  1, P:  9]) '['>, <CodeSegment: ([L:  1, P: 10]) '5'>, <CodeSegment: ([L:  1, P: 11]) ':'>, <CodeSegment: ([L:  1, P: 12]) '8'>, <CodeSegment: ([L:  1, P: 13]) ']'>)
Base route...
<ExpressionSegment: ([L:  1, P:  1])>
<ExpressionSegment: ([L:  1, P:  1])>
<class 'sqlfluff.dialects.dialect_ansi.ExpressionSegment'>
<class 'str'>
------------------------------ Captured log call -------------------------------
DEBUG    sqlfluff.parser:base.py:777 ExpressionSegment.parse: no grammar. Going straight to expansion
DEBUG    sqlfluff.parser:base.py:859 ExpressionSegment.parse: Done Parse. Plotting Recursion. Recurse=True
DEBUG    sqlfluff.parser:base.py:868 ###
#
# Beginning Parse Depth 1: ExpressionSegment
#
###
Initial Structure:
[L:  1, P:  1]      |expression:
[L:  1, P:  1]      |    raw:                                                      'my_array'
[L:  1, P:  9]      |    raw:                                                      '['
[L:  1, P: 10]      |    raw:                                                      '5'
[L:  1, P: 11]      |    raw:                                                      ':'
[L:  1, P: 12]      |    raw:                                                      '8'
[L:  1, P: 13]      |    raw:                                                      ']'

INFO     sqlfluff.parser:base.py:251 [PD:1] Skipping expansion of <CodeSegment: ([L:  1, P:  1]) 'my_array'>...
INFO     sqlfluff.parser:base.py:251 [PD:1] Skipping expansion of <CodeSegment: ([L:  1, P:  9]) '['>...
INFO     sqlfluff.parser:base.py:251 [PD:1] Skipping expansion of <CodeSegment: ([L:  1, P: 10]) '5'>...
INFO     sqlfluff.parser:base.py:251 [PD:1] Skipping expansion of <CodeSegment: ([L:  1, P: 11]) ':'>...
INFO     sqlfluff.parser:base.py:251 [PD:1] Skipping expansion of <CodeSegment: ([L:  1, P: 12]) '8'>...
INFO     sqlfluff.parser:base.py:251 [PD:1] Skipping expansion of <CodeSegment: ([L:  1, P: 13]) ']'>...
_ test__dialect__ansi_specific_segment_parses[ExpressionSegment-4 + my_array[OFFSET(1)]] _
----------------------------- Captured stdout call -----------------------------
(<CodeSegment: ([L:  1, P:  1]) '4'>, <WhitespaceSegment: ([L:  1, P:  2]) ' '>, <CodeSegment: ([L:  1, P:  3]) '+'>, <WhitespaceSegment: ([L:  1, P:  4]) ' '>, <CodeSegment: ([L:  1, P:  5]) 'my_array'>, <CodeSegment: ([L:  1, P: 13]) '['>, <CodeSegment: ([L:  1, P: 14]) 'OFFSET'>, <CodeSegment: ([L:  1, P: 20]) '('>, <CodeSegment: ([L:  1, P: 21]) '1'>, <CodeSegment: ([L:  1, P: 22]) ')'>, <CodeSegment: ([L:  1, P: 23]) ']'>)
Base route...
<ExpressionSegment: ([L:  1, P:  1])>
<ExpressionSegment: ([L:  1, P:  1])>
<class 'sqlfluff.dialects.dialect_ansi.ExpressionSegment'>
<class 'str'>
------------------------------ Captured log call -------------------------------
DEBUG    sqlfluff.parser:base.py:777 ExpressionSegment.parse: no grammar. Going straight to expansion
DEBUG    sqlfluff.parser:base.py:859 ExpressionSegment.parse: Done Parse. Plotting Recursion. Recurse=True
DEBUG    sqlfluff.parser:base.py:868 ###
#
# Beginning Parse Depth 1: ExpressionSegment
#
###
Initial Structure:
[L:  1, P:  1]      |expression:
[L:  1, P:  1]      |    raw:                                                      '4'
[L:  1, P:  2]      |    whitespace:                                               ' '
[L:  1, P:  3]      |    raw:                                                      '+'
[L:  1, P:  4]      |    whitespace:                                               ' '
[L:  1, P:  5]      |    raw:                                                      'my_array'
[L:  1, P: 13]      |    raw:                                                      '['
[L:  1, P: 14]      |    raw:                                                      'OFFSET'
[L:  1, P: 20]      |    raw:                                                      '('
[L:  1, P: 21]      |    raw:                                                      '1'
[L:  1, P: 22]      |    raw:                                                      ')'
[L:  1, P: 23]      |    raw:                                                      ']'

INFO     sqlfluff.parser:base.py:251 [PD:1] Skipping expansion of <CodeSegment: ([L:  1, P:  1]) '4'>...
INFO     sqlfluff.parser:base.py:251 [PD:1] Skipping expansion of <WhitespaceSegment: ([L:  1, P:  2]) ' '>...
INFO     sqlfluff.parser:base.py:251 [PD:1] Skipping expansion of <CodeSegment: ([L:  1, P:  3]) '+'>...
INFO     sqlfluff.parser:base.py:251 [PD:1] Skipping expansion of <WhitespaceSegment: ([L:  1, P:  4]) ' '>...
INFO     sqlfluff.parser:base.py:251 [PD:1] Skipping expansion of <CodeSegment: ([L:  1, P:  5]) 'my_array'>...
INFO     sqlfluff.parser:base.py:251 [PD:1] Skipping expansion of <CodeSegment: ([L:  1, P: 13]) '['>...
INFO     sqlfluff.parser:base.py:251 [PD:1] Skipping expansion of <CodeSegment: ([L:  1, P: 14]) 'OFFSET'>...
INFO     sqlfluff.parser:base.py:251 [PD:1] Skipping expansion of <CodeSegment: ([L:  1, P: 20]) '('>...
INFO     sqlfluff.parser:base.py:251 [PD:1] Skipping expansion of <CodeSegment: ([L:  1, P: 21]) '1'>...
INFO     sqlfluff.parser:base.py:251 [PD:1] Skipping expansion of <CodeSegment: ([L:  1, P: 22]) ')'>...
INFO     sqlfluff.parser:base.py:251 [PD:1] Skipping expansion of <CodeSegment: ([L:  1, P: 23]) ']'>...
_ test__dialect__ansi_specific_segment_parses[ExpressionSegment-bits[OFFSET(0)] + 7] _
----------------------------- Captured stdout call -----------------------------
(<CodeSegment: ([L:  1, P:  1]) 'bits'>, <CodeSegment: ([L:  1, P:  5]) '['>, <CodeSegment: ([L:  1, P:  6]) 'OFFSET'>, <CodeSegment: ([L:  1, P: 12]) '('>, <CodeSegment: ([L:  1, P: 13]) '0'>, <CodeSegment: ([L:  1, P: 14]) ')'>, <CodeSegment: ([L:  1, P: 15]) ']'>, <WhitespaceSegment: ([L:  1, P: 16]) ' '>, <CodeSegment: ([L:  1, P: 17]) '+'>, <WhitespaceSegment: ([L:  1, P: 18]) ' '>, <CodeSegment: ([L:  1, P: 19]) '7'>)
Base route...
<ExpressionSegment: ([L:  1, P:  1])>
<ExpressionSegment: ([L:  1, P:  1])>
<class 'sqlfluff.dialects.dialect_ansi.ExpressionSegment'>
<class 'str'>
------------------------------ Captured log call -------------------------------
DEBUG    sqlfluff.parser:base.py:777 ExpressionSegment.parse: no grammar. Going straight to expansion
DEBUG    sqlfluff.parser:base.py:859 ExpressionSegment.parse: Done Parse. Plotting Recursion. Recurse=True
DEBUG    sqlfluff.parser:base.py:868 ###
#
# Beginning Parse Depth 1: ExpressionSegment
#
###
Initial Structure:
[L:  1, P:  1]      |expression:
[L:  1, P:  1]      |    raw:                                                      'bits'
[L:  1, P:  5]      |    raw:                                                      '['
[L:  1, P:  6]      |    raw:                                                      'OFFSET'
[L:  1, P: 12]      |    raw:                                                      '('
[L:  1, P: 13]      |    raw:                                                      '0'
[L:  1, P: 14]      |    raw:                                                      ')'
[L:  1, P: 15]      |    raw:                                                      ']'
[L:  1, P: 16]      |    whitespace:                                               ' '
[L:  1, P: 17]      |    raw:                                                      '+'
[L:  1, P: 18]      |    whitespace:                                               ' '
[L:  1, P: 19]      |    raw:                                                      '7'

INFO     sqlfluff.parser:base.py:251 [PD:1] Skipping expansion of <CodeSegment: ([L:  1, P:  1]) 'bits'>...
INFO     sqlfluff.parser:base.py:251 [PD:1] Skipping expansion of <CodeSegment: ([L:  1, P:  5]) '['>...
INFO     sqlfluff.parser:base.py:251 [PD:1] Skipping expansion of <CodeSegment: ([L:  1, P:  6]) 'OFFSET'>...
INFO     sqlfluff.parser:base.py:251 [PD:1] Skipping expansion of <CodeSegment: ([L:  1, P: 12]) '('>...
INFO     sqlfluff.parser:base.py:251 [PD:1] Skipping expansion of <CodeSegment: ([L:  1, P: 13]) '0'>...
INFO     sqlfluff.parser:base.py:251 [PD:1] Skipping expansion of <CodeSegment: ([L:  1, P: 14]) ')'>...
INFO     sqlfluff.parser:base.py:251 [PD:1] Skipping expansion of <CodeSegment: ([L:  1, P: 15]) ']'>...
INFO     sqlfluff.parser:base.py:251 [PD:1] Skipping expansion of <WhitespaceSegment: ([L:  1, P: 16]) ' '>...
INFO     sqlfluff.parser:base.py:251 [PD:1] Skipping expansion of <CodeSegment: ([L:  1, P: 17]) '+'>...
INFO     sqlfluff.parser:base.py:251 [PD:1] Skipping expansion of <WhitespaceSegment: ([L:  1, P: 18]) ' '>...
INFO     sqlfluff.parser:base.py:251 [PD:1] Skipping expansion of <CodeSegment: ([L:  1, P: 19]) '7'>...
_ test__dialect__ansi_specific_segment_parses[ExpressionSegment-count_18_24 * bits[OFFSET(0)] + count_25_34] _
----------------------------- Captured stdout call -----------------------------
(<CodeSegment: ([L:  1, P:  1]) 'count_18_24'>, <WhitespaceSegment: ([L:  1, P: 12]) ' '>, <CodeSegment: ([L:  1, P: 13]) '*'>, <WhitespaceSegment: ([L:  1, P: 14]) ' '>, <CodeSegment: ([L:  1, P: 15]) 'bits'>, <CodeSegment: ([L:  1, P: 19]) '['>, <CodeSegment: ([L:  1, P: 20]) 'OFFSET'>, <CodeSegment: ([L:  1, P: 26]) '('>, <CodeSegment: ([L:  1, P: 27]) '0'>, <CodeSegment: ([L:  1, P: 28]) ')'>, <CodeSegment: ([L:  1, P: 29]) ']'>, <WhitespaceSegment: ([L:  1, P: 30]) ' '>, <CodeSegment: ([L:  1, P: 31]) '+'>, <WhitespaceSegment: ([L:  1, P: 32]) ' '>, <CodeSegment: ([L:  1, P: 33]) 'count_25_34'>)
Base route...
<ExpressionSegment: ([L:  1, P:  1])>
<ExpressionSegment: ([L:  1, P:  1])>
<class 'sqlfluff.dialects.dialect_ansi.ExpressionSegment'>
<class 'str'>
------------------------------ Captured log call -------------------------------
DEBUG    sqlfluff.parser:base.py:777 ExpressionSegment.parse: no grammar. Going straight to expansion
DEBUG    sqlfluff.parser:base.py:859 ExpressionSegment.parse: Done Parse. Plotting Recursion. Recurse=True
DEBUG    sqlfluff.parser:base.py:868 ###
#
# Beginning Parse Depth 1: ExpressionSegment
#
###
Initial Structure:
[L:  1, P:  1]      |expression:
[L:  1, P:  1]      |    raw:                                                      'count_18_24'
[L:  1, P: 12]      |    whitespace:                                               ' '
[L:  1, P: 13]      |    raw:                                                      '*'
[L:  1, P: 14]      |    whitespace:                                               ' '
[L:  1, P: 15]      |    raw:                                                      'bits'
[L:  1, P: 19]      |    raw:                                                      '['
[L:  1, P: 20]      |    raw:                                                      'OFFSET'
[L:  1, P: 26]      |    raw:                                                      '('
[L:  1, P: 27]      |    raw:                                                      '0'
[L:  1, P: 28]      |    raw:                                                      ')'
[L:  1, P: 29]      |    raw:                                                      ']'
[L:  1, P: 30]      |    whitespace:                                               ' '
[L:  1, P: 31]      |    raw:                                                      '+'
[L:  1, P: 32]      |    whitespace:                                               ' '
[L:  1, P: 33]      |    raw:                                                      'count_25_34'

INFO     sqlfluff.parser:base.py:251 [PD:1] Skipping expansion of <CodeSegment: ([L:  1, P:  1]) 'count_18_24'>...
INFO     sqlfluff.parser:base.py:251 [PD:1] Skipping expansion of <WhitespaceSegment: ([L:  1, P: 12]) ' '>...
INFO     sqlfluff.parser:base.py:251 [PD:1] Skipping expansion of <CodeSegment: ([L:  1, P: 13]) '*'>...
INFO     sqlfluff.parser:base.py:251 [PD:1] Skipping expansion of <WhitespaceSegment: ([L:  1, P: 14]) ' '>...
INFO     sqlfluff.parser:base.py:251 [PD:1] Skipping expansion of <CodeSegment: ([L:  1, P: 15]) 'bits'>...
INFO     sqlfluff.parser:base.py:251 [PD:1] Skipping expansion of <CodeSegment: ([L:  1, P: 19]) '['>...
INFO     sqlfluff.parser:base.py:251 [PD:1] Skipping expansion of <CodeSegment: ([L:  1, P: 20]) 'OFFSET'>...
INFO     sqlfluff.parser:base.py:251 [PD:1] Skipping expansion of <CodeSegment: ([L:  1, P: 26]) '('>...
INFO     sqlfluff.parser:base.py:251 [PD:1] Skipping expansion of <CodeSegment: ([L:  1, P: 27]) '0'>...
INFO     sqlfluff.parser:base.py:251 [PD:1] Skipping expansion of <CodeSegment: ([L:  1, P: 28]) ')'>...
INFO     sqlfluff.parser:base.py:251 [PD:1] Skipping expansion of <CodeSegment: ([L:  1, P: 29]) ']'>...
INFO     sqlfluff.parser:base.py:251 [PD:1] Skipping expansion of <WhitespaceSegment: ([L:  1, P: 30]) ' '>...
INFO     sqlfluff.parser:base.py:251 [PD:1] Skipping expansion of <CodeSegment: ([L:  1, P: 31]) '+'>...
INFO     sqlfluff.parser:base.py:251 [PD:1] Skipping expansion of <WhitespaceSegment: ([L:  1, P: 32]) ' '>...
INFO     sqlfluff.parser:base.py:251 [PD:1] Skipping expansion of <CodeSegment: ([L:  1, P: 33]) 'count_25_34'>...
__ test__dialect__ansi_specific_segment_parses[ObjectReferenceSegment-a..c.*] __
----------------------------- Captured stdout call -----------------------------
(<CodeSegment: ([L:  1, P:  1]) 'a'>, <CodeSegment: ([L:  1, P:  2]) '.'>, <CodeSegment: ([L:  1, P:  3]) '.'>, <CodeSegment: ([L:  1, P:  4]) 'c'>, <CodeSegment: ([L:  1, P:  5]) '.'>, <CodeSegment: ([L:  1, P:  6]) '*'>)
Base route...
<ObjectReferenceSegment: ([L:  1, P:  1])>
<ObjectReferenceSegment: ([L:  1, P:  1])>
<class 'sqlfluff.dialects.dialect_ansi.ObjectReferenceSegment'>
<class 'str'>
------------------------------ Captured log call -------------------------------
DEBUG    sqlfluff.parser:base.py:777 ObjectReferenceSegment.parse: no grammar. Going straight to expansion
DEBUG    sqlfluff.parser:base.py:859 ObjectReferenceSegment.parse: Done Parse. Plotting Recursion. Recurse=True
DEBUG    sqlfluff.parser:base.py:868 ###
#
# Beginning Parse Depth 1: ObjectReferenceSegment
#
###
Initial Structure:
[L:  1, P:  1]      |object_reference:
[L:  1, P:  1]      |    raw:                                                      'a'
[L:  1, P:  2]      |    raw:                                                      '.'
[L:  1, P:  3]      |    raw:                                                      '.'
[L:  1, P:  4]      |    raw:                                                      'c'
[L:  1, P:  5]      |    raw:                                                      '.'
[L:  1, P:  6]      |    raw:                                                      '*'

INFO     sqlfluff.parser:base.py:251 [PD:1] Skipping expansion of <CodeSegment: ([L:  1, P:  1]) 'a'>...
INFO     sqlfluff.parser:base.py:251 [PD:1] Skipping expansion of <CodeSegment: ([L:  1, P:  2]) '.'>...
INFO     sqlfluff.parser:base.py:251 [PD:1] Skipping expansion of <CodeSegment: ([L:  1, P:  3]) '.'>...
INFO     sqlfluff.parser:base.py:251 [PD:1] Skipping expansion of <CodeSegment: ([L:  1, P:  4]) 'c'>...
INFO     sqlfluff.parser:base.py:251 [PD:1] Skipping expansion of <CodeSegment: ([L:  1, P:  5]) '.'>...
INFO     sqlfluff.parser:base.py:251 [PD:1] Skipping expansion of <CodeSegment: ([L:  1, P:  6]) '*'>...
_ test__dialect__ansi_specific_segment_parses[ExpressionSegment-concat(left(uaid, 2), '|', right(concat('0000000', SPLIT_PART(uaid, '|', 4)), 10), '|', '00000000')] _
----------------------------- Captured stdout call -----------------------------
(<CodeSegment: ([L:  1, P:  1]) 'concat'>, <CodeSegment: ([L:  1, P:  7]) '('>, <CodeSegment: ([L:  1, P:  8]) 'left'>, <CodeSegment: ([L:  1, P: 12]) '('>, <CodeSegment: ([L:  1, P: 13]) 'uaid'>, <CodeSegment: ([L:  1, P: 17]) ','>, <WhitespaceSegment: ([L:  1, P: 18]) ' '>, <CodeSegment: ([L:  1, P: 19]) '2'>, <CodeSegment: ([L:  1, P: 20]) ')'>, <CodeSegment: ([L:  1, P: 21]) ','>, <WhitespaceSegment: ([L:  1, P: 22]) ' '>, <CodeSegment: ([L:  1, P: 23]) "'|'">, <CodeSegment: ([L:  1, P: 26]) ','>, <WhitespaceSegment: ([L:  1, P: 27]) ' '>, <CodeSegment: ([L:  1, P: 28]) 'right'>, <CodeSegment: ([L:  1, P: 33]) '('>, <CodeSegment: ([L:  1, P: 34]) 'concat'>, <CodeSegment: ([L:  1, P: 40]) '('>, <CodeSegment: ([L:  1, P: 41]) "'0000000'">, <CodeSegment: ([L:  1, P: 50]) ','>, <WhitespaceSegment: ([L:  1, P: 51]) ' '>, <CodeSegment: ([L:  1, P: 52]) 'SPLIT_PART'>, <CodeSegment: ([L:  1, P: 62]) '('>, <CodeSegment: ([L:  1, P: 63]) 'uaid'>, <CodeSegment: ([L:  1, P: 67]) ','>, <WhitespaceSegment: ([L:  1, P: 68]) ' '>, <CodeSegment: ([L:  1, P: 69]) "'|'">, <CodeSegment: ([L:  1, P: 72]) ','>, <WhitespaceSegment: ([L:  1, P: 73]) ' '>, <CodeSegment: ([L:  1, P: 74]) '4'>, <CodeSegment: ([L:  1, P: 75]) ')'>, <CodeSegment: ([L:  1, P: 76]) ')'>, <CodeSegment: ([L:  1, P: 77]) ','>, <WhitespaceSegment: ([L:  1, P: 78]) ' '>, <CodeSegment: ([L:  1, P: 79]) '10'>, <CodeSegment: ([L:  1, P: 81]) ')'>, <CodeSegment: ([L:  1, P: 82]) ','>, <WhitespaceSegment: ([L:  1, P: 83]) ' '>, <CodeSegment: ([L:  1, P: 84]) "'|'">, <CodeSegment: ([L:  1, P: 87]) ','>, <WhitespaceSegment: ([L:  1, P: 88]) ' '>, <CodeSegment: ([L:  1, P: 89]) "'00000000'">, <CodeSegment: ([L:  1, P: 99]) ')'>)
Base route...
<ExpressionSegment: ([L:  1, P:  1])>
<ExpressionSegment: ([L:  1, P:  1])>
<class 'sqlfluff.dialects.dialect_ansi.ExpressionSegment'>
<class 'str'>
------------------------------ Captured log call -------------------------------
DEBUG    sqlfluff.parser:base.py:777 ExpressionSegment.parse: no grammar. Going straight to expansion
DEBUG    sqlfluff.parser:base.py:859 ExpressionSegment.parse: Done Parse. Plotting Recursion. Recurse=True
DEBUG    sqlfluff.parser:base.py:868 ###
#
# Beginning Parse Depth 1: ExpressionSegment
#
###
Initial Structure:
[L:  1, P:  1]      |expression:
[L:  1, P:  1]      |    raw:                                                      'concat'
[L:  1, P:  7]      |    raw:                                                      '('
[L:  1, P:  8]      |    raw:                                                      'left'
[L:  1, P: 12]      |    raw:                                                      '('
[L:  1, P: 13]      |    raw:                                                      'uaid'
[L:  1, P: 17]      |    comma:                                                    ','
[L:  1, P: 18]      |    whitespace:                                               ' '
[L:  1, P: 19]      |    raw:                                                      '2'
[L:  1, P: 20]      |    raw:                                                      ')'
[L:  1, P: 21]      |    comma:                                                    ','
[L:  1, P: 22]      |    whitespace:                                               ' '
[L:  1, P: 23]      |    raw:                                                      "'|'"
[L:  1, P: 26]      |    comma:                                                    ','
[L:  1, P: 27]      |    whitespace:                                               ' '
[L:  1, P: 28]      |    raw:                                                      'right'
[L:  1, P: 33]      |    raw:                                                      '('
[L:  1, P: 34]      |    raw:                                                      'concat'
[L:  1, P: 40]      |    raw:                                                      '('
[L:  1, P: 41]      |    raw:                                                      "'0000000'"
[L:  1, P: 50]      |    comma:                                                    ','
[L:  1, P: 51]      |    whitespace:                                               ' '
[L:  1, P: 52]      |    raw:                                                      'SPLIT_PART'
[L:  1, P: 62]      |    raw:                                                      '('
[L:  1, P: 63]      |    raw:                                                      'uaid'
[L:  1, P: 67]      |    comma:                                                    ','
[L:  1, P: 68]      |    whitespace:                                               ' '
[L:  1, P: 69]      |    raw:                                                      "'|'"
[L:  1, P: 72]      |    comma:                                                    ','
[L:  1, P: 73]      |    whitespace:                                               ' '
[L:  1, P: 74]      |    raw:                                                      '4'
[L:  1, P: 75]      |    raw:                                                      ')'
[L:  1, P: 76]      |    raw:                                                      ')'
[L:  1, P: 77]      |    comma:                                                    ','
[L:  1, P: 78]      |    whitespace:                                               ' '
[L:  1, P: 79]      |    raw:                                                      '10'
[L:  1, P: 81]      |    raw:                                                      ')'
[L:  1, P: 82]      |    comma:                                                    ','
[L:  1, P: 83]      |    whitespace:                                               ' '
[L:  1, P: 84]      |    raw:                                                      "'|'"
[L:  1, P: 87]      |    comma:                                                    ','
[L:  1, P: 88]      |    whitespace:                                               ' '
[L:  1, P: 89]      |    raw:                                                      "'00000000'"
[L:  1, P: 99]      |    raw:                                                      ')'

INFO     sqlfluff.parser:base.py:251 [PD:1] Skipping expansion of <CodeSegment: ([L:  1, P:  1]) 'concat'>...
INFO     sqlfluff.parser:base.py:251 [PD:1] Skipping expansion of <CodeSegment: ([L:  1, P:  7]) '('>...
INFO     sqlfluff.parser:base.py:251 [PD:1] Skipping expansion of <CodeSegment: ([L:  1, P:  8]) 'left'>...
INFO     sqlfluff.parser:base.py:251 [PD:1] Skipping expansion of <CodeSegment: ([L:  1, P: 12]) '('>...
INFO     sqlfluff.parser:base.py:251 [PD:1] Skipping expansion of <CodeSegment: ([L:  1, P: 13]) 'uaid'>...
INFO     sqlfluff.parser:base.py:251 [PD:1] Skipping expansion of <CodeSegment: ([L:  1, P: 17]) ','>...
INFO     sqlfluff.parser:base.py:251 [PD:1] Skipping expansion of <WhitespaceSegment: ([L:  1, P: 18]) ' '>...
INFO     sqlfluff.parser:base.py:251 [PD:1] Skipping expansion of <CodeSegment: ([L:  1, P: 19]) '2'>...
INFO     sqlfluff.parser:base.py:251 [PD:1] Skipping expansion of <CodeSegment: ([L:  1, P: 20]) ')'>...
INFO     sqlfluff.parser:base.py:251 [PD:1] Skipping expansion of <CodeSegment: ([L:  1, P: 21]) ','>...
INFO     sqlfluff.parser:base.py:251 [PD:1] Skipping expansion of <WhitespaceSegment: ([L:  1, P: 22]) ' '>...
INFO     sqlfluff.parser:base.py:251 [PD:1] Skipping expansion of <CodeSegment: ([L:  1, P: 23]) "'|'">...
INFO     sqlfluff.parser:base.py:251 [PD:1] Skipping expansion of <CodeSegment: ([L:  1, P: 26]) ','>...
INFO     sqlfluff.parser:base.py:251 [PD:1] Skipping expansion of <WhitespaceSegment: ([L:  1, P: 27]) ' '>...
INFO     sqlfluff.parser:base.py:251 [PD:1] Skipping expansion of <CodeSegment: ([L:  1, P: 28]) 'right'>...
INFO     sqlfluff.parser:base.py:251 [PD:1] Skipping expansion of <CodeSegment: ([L:  1, P: 33]) '('>...
INFO     sqlfluff.parser:base.py:251 [PD:1] Skipping expansion of <CodeSegment: ([L:  1, P: 34]) 'concat'>...
INFO     sqlfluff.parser:base.py:251 [PD:1] Skipping expansion of <CodeSegment: ([L:  1, P: 40]) '('>...
INFO     sqlfluff.parser:base.py:251 [PD:1] Skipping expansion of <CodeSegment: ([L:  1, P: 41]) "'0000000'">...
INFO     sqlfluff.parser:base.py:251 [PD:1] Skipping expansion of <CodeSegment: ([L:  1, P: 50]) ','>...
INFO     sqlfluff.parser:base.py:251 [PD:1] Skipping expansion of <WhitespaceSegment: ([L:  1, P: 51]) ' '>...
INFO     sqlfluff.parser:base.py:251 [PD:1] Skipping expansion of <CodeSegment: ([L:  1, P: 52]) 'SPLIT_PART'>...
INFO     sqlfluff.parser:base.py:251 [PD:1] Skipping expansion of <CodeSegment: ([L:  1, P: 62]) '('>...
INFO     sqlfluff.parser:base.py:251 [PD:1] Skipping expansion of <CodeSegment: ([L:  1, P: 63]) 'uaid'>...
INFO     sqlfluff.parser:base.py:251 [PD:1] Skipping expansion of <CodeSegment: ([L:  1, P: 67]) ','>...
INFO     sqlfluff.parser:base.py:251 [PD:1] Skipping expansion of <WhitespaceSegment: ([L:  1, P: 68]) ' '>...
INFO     sqlfluff.parser:base.py:251 [PD:1] Skipping expansion of <CodeSegment: ([L:  1, P: 69]) "'|'">...
INFO     sqlfluff.parser:base.py:251 [PD:1] Skipping expansion of <CodeSegment: ([L:  1, P: 72]) ','>...
INFO     sqlfluff.parser:base.py:251 [PD:1] Skipping expansion of <WhitespaceSegment: ([L:  1, P: 73]) ' '>...
INFO     sqlfluff.parser:base.py:251 [PD:1] Skipping expansion of <CodeSegment: ([L:  1, P: 74]) '4'>...
INFO     sqlfluff.parser:base.py:251 [PD:1] Skipping expansion of <CodeSegment: ([L:  1, P: 75]) ')'>...
INFO     sqlfluff.parser:base.py:251 [PD:1] Skipping expansion of <CodeSegment: ([L:  1, P: 76]) ')'>...
INFO     sqlfluff.parser:base.py:251 [PD:1] Skipping expansion of <CodeSegment: ([L:  1, P: 77]) ','>...
INFO     sqlfluff.parser:base.py:251 [PD:1] Skipping expansion of <WhitespaceSegment: ([L:  1, P: 78]) ' '>...
INFO     sqlfluff.parser:base.py:251 [PD:1] Skipping expansion of <CodeSegment: ([L:  1, P: 79]) '10'>...
INFO     sqlfluff.parser:base.py:251 [PD:1] Skipping expansion of <CodeSegment: ([L:  1, P: 81]) ')'>...
INFO     sqlfluff.parser:base.py:251 [PD:1] Skipping expansion of <CodeSegment: ([L:  1, P: 82]) ','>...
INFO     sqlfluff.parser:base.py:251 [PD:1] Skipping expansion of <WhitespaceSegment: ([L:  1, P: 83]) ' '>...
INFO     sqlfluff.parser:base.py:251 [PD:1] Skipping expansion of <CodeSegment: ([L:  1, P: 84]) "'|'">...
INFO     sqlfluff.parser:base.py:251 [PD:1] Skipping expansion of <CodeSegment: ([L:  1, P: 87]) ','>...
INFO     sqlfluff.parser:base.py:251 [PD:1] Skipping expansion of <WhitespaceSegment: ([L:  1, P: 88]) ' '>...
INFO     sqlfluff.parser:base.py:251 [PD:1] Skipping expansion of <CodeSegment: ([L:  1, P: 89]) "'00000000'">...
INFO     sqlfluff.parser:base.py:251 [PD:1] Skipping expansion of <CodeSegment: ([L:  1, P: 99]) ')'>...
___ test__dialect__ansi_specific_segment_parses[ExpressionSegment-c is null] ___
----------------------------- Captured stdout call -----------------------------
(<CodeSegment: ([L:  1, P:  1]) 'c'>, <WhitespaceSegment: ([L:  1, P:  2]) ' '>, <CodeSegment: ([L:  1, P:  3]) 'is'>, <WhitespaceSegment: ([L:  1, P:  5]) ' '>, <CodeSegment: ([L:  1, P:  6]) 'null'>)
Base route...
<ExpressionSegment: ([L:  1, P:  1])>
<ExpressionSegment: ([L:  1, P:  1])>
<class 'sqlfluff.dialects.dialect_ansi.ExpressionSegment'>
<class 'str'>
------------------------------ Captured log call -------------------------------
DEBUG    sqlfluff.parser:base.py:777 ExpressionSegment.parse: no grammar. Going straight to expansion
DEBUG    sqlfluff.parser:base.py:859 ExpressionSegment.parse: Done Parse. Plotting Recursion. Recurse=True
DEBUG    sqlfluff.parser:base.py:868 ###
#
# Beginning Parse Depth 1: ExpressionSegment
#
###
Initial Structure:
[L:  1, P:  1]      |expression:
[L:  1, P:  1]      |    raw:                                                      'c'
[L:  1, P:  2]      |    whitespace:                                               ' '
[L:  1, P:  3]      |    raw:                                                      'is'
[L:  1, P:  5]      |    whitespace:                                               ' '
[L:  1, P:  6]      |    raw:                                                      'null'

INFO     sqlfluff.parser:base.py:251 [PD:1] Skipping expansion of <CodeSegment: ([L:  1, P:  1]) 'c'>...
INFO     sqlfluff.parser:base.py:251 [PD:1] Skipping expansion of <WhitespaceSegment: ([L:  1, P:  2]) ' '>...
INFO     sqlfluff.parser:base.py:251 [PD:1] Skipping expansion of <CodeSegment: ([L:  1, P:  3]) 'is'>...
INFO     sqlfluff.parser:base.py:251 [PD:1] Skipping expansion of <WhitespaceSegment: ([L:  1, P:  5]) ' '>...
INFO     sqlfluff.parser:base.py:251 [PD:1] Skipping expansion of <CodeSegment: ([L:  1, P:  6]) 'null'>...
_ test__dialect__ansi_specific_segment_parses[ExpressionSegment-c is not null] _
----------------------------- Captured stdout call -----------------------------
(<CodeSegment: ([L:  1, P:  1]) 'c'>, <WhitespaceSegment: ([L:  1, P:  2]) ' '>, <CodeSegment: ([L:  1, P:  3]) 'is'>, <WhitespaceSegment: ([L:  1, P:  5]) ' '>, <CodeSegment: ([L:  1, P:  6]) 'not'>, <WhitespaceSegment: ([L:  1, P:  9]) ' '>, <CodeSegment: ([L:  1, P: 10]) 'null'>)
Base route...
<ExpressionSegment: ([L:  1, P:  1])>
<ExpressionSegment: ([L:  1, P:  1])>
<class 'sqlfluff.dialects.dialect_ansi.ExpressionSegment'>
<class 'str'>
------------------------------ Captured log call -------------------------------
DEBUG    sqlfluff.parser:base.py:777 ExpressionSegment.parse: no grammar. Going straight to expansion
DEBUG    sqlfluff.parser:base.py:859 ExpressionSegment.parse: Done Parse. Plotting Recursion. Recurse=True
DEBUG    sqlfluff.parser:base.py:868 ###
#
# Beginning Parse Depth 1: ExpressionSegment
#
###
Initial Structure:
[L:  1, P:  1]      |expression:
[L:  1, P:  1]      |    raw:                                                      'c'
[L:  1, P:  2]      |    whitespace:                                               ' '
[L:  1, P:  3]      |    raw:                                                      'is'
[L:  1, P:  5]      |    whitespace:                                               ' '
[L:  1, P:  6]      |    raw:                                                      'not'
[L:  1, P:  9]      |    whitespace:                                               ' '
[L:  1, P: 10]      |    raw:                                                      'null'

INFO     sqlfluff.parser:base.py:251 [PD:1] Skipping expansion of <CodeSegment: ([L:  1, P:  1]) 'c'>...
INFO     sqlfluff.parser:base.py:251 [PD:1] Skipping expansion of <WhitespaceSegment: ([L:  1, P:  2]) ' '>...
INFO     sqlfluff.parser:base.py:251 [PD:1] Skipping expansion of <CodeSegment: ([L:  1, P:  3]) 'is'>...
INFO     sqlfluff.parser:base.py:251 [PD:1] Skipping expansion of <WhitespaceSegment: ([L:  1, P:  5]) ' '>...
INFO     sqlfluff.parser:base.py:251 [PD:1] Skipping expansion of <CodeSegment: ([L:  1, P:  6]) 'not'>...
INFO     sqlfluff.parser:base.py:251 [PD:1] Skipping expansion of <WhitespaceSegment: ([L:  1, P:  9]) ' '>...
INFO     sqlfluff.parser:base.py:251 [PD:1] Skipping expansion of <CodeSegment: ([L:  1, P: 10]) 'null'>...
___ test__dialect__ansi_specific_segment_parses[ExpressionSegment-NULL::INT] ___
----------------------------- Captured stdout call -----------------------------
(<CodeSegment: ([L:  1, P:  1]) 'NULL'>, <CodeSegment: ([L:  1, P:  5]) '::'>, <CodeSegment: ([L:  1, P:  7]) 'INT'>)
Base route...
<ExpressionSegment: ([L:  1, P:  1])>
<ExpressionSegment: ([L:  1, P:  1])>
<class 'sqlfluff.dialects.dialect_ansi.ExpressionSegment'>
<class 'str'>
------------------------------ Captured log call -------------------------------
DEBUG    sqlfluff.parser:base.py:777 ExpressionSegment.parse: no grammar. Going straight to expansion
DEBUG    sqlfluff.parser:base.py:859 ExpressionSegment.parse: Done Parse. Plotting Recursion. Recurse=True
DEBUG    sqlfluff.parser:base.py:868 ###
#
# Beginning Parse Depth 1: ExpressionSegment
#
###
Initial Structure:
[L:  1, P:  1]      |expression:
[L:  1, P:  1]      |    raw:                                                      'NULL'
[L:  1, P:  5]      |    raw:                                                      '::'
[L:  1, P:  7]      |    raw:                                                      'INT'

INFO     sqlfluff.parser:base.py:251 [PD:1] Skipping expansion of <CodeSegment: ([L:  1, P:  1]) 'NULL'>...
INFO     sqlfluff.parser:base.py:251 [PD:1] Skipping expansion of <CodeSegment: ([L:  1, P:  5]) '::'>...
INFO     sqlfluff.parser:base.py:251 [PD:1] Skipping expansion of <CodeSegment: ([L:  1, P:  7]) 'INT'>...
_ test__dialect__ansi_specific_segment_parses[TruncateStatementSegment-TRUNCATE TABLE test] _
----------------------------- Captured stdout call -----------------------------
(<CodeSegment: ([L:  1, P:  1]) 'TRUNCATE'>, <WhitespaceSegment: ([L:  1, P:  9]) ' '>, <CodeSegment: ([L:  1, P: 10]) 'TABLE'>, <WhitespaceSegment: ([L:  1, P: 15]) ' '>, <CodeSegment: ([L:  1, P: 16]) 'test'>)
Base route...
<TruncateStatementSegment: ([L:  1, P:  1])>
<TruncateStatementSegment: ([L:  1, P:  1])>
<class 'sqlfluff.dialects.dialect_ansi.TruncateStatementSegment'>
<class 'str'>
------------------------------ Captured log call -------------------------------
DEBUG    sqlfluff.parser:base.py:777 TruncateStatementSegment.parse: no grammar. Going straight to expansion
DEBUG    sqlfluff.parser:base.py:859 TruncateStatementSegment.parse: Done Parse. Plotting Recursion. Recurse=True
DEBUG    sqlfluff.parser:base.py:868 ###
#
# Beginning Parse Depth 1: TruncateStatementSegment
#
###
Initial Structure:
[L:  1, P:  1]      |truncate_table:
[L:  1, P:  1]      |    raw:                                                      'TRUNCATE'
[L:  1, P:  9]      |    whitespace:                                               ' '
[L:  1, P: 10]      |    raw:                                                      'TABLE'
[L:  1, P: 15]      |    whitespace:                                               ' '
[L:  1, P: 16]      |    raw:                                                      'test'

INFO     sqlfluff.parser:base.py:251 [PD:1] Skipping expansion of <CodeSegment: ([L:  1, P:  1]) 'TRUNCATE'>...
INFO     sqlfluff.parser:base.py:251 [PD:1] Skipping expansion of <WhitespaceSegment: ([L:  1, P:  9]) ' '>...
INFO     sqlfluff.parser:base.py:251 [PD:1] Skipping expansion of <CodeSegment: ([L:  1, P: 10]) 'TABLE'>...
INFO     sqlfluff.parser:base.py:251 [PD:1] Skipping expansion of <WhitespaceSegment: ([L:  1, P: 15]) ' '>...
INFO     sqlfluff.parser:base.py:251 [PD:1] Skipping expansion of <CodeSegment: ([L:  1, P: 16]) 'test'>...
_ test__dialect__ansi_specific_segment_parses[TruncateStatementSegment-TRUNCATE test] _
----------------------------- Captured stdout call -----------------------------
(<CodeSegment: ([L:  1, P:  1]) 'TRUNCATE'>, <WhitespaceSegment: ([L:  1, P:  9]) ' '>, <CodeSegment: ([L:  1, P: 10]) 'test'>)
Base route...
<TruncateStatementSegment: ([L:  1, P:  1])>
<TruncateStatementSegment: ([L:  1, P:  1])>
<class 'sqlfluff.dialects.dialect_ansi.TruncateStatementSegment'>
<class 'str'>
------------------------------ Captured log call -------------------------------
DEBUG    sqlfluff.parser:base.py:777 TruncateStatementSegment.parse: no grammar. Going straight to expansion
DEBUG    sqlfluff.parser:base.py:859 TruncateStatementSegment.parse: Done Parse. Plotting Recursion. Recurse=True
DEBUG    sqlfluff.parser:base.py:868 ###
#
# Beginning Parse Depth 1: TruncateStatementSegment
#
###
Initial Structure:
[L:  1, P:  1]      |truncate_table:
[L:  1, P:  1]      |    raw:                                                      'TRUNCATE'
[L:  1, P:  9]      |    whitespace:                                               ' '
[L:  1, P: 10]      |    raw:                                                      'test'

INFO     sqlfluff.parser:base.py:251 [PD:1] Skipping expansion of <CodeSegment: ([L:  1, P:  1]) 'TRUNCATE'>...
INFO     sqlfluff.parser:base.py:251 [PD:1] Skipping expansion of <WhitespaceSegment: ([L:  1, P:  9]) ' '>...
INFO     sqlfluff.parser:base.py:251 [PD:1] Skipping expansion of <CodeSegment: ([L:  1, P: 10]) 'test'>...
_ test__dialect__ansi_specific_segment_not_match[ObjectReferenceSegment-\n     ] _
----------------------------- Captured stdout call -----------------------------
(<NewlineSegment: ([L:  1, P:  1]) '\n'>, <WhitespaceSegment: ([L:  2, P:  1]) '     '>)
------------------------------ Captured log call -------------------------------
DEBUG    sqlfluff.parser:match_logging.py:30 [PD:0  MD:2 ]	..None                                            	Delim._look_ahead_match IN	    	[ls=2, seg='\n     ']
DEBUG    sqlfluff.parser:match_logging.py:30 [PD:0  MD:2 ]	..None                                            	Delim._look_ahead_match SI	    	[mq=[], sb=['', '']]
INFO     sqlfluff.parser:match_logging.py:28 [PD:0  MD:2 ]	..None                                            	OneOf.match PRN     	    	[ns=1, ps=10, ms=0, pruned=[<Ref: OnKeywordSegment>, <Ref: AsKeywordSegment>, <Ref: UsingKeywordSegment>, <Ref: CommaSegment>, <Ref: CastOperatorSegment>, <Ref: StartSquareBracketSegment>, <Ref: StartBracketSegment>, <Ref: ColonSegment>, <Ref: DelimiterSegment>, <class 'sqlfluff.core.parser.segments.base.BracketedSegment'>], opts=[<Ref: BinaryOperatorGrammar>]]
INFO     sqlfluff.parser:match_logging.py:28 [PD:0  MD:3 ]	...BinaryOperatorGrammar                          	OneOf.match PRN     	    	[ns=1, ps=3, ms=0, pruned=[<Ref: ArithmeticBinaryOperatorGrammar>, <Ref: StringBinaryOperatorGrammar>, <Ref: BooleanBinaryOperatorGrammar>], opts=[<Ref: ComparisonOperatorGrammar>]]
INFO     sqlfluff.parser:match_logging.py:28 [PD:0  MD:4 ]	....ComparisonOperatorGrammar                     	OneOf.match PRN     	    	[ns=1, ps=7, ms=0, pruned=[<Ref: EqualsSegment>, <Ref: GreaterThanSegment>, <Ref: LessThanSegment>, <Ref: GreaterThanOrEqualToSegment>, <Ref: LessThanOrEqualToSegment>, <Ref: NotEqualToSegment_a>, <Ref: NotEqualToSegment_b>], opts=[<Ref: LikeOperatorSegment>]]
DEBUG    sqlfluff.parser:match_logging.py:30 [PD:0  MD:5 ]	.....ComparisonOperatorGrammar                    	Ref.match OUT       	    	[match=<MatchResult 0/2: ''>, seg="'\\n     '"]
INFO     sqlfluff.parser:match_logging.py:28 [PD:0  MD:4 ]	....ComparisonOperatorGrammar                     	OneOf.match OUT     	    	[match=<MatchResult 0/2: ''>, seg="'\\n     '"]
DEBUG    sqlfluff.parser:match_logging.py:30 [PD:0  MD:4 ]	....BinaryOperatorGrammar                         	Ref.match OUT       	    	[match=<MatchResult 0/2: ''>, seg="'\\n     '"]
INFO     sqlfluff.parser:match_logging.py:28 [PD:0  MD:3 ]	...BinaryOperatorGrammar                          	OneOf.match OUT     	    	[match=<MatchResult 0/2: ''>, seg="'\\n     '"]
DEBUG    sqlfluff.parser:match_logging.py:30 [PD:0  MD:3 ]	...None                                           	Ref.match OUT       	    	[match=<MatchResult 0/2: ''>, seg="'\\n     '"]
INFO     sqlfluff.parser:match_logging.py:28 [PD:0  MD:2 ]	..None                                            	OneOf.match OUT     	    	[match=<MatchResult 0/2: ''>, seg="'\\n     '"]
DEBUG    sqlfluff.parser:match_logging.py:30 [PD:0  MD:2 ]	..None                                            	NonCo.match OUT     	++  	[match=<MatchResult 2/2: '\n     '>, seg="'\\n     '"]
INFO     sqlfluff.parser:match_logging.py:28 [PD:0  MD:1 ]	.None                                             	Delim.match OUT     	    	[match=<MatchResult 0/2: ''>, seg="'\\n     '"]
DEBUG    sqlfluff.parser:match_logging.py:30 [PD:0  MD:0 ]	None                                              	Objec.match OUT     	    	[match=<MatchResult 0/2: ''>, seg="'\\n     '"]
_ test__dialect__ansi_specific_segment_not_parse[SELECT 1 + (2 -err_locations0] _
----------------------------- Captured stdout call -----------------------------
[SQLParseError("Couldn't find closing bracket for opening bracket.")]
=========================== short test summary info ============================
PASSED test/dialects/ansi_test.py::test__dialect__ansi__file_lex[a b-res0]
PASSED test/dialects/ansi_test.py::test__dialect__ansi__file_lex[b.c-res1]
PASSED test/dialects/ansi_test.py::test__dialect__ansi__file_lex[abc \n \t def  ;blah-res2]
PASSED test/dialects/ansi_test.py::test__dialect__ansi_specific_segment_parses[SelectKeywordSegment-select]
PASSED test/dialects/ansi_test.py::test__dialect__ansi_specific_segment_parses[NakedIdentifierSegment-online_sales]
PASSED test/dialects/ansi_test.py::test__dialect__ansi_specific_segment_parses[BareFunctionSegment-current_timestamp]
PASSED test/dialects/ansi_test.py::test__dialect__ansi_specific_segment_parses[FunctionSegment-current_timestamp()]
PASSED test/dialects/ansi_test.py::test__dialect__ansi_specific_segment_parses[NumericLiteralSegment-1000.0]
PASSED test/dialects/ansi_test.py::test__dialect__ansi_specific_segment_parses[ExpressionSegment-online_sales / 1000.0]
PASSED test/dialects/ansi_test.py::test__dialect__ansi_specific_segment_parses[IntervalExpressionSegment-INTERVAL 1 YEAR]
PASSED test/dialects/ansi_test.py::test__dialect__ansi_specific_segment_parses[ExpressionSegment-CASE WHEN id = 1 THEN 'nothing' ELSE 'test' END]
PASSED test/dialects/ansi_test.py::test__dialect__ansi_specific_segment_parses[ExpressionSegment-CASE WHEN id = 1 THEN CASE WHEN true THEN 'something' ELSE 'nothing' END ELSE 'test' END]
PASSED test/dialects/ansi_test.py::test__dialect__ansi_specific_segment_parses[ExpressionSegment-CAST(ROUND(online_sales / 1000.0) AS varchar)]
PASSED test/dialects/ansi_test.py::test__dialect__ansi_specific_segment_parses[ExpressionSegment-name NOT LIKE '%y']
PASSED test/dialects/ansi_test.py::test__dialect__ansi_specific_segment_parses[ExpressionSegment-DATE_ADD(CURRENT_DATE('America/New_York'), INTERVAL 1 year)]
PASSED test/dialects/ansi_test.py::test__dialect__ansi_specific_segment_parses[ExpressionSegment-my_array[1]]
PASSED test/dialects/ansi_test.py::test__dialect__ansi_specific_segment_parses[ExpressionSegment-my_array[OFFSET(1)]]
PASSED test/dialects/ansi_test.py::test__dialect__ansi_specific_segment_parses[ExpressionSegment-my_array[5:8]]
PASSED test/dialects/ansi_test.py::test__dialect__ansi_specific_segment_parses[ExpressionSegment-4 + my_array[OFFSET(1)]]
PASSED test/dialects/ansi_test.py::test__dialect__ansi_specific_segment_parses[ExpressionSegment-bits[OFFSET(0)] + 7]
PASSED test/dialects/ansi_test.py::test__dialect__ansi_specific_segment_parses[ExpressionSegment-count_18_24 * bits[OFFSET(0)] + count_25_34]
PASSED test/dialects/ansi_test.py::test__dialect__ansi_specific_segment_parses[ObjectReferenceSegment-a..c.*]
PASSED test/dialects/ansi_test.py::test__dialect__ansi_specific_segment_parses[ExpressionSegment-concat(left(uaid, 2), '|', right(concat('0000000', SPLIT_PART(uaid, '|', 4)), 10), '|', '00000000')]
PASSED test/dialects/ansi_test.py::test__dialect__ansi_specific_segment_parses[ExpressionSegment-c is null]
PASSED test/dialects/ansi_test.py::test__dialect__ansi_specific_segment_parses[ExpressionSegment-c is not null]
PASSED test/dialects/ansi_test.py::test__dialect__ansi_specific_segment_parses[ExpressionSegment-NULL::INT]
PASSED test/dialects/ansi_test.py::test__dialect__ansi_specific_segment_parses[TruncateStatementSegment-TRUNCATE TABLE test]
PASSED test/dialects/ansi_test.py::test__dialect__ansi_specific_segment_parses[TruncateStatementSegment-TRUNCATE test]
PASSED test/dialects/ansi_test.py::test__dialect__ansi_specific_segment_not_match[ObjectReferenceSegment-\n     ]
PASSED test/dialects/ansi_test.py::test__dialect__ansi_specific_segment_not_parse[SELECT 1 + (2 -err_locations0]
PASSED test/dialects/ansi_test.py::test__dialect__ansi_is_whitespace
PASSED test/dialects/ansi_test.py::test__dialect__ansi_multiple_semicolons[;;-Line 1, Position 1: Found unparsable section: ';;']
FAILED test/dialects/ansi_test.py::test__dialect__ansi_specific_segment_parses[SelectClauseElementSegment-MIN (test.id) AS min_test_id]
FAILED test/dialects/ansi_test.py::test__dialect__ansi_specific_segment_parses[SelectClauseElementSegment-(count_18_24 * bits[OFFSET(0)]) / audience_size AS relative_abundance]
FAILED test/dialects/ansi_test.py::test__dialect__ansi_specific_segment_parses[SelectClauseElementSegment-(count_18_24 * bits[OFFSET(0)] + count_25_34) / audience_size AS relative_abundance]
FAILED test/dialects/ansi_test.py::test__dialect__ansi_specific_segment_parses[SelectStatementSegment-SELECT t.val/t.id FROM test WHERE id*1.0/id > 0.8]
FAILED test/dialects/ansi_test.py::test__dialect__ansi_specific_segment_parses[SelectClauseElementSegment-t.val/t.id]
FAILED test/dialects/ansi_test.py::test__dialect__ansi_specific_segment_parses[SelectClauseElementSegment-CAST(num AS INT64)]
FAILED test/dialects/ansi_test.py::test__dialect__ansi_specific_segment_parses[SelectClauseElementSegment-CAST(num AS numeric(8,4))]
FAILED test/dialects/ansi_test.py::test__dialect__ansi_specific_segment_parses[SelectClauseElementSegment-a.*]
FAILED test/dialects/ansi_test.py::test__dialect__ansi_specific_segment_parses[SelectClauseElementSegment-a.b.*]
FAILED test/dialects/ansi_test.py::test__dialect__ansi_specific_segment_parses[SelectClauseElementSegment-a.b.c.*]
FAILED test/dialects/ansi_test.py::test__dialect__ansi_specific_segment_parses[SelectClauseElementSegment--some_variable]
FAILED test/dialects/ansi_test.py::test__dialect__ansi_specific_segment_parses[SelectClauseElementSegment-- some_variable]
FAILED test/dialects/ansi_test.py::test__dialect__ansi_specific_segment_parses[SelectClauseElementSegment-c is null as c_isnull]
FAILED test/dialects/ansi_test.py::test__dialect__ansi_specific_segment_parses[SelectClauseElementSegment-c is not null as c_notnull]
FAILED test/dialects/ansi_test.py::test__dialect__ansi_specific_segment_parses[SelectClauseElementSegment-NULL::INT AS user_id]
FAILED test/dialects/ansi_test.py::test__dialect__ansi_specific_segment_not_parse[SELECT * FROM a ORDER BY 1 UNION SELECT * FROM b-err_locations1]
FAILED test/dialects/ansi_test.py::test__dialect__ansi_specific_segment_not_parse[SELECT * FROM a LIMIT 1 UNION SELECT * FROM b-err_locations2]
FAILED test/dialects/ansi_test.py::test__dialect__ansi_specific_segment_not_parse[SELECT * FROM a ORDER BY 1 LIMIT 1 UNION SELECT * FROM b-err_locations3]
FAILED test/dialects/ansi_test.py::test__dialect__ansi_parse_indented_joins[select field_1 from my_table as alias_1-True-meta_loc0]
FAILED test/dialects/ansi_test.py::test__dialect__ansi_parse_indented_joins[select field_1 from my_table as alias_1-False-meta_loc1]
FAILED test/dialects/ansi_test.py::test__dialect__ansi_parse_indented_joins[select field_1 from my_table as alias_1 join foo using (field_1)-True-meta_loc2]
FAILED test/dialects/ansi_test.py::test__dialect__ansi_parse_indented_joins[select field_1 from my_table as alias_1 join foo using (field_1)-False-meta_loc3]
FAILED test/dialects/ansi_test.py::test__dialect__ansi_multiple_semicolons[select id from tbl;-]
FAILED test/dialects/ansi_test.py::test__dialect__ansi_multiple_semicolons[select id from tbl;;-Could not parse: ;]
FAILED test/dialects/ansi_test.py::test__dialect__ansi_multiple_semicolons[select id from tbl;;;;;;-Could not parse: ;;;;;]
FAILED test/dialects/ansi_test.py::test__dialect__ansi_multiple_semicolons[select id from tbl;select id2 from tbl2;-]
FAILED test/dialects/ansi_test.py::test__dialect__ansi_multiple_semicolons[select id from tbl;;select id2 from tbl2;-Could not parse: ;select id2 from tbl2;]
=================== 27 failed, 32 passed, 1 warning in 1.53s ===================
+ git checkout 304a197829f98e7425a46d872ada73176137e5ae test/dialects/ansi_test.py
Updated 1 path from c2e0eb73a
